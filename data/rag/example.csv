Chunk Content
"module 
 
1.4.2 Dataflow Modeling 
For small circuits, the gate-level modeling approach works very well because the 
numbers of gates is limited and the designer can instantiate and connect every gate individually. 
Also, gate-level modeling is very intuitive to a designer with a basic knowledge of digital logic 
design. However, in complex designs the number of gates is very large. Thus, designers can 
design more effectively if they concentrate on implementing the function at a level of abstraction 
higher than gate level. Dataflow modeling provides a powerful way to implement a design. 
Verilog allows a circuit to be designed in terms of the data flow between registers and how a 
design processes data rather than instantiation of individual gates. Later in this chapter, the 
benefits of dataflow modeling will become more apparent. With gate densities on chips 
increasing rapidly, dataflow modeling has assumed great importance. No longer can companies 
devote engineering resources to handcrafting entire designs with gates. Currently, automated 
tools are used to create a gate-level circuit from a dataflow design description. This process is 
called logic synthesis. Dataflow modeling has become a popular design approach as logic 
synthesis tools have become sophisticated. This approach allows the designer to concentrate on 
optimizing the circuit in terms of data flow. For maximum flexibility in the design process, 
designers typically use a Verilog description style that combines the concepts of gate-level, data 
flow, and behavioral design. In the digital design community, the term RTL (Register Transfer 
Level) design is commonly used for a combination of dataflow modeling and behavioral 
modeling. 
 
Example: 
Master Slave Flip-flop:  
module MSDFF_DF (D, C, Q, Qbar) ; 
input D, C;  
output Q, Qbar;  
wireNotC, NotD, NotY, Y, Dl, D2, Ybar, Yl, Y2;  
assignNotD = ~ D;  
assign Note = ~ C;  
assign NotY = ~ Y;  
assign D1= - (D & C) ;  
assign D2 = ~ (C &NotD);  
assign Y = ~ (Dl St Ybar);  
assign Ybar = ~ (Y & D2);  
assign Yl = ~ (y & Note);  
assign Y2 = - (NotY&NotC);  
assign Q = ~ (Qbar&Yl);  
assignQbar = ~ (Y2 & Q);  
endmodule"
"moduleMagnitudeComparator (A, B, AgtB, AeqB, AltB) ;  
parameter BUS= 8;  
parameter EQ_DELAY = 5, LT_DELAY = 8, GT_DELAY = 8;  
input [1 : BUS]A, B;  
outputAgtB, AeqB, AltB;  
assign %EQ_DELAY AeqB = A == B; 19  
assign $GT_DELAY AgtB = A > B;  
assign $LT_DELAY AltB = A < B;  
endmodule"
"module mux4( input a, b, c, d 
input [1:0] sel, 
output out ); 
always @(a or b or c or d or sel) 
begin 
if(sel==0) 
out = a; 
else if (sel==1) 
out = b; 
else if ( sel == 2 ) 
out = c ; 
else if ( sel == 3 ) 
out = d; 
end 
endmodule"
"module 
 
Shift Register (Serial In Serial Out) 
module shift (C, SI, SO); 
input C,SI; 
output SO; 
reg [7:0] tmp; 
always @(posedge C) 
begin 
tmp = tmp<< 1; 
tmp[0] = SI; 
end 
assign SO = tmp[7]; 
endmodule"
"module. Tasks and  
functions are procedures that are enabled from one or more places in other procedures. 
 
1.4.4 Structural Modelling: 
The structural model of Verilog HDL is described using: 
 Gate instantiation 
 UDP instantiation 
 Module instantiation 
Module: A module defines a basic unit in Verilog HDL. It is of the form: 
modulemodule_name ( port_list ); 
Declarations_and_Statements 
endmodule"
"module 
 
Module Instantiation : A module can be instantiated in another module, thus creating 
hierarchy. A module instantiation statement is of the form: 
module_name instance_name( port_associations); 
Port associations can be by position or by name; however, associations cannot be mixed. A 
port association is of the form: 
port_expr // By position. 
.PortName (port_expr )// By name. 
Where port_expr can be any of the following: 
i. an identifier (a register or a net) 
ii. a bit-select 
iii. a part-select 
iv. a concatenation of the above 
v. an expression (only for input ports) 
In positional association, the port expressions connect to the ports of the module in the 
specified order. In association by name, the connection between the module port and the port 
expression is explicitly specified and thus the order of port associations is not important. Here is 
an example of a full-adder built using two half-adder modules. 
 
Half Adder: 
module HA (A, B, S, C); 
input A, B; 
output S, C; 
parameter AND_DELAY = 1, XOR_DELAY = 2; 
assign #XOR_DELAY s=A ^ B; 
assign #AND_ DELAY C= A & B; 
endmodule"
"modules 
2.4 Packages 
In Verilog, declarations of variables, nets, tasks and functions must be declared within a 
module, between the module...endmodule"
"module d_edge_ff_gates(q, qBar, preset, clear, clock, d);
inout q, qBar;
input clock, d, preset, clear;
nand #1 nl (ol, preset, o4, o2),
n2 (o2, clear, clock, ol),
n3 (o3, clock, o2, o4),
n4 (o4, d, o3, clear),
n5 (q, preset, o2, qBar),
n6 (qBar, q, o3, clear);
endmodule"
"module”. The interface to the module is described in the same line as
module name “d_edge_ff_gates”. The direction of each port in the interface list is
described in the following lines  beginning with the words like “inout” and “input”.
The “nand” statement has six instances of nand gates with names nl through n6.
The interface list on each line enclosed in parentheses. The first identifier describes
the output and the subsequent identifiers describe the inputs of each nand gate. Thus,
ol through o4 and q and qBar are outputs of the gates nl through n6; p reset, clear,
clock and data are inputs a long with ol-o4, q and qBar which are in  the feedback
loop. The “#” symbol indicates delay on the gate  which is a unit delay (1 unit) in this
case.
Example 1-2 builds a 4-bit counter built with d flip-flops defined in Example 1-1.
The flip-flop was  built using predefined nand gate while the counter is built
hierarchically using a module de fined earlier. Again, the definition of this block is
enclosed between the keywords “module” and “endmodule"
"module. The four flip-flops are instantiated using the
name of the  module “d_edge_ff_gates” followed by names (dffl-dff4) and the
connection list.
The definition of the counter output q specifies the  4-bit output by using [3:0]
expression. This indicates the size of this bit-vector of size 4 and indices from 3
down to 0. Verilog supports single-bit quantities or scalars and multi-bit or vec tors.
Bits in Vectors are addressed using brackets, as in q[0] indicating bit 0 is vector q.
module counter_behav(q, clock, preset,  clear);
output [3:0] q;
reg [3:0]  q;
input clock,  preset, clear;
always @(posedge clock)
begin
if( (preset = = 1) && (clear = = 1))
q =q + l;
else
if ((preset = = 0) && (clear = = 1))
q = 4'bllll;
else
q = 0;
end
endmodule"
"module test_counter;
reg preset, clear, clock, data;
wire [3:0] q;
counter ci(q, clock, preset, clear);
counter_behav ci(q, clock, preset, clear);
initial
begin
clock = 0;
forever #50 clock = ~clock;
end
initial
begin
$monitor(""time=%d preset=%d clear=%d clock=%d q[0]=%d q[l]=%d
q[2]=%dq[3]=%d"",
$time, preset, clear, clock, q[0], q[l], q[2], q[3]);
preset = 0;
clear = 1;
#200
/* preset = 1;
clear = 0;
*/ #200
preset = 1;
clear = 1;
#200 ;
#200
data = 0;
#1600
$finish;
end
endmodule"
"module factorial(n,  fact);
nput [31:0] n;
utput[31:0]fact;
eg [31:0] fact;
eg factReady;
nteger i;
initial begin
factReady = 0;
fact = 0;
$monitor(""time=%d num ber =%d factorial = %d"", $time, n, fact);
end
always  @n
begin
factReady = 0;
fact = 1;
for(i=l;i<=n;i=i+l)
fact = fact * i;
factReady = 1;
end
endmodule"
"module test;
reg[31:0]n;
wire [31:0] fact;
integer j;
reg nReady;
factorial f (n, fact);
initial
begin
#1 n =1;
for(j=l;j<=4;j=j+l)
begin
nReady = 0;
#ln=j;
nReady = 1;
end
end
endmodule"
"module
module MainMemory(memRead, mem Write, memAddress, memData, memClock,reset);
input memRead, mem Write, memClock, reset;
input [`ADDR_SIZE-1:0] memAddress;
input [`DATA_SIZE-1:0] memData;
// memory description
//
endmodule"
"module Cache(procRead, procWrite, procAddress, procData,
memRead, mem Write, memAddress,  memData, reset, clock);
input procRead, procWrite, reset, clock;
input [`ADDR_SIZE-l:0] procAddress;
output memRead, memWrite;output [`ADDR_SIZE-1:0] memAddress;
inout [`DATA_SIZE-l:0] memData, procData;
wire [`DATA_SIZE-1:0] dataIn, outData, dataOut;wire [`TAG_SIZE-1:0] tagOut;
tagCache tc(procAddress, tagOut, clock, write, procRead, reset);
validCache vc(procAddress, valid, clock, write , procRead, reset);
dataCache dc(procAddress, dataln, dataOut, clock, write, read);
comparator c(tagOut, procAddress[`ADDR_SIZE-l:`ADDR_SIZE-`TAG_SIZE],
match);
cacheControl cc(procRead,  procWrite, match, valid, read, write, mem Write,
memRead, dataOutSel, dataInSel, clock, reset);
dataMux dmIn(procData, memData, dataInSel, dataIn);dataMux dmOut(dataOut, memData, dataOutSel, outData);
endmodule"
"module System();
wire [`ADDR-SIZE-l:()] memAddress;
wire [`DATA_SIZE-l:0] memData;
wire [`ADDR_SIZE-l:0]  procAddress;
wire [`DATA_SIZE-l:0] procData;
Processor p(procRead, procWrite, procAddress, procData, procClock,
eset);
MainMemory m(memRead, memWrite, memAddress, memData, memClock,
reset);
Cache c(procRead, procWrite, procAddress, procData,
memRead, memWrite, memAddress, memData, reset, clock);
endmodule"
"module wand_test(out, i1, i2);
input il, i2;
output out;
wand out;
assign out = il;
assign out = i2;
endmodule"
"module w or_test(il, i2,  out);
input il, i2;
output out;
wor out;
assign out = in1;
assign out = in2;
endmodule"
"module such that only one driver is  active at a time.
module tri_test (out, select, a, b, c);
input [1:0] select, a, b, c;
output out;
tri out;
assign out = a; //make the tri connection
assign out = b;
assign out = c;
endmodule"
"module
Example 2-6. Tri (Three-State)  declarations and usage.
The drivers may be gate outputs as in the example below.
module tri_test (out, select, a, b, c);
input [1:0] select, a, b, c;
output out;
tri out;
nand(out, a1,a2); //make the tri connectio
nand(out, bl, b2)
nand( out, cl, c2, c3);
endmodule"
"module fullAdder(cOut, sum, aIn, bIn, cIn);
input aIn, bIn, cIn;
output cOut, sum;
wire aIn, bIn, cin;
reg cOut, sum;
endmodule"
"module
Behavioral Level of Modeling of multiplier
module mult_rtl(out, in1, in2, carry, sign);
input[31:0] in1,in2;
output [63:0] out;
output carry;
output sign;
assign {carry, out} = in1 * in2;
assign sign = ({ carry, out} < 0) ? 1 : 0;
endmodule"
"module_declaration
| UDP_declaration
module_declaration
::= module_keyword  module_identifier [list_of_ports];
{module_item}
endmodule"
"module_Keyword
::= module | macromodule
{module_item}
endmodule"
"module timing behavior description in Verilog. This is structurally bound to the
module pins or inputs-outputs.
3.2.2 Examples
// Here is an example of behavioral description of the full adder above
// Abstraction is added by a. Use of operator  b. Use of vectorizing  c. Control  flow  abstraction
// (always block- Implicit Sensitivity to the RHS operands; Sequential Description adds
power to the
//modeling ability by reducing complexity in control flow (almost random in RTL)
module fullAdder_b(cOut, sum, aIn, bIn, cIn);
output cOut, sum;
input  aIn, bIn, cIn;
reg[1:0]tmp;
reg cOut, sum;
always @(aIn or bIn or cIn)
begin
Imp = aIn+bIn+cIn;
sum = tmp[0];
cOut = tmp[1];
end
endmodule"
"module fullAdder_r(cOut, sum, aIn, bIn, cIn);
output cOut, sum;
input    aIn, bIn,  cIn;
wire x1,x2,x3,x4,x5,x6,x7,x8,x9;
// This describes the same full adder using RTL
assign x2 = ~(aIn & bIn);
assign cOut= ~(x2& x8);
assign x9 = ~(x5 ^ x6);
assign x5 = ~(x1 | x3);
assign x1 = ~(aIn | bIn);
assign x8 = (x1 | x7);
assign sum = ~x9;
assign x3 = ~x2;
assign x6 = ~x4;
assign x4 = ~cIn;
assign x7=  ~x6;
endmodule"
"module fullAdder_r(cOut, sum, aIn, bIn, cIn);
output  cOut, sum;
input   aIn,  bIn,   cIn;
wire x2;
// This describes the same RTL above, but using power of expressions
// This is not simplified just to show how it was obtained by substituting
// each intermediate term above until only primary inputs  remain on RHS
assign cOut = ~(~(aIn & bIn) & (((-(aIn | bIn)) |
~(~(~cIn)))));
assign sum = ~ (~((~((~(aIn | bIn)) | (~~(aIn & bIn))))^ (~(~cIn))));
endmodule"
"module (cOut, sum, aIn, bIn, cIn);
output cOut, sum;
input       aIn, bIn, cIn;
wire x2;
// This describes the same RTL above, but simplifying using Boolean algebra rules
assign cOut = ~(~(aIn & bIn) & (((~(aIn | bIn)) | ~(cIn)));
assign sum = (~((~(aIn | bIn)) | (aIn & bIn)))^ (cIn);
endmodule"
"module check_opcode_jmp( instruction, opcode);
parameter jmp = 0;
input [7:0] instruction;
output opcode;
assign opcode = (instruction[7:6] == jmp);
endmodule"
"module check_inst(inst, ok);
`define ADD=0,
`define SUB=1,
`define MUL=2,
`define DIV =3;
input [7:0] inst;
assign ok = ((inst == `ADD) | (inst == `SUB) I
(inst == `MUL) | (`inst == `DIV));
endmodule"
"module full_adder( i1, i2, cin, sum, cout);
input i1,i2,cin;
output sum, c out;
assign sum = i1 ^ i2 ^ cin;
assign cout = (i1&i2) | (cin & (i1|i2));
endmodule"
"module par (in, parity, all_ones);
input [7:0] in;
output parity, a ll_ones;
assign parity = ^in;
assign all_ones = & in;
endmodule"
"module div4( dividend, res);
input [7:0] dividend;
output [5:0] res;
assign res = dividend >> 2; //divide by 4 by shifting right 2 bits
endmodule"
"module add_or_subtract( i1, i2, op, result);
`define ADD =1'b1;
input [7:0] a, b;
input op;
output [7:0] result;
assign result = (op == `ADD) ? i1+i2 : i1-i2;
endmodule"
"module add_or_subtract( a, b, op, s);
// performs s = a+b if op is ADD
// s = a-b if op is not ADD
parameter size=8;
parameter ADD= 1 'b1;
input op;
input [si ze-1:0] a, b;
output [size-1:0] s;
assign s = (op == ADD) ? a+b : a-b; //not a constant-valued expression
endmodule"
"module
module multiplier(inl, in2, product, carry, cc);
parameter size = 32; //default is 8-bit adder
input [si ze-l:0] inl, in2;
output [size-1:0] product;
output carry;
output [1:0] cc; // condition code
assign #(2*`clock_period ) {carry, product} = inl * in2;
// Set condition codes
assign cc[0] = (product == 0)? 1:0; //Condition Code 0 - Zero Value
assign cc[l] = (product[size-l]); //Condition Code 1 - Negative Value
endmodule"
"module alu;
endmodule"
"module multiplexor(out, control, inl, in2, in3, in4);
parameter size = 32;
input [1:0] control;
input [size-l:0] inl, in2, in3, in4;
output [size-1:0] out;
assign out = (control == 0) ? inl :
((control == 1) ? in2 :
((control == 2) ? in3 :
((control == 3) ? in4 :
'bx)));
endmodule"
"module bus_control;
parameter size = 32;
tri [size-l:0]bus;
wire [si ze-l:0] data;
wire dcontrol;
assign bus = dcontrol ? data: 128'bz;
endmodule"
"module
module xdetect(in, xdet);
parameter size=32;
input [size-1:0] in;
output xdet;
assign xdet = ((in == in) ? 0:1);
endmodule"
"module barrel_shifter(func, mode, out, in);
parameter size = 32;
output [size-1:0] out;
input [size-l:0] in;
input func, mode;
`define SHIFT 1
`define ROTATE 0
`define LEFT 1
`define RIGHT 0
`define shift_expr (mode ? (in << 1): (in >> 1))
`define rotate_expr (mode ? ({in[size-2:0], in[size-l]}): ({in[0], in[size-l:l]}))
assign out = `shift_expr;
assign out  = `rotate_expr;
assign out = func ? `shift_expr: `rotate_expr;
endmodule"
"modules */
adder a (rl, r2, sum, cl, c codel);
multiplier m (rl, r2, prod, c2, ccode2);
comparator c (rl, r2, c ompare_out);
barrel_shifter b (funcl, mode, shift_out, rl);
multiplexor mx(out, func2,  sum, prod, {compare_out,63'b0}, shift_out);
defparam a.size = alu_size;
defparam m.size = alu_size;
defparam c.size = alu_size;
defparam b.size = alu_size;
defparam mx.size = alu_size;
initial
begin: testl
rl = 5;
r2 = 3;
funcl = 1;
mode = 1;
for (func2 =0; func2 <=3; func2=func2+l)
begin
#100
$display(""alu inputs func2 = %0d inl=%0d and in2=%0d func=%0d
mode=%0d give output out =%0d with carryl=%0d carry2=%0d and condition codel=%0d
code2=%0d"",
func2, rl, r2, funcl, mode, out, cl, c2, ccodel, ccode2);
if (func2 == 3) disable testl;
end
end
endmodule"
"module. Modules in turn can have other modules,
behavioral blocks, RTL descriptions, built-in gates and transistors (single bits), and
user-defined primitives. The other modules are included using the constructs of
module instantiations. The gates, switches and udps can be viewed as predefined
modules. Then rules for instancing these fall into the rules of instancing  modules.
3.10.1.2 Example
module fullAdder_s(cOut, sum, aIn, bIn, cIn);
output cOut, sum;
input
wire x2;
nand (x2, aIn, bIn),
(cOut, x2, x8);
xnor (x9, x5, x6);
nor (x5, xl,x3),
(xl, aIn, bIn);
or (x8,xl,x7);
not (sum,  x9),
(x3, x2),
(x6, x4),
(x4, cIn),
(x7, x6);
endmodule"
"module ALU(Data, Address, control);
inout Data, Address, control;
fullAdder(cOut, sum, aIn, bIn, cIn);
Multiplier(overflow, product, aIn, bIn, cIn);
endmodule"
"module CPU(Data,Address,control);
inout Data, Address, control;
ALU a(Data, Address, control);
FPU f(Data, Address, control);
REGISTERS r(Data, Address, control);
QUEUES q(Data, Address, control);
CONTROL_UNIT c(Data,  Address,  control);
endmodule"
"module definition with a
parameter.
module adder (in1, in2, sum , carry, cc);
parameter size = 32; //default is 32-bit adder
input [size-1:0] inl, in2;
output [1:0] cc; // condition code
output [size-1:0] sum;
output carry;
assign #`clock_period{carry, sum} = inl + in2;
// Set condition codes
assign cc[0] = (sum == 0)? 1:0;//Condition Code 0 - Zero Value
assign cc[l] = (sum[size-l]); //Condition Code 1 - Negative Value
endmodule"
"module definitions.
Parameters
Verilog parameters allow you to customize each instantiation of a module. By  setting
different values for the parameter when you instantiate the module, you can cause
different logic to be constructed. A parameter represents constant values
symbolically. The definition for a parameter consists of thè  parameter name and the
value assigned to it. The value can be  any constant-valued expression of integer or
Boolean type, but not of type real. If you do not set the size of the parameter with a
range definition or a sized constant, the parameter is unsized and defaults to a 32-bit
quantity. The typical uses of parameters are in delays and sizes, but they have broad
applications.
Macromodules
Macromodules allow de finition of modules that get compiled as parts of the modules
in all instantiations without the module boundaries.
macromodule adder (inl,in2,outl);
input [3:0] in1,in2;
output [4:0] outl;
assign outl = inl + in2;
endmodule"
"module
module ex5( .il(a[l]), .i0(a[0]),z );
input [1:0] a;
output z;
endmodule"
"module ex6( .i({a,b}), z);
input a,b;
output z;
endmodule"
"modules.
You can rename a port by explicitly assigning a name to a port expression by
using the dot (.) operator. The module definition fragments in Example 3-31 show
how to rename ports. The ports for module ex4 are explicitly named in_a, in_b, and
out and are connected to nets a, b, and z. Module ex5 shows ports named il, i0, and
z connected to nets a[l], a[0], and z, respectively. The first port for module ex6 (the
concatenation of nets a and b) is named i.
3.10.2.3 Syntax
module_declaration
::= module_keyword  module_identifier [list_of_ports];
{module_item}
endmodule"
"module_keyword
::= module | macromodule
{module_item}
endmodule"
"modules. It is
also a mechanism to describe connectivity and a mechanism  to create hierarchical
design. This is a mechanism to select various views of the design units. This supports
hierarchical names.
Module instantiations are copies of the logic in a module that define component
interconnections. A module  instantiation is done using th e following form:
module_name instance_name1 (terminal1, terminal2), instance_name2 (terminal1,terminal2);
A module instantiation consists of the name of the module (module_name),
followed by one or more instantiations. An  instantiation consists of an instantiation
name (instance_name) and a connection list. A connection list is a list of  expressions
called terminals, separated by  commas. These terminals are connected to the ports of
the instantiated module. Terminals connected to input ports can be any ar bitrary
expression. Terminals connected to output and inout ports can be identifiers, single-
or multiple-bit slices of an  array, or a concatenation of these. The bit widths for a
terminal and its module port must be the same.
Named and Positional Notation
Module instantiations can use either named or  positional notation to specify the
terminal connections. In name-based module instantiation, you explicitly designate
which port is connected to each terminal in the list. Undesignated ports in the
module are unconnected. In pos ition-based module instantiation, you list the
terminals and specify connections to the module according to the terminal's position
in the list. The first terminal  in the connection list is connected to the first module
port, the second terminal to the second module port, and so on. Omitted terminals
indicate that the corresponding port on the module is unconnected. If you use an
undeclared variable as a terminal, the terminal is implicitly declared as a scalar
(1-bit) wire. After the variable is implicitly declared as a wire, it can appear
wherever a wire is allowed
3.10.3.2 Examples of Structural  Descriptions Using Modules
Example 1
Example 3-32 shows the declaration for the module m with two instances (ml and
m2).
module next_level(bus0, bus 1, out); //description of module SEQ
input bus0, bus 1;
output out;
endmodule"
"module top( il, i2, i3, i4, ol, o2);
input il, i2, i3, i4;
output ol, o2;
next_level 10(il, i2, i3), //instantiations of module SEQ
l1(.out(ol), in.(i3),. Bus0(i2));
endmodule"
"module.
d_cache d_cache(d_cache_in, d_cache_addr, d_cache_write,  d_cache_read,
d_cache_out, d_tag_in, d_tag_addr, d_tag_write,
d_tag_read, d_tag_out,  clk);
// Instruction cache module.
i_cache i_cache(i_cache_in, i_cache_addr, i_cache_write,  i_cache_read,
i_cache_out, i_tag_in, i_tag_addr, i_tag_write,
i_tag_read, i_tag_out, clk);
// CP0 module.
wire [20:0] IFN;
wire [20:0] DFN;
cop0 cp0(IVA, DVA, DBus,  Cache_data, Interrupts, IFN, DFN,
Exceptions, Status);
execution_unit exec_unit(Dbus, nReset, pClock, sys_inst, selecte);
pipeline_control pipe_ctrl (Dbus, n Reset, pClock, sys_inst, selectp , control);
endmodule"
"module_instantiation
::= module_identifier [parameter_value_assignment]
module_instance{ ,module_instance}
parameter_value_assignment
::= # ( expression{ ,expression} )
module_instance
::= name_ of_ instance ( [list_of_module_connections] )
list_of_module_connections
::= ordered_port_connection{ , ordered _port_connection}
| named_port_connection{ ,named_port_connection}
ordered _port_connection
::= [expression]
named_port_connection
::= . port_identifier ( expression )
3.11 Exercises
1.
2.Instantiate the two modules in Example 3-1 in a test module. Apply stimulus
and see the two modules give out exactly  the same results. Use  the Example 1-6
as a guideline to writing this test module.
Convert the following RTL description into a behavioral statement using case
statement.
module multiplexor(control, in1, in2, in3, in4, out);
input [1:0] control;
input in1, in2, in3, in4;
output out;
assign out = (control == 0) ? in1:
((control == 1) ? in2 :
((control == 2) ? in3 :
((control == 3) ? in4 :
'bx)));
endmodule"
"module andor;
reg i1, i2, i3, i4;
and #2 a1  (o1, i1, i2), a2 (o2, i3, i4); or r1  (o3, o1, o2);
initial
begin : beh_block
$monitor(""Sim Time=%d i1=%d i2=%d i3=%d i4=%d o1=%d o2=%d
o3=%d"", $time,i1, i2, i3, i4, o1, o2, o3);
#25 i1 = l; #25  i2 = 0;
# 2 5 i3=l; # 2 5 i4=l;
#100 $finish;
end
endmodule"
"module m;
wire out;
reg in1, in2;
assign #5 out = in1 | in2;
initial
begin
$monitor(""Time = %d out = %d in1=%d in2=%d"", $time, out,
in1, in2);
$dumpfile(""ex4_2.dmp"");
$dumpvars;
// $gr_waves(out, in1. in2);
#1
in1 =  1;
#2
in2 =  1;
#10
$finish;
end
endmodule"
"module using ‘step and
trace’ OR with ‘trace on’ option. Modify this log using the semantic model to
obtain the ideal simulation log in terms of ‘EVALUATE EVENTS, UPDATE
EVENTS, SCHEDULE and STATEMENT EXECUTION’ primitive steps as in
Examples 4-2 and 4-3 in the book.
module mixed_sim;
// This is a part of bigger circuit that drives the bus
// This is modeled with mixed structure, rtl and behavior
reg dcontrol, x; y;
reg [31:0] data; wire [31:0] bus;
assign bus = dcontrol ? data : 'bz;
always @x
y = ~x;
initial
begin
$monitor(""time=%d dcontrol=%d data=%d x=%d y=%d bus=%d"",
$time, dcontrol, data, x, y, bus);
dcontrol = 0;
#10 data = 15;
#10 x = 0;
#10 dcontrol = y;
#10;
end
endmodule"
"module clock(clock);
output clock;
initial
clock = 0;
always
#100 clock = ~clock;
endmodule"
"module evaluates3(out); //The simulator evaluates
output out; // right-hand side of the
reg a, b, c; // non-blocking assignments and
// schedules the assignments of
initial
begin // the new values at posedge c.
a = 0;
b = 1; // Step 2 : At posedge c,the simulator
c = 0; // updates the left-hand side of
end // each non-blocking assignment
// statement.
always c = # 5 ~c;
always @ ( posedge c )
begin: exch_block
a <= b; // evaluates, schedules
b <= a; // and  executes in  two steps
end
//simulation control section
initial
begin
$monitor(""$time=%d a=%d b=%d c=%d"", $time, a, b, c);#30 $finish;
end
endmodule"
"module
This produces  following output:
time= 0, i=6 r1 = 0
time= 10, i=6 r1 = 1
time= 20, i=6 r1 = 0
time= 30, i=6 r1 = 1
time= 40, i=6 r1 = 0
time= 50, i=6 r1 = 1
Example 5-8. Non-Blocking assignments – support of multiple schedules.
5.2.4.4 Example 4  - Here we take the Example 3 above and replace the non-
blocking with a blocking  assignment.
module multiple;
reg r1;
reg [2:0]i;
initial begin
$monitor(""time=%d, i=%d r1 = %d"", $time, i, r1);
// starts at time 0, doesn't hold the block
r1= 0;
// make assignments to r1 without canceling previous assignments
for ( i = 0; i <= 5;  i = i+1 )
r1 = # (i*10) i[0];
end
endmodule"
"module m(a,b,c,d, select, mux);
input a, b,c,d;
input [1:0] select;
output mux;
reg mux;
always@({a,b,c,d,select})
case (select)
2'b00: mux = a;
2'b01: mux = b;
2'b10: mux = c;
2'b11: mux = d;
default: mux = 'bx;
endcase
endmodule"
"module m;
reg sig;
always @(sig)
case (sig)
1'bx : $display (""signal is unknown"");
1'bz: $display (""signal is floating"");
default: $display (""signal is %b"", sig);
endcase
initial
begin
$monitor(""time=%d sig=%b"",$time, sig);
#10 sig = 0,
#10 sig = 1;
#10  sig = 'bz;
#10  sig = 'bx;
end
endmodule"
"module m;
reg sig;
always @(sig)
casez (sig)
1'bx: $display (""signal is unknown"") ;
1'bz: $display (""signal is floa ting"") ;
default: $display (""signal is %b"", sig) ;
endcase
initial
begin
$monitor(""time=%d sig=%b"",$time, sig);
#10 sig = 0;
#10 sig = 1;
#10 sig = 'bz;
#10 sig = 'bx;
end
endmodule"
"module multiplexor(a, b, c, d, select, e);
input a, b, c, d;
input [1:0] select;
output e;
assign e = mux (a, b, c, d, select);
endmodule"
"module waveShReg;
wire shiftout; //net to receive circuit output value
reg shiftin;  //register to drive value into circuit
reg phase1,phase2;       //clock driving values
parameter d = 100; //define the waveform time step
shreg cct (shiftout, shiftin, phase1, phase2);
initial
begin :main
shiftin = 0; /initialize waveform input stimulus
phase1 = 0;phase2 = 0;
setmon; // setup the monitoring information
repeat(2) //shift data in
clockcct;
end
task setmon; //display header and setup monitoring
begin
$display("" time clks in out wal-3 wbl-2"");
$monitor ($time,,,,phasel, phase2,,,,,,shiftin,,,, shif tout,,,,,
cct.wa1, cct.wa2, cct.wa3,,,,,cct.wb1, cct.wb2);
end
endtask
endmodule"
"module e (out);
output out;
reg a,b,c;
reg d,e,f;
initial
begin
$monitor (""time=%d a=%d b=%d c=%d e=%d
\n"",$time,a,b,c,d,e):
a=0; b=1; c=0; d=0; e=1;
#30 $finish;
end
always c = #5 ~c;
always @(posedge c)
begin
a = b;
b = a;
d<= e;
e <= d;
end
endmodule"
"module test_carry;
reg a, b, c;
integer i;
wire cout;
carry ci(cout, c, a, b);
initialbegin
$monitor(""time=%d a= %b b=%b c=%b
cout=%b"",$time,a,b,c,cout);
for (i=0; i<9; i=i+1)
begin
{a,b,c}= i;
#10;
end
a = 'bx;
#10
b= 'bx;
end
endmodule"
"module test_latch;
reg a, b, c;
integer i;
wire q;
latch li(q , a, b);
initial
begin
$monitor(""time=%d a= %b b=% b--------- q=%b"",$time,a,b,q);
for (i=0; i<5; i=i+l)
begin
{a,b}  = i;
#10;
end
a= 'bx;
#10
b= 'bx;
end
endmodule"
"module sr_edge_ff(clear, s, r, clock, q, qbar);
inout q, qbar;
input clear, s, r, clock;
sr_edge_prim pi (q, clear, s, r, clock);
not (qbar, q);
endmodule"
"module
module m555 (clock);
output clock;
reg clock;
initial
#5 clock =1;
always
#50 clock = ~ clock;
endmodule"
"module test_k;
wire q, clock, j, k, preset, clear;
reg j, k;
jkEdgeFF jk (q, clock, j, k,  preset,  clear);
initial
begin
reset_ff;
#50;
j  = 1;
k = 0;
#50;
end
m555 timer (clock);
endmodule"
"module
primitive latch (q, clock, data);
output q;
reg q;
input clock, data;
wire clock, data;
table
// clock data states output
0 1 : ??: 1;
00 :? ?: 0;
1 ? : ?  ?: -;
endtable
endprimitive
Convert the following behavioral description into a user-defined  primitive. After
doing this, add cases to reduce pessimism on x values for bits in flag.
module m(out, inl, in2, in3, in4, flag);
output out;
input in1, in2, in3, in4;
input [1:0] flag;
reg out;
always
@ {case, in1 , in2 , in3 , in4 }
case (flag)
0 :out =  in1;
1:out = in2;
2:out =  in3;
3 : out =  in4;
endcase
endmodule"
"module sr_edge_ff(clear, s, r, clock, q, qbar);
inout q, qbar;
input cl ear, s, r, clock;
sr_edge_prim pi (q, clear, s, r, clock);
not (qbar, q);
endmodule"
"module te st_sredge;
reg s, r, clear;
sr_edge_ff s1 (clear, s, r, clock, q, qbar);
m555 m1 (clock);
initial
begin
#10
clear = 1;
#200
clear = 0;
#200
s=l; r=0;
#200
s=0; r=l;
#200
s=0; r=0;
#200
$finish;
end
always
#200
$display(""time=%d clear=%d s=%d r=%d clock=%d q=%d qbar=%d"",
$time, clear, s, r, clock, q, qbar);
endmodule"
"module m555 (clock);
output clock;
reg clock;
initial
#5 clock = 1;
always
#50 clock = ~ clock;
endmodule"
"module
module  fullAdder_s(cOut, sum, aIn, bIn, cIn);
output  cOut, sum;
input  aIn, bIn, cIn;
wire x2;
nand
xnor
nor
or
not
endmodule"
"module system();
micro mbehav();
mem mrtl();
graph masic();
parity_check pswitch();
endmodule"
"module adder(in1, in2, cin, out,  cout, zero_flag);
/* repeat structural adder from chapter 4; add 1 o/p*/
/* add block of code as follows */
output out, zero_flag, cout;
reg zero_flag;
input in1, in2, cin;
always@ out
if (out == 0)
zero_flag = 1;
else
zero_flag = 0;
nand (x2, in1, in2),
(cout, x2, x8);
xnor (x9, x5, x6);
nor (x5,  x1, x3),
(xl,inl,in2);
or (x8, x1,x7);
not (out,  x9),
(x3, x2),
(x6, x4),
(x4, cin),
(x7, x6);
endmodule"
"module disp;
reg [0:31] rval, rvall, i;
initial
begin
rval =101;
rvall = 2020;
$display(""rval=%h hex =%d decimal"",rval,rval);
$display(""rval=%0h hex =%0d decimal"" ,rval,rval);
$displayh(""rval = %d"",rval);
$display (""table of hex values"");
$display(""rval rvall"");
$displayh(rval[0:7], rvall [0:7]);
$displayh(rval[8:15], rvall[8:15]);
$displayh(rval[16:23],rvall[16:23]);
$displayh(rval[24:31], rvall [24:31]);
$display(""example of  displayb follows"");
$displayb(rval);
$display(""example of displayo follows"");
$displayo(rval);
$display(""Simulation time is %t"",$time);
$display(""%d"", 1'bx);
$display(""“%h"", 14'bx01010);
$display(""%h %o"", 12'b001xxx101x01, 12'b001xxx101x01);
$display(""Current scope is %m"");
end
endmodule"
"module test_adder;
// test a 2 bit adder using $monitor
reg[1:0] in1, in2;
wire [2:0] out;
adder a (out,  inl, in2);
initial
begin
$monitor(""time=%d out=%d in1=%d in2=%d"",$time,out,in1,
in2);
in1=0;
in2 =  0;
repeat (4)
begin
repeat(4)
#5
in2 = in2+l;in1 =
in1+1;
end
end
initial
begin
#30 $monitoroff;#15 $monitoron;
#30 $finish;
end
endmodule"
"module adder(o,il,i2);
output [2:0]o; i nput [l:0]il, i2;
assign o = il + i2;
endmodule"
"module
module adder(...);
endmodule"
"module test_adder;
// All lines here are same as in the 9.3.2
// Add the following always block to this module
always @out
if (out=== 'bX)
$stop;
endmodule"
"module adder(...);
endmodule"
"module
module adder(o,il,i2);
endmodule"
"module my_design(....);
endmodule"
"module
Example 9-2. Compiling code conditionally based on prior macro
definitions using `ifdef.
In the above example, the text-macro RTL must be defined prior to the module if
RTL view is desired. The lines between `ifdef and `else [line starting with wire in
this case] is selected  and lines between `else and `endif are ignored [and  line here].
9.4.2 Syntax
conditional_compiler_directive ::=
`ifdef text_macro_name
first_group_of_lines
[`else
second_group_of_lines
`endif]
9.5 `default_nettype
9.5.1 Example
`default_nettype trireg
module switch_sim(,,,);
nmos(out0, in1, in2);
nmos(out, in1, out0);                 ..............
endmodule"
"module Processor(procRead, pro cWrite, procAddress, procData, procClock, reset);
output procRead, procWrite;
inout [`ADDR_SIZE-1:0]procAddress;
inout [`DATA_SIZE-1:0] procData;
input procClock;
input reset;
endmodule"
"module MainMemory(memRead, memWrite,  memAddress, memData, memClock,reset);
input memRead, memWrite, memClock, reset;
input [`ADDR_SIZE-1:0] memAddress;
input [`DATA_SIZE-1:0] memData;
endmodule"
"module
module System();
wire [`ADDR_SIZE-1:0] memAddress;
wire [`DATA_SIZE-1:0] memData;
wire [`ADDR_SIZE-1:0] procAddress;
wire [`DATA_SIZE-1:0] procData;
Processor p(procRead, procWrite, procAddress, procData, procClock,
reset);
MainMemory m(memRead , memWrite, memAddress, memData, memClock,
reset);
Cache c(procRead, procWrite, procAdd ress, procData,
memRead, memWrite, memAddress, memData, reset, clock);
endmodule"
"module
module validCache(address, validOut, clock, write, read, reset);
input [`ADDR_SIZE-1:0] address;
input clock, write, read, reset;
output validOut;
reg validOut;
reg [`CACHE_SIZE-1:0] validCacheMem;
always @reset
if (reset)
validCacheMem  = `CACHE_SIZE'bO;
always@write
@ (negedge clock)
if(!reset)
validCacheMem[address[`ADDR_SIZE-`TAG_SIZE-1:0]]=1;
always @read
@(posedge clock)
validOut = validCacheMem[address[`ADDR_SIZE-`TAG_SIZE-1:0]];
endmodule"
"module
module comparator(in1, in2, match);
input [`TAG_SIZE-1:0] in1, in2;
output match;
assign match = (in1 == in2);
endmodule"
"module
/* This mux will output data onto processor for read */
module dataMux(data0, data1, dataSel, outData);
input [`DATA_SIZE-1:0] data0, data1;
input dataSel;
output [`DATA_SIZE-1:0] outData;
// cache controller must generate a 1 for read_cache and
// 0 for read_miss states for dataSel lines.
assign outData = dataSel ? data0 : data1;
endmodule"
"module)
12.4 Examples
Adder(Combinational Logic e xample):
module m(out,in 1,in2);
output [4:0] out;
input [3:0] inl, in2;
assign out = inl + in2;
endmodule"
"module mux42(out, data, sel);
input [3:0] data;
input [1:0] sel;
output out;
reg out;
always @(data or sel)
case (sel)
`DATA0 : out = data[0];
`DATA1 : out = data[l];
`DATA2 : out = data[2];
`DATA3 : out = data[3];
endcase
endmodule"
"module TLC(R, G, Y, clock, reset);
output R, Y, G; // Red, Ye llow, Green Signal lines
input clock, reset;
reg next_state;
reg R, Y, G;
always @(posedge clock)
begin
case (next_state)
`GREEN:
begin
next_state = `YELLOW;
G=1 ;
R = 0;
end
`YELLOW: begin
next_state = `RED;
Y=1;
G = 0;
end
`RED: begin
next_state = `GREEN;
R = 1;
Y = 0;
end
endcase
end
always @(reset)
next_state = `RED;
endmodule"
"module comparator(in1, in2, match);
input [TAG_SIZE-l:0] in1, in2;
output match;
assign match = (in1  == in2);
endmodule"
"module
/* This mux will output data onto processor for read */
module dataMux(data0, datal, dataSel, outData);
input [`DATA_SIZE-1:0] data0, data1;
input dataSel;
output [`DATA_SIZE-1:0] outData;
// cache controller must generate a 1 for read_cache and
// 0 for read_miss states for dataSel lines.
assign outData = dataSel ? data0: data1;
endmodule"
"module
Example 13-1. Parametrized design.
In Example 13-1, the default value of the parameter width is 8, unless you
override the  value when the module is instantiated. When you  change the value, you
build a different version of your design. This type of design is called a parameterized
design. Parameterized designs are read into dc_shell as templates with the read
command. These designs are stored in an intermediate format so that they can be
built with different (nondefault) parameter values when they are instantiated.
If you use parameters as constants that never change, do not read in your design
as a template. One way to build a template into your design is by instantiating it in
your Verilog  code. Example 13-2 s hows how to do this.
module param (a,b,c);
input [3:0] a,b;
output [3:0] c;
foo #(4) U1(a,b,c);
//instantiate foo
endmodule"
"module f_add(add, i1, i2);
input [ 3:0] i1, i2;
output [4:0] add;
function [4:0] FourBitAdd;
input [3:0] a, b;
reg c;
integer i;
begin
c = 0;
for (i = 0; i <= 3; i = i + 1) begin
FourBitAdd[i] = a[i]^ b[i]^ c;
c = a[i] & b[i] | a[i] & c | b[i] & c;
end
adder[4] = c;
end
endfunction
assign add = adder(i1, i2);
endmodule"
"module mux42(out, data, sel);
input [3:0] data;
input [1:0] sel;
output out;
reg out;
reg [3:0] data;
reg [1:0] sel;
always @(data or sel)
case (sel)
`DATA0 : out = data[0];
`DATA1 : out = data[l];
`DATA2 : o ut = data[2];
`DATA3 : out = data[3];
endcase
endmodule"
"module latch(out, clock , data);
output out;
input clock, data;
always @ (clock or reset)
begin
if (clock) begin
out = data;
end
endmodule"
"module bcd_decode(b, d);
input [3:0] b;
output [9:0] d;
reg [9:0]  d;
always @(b) begin
case(b)
4'h0: d= 10'b1;
4'h1: d= 10'b10;
4'h2: d=   10'bl00;
4'h3: d=    10'b1000;
4'h4: d=   10'b10000;
4'h5: d= 10'b100000;
4'h6: d= 10'b1000000;
4'h7: d= 10'b10000000;
4'h8: d= 10'bl00000000;
4'h9: d=  10'bl000000000;
// default: d= 10’b0; Uncommenting this line will stop
latch-creation
endcase
end
endmodule"
"module dff_with_reset(data, clock, r, out);
input clock, r, data;
output out;
reg out;
always @ (posedge clock or posedge r)
begin
if(r)
//asynchronous reset
out = 0;
else
//posedge clock is  assumed
out = data;
end
endmodule"
"module
Example 14-7. Asynchronous set/reset on a design.
14.1.5.2 synchronous_set_reset –  The synchornous_set_reset check causes
Synthesizer to  check specified objects for synchronous set or reset of a flip-flop.
This directive takes one argument of a double-quoted list of single-bit signals
separated by commas.
The syntax of  synchronous_set_reset is
// Synthesis  synchronous_set_reset ""object_name,...""
module sync_set_reset(clk, reset, set, dl, d2, y, t);
input clk, reset, set, dl, d2 ;
output y, t;
// Synthesis sync_set_reset ""reset, set""
reg y, t;
always @ (posedge clk)
begin: synchronous_reset
if (reset)
y = 1'b0; //synchronous reset
else
y = d1;
end
always @ (posedge clk)
begin: synchronous_set
if (set)
t = 1'b1; //synchronous set
else
t = d2;
end
endmodule"
"module one_hot_example (reset, set, , out, data);
input reset, set;
output out;
// Synthesis one_hot ""reset, set""
reg y,t;
always @ (reset or set)
begin: di rect_set_reset
if (reset)
y = 1'b0; //asynchronous reset by ""reset""
else if (set)
y = 1'bl; //asynchronous set by ""set""
end
// code for normal clocking cases here
endmodule"
"module one_cold(reset, set, out; in)
input reset, set;
output out;
input in;
// Synthesis one_cold ""reset, set""
reg out;
always @ (reset or set)
begin: direct_set_reset
if (~reset)
y = 1'b0; // asynchronous reset by ""~reset""
else if (~set)
y = 1'bl; // asynchronous set by ""~set""
end
endmodule"
"module bus_latch(reset, set, control, out, in);
input reset, set, control;
input [0:1] in;
output [0:1] out
always @ (reset or set or  control or in)
begin:
if (reset)
y = 0;
else if (set)
y = 2;
else if  (control)
out = in;
end
endmodule"
"module mux8tol(DIN,SEL,DOUT);
input [7:0] DIN;
input [2:0] SEL;
output DOUT;
reg DOUT;
//Synthesis infer_mux ""mux_blk""
always @ (SEL or DIN)
begin: mux_blk
case (SEL)
3'b000 : DOUT < =DIN[0];
3'b001: DOUT<=DIN[l];
3'b010 : DOUT<=DIN[2];
3'b011: DOUT<=DIN[3];
3'b100 : DOUT < =DIN[4];
3'bl01 :DOUT<=DIN[5];
3'b110 :   DOUT <=D IN[6];
3'b111 : DOUT<=DIN[7];
endcase
end
endmodule"
"module
Example 14-16. Three-state with registered enable.
14.3.4 Three-State with Registered Enable
In Example 14-16, the three-state gate has a register on its enable. To remove the
register from the  enable, use two always blocks to separate the register inference
from the three-state gate  inference, and add a register temp, as  shown in
Example 14-17.
module threestate_noreg_ff (c lock, condition, enable, in, out);
input in, ena ble, condition, clock;
output out;
reg out;
reg temp;
always @ (posedge clock)
begin //f lip-flop on input
if (condition)
temp = in;
end
always @ (enable or temp)
begin
if (enable) //three-state
out = temp;
else
out= 1'bz;
end
endmodule"
"module
module dff_logic(q, data, clock);
input clock, data;
output q;
always @posedge clock
q = data;
endmodule"
"module  m( );
reg notif_reg;wire data, clock;
specify
$setup(posedge data, posedge clock, 10, notif_reg);
endspecify
always @ notif_reg
$display(“Setup violation in %m at time %t”, $time);
endmodule"
"module path delays
(clk *> q, qBar) = (tPLHc, tPHLc);
(p, c *> q,  qBar) = (tPLHpc, tPHLpc);
// Model the timing c hecks
$setup(d, posedge clk &&  e, tsetup, notifier);
$hold(d, negedge clk && e, thold, notifier);
$period(negedge clk, twidth, notifier);
$width(negedge c, t_pc_width, notifier);
$width(negedge p, t_pc_width, notifier);
$recovery(posedge c, posedge clk, (recover, notifier);
endspecify
endmodule"
"module
Example 15-5. State dependent path delay specifications: example
statements.
In this example, first two state-dependent paths describe a pair of output rise and
fall delay times when the XOR gate (xl) inverts a changing input. The last two state-
dependent paths describe another pair of output rise and fall delay times when the
XOR gate buffers a changing input.
Another Example
module  ALU (ol, il, i2, opcode);
input  [7:0] i1,i2;
input  [2:1] opcode;
output  [7 :0]ol;
//functional description omitted
specify
// add operation
if (opcode == 2'b00) (i1,i2 *> ol) = (25.0,25.0);
//pass-through il operation
if (opCOde == 2'b01) (i1 => ol) = (5.6,8.0);
// pass-through i2 operation
if (opcode == 2'b10) (i2 => ol) -=(5.6, 8.0);
// delays on opcode changes
(opcode  => ol) = (6.1,6.5);
endspecify
endmodule"
"module
module dff_logic(q, data, clk, reset);
regq;
output q;
wire clk, reset, data;
always @posedge clk
q = data;
always @reset
if (reset ==1)
deassign q;
else
assign q = 0;
endmodule"
"module m;
initial
$hello;
endmodule"
"module
Note:  Use the $log2 task as def ined using Programming Language Interface, in
the book, for both the modules.
module m2;
reg [7:0]  in, out;
initial
begin
in =16;
$monitor($time,,in,, out);
#100
$log2(in, out, in);
end
endmodule"
"module shreg (out, in,  phase1, phase2);
/* IO port declarations, where 'out' is the inverse
of 'in' c ontrolled by the dual-phased clock */
output out; //shift register output
input in, //shift register input
phase1, //clocks
phase2;
tri wb1, wb2, out; //tri nets pulled up to VDD
pullup //depletion mode pullup devices
(wb1), (wb2), (out);
trireg (medium) wa1, wa2, wa3 ; //charge storage nodes
supply0 gnd; //ground supply
nmos #3  //pass devices and their interconnections
a1(wa1,in,phase1), b1(wb1,gnd,wa1),
a2(wa2,wb1 ,phase2), b2(wb2,gnd,wa2),
a3(wa3,wb2,phase1), gout(out,gnd,wa3);
endmodule"
"module sram(dataOut, address, dataIn, write);
output dataOut;
input address, dataIn, w rite;
tri       w1, w3, w4,  w43;
bufif1
g1(w1, dataIn , write);
tranif1
g2(w4, w1,  address);
not (pull0, pull1)
g3(w3, w4), g4(w4, w3);
buf
g5(dataOut, w1);
endmodule"
"module as below:
module NewTestShReg;
wire shiftout; //net to receive circuit output value
reg shiftin; //register to drive value into circuit
reg   phase1,phase2; //clock driving values
parameter d = 100; //define the waveform time step
shreg cct (shiftout, shiftin, phase1, phase2);
initial
begin :main
shiftin = 0;//initialize waveform input stimulus
phase1 = 0;
phase2 = 0;
$monitor(""time=%d wa1=%d wb1=%d wa2=%d wb2 = %d wa3=%d out =
%d\n"",
cct.wa1, cct.wb1, cct.wa2, cct.wb2,
cct.wa3, cctout);
// setup the  monitoring  information
repeat(2) //shift data in
begin
#d phase1 = 0; //time step defined by parameter d
#d phase1 = 1;#d phase1 = 0;#d phase2 = 0;
#d phase2 = 1;
#d phase2 = 0;
end
end
endmodule"
"module
Example 19-1. Analog resistor described in Verilog’s analog extensions.
19.1.3 Syntax
analog_module ::=
module_keyword module_identifier [list_of_ports]
{analog_ module _item}
endmodule"
"module  transformer(inl, in2, outl, out2);
analog
begin
V(node, outm) <+ leakL * dot(I(node, outl);
V(out2, node) <+ ratio * V(in2, inl);
end
endmodule"
"module will be
defined that instantiates an analog module and a digital module. This will be
transparent to the language and one really has to develop a model underneath for the
connections of electrical wires to digital net types.
module  mixed-signal;
electrical a1;
wire w2, w3, w4;
manalog mai(al, w2, w3);
mdigital mdi(al, w4);
endmodule"
"module manalog (a1, a2, a3) ;
inout a1,  a2,  a3;
electrical a1, a2, a3;
// Body of the module
endmodule"
"module
endmodule"
"module_declaration
| UDP_declaration
module_declaration
::= module_keyword  module_identifier [lis t_of_ports]
{module_item}
endmodule"
"module_declaration
syn_module_declaration
::=module_keyword module_identifier [list_of_ports]
{syn_module_item}
endmodule"
"module
`ifdef, `end if and `else compiler directives
B.5 Verilog Keywords Set for Logic Synthesis
always and assign begin
buf bufif0 bufif1 case
casex casez cmos deassign
default defparam disable else
end case endunction endmodule"
"module. A module is the basic building block in Verilog. A module can be an element or a collection of lower-level design blocks. Typically, elements are grouped 
into modules to provide common functionality th at is used at many places in the design. 
A module provides the necessary functionality to  the higher-level block through its port 
interface (inputs and outputs), but hides the internal implementation. This allows the 
designer to modify module internals w ithout affecting the rest of the design. 
   
In Figure 2-5
, ripple carry counter, T_FF, D_FF are examples of modules. In Verilog, a 
module is declared by the keyword module. A corresponding keyword endmodule"
"module definition. Each module must have a module_name, 
which is the identifier for the module, and a module_terminal_list, which describes the 
input and output terminals of the module.   
module <module_name> (<module_terminal_list>); 
 
... <module internals> ... 
... endmodule"
"module as follows: 
  
module T_FF (q, clock, reset); 
. . 
<functionality of T-flipflop> 
. . endmodule"
"module provides a template from which you can create actual objects. When a module 
is invoked, Verilog creates a unique object from the template. Each object has its own name, variables, parameters, and I/O interface. The process of creating objects from a 
module template is called instantiation, and the objects are called instances. In Example 
2-1, the top-level block creates four instances from the T-flipflop (T_FF) template. Each 
T_FF instantiates a D_FF and an inverter gate. Each instance must be given a unique 
name. Note that // is used to denote single-line comments. 
  
Example 2-1 Module Instantiation 
  
// Define the top-level module called ripple carry 
// counter. It instantiates 4 T-flipflops. Interconnections are 
// shown in Section 2.2, 4-bit Ripple Carry Counter. module ripple_carry_counter(q, clk, reset); 
 
output [3:0] q; //I/O signals and vector declarations 
              //will be explained later. 
input clk, reset; //I/O signals will be explained later.  
//Four instances of the module T_FF are created. Each has a unique 
//name.Each instance is passed a set of signals. Notice, that 
//each instance is a copy of the module T_FF. 
T_FF tff0(q[0],clk, reset); T_FF tff1(q[1],q[0], reset); T_FF tff2(q[2],q[1], reset); 
T_FF tff3(q[3],q[2], reset);  
endmodule"
"module T_FF. It instantiates a D-flipflop. We assumed 
// that module D-flipflop is defined elsewhere in the design. Refer // to Figure 2-4 for interconnections. 
module T_FF(q, clk, reset);  //Declarations to be explained later 
output q; input clk, reset; 
wire d;  D_FF dff0(q, d, clk, reset); // Instantiate D_FF. Call it dff0. 
not n1(d, q); // not gate is a Verilog primitive. Explained later.  
endmodule"
modules. One module definition cannot contain another module definition within the module and endmodule
"module definitions and instances of a module. Module definitions simply 
specify how the module will work, its internal s, and its interface. Modules must be 
instantiated for use in the design.   
 
Example 2-2
 shows an illegal module nesting where the module T_FF is defined inside 
the module definition of the ripple carry counter. 
  
Example 2-2 Illegal Module Nesting 
  
// Define the top-level module called ripple carry counter. 
// It is illegal to define the module T_FF inside this module. module ripple_carry_counter(q, clk, reset); 
output [3:0] q; input clk, reset;  
   module T_FF(q, clock, reset);// ILLEGAL MODULE NESTING    ... 
   <module T_FF internals>    ...    endmodule"
"module ripple_carry_counter(q, clk, reset); 
 output [3:0] q; 
input clk, reset;  //4 instances of the module T_FF are created. 
T_FF tff0(q[0],clk, reset); T_FF tff1(q[1],q[0], reset); 
T_FF tff2(q[2],q[1], reset); T_FF tff3(q[3],q[2], reset);  
endmodule"
"module, four instances of the module T_FF (T-flipflop) are used. Therefore, 
we must now define ( Example 2-4 ) the internals of the module T_FF, which was shown 
in Figure 2-4 . 
  
Example 2-4 Flipflop T_FF 
  
module T_FF(q, clk, reset); 
 
output q; input clk, reset; 
wire d; 
D_FF dff0(q, d, clk, reset); 
not n1(d, q); // not is a Verilog-provided primitive. case sensitive 
endmodule"
"module D_FF. We assume asyn chronous reset for the D_FFF. 
  
Example 2-5 Flipflop D_F 
  
// module D_FF with synchronous reset 
module D_FF(q, d, clk, reset);  
output q; input d, clk, reset; reg q; 
 // Lots of new constructs.  Ignore the functionality of the 
// constructs. // Concentrate on how the design block is built in a top-down fashion. always @(posedge reset or negedge clk) 
if (reset)     q <= 1'b0; 
else     q <= d;  endmodule"
"module stimulus; 
 reg clk; 
reg reset; wire[3:0] q;  
// instantiate the design block ripple_carry_counter r1(q, clk, reset); 
 // Control the clk signal that drives the design block. Cycle time = 10initial    clk = 1'b0; //set clk to 0 
always 
   #5 clk = ~clk; //toggle clk every 5 time units  // Control the reset signal that drives the design block // reset is asserted from 0 to 20 and from 200 to 220. 
initial 
begin    reset = 1'b1;    #15 reset = 1'b0;    #180 reset = 1'b1; 
   #10 reset = 1'b0; 
   #20 $finish; //terminate the simulation end  // Monitor the outputs 
initial 
   $monitor($time, "" Output q = %d"",  q);  endmodule"
"modules MEM, SC, and Xbar, using the module/endmodule"
"modules have no terminal lists.  
 
b. Define the module IS, using the module/endmodule"
"modules MEM, SC, Xbar and call the instances mem1, 
sc1, and xbar1, respectively. You do not need to define the internals. Assume that the module IS has no terminals.  
 
c. Define a stimulus block (Top), using the module/endmodule"
"module is a basic building block in Chapter 2 , Hierarchical 
Modeling Concepts. We ignored the internals of modules and concentrated on how modules are defined and instantiated. In this section, we analyze the internals of the 
module in greater detail. 
   
A module in Verilog consists of distinct parts, as shown in Figure 4-1
. 
  
 
Figure 4-1. Components of a Verilog Module 
  
 
 
A module definition always begins with the keyword module. The module name, port 
list, port declarations, and optional parameters must come first in a module definition. Port list and port declarations are present only if the module has any ports to interact with 
the external environment.The five components within a module are: variable declarations, 
dataflow statements, instantiation of lower modules, behavioral blocks, and tasks or functions. These components can be in any order and at any place in the module 
definition. The endmodule"
"module definition. All 
components except module, module name, and endmodule"
"module shown above, let us consider a simple 
example of an SR latch, as shown in Figure 4-2 . 
  
 
Figure 4-2. SR Latch 
  
 
 
The SR latch has S and R as the input ports and Q and Qbar as the output ports. The SR latch and its stimulus can be modeled as shown in Example 4-1
. 
  
Example 4-1 Components of SR Latch 
  
// This example illustrates the different components of a module 
 
// Module name and port list // SR_latch module 
module SR_latch(Q, Qbar, Sbar, Rbar); 
 
//Port declarations 
output Q, Qbar; input Sbar, Rbar; 
 
// Instantiate lower-level modules // In this case, instantiate Verilog primitive nand gates 
// Note, how the wires are connected in a cross-coupled fashion. 
nand n1(Q, Sbar, Qbar); 
nand n2(Qbar, Rbar, Q); 
 // endmodule"
"modules 
// In this case, instantiate SR_latch // Feed inverted set and reset signals to the SR latch SR_latch m1(q, qbar, ~set, ~reset);  
// Behavioral block, initial 
initial begin   $monitor($time, "" set = %b, reset= %b, q= %b\n"",set,reset,q);   set = 0; reset = 0; 
  #5 reset = 1; 
  #5 reset = 0;   #5 set = 1; end  
// endmodule"
"module 
  
 
Notice the following characteristic s about the modules defined above: 
   
• In the SR latch definition above , no tice that all components described in Figure 
4-1 need not be present in a module. We do not find variable declarations, 
dataflow (assign) statements, or behavioral blocks (always or initial).  
 
• However, the stimulus block for the SR latch contains module name, wire, reg, 
and variable declarations, instantiation of lower level modules, behavioral block 
(initial), and endmodule"
"module, module name, and endmodule"
"module fulladd4(sum, c_out, a, b, c_in); 
 
//Begin port declarations section 
output[3:0] sum; output c_cout; 
 
input [3:0] a, b; 
input c_in; 
//End port declarations section ... 
<module internals> 
... 
endmodule"
"module DFF(q, d, clk, reset); 
output q; 
reg q; // Output port q holds value; therefore it is declared as reg. 
input d, clk, reset; 
... 
... endmodule"
"module fulladd4 in Example 4-3  can be declared using an ANSI C style 
syntax to specify the ports of that module. Each declared port provides the complete 
information about the port. Example 4-5  shows this alternate syntax. This syntax avoids 
the duplication of naming the ports in both the module definition statement and the module port list definitions. If a port is declar ed but no data type is specified, then, under 
specific circumstances, the signal will default to a wire data type. 
  
Example 4-5 ANSI C Style Port Declaration Syntax 
  
module fulladd4(output reg [3:0] sum, 
                output reg c_out, 
                input [3:0] a, b, //wire by default                 input c_in); //wire by default ... 
<module internals> ... 
endmodule"
"module fulladd4     //is connected to a register variable SUM in module Top.     .     . 
    <stimulus> 
    .     . endmodule"
"module instantiation and the ports in a module definition. These two methods cannot be mixed. 
These methods are discussed in the following sections. 
   
Connecting by ordered list 
  
Connecting by ordered list is the most intuitiv e method for most beginners. The signals to 
be connected must appear in the module instantiation in the same order as the ports in the 
port list in the module definition. Once agai n, consider the module fulladd4 defined in 
Example 4-3
. To connect signals in module Top by ordered list, the Verilog code is 
shown in Example 4-7 . Notice that the external signals SUM, C_OUT, A, B, and C_IN 
appear in exactly the same order as the ports sum, c_out, a, b, and c_in in module 
definition of fulladd4.   
Example 4-7 Connection by Ordered List 
  
module Top; 
 
//Declare connection variables 
reg [3:0]A,B; 
reg C_IN; 
wire [3:0] SUM; wire C_OUT; 
 
    //Instantiate fulladd4, call it fa_ordered. 
    //Signals are connected to ports in order (by position) 
    fulladd4 fa_ordered(SUM, C_OUT, A, B, C_IN);     ... 
    <stimulus> 
    ... 
endmodule"
"module fulladd4(sum, c_out, a, b, c_in); output[3:0] sum; 
output c_cout; 
input [3:0] a, b; input c_in;     ...     <module internals> 
    ... 
endmodule"
"module and 
endmodule"
"modules.   
Example 5-5 Verilog Description of Multiplexer 
  
// Module 4-to-1 multiplexer. Port list is taken exactly from 
// the I/O diagram. 
module mux4_to_1 (out, i0, i1, i2, i3, s1, s0);  
// Port declarations from the I/O diagram output out; input i0, i1, i2, i3; 
input s1, s0;  
// Internal wire declarations wire s1n, s0n; wire y0, y1, y2, y3; 
 // Gate instantiations 
 // Create s1n and s0n signals. 
not (s1n, s1); 
not (s0n, s0);  
// 3-input and gates instantiated 
and (y0, i0, s1n, s0n); 
and (y1, i1, s1n, s0); 
and (y2, i2, s1, s0n); and (y3, i3, s1, s0); 
 
// 4-input or gate instantiated 
or (out, y0, y1, y2, y3); 
 endmodule"
"module (no ports) initial begin   // set input lines 
  IN0 = 1; IN1 = 0; IN2 = 1; IN3 = 0; 
  #1 $display(""IN0= %b, IN1= %b, IN2= %b, IN3= %b\n"",IN0,IN1,IN2,IN3);    // choose IN0   S1 = 0; S0 = 0; 
  #1 $display(""S1 = %b, S0 = %b, OUTPUT = %b \n"", S1, S0, OUTPUT); 
   // choose IN1   S1 = 0; S0 = 1; 
  #1 $display(""S1 = %b, S0 = %b, OUTPUT = %b \n"", S1, S0, OUTPUT);  
  // choose IN2   S1 = 1; S0 = 0;   #1 $display(""S1 = %b, S0 = %b, OUTPUT = %b \n"", S1, S0, OUTPUT); 
 
  // choose IN3 
  S1 = 1; S0 = 1; 
  #1 $display(""S1 = %b, S0 = %b, OUTPUT = %b \n"", S1, S0, OUTPUT); end 
 
endmodule"
"module fulladd(sum, c_out, a, b, c_in); 
 // I/O port declarations output sum, c_out; input a, b, c_in; 
 // Internal nets 
wire s1, c1, c2;  // Instantiate logic gate primitives 
xor (s1, a, b); and (c1, a, b); 
 xor (sum, s1, c_in); and (c2, s1, c_in); 
 xor  (c_out, c2, c1); 
 endmodule"
"module fulladd (1-bit 
full adder). 
  
 
Figure 5-7. 4-bit Ripple Carry Full Adder 
  
 
 
This structure can be translated to Verilog as shown in Example 5-8 . Note that the port 
names used in a 1-bit full adder and a 4-bit full adder are the same but they represent different elements. The element sum in a 1-bit adder is a scalar quantity and the element 
sum in the 4-bit full adder is a 4-bit vector quantity. Verilog keeps names local to a 
module. Names are not visible outside the module unless hierarchical name referencing is used. Also note that instance names must be specified when defined modules are 
instantiated, but when instantiating Verilo g primitives, the instance names are optional. 
  
Example 5-8 Verilog Description for 4-bit Ripple Carry Full Adder 
  
// Define a 4-bit full adder 
module fulladd4(sum, c_out, a, b, c_in);  
// I/O port declarations output [3:0] sum; 
output c_out; input[3:0] a, b; input c_in; 
 // Internal nets 
wire c1, c2, c3;  // Instantiate four 1-bit full adders. 
fulladd fa0(sum[0], c1, a[0], b[0], c_in); fulladd fa1(sum[1], c2, a[1], b[1], c1); 
fulladd fa2(sum[2], c3, a[2], b[2], c2); fulladd fa3(sum[3], c_out, a[3], b[3], c3);  
endmodule"
"module stimulus stimulates the 4-bit full adder by applying a few input combinations and 
monitors the results.   
Example 5-9 Stimulus for 4-bit Ripple Carry Full Adder 
  
// Define the stimulus (top level module) 
module stimulus; 
 // Set up variables 
reg [3:0] A, B; reg C_IN; wire [3:0] SUM; 
wire C_OUT;  
// Instantiate the 4-bit full adder. call it FA1_4 fulladd4 FA1_4(SUM, C_OUT, A, B, C_IN);  
 // Set up the monitoring for the signal values 
initial begin   $monitor($time,"" A= %b, B=%b, C_IN= %b, --- C_OUT= %b, SUM= %b\n"", 
                          A, B, C_IN, C_OUT, SUM); 
end 
 
// Stimulate inputs initial 
begin 
  A = 4'd0; B = 4'd0; C_IN = 1'b0; 
 
  #5 A = 4'd3; B = 4'd4;  
  #5 A = 4'd2; B = 4'd5; 
 
  #5 A = 4'd9; B = 4'd9; 
   #5 A = 4'd10; B = 4'd15; 
 
  #5 A = 4'd10; B = 4'd5; C_IN = 1'b1; 
end 
 endmodule"
"module called D implements the following logic equations: 
   
 
out = (a
b) + c 
  
 
The gate-level implementation is shown in Module D ( Figure 5-8 ). The module contains 
two gates with delays of 5 and 4 time units.   
 
Figure 5-8. Module D 
  
 
 
The module D is defined in Verilog as shown in Example 5-12 . 
  
Example 5-12 Verilog Definition for Module D with Delay 
  
// Define a simple combination module called D 
module D (out, a, b, c); 
 // I/O port declarations 
output out; 
input a,b,c; 
 
// Internal nets wire e;  
// Instantiate primitive gates to build the circuit and #(5) a1(e, a, b); //Delay of 5 on gate a1 
or  #(4) o1(out, e,c); //Delay of 4 on gate o1  endmodule"
"module is tested by the stimulus file shown in Example 5-13 . 
  
Example 5-13 Stimulus for Module D with Delay 
  
// Stimulus (top-level module) 
module stimulus; 
 
// Declare variables reg A, B, C; 
wire OUT; 
 
// Instantiate the module D 
D d1( OUT, A, B, C);  
// Stimulate the inputs. Finish the simulation at 40 time units. 
initial 
begin 
  A= 1'b0; B= 1'b0; C= 1'b0;  
  #10 A= 1'b1; B= 1'b1; C= 1'b1; 
 
  #10 A= 1'b1; B= 1'b0; C= 1'b0; 
   #20 $finish; 
end 
 
endmodule"
"module change. Notice how concise the description is compared to the 
gate-level description.   
Example 6-2 4-to-1 Multiplexer, Using Logic Equations 
  
// Module 4-to-1 multiplexer using data flow. logic equation 
// Compare to gate-level model module mux4_to_1 (out, i0, i1, i2, i3, s1, s0); 
 
// Port declarations from the I/O diagram 
output out; 
input i0, i1, i2, i3; input s1, s0; 
 
//Logic equation for out 
assign out =    (~s1 & ~s0 & i0)| 
                (~s1 & s0 & i1) |                 (s1 & ~s0 & i2) | 
                (s1 & s0 & i3) ; 
 
endmodule"
"module multiplexer4_to_1 (out, i0, i1, i2, i3, s1, s0);  // Port declarations from the I/O diagram 
output out; input i0, i1, i2, i3; 
input s1, s0;  // Use nested conditional operator 
assign out = s1 ? ( s0 ? i3 : i2) : (s0 ? i1 : i0) ;  
endmodule"
"module fulladd4(sum, c_out, a, b, c_in); 
 
// I/O port declarations 
output [3:0] sum; 
output c_out; input[3:0] a, b; 
input c_in; 
 // Specify the function of a full adder 
assign {c_out, sum} = a + b + c_in; 
 
endmodule"
"module counter. The code is shown in Figure 6-6
. The code contains instantiation of four T_FF modules. 
  
Example 6-6 Verilog Code for Ripple Counter 
  
// Ripple counter 
module counter(Q , clock, clear);  // I/O ports 
output [3:0] Q; input clock, clear; 
 // Instantiate the T flipflops T_FF tff0(Q[0], clock, clear); 
T_FF tff1(Q[1], Q[0], clear); 
T_FF tff2(Q[2], Q[1], clear); 
T_FF tff3(Q[3], Q[2], clear); 
 endmodule"
"module T_FF(q, clk, clear); 
 // I/O ports 
output q; input clk, clear;  
// Instantiate the edge-triggered DFF // Complement of output q is fed back. 
// Notice qbar not needed. Unconnected port. edge_dff ff1(q, ,~q, clk, clear);  
endmodule"
"module 
  
The design block is now ready. Now we must instantiate the design block inside the 
stimulus block to test the design. The stimulus block is shown in Example 6-9 . The clock 
has a time period of 20 with a 50% duty cycle.   
Example 6-9 Stimulus Module for Ripple Counter 
  
// Top level stimulus module 
module stimulus;  
// Declare variables for stimulating input 
reg CLOCK, CLEAR; wire [3:0] Q;  initial 
        $monitor($time, "" Count Q = %b Clear= %b"",  Q[3:0],CLEAR); 
 // Instantiate the design block counter counter c1(Q, CLOCK, CLEAR);  
// Stimulate the Clear Signal 
initial begin         CLEAR = 1'b1;         #34 CLEAR = 1'b0; 
        #200 CLEAR = 1'b1; 
        #50 CLEAR = 1'b0; end // Set up the clock to toggle every 10 time units initial 
begin         CLOCK = 1'b0; 
        forever #10 CLOCK = ~CLOCK; end 
 
// Finish the simulation at time 400 
initial 
begin         #400 $finish; 
end 
 
endmodule"
"module adder (sum, co, a, b, ci); 
output reg [7:0] sum = 0; //Initialize 8 bit output sum 
output reg       co  = 0; //Initialize 1 bit output co 
input      [7:0] a, b; 
input            ci; 
 -- 
-- 
endmodule"
"module adder (output reg [7:0] sum = 0, //Initialize 8 bit output 
              output reg       co  = 0, //Initialize 1 bit output co               input      [7:0] a, b, 
              input            ci               ); -- 
-- endmodule"
"module mux4_to_1 (out, i0, i1, i2, i3, s1, s0); 
 
// Port declarations from the I/O diagram output out; 
input i0, i1, i2, i3; input s1, s0; reg out; 
 always @(s1 or s0 or i0 or i1 or i2 or i3) 
case ({s1, s0}) //Switch based on concatenation of control signals         2'd0 : out = i0;         2'd1 : out = i1; 
        2'd2 : out = i2;         2'd3 : out = i3; 
        default: $display(""Invalid control signals""); endcase  
endmodule"
"module generates a bit-wise xor of two N-bit buses 
 module bitwise_xor (out, i0, i1); // Parameter Declaration. This can be redefined 
parameter N = 32; // 32-bit bus by default // Port declarations 
output [N-1:0] out; input [N-1:0] i0, i1;  
// Declare a temporary loop variable. This variable is used only // in the evaluation of generate blocks. This variable does not 
// exist during the simulation of a Verilog design genvar j;  //Generate the bit-wise Xor with a single loop 
generate for (j=0; j<N; j=j+1) begin: xor_loop 
 xor g1 (out[j], i0[j], i1[j]); end //end of the for loop inside the generate block endgenerate //end of the generate block  
// As an alternate style, 
// the xor gates could be replaced by always blocks. // reg [N-1:0] out; //generate for (j=0; j<N; j=j+1) begin: bit // always @(i0[j] or i1[j]) out[j] = i0[j] ^ i1[j]; 
//end 
//endgenerate  endmodule"
"module instance # statement. localparam product_width = a0_width + a1_width;  
// Port declarations 
output [product_width -1:0] product; input [a0_width-1:0] a0; input [a1_width-1:0] a1;  
 
// Instantiate the type of multiplier conditionally. // Depending on the value of the a0_width and a1_width // parameters at the time of instantiation, the appropriate // multiplier will be instantiated. 
generate 
 if (a0_width <8) || (a1_width < 8)     cla_multiplier #(a0_width, a1_width) m0 (product, a0, a1);  else 
    tree_multiplier #(a0_width, a1_width) m0 (product, a0, a1); endgenerate //end of the generate block 
 endmodule"
"module mux4_to_1 (out, i0, i1, i2, i3, s1, s0); 
 // Port declarations from the I/O diagram output out; input i0, i1, i2, i3; 
input s1, s0; //output declared as register 
reg out;  //recompute the signal out if any input signal changes. 
//All input signals that cause a recomputation of out to //occur must go into the always @(...)  sensitivity list. 
always @(s1 or s0 or i0 or i1 or i2 or i3) begin   case ({s1, s0}) 
  2'b00: out = i0;   2'b01: out = i1; 
  2'b10: out = i2;   2'b11: out = i3;   default: out = 1'bx; 
  endcase end 
 endmodule"
"module counter(Q , clock, clear);  
// I/O ports 
output [3:0] Q; input clock, clear; //output defined as register reg [3:0] Q; 
 
always @( posedge clear  or negedge clock) begin   if (clear) 
     Q <= 4'd0;  //Nonblocking assignments are recommended                  //for creating sequential logic such as flipflops 
  else      Q <= Q + 1;// Modulo 16 is not necessary because Q is a                 // 4-bit value and wraps around. 
end 
 
endmodule"
"module. task asymmetric_sequence; begin         #12 clock = 1'b0; 
        #5 clock = 1'b1; 
        #3 clock = 1'b0;         #10 clock = 1'b1; end 
endtask ... 
... endmodule"
"module top; 
reg [15:0] cd_xor, ef_xor; //variables in module top 
reg [15:0] c, d, e, f; //variables in module top - task automatic bitwise_xor; output [15:0] ab_xor; //output from the task 
input [15:0] a, b; //inputs to the task 
begin     #delay ab_and = a & b;     ab_or = a | b;     ab_xor = a ^ b; 
end 
endtask ... - // These two always blocks will call the bitwise_xor task 
// concurrently at each positive edge of clk. However, since 
// the task is re-entrant, these concurrent calls will work correctly. always @(posedge clk)     bitwise_xor(ef_xor, e, f); 
- always @(posedge clk2) // twice the frequency as the previous block 
    bitwise_xor(cd_xor, c, d); - - 
endmodule"
"module that contains the function calc_parity 
module parity; 
... reg [31:0] addr; 
reg parity;  //Compute new parity whenever address value changes 
always @(addr) 
begin 
        parity = calc_parity(addr); //First invocation of calc_parity 
        $display(""Parity calculated = %b"", calc_parity(addr) ); 
                                    //Second invocation of calc_parity 
end ... 
... 
//define the parity calculation function 
function calc_parity; 
input [31:0] address; begin 
        //set the output value appropriately. Use the implicit 
        //internal register calc_parity. 
        calc_parity = ^address; //Return the xor of all address bits. 
end endfunction 
... 
... 
endmodule"
"module 
  
8.3.3 Automatic (Recursive) Functions 
  
 
Functions are normally used non-recursively . If a function is called concurrently from two locations, the results are non-deterministic because both calls operate on the same 
variable space.   
 
However, the keyword automatic can be used to declare a recursive (automatic) function 
where all function declarations are allocated dynamically for each recursive calls. Each call to an automatic function operates in an independent variable space.Automatic 
function items cannot be accessed by hierarchical references. Automatic functions can be 
invoked through the use of their hierarchical name.   
 
Example 8-10
 shows how an automatic function is  defined to compute a factorial. 
  
Example 8-10 Recursive (Automatic) Functions 
  
//Define a factorial with a recursive function 
module top; 
... 
// Define the function 
function automatic integer factorial; 
input [31:0] oper; integer i; 
begin 
if (operand >= 2) 
   factorial = factorial (oper -1) * oper; //recursive call 
else    factorial = 1 ; end 
endfunction  
// Call the function integer result; initial 
begin      result = factorial(4); // Call the factorial of 7 
     $display(""Factorial of 4 is %0d"", result); //Displays 24 end ... 
... endmodule"
"module. 
  
Example 8-11 Constant Functions 
  
//Define a RAM model 
module ram (...); 
parameter RAM_DEPTH = 256; 
input [clogb2(RAM_DEPTH)-1:0] addr_bus; //width of bus computed                                         //by calling constant 
                                        //function defined below 
                                        //Result of clogb2 = 8 
                                        //input [7:0] addr_bus; 
-- -- 
//Constant function 
function integer clogb2(input integer depth); 
begin 
   for(clogb2=0; depth >0; clogb2=clogb2+1)       depth = depth >> 1; 
end 
endfunction 
-- 
-- endmodule"
"module if(compute_signed(vector) < -3) begin -- 
end 
 -- endmodule"
"module 
  
force and release on nets 
  
 force on nets overrides any continuous assign ments until the net is released. The net will 
immediately return to its normal driven value when it is released. A net can be forced to 
an expression or a value.   
module top; 
... 
... 
assign out = a & b & c; //continuous assignment on net out ... 
initial 
   #50 force out = a | b & c; 
   #50 release out; 
end ... 
... 
endmodule"
"module definition, as was discussed earlier in Section 
3.2.8 , Parameters. However, during compilation of Verilog modules, parameter values 
can be altered separately for each module instan ce. This allows us to pass a distinct set of 
parameter values to each module during comp ilation regardless of predefined parameter 
values.   
 
There are two ways to override parameter values: through the defparam statement or through module instance para meter value assignment. 
  
9.2.1 defparam Statement 
   
Parameter values can be changed in any module instance in the design with the keyword defparam. The hierarchical name of the module instance can be used to override 
parameter values. Consider Example 9-2
, which uses defparam to override the parameter 
values in module instances.   
Example 9-2 Defparam Statement 
  
//Define a module hello_world 
module hello_world; 
parameter id_num = 0; //define a module identification number = 0 
 
initial //display the module identification number         $display(""Displaying hello_world id number = %d"", id_num); 
endmodule"
"module module top; 
//change parameter values in the instantiated modules 
//Use defparam statement 
defparam w1.id_num = 1, w2.id_num = 2; 
 //instantiate two hello_world modules 
hello_world w1(); 
hello_world w2(); 
 
endmodule"
"module. Any parameter can be overridden 
with the defparam statement. The defparam construct is now considered to be a bad coding style and it is recommended that alternative styles be used in Verilog HDL code. 
  
 Note that the module hello_world can also be defined using an ANSI C style parameter 
declaration. Figure 9-3 shows the ANSI C style parameter declaration for the module 
hello_world.   
Example 9-3 ANSI C Style Parameter Declaration 
  
//Define a module hello_world 
module hello_world #(parameter id_num = 0) ;//ANSI C Style Parameter  
initial //display the module identification number         $display(""Displaying hello_world id number = %d"", id_num); 
endmodule"
"module is instantiated. To illustrate this, we 
will use Example 9-2  and modify it a bit. The new parameter values are passed during 
module instantiation. The top-level module can pass parameters to the instances w1 and 
w2, as shown below. Notice th at defparam is not needed. The simulation output will be 
identical to the output obtained with the defparam statement.   
//define top-level module 
module top; 
 
//instantiate two hello_world modules; pass new parameter values 
//Parameter value assignment by ordered list hello_world #(1) w1; //pass value 1 to module w1 
 
//Parameter value assignment by name 
hello_world #(.id_num(2)) w2; //pass value 2 to id_num parameter 
                              //for module w2  
endmodule"
"module with delays 
module bus_master; 
parameter delay1 = 2; 
parameter delay2 = 3; parameter delay3 = 7; 
... 
<module internals> 
... 
endmodule"
"module; instantiates two bus_master modules 
module top; 
 
//Instantiate the modules with new delay values  
//Parameter value assignment by ordered list 
bus_master #(4, 5, 6) b1(); //b1: delay1 = 4, delay2 = 5, delay3 = 6 
bus_master #(9, 4) b2(); //b2: delay1 = 9, delay2 = 4, delay3 = 
7(default)  
//Parameter value assignment by name 
bus_master #(.delay2(4), delay3(7)) b3(); //b2: delay2 = 4, delay3 = 7 
                                          //delay1=2 (default) 
// It is recommended to use the parameter value assignment by name // This minimizes the chance of error and parameters can be added 
// or deleted without worrying about the order. 
 
endmodule"
"module test only if text macro TEST is defined 
module test; ... ... 
endmodule"
"module stimulus as default 
module stimulus; ... ... 
endmodule"
"module 
  
 
The `ifdef and `ifndef directives can appear anywhere in the design. A designer can 
conditionally compile statements, modules, blocks, declarations, and other compiler directives. The `else directive is optional. A maximum of one `else directive can 
accompany an `ifdef or `ifndef. Any number of `elsif directives can accompany an `ifdef 
or `ifndef. An `ifdef or `ifndef is always closed by a corresponding `endif.   
 
The conditional compile flag can be set by using the `define statement inside the Verilog file. In the example above, we could define the flags by defining text macros TEST and 
ADD_B2 at compile time by using the `define statement. The Verilog compiler simply 
skips the portion if the conditional compile flag is not set. A Boolean expression, such as 
TEST && ADD_B2, is not allowed with the `ifdef statement. 
  
9.3.2 Conditional Execution 
   
Conditional execution flags allow the designer to control statement execution flow at run time. All statements are compiled but executed conditionally. Conditional execution flags 
can be used only for behavioral statements. The system task keyword $test$plusargs is 
used for conditional execution.   
 
Consider Example 9-6
, which illustrates conditional execution with $test$plusargs. 
  
Example 9-6 Conditional Execution with $test$plusargs 
  
//Conditional execution 
module test; 
... ... 
initial begin    if($test$plusargs(""DISPLAY_VAR"")) 
       $display(""Display = %b "", {a,b,c} ); //display only if flag is set 
   else //Conditional execution        $display(""No Display""); //otherwise no display 
end 
endmodule"
"module test; 
reg [8*128-1:0] test_string; 
integer clk_period; ... 
... 
initial 
begin 
   if($value$plusargs(""testname=%s"", test_string))        $readmemh(test_string, vectors); //Read test vectors 
   else 
       //otherwise display error message 
       $display(""Test name option not specified""); 
    if($value$plusargs(""clk_t=%d"", clk_period)) 
       forever #(clk_period/2) clk = ~clk; //Set up clock 
   else 
       //otherwise display error message 
       $display(""Clock period option name not specified"");  
end 
 
//For example, to invoke the above options invoke simulator with 
//+testname=test1.vec +clk_t=10 //Test name = ""test1.vec"" and clk_period = 10 
endmodule"
"module need to be defined by using 
certain time unit, e.g., 1  s, and delay values in another module need to be defined by using a different time unit, e.g. 100 ns. Verilog HDL allows the reference time unit for 
modules to be specified with the `timescale compiler directive. 
   
Usage: `timescale <reference_time_unit> / <time_precision> 
   
The <reference_time_unit> specifies the unit of measurement for times and delays. The 
<time_precision> specifies the precision to which the delays are rounded off during simulation. Only 1, 10, and 100 are valid integers for specifying time unit and time 
precision. Consider the two modules, dummy1 and dummy2, in Example 9-8
. 
  
Example 9-8 Time Scales 
  
//Define a time scale for the module dummy1 
//Reference time unit is 100 nanoseconds and precision is 1 ns `timescale 100 ns / 1 ns  
module dummy1;  
reg toggle;  //initialize toggle initial 
  toggle = 1'b0; 
 //Flip the toggle register every 5 time units 
//In this module 5 time units = 500 ns = .5 µs 
always #5 
    begin 
        toggle = ~toggle; 
        $display(""%d , In %m toggle = %b "", $time, toggle);     end 
 
endmodule"
"module 5 time units = 5 µs  = 5000 ns 
always #5 
    begin         toggle = ~toggle; 
        $display(""%d , In %m toggle = %b "", $time, toggle); 
    end 
 
endmodule"
"module execute the same Verilog code, the %m option will distinguish from which module instance the output is coming. No argument is needed for the %m option in the 
display tasks. See Example 9-10
. 
  
Example 9-10 Displaying Hierarchy 
  
//Displaying hierarchy information 
module M; ... initial 
    $display(""Displaying in %m""); 
endmodule"
"module top; 
... M  m1(); 
M  m2(); 
//Displaying hierarchy information M  m3(); endmodule"
"module test; integer r_seed; 
reg [31:0] addr;//input to ROM 
wire [31:0] data;//output from ROM 
... 
... ROM rom1(data, addr); 
 
initial 
   r_seed = 2; //arbitrarily define the seed as 2. 
 always @(posedge clock) 
   addr = $random(r_seed); //generates random numbers 
... 
<check output of ROM against expected results> 
... ... 
endmodule"
"module. Force the sum output to a & b & c_in for the time 
between 15 and 35 units. 
3: A 1-bit full adder FA is defined with gates and with delay parameters as shown 
below.   
// Define a 1-bit full adder 
module fulladd(sum, c_out, a, b, c_in); 
parameter d_sum = 0, d_cout = 0;  // I/O port declarations 
output sum, c_out; input a, b, c_in; 
 // Internal nets wire s1, c1, c2; 
 // Instantiate logic gate primitives 
xor (s1, a, b); and (c1, a, b);  
xor #(d_sum) (sum, s1, c_in); //delay on output sum is d_sum and (c2, s1, c_in); 
 or  #(d_cout) (c_out, c2, c1); //delay on output c_out is d_cout  
endmodule"
"module with defparam statements to change instance 
parameter values. Simulate the 4-bit full adder using the stimulus shown 
in Example 5-9  on page 77. Explain the effect of the full adder delays on 
the times when outputs of the adder appear. (Use delays of 20 instead of 5 used in this stimulus.)  
b. Build the fulladd4 with delay values passed to instances fa0, fa1, fa2, 
and fa3 during instantiation. Resimulate the 4-bit adder, using the stimulus above. Check if the results are identical. 
4: Create a design that uses the full adder example above. Use a conditional 
compilation (`ifdef). Compile the fulladd4 with defparam statements if the text 
macro DPARAM is defined by the `define statement; otherwise, compile the 
fulladd4 with module instance parameter values. 
5: Identify the files to which the follow ing display statements will write: 
  
//File output with multi-channel descriptor 
 
module test;  integer handle1,handle2,handle3; //file handles 
 //open files 
initial begin   handle1 = $fopen(""f1.out""); 
  handle2 = $fopen(""f2.out"");   handle3 = $fopen(""f3.out""); 
end  //Display statements to files 
initial begin 
//File output with multi-channel descriptor   #5;   $fdisplay(4, ""Display Statement # 1""); 
  $fdisplay(15, ""Display Statement # 2""); 
  $fdisplay(6, ""Display Statement # 3""); 
  $fdisplay(10, ""Display Statement # 4""); 
  $fdisplay(0, ""Display Statement # 5""); end 
 
endmodule"
"module top; 
A a1(); 
endmodule"
"module  
module B; initial 
    $display(""I am inside instance %m""); endmodule"
"module 
 
//Distributed delays in data flow definition of a module module M (out, a, b, c, d); output out; input a, b, c, d; 
 
wire e, f;  //Distributed delay in each expression assign #5 e = a & b; 
assign #7 f = c & d; 
assign #4 out = e & f; endmodule"
"module M (out, a, b, c, d); 
output out; input a, b, c, d; 
 wire e, f;  
and a1(e, a, b); and a2(f, c, d); 
and #11 a3(out, e, f);//delay only on the output gate endmodule"
"module is called a module path delay. Path delays are assigned in Verilog within the keywords specify and endspecify. The statements within these keywords constitute a 
specify block. 
  Specify blocks contain statements to do the following: 
  
• Assign pin-to-pin timing delays across module paths  
 
• Set up timing checks in the circuits  
 
• Define specparam constants  
  
 For the example in Figure 10-3
, we can write the module M with pin-to-pin delays, using 
specify blocks as follows: 
  
Example 10-3 Pin-to-Pin Delay 
  
//Pin-to-pin delays 
module M (out, a, b, c, d); 
output out; input a, b, c, d; 
 
wire e, f; 
 
//Specify block with path delay statements specify 
    (a => out) = 9; 
    (b => out) = 9; 
    (c => out) = 11; 
    (d => out) = 11; endspecify 
 
//gate instantiations 
and a1(e, a, b); 
and a2(f, c, d); and a3(out, e, f); 
endmodule"
"module 
  
 
We can now test our nor gate, using the stimulus shown below. 
  
//stimulus to test the gate 
module  stimulus; reg A, B; 
wire OUT; 
 //instantiate the my_nor module my_nor  n1(OUT, A, B);  
//Apply stimulus 
initial begin     //test all possible combinations     A = 1'b0;  B = 1'b0; 
    #5 A = 1'b0;  B = 1'b1; 
    #5 A = 1'b1;  B = 1'b0;     #5 A = 1'b1;  B = 1'b1; end  
//check results 
initial     $monitor($time, ""  OUT = %b, A = %b, B = %b"", OUT, A, B);  endmodule"
"module my_mux (out, s, i0, i1); 
 
output out; input s, i0, i1; 
 
//internal wire 
wire sbar; //complement of s 
 //create the complement of s; use my_nor defined previously. 
my_nor nt(sbar, s, s); //equivalent to a not gate 
 
//instantiate cmos switches 
cmos (out, i0, sbar, s); cmos (out, i1, s, sbar);  
endmodule"
"module description for the CMOS inverter from the switch-level circuit diagram in Figure 11-7
. 
The Verilog description of the inverter is shown below. 
  
Example 11-6 CMOS Inverter 
  
//Define an inverter using MOS switches 
module my_not(out, in); 
 
output out; input in; 
 
//declare power and ground 
supply1 pwr; 
supply0 gnd;  
//instantiate nmos and pmos switches 
pmos  (out, pwr, in); 
nmos  (out, gnd, in); 
 endmodule"
"module cff ( q, qbar, d, clk); 
  output q, qbar; input d, clk; 
 
//internal nets wire e; wire nclk; //complement of clock  
//instantiate the inverter 
my_not nt(nclk, clk);  //instantiate CMOS switches cmos  (e, d, clk, nclk); //switch C1 closed i.e. e = d, when clk = 1. 
cmos  (e, q, nclk, clk); //switch C2 closed i.e. e = q, when clk = 0. 
  //instantiate the inverters my_not nt1(qbar, e); 
my_not nt2(q, qbar); 
 endmodule"
"module fulladd(sum, c_out, a, b, c_in);  
// I/O port declarations output sum, c_out; input a, b, c_in; 
 // Internal nets 
wire s1, c1, c2;  // Instantiate logic gate primitives 
xor (s1, a, b);//use Verilog primitive udp_and (c1, a, b); //use UDP 
 xor (sum, s1, c_in); //use Verilog primitive udp_and (c2, s1, c_in); //use UDP  
udp_or  (c_out, c2, c1);//use UDP 
 endmodule"
"module hello_top, 
which calls the task $hello_verilog, is defined in file hello.v as shown below. 
  
module hello_top; 
 initial 
    $hello_verilog; //Invoke the user-defined task $hello_verilog  
endmodule"
"module. All sets are 
interconnected. The connections between the sets are bidirectional. The entire internal 
representation can be traversed by using PLI library routines to obtain information about the module. PLI library routines are discussed later in the chapter. 
  
 To illustrate the internal data representation,  consider the example of a simple 2-to-1 
multiplexer whose gate level circuit is shown in Figure 13-4
. 
  
 
Figure 13-4. 2-to-1 Multiplexer 
  
 
 
The Verilog description of the circuit is shown in Example 13-1 . 
  
Example 13-1 Verilog Description of 2-to-1 Multiplexer 
  
module mux2_to_1(out, i0, i1, s); 
 
output out; //output port input i0, i1; //input ports 
input s; 
 
wire sbar, y1, y2; //internal nets 
 //Gate Instantiations 
not n1(sbar, s); 
and a1(y1, i0, sbar); 
and a2(y2, i1, s); 
or o1(out, y1, y2);  
endmodule"
"module mux2_to_1 described in Example 13-1 . A top-level module that instantiates the 
2-to-1 multiplexer and invokes the $get_ports task is shown below.   
module top; 
wire OUT; reg I0, I1, S; 
 mux2_to_1 my_mux(OUT, I0, I1, S); /*Instantiate the 2-to-1 mux*/  
initial begin 
  $get_ports(""top.my_mux""); /*invoke task $get_ports to get port list*/end  
endmodule"
"module mux2_to_1 described in Example 13-1
 on page 281. A top-level module that 
instantiates the 2-to-1 multiplexer, applies stimulus, and invokes the $my_stop_finish 
task is shown below.   
module top; 
wire OUT; 
reg I0, I1, S; 
 mux2_to_1 my_mux(OUT, I0, I1, S); //Instantiate the module mux2_to_1 
 
initial //Apply Stimulus 
begin 
  I0=1'b0; I1=1'b1; S = 1'b0;   $my_stop_finish(0); //Stop simulation. Don't print module instance 
name 
  #5 I0=1'b1; I1=1'b1; S = 1'b1; 
  $my_stop_finish(0,1); //Stop simulation. Print module instance name 
  #5 I0=1'b0; I1=1'b1; S = 1'bx;   $my_stop_finish(2,1); //Pass bad argument 2 to the task 
  #5 I0=1'b1; I1=1'b1; S = 1'b1; 
  $my_stop_finish(1,1); //Terminate simulation. Print module instance 
                          //name 
end  endmodule"
"module magnitude_comparator(A_gt_B, A_lt_B, A_eq_B, A, B); 
 //Comparison output output A_gt_B, A_lt_B, A_eq_B; 
 //4-bits numbers input 
input [3:0] A, B;  assign A_gt_B = (A > B); //A greater than B 
assign A_lt_B = (A < B); //A less than B assign A_eq_B = (A == B); //A equal to B 
 endmodule"
"module stimulus; 
 
reg [3:0] A, B; 
wire A_GT_B, A_LT_B, A_EQ_B;  //Instantiate the magnitude comparator magnitude_comparator MC(A_GT_B, A_LT_B, A_EQ_B, A, B); 
 initial 
  $monitor($time,"" A = %b, B = %b, A_GT_B = %b, A_LT_B = %b, A_EQ_B = %b"",         A, B, A_GT_B, A_LT_B, A_EQ_B); 
 //stimulate the magnitude comparator. 
initial begin   A = 4'b1010; B = 4'b1001; 
  # 10 A = 4'b1110; B = 4'b1111;   # 10 A = 4'b0000; B = 4'b0000; 
  # 10 A = 4'b1000; B = 4'b1100;   # 10 A = 4'b0110; B = 4'b1110;   # 10 A = 4'b1110; B = 4'b1110; 
end  
endmodule"
"module VAND (out, in0, in1); input in0; 
input in1; output out;  
//timing information, rise/fall and min:typ:max specify 
(in0 => out) = (0.260604:0.513000:0.955206, 0.255524:0.503000:0.936586); (in1 => out) = (0.260604:0.513000:0.955206, 
0.255524:0.503000:0.936586); endspecify 
 //instantiate a Verilog HDL primitive and (out, in0, in1); 
endmodule"
"modules more effectively. However, instantiation of building blocks is not a concise way to describe the design; it in hibits retargeting to alternate technologies, 
and generally there is a degradation in simulator performance. 
   
Assume that a 2-to-1, 8-
bit multiplexer is defined as a module mux2_1L8 in the design. I f 
a 32-bit multiplexer is needed, it can be built by instantiating 8-bit multiplexers rather 
than by using the assign statement. 
  
//Style 1: 32-bit mux using assign statement 
module mux2_1L32(out, a, b, select); 
output [31:0] out; 
input [31:0] a, b; 
wire select;  
assign out = select ? a : b; 
endmodule"
"module mux2_1L32(out, a, b, select); output [31:0] out; 
input [31:0] a, b; wire select;  
mux2_1L8 m0(out[7:0], a[7:0], b[7:0], select); //bits 7 through 0 mux2_1L8 m1(out[15:7], a[15:7], b[ 15:7], select); //bits 15 through 7 
mux2_1L8 m2(out[23:16], a[23:16], b[23:16], select); //bits 23 through 16 mux2_1L8 m3(out[31:24], a[31:24], b[31:24], select); //bits 31 through 
24  
endmodule"
"module mux(out, a, b, control); 
output out; 
input a, b, control; 
tri out; wire a, b, control;  
bufif0 b1(out, a, control); //drives a when control = 0; z otherwise bufif1 b2(out, b, control); //drives b when control = 1; z otherwise 
 endmodule"
"module_parameter_port_list 
               ] 
          [ list_of_ports ] ; { module_item }           endmodule"
"module_keyword module_identifier [ 
module_parameter_port_list                  ] 
          [ list_of_port_declarations ] ; { non_port_module_item } 
          endmodule"
"module FIFO_MEM_BLK( clk, 
                     writeN,                      wr_addr, 
                     rd_addr, 
                     data_in,                      data_out                    );  
 
input                    clk;       // input clk. input  writeN;  // Write Signal to put data into fifo. input  [(`FCWIDTH-1):0]  wr_addr;   // Write Address. input  [(`FCWIDTH-1):0]  rd_addr;   // Read Address. 
input  [(`FWIDTH-1):0]   data_in;   // DataIn in to Memory Block 
 output [(`FWIDTH-1):0]   data_out;  // Data Out from the Memory                                     // Block(FIFO)  
wire   [(`FWIDTH-1):0] data_out; 
 reg    [(`FWIDTH-1):0] FIFO[0:(`FDEPTH-1)];  
  
assign data_out  = FIFO[rd_addr];  always @(posedge clk) 
begin 
 
   if(writeN==1'b0) 
      FIFO[wr_addr] <= data_in; end 
 
endmodule"
"module
Example 1-2 Verilog for Gate-Level Mux
module mux(OUT, A, B, SEL);
output OUT;
input A,B,SEL;
not I5 (sel_n, SEL);
and I6 (sel_a, A, SEL);
and I7 (sel_b, sel_n, B);
or I4 (OUT, sel_a, sel_b);
endmodule"
"module hello1;
initial $display(""Hello Verilog"");
endmodule"
"module hello2; initial $display(""Hello Verilog"");endmodule"
"module
hello3;
initial
$display(
""Hello Verilog""
)
endmodule"
"module hello4;
initial $display(""
Hello Verilog
"");
endmodule"
"module. You create modules using the
keywords  module and  endmodule"
"modules and the primitives w ithin modules. Chapter 3 wil l introduce Verilog
primitives. Thus far in the book you have seen three  modules: the  phone module,
the mux module, and the  hello module.
SEMICOLONS
Each Verilog statement ends with a semicolon. The only lines that do not need
semicolons are those lines with keywords that end a statement themselves, such as
endmodule"
"module mux(OUT, A, B, SEL);
output OUT;
input A,B,SEL;
not I5 (sel_n, SEL) ;
and I6 (sel_a, A, SEL);
and I7 (sel_b, sel_n, B);
or I4 (OUT, sel_a, sel_b);
endmodule"
"module you are required to give it an instance
name.
Example 3-2 Verilog for Gate-level Mux
module mux(OUT, A, B, SEL);
output OUT;
input A,B,SEL;
not I5 (sel_n, SEL);
and I6 (sel_a, A, SEL);
and I7 (sel_b, sel_n, B);
or I4 (OUT, sel_a, sel_b);
endmodule"
"module mux2(OUT, A, B, SEL);
output [1:0] OUT;
input [1:0] A,B;
input SEL;
mux hi (OUT[1], A[1], B[1], SEL);
mux lo (OUT[0], A[0], B[0], SEL);
endmodule"
"module mux4(OUT, A, B, SEL);
output [3:0] OUT;
input [3:0] A,B;
input SEL;
mux2 hi (OUT[3:2], A[3:2], B[3:2], SEL);
mux2 lo (OUT[1:0], A[l:0], B[1:0], SEL);
endmodule"
"module instances in Example 3-3 and Example 3-4 are
built by matching the port declaration order to the used to create the c onnections.
This type of  instantiation is called  connect by order since the port order must be
known and matched. Verilog also supports a  connect by name  syntax, where the
port order does not need to be known, but the port names must  be known. The
connect by name  syntax uses the hierarchical name for the ports to make the
connects. Example 3-6 shows Example 3-4 re-written to use the  connect by name
syntax.
Example 3-6 Mux Connected by Name
module mux4cbn(OUT, A, B, SEL);
output [3:0] OUT;
input [3:0] A, B;
input SEL;
mux2 hi( .A(A[3:2]), .B(B[3:2]), .SEL(SEL), .OUT(OUT[3:2]) );
mux2 lo( .A(A[1:0]), .B(B[1:0]), .OUT(OUT[1:0]), .SEL(SEL) );
endmodule"
"module hello;
initial $display(""Hello Verilog"");
endmodule"
"module test_adder;
reg [7:0] a,b;
reg carry_in ;
wire [7:0] sum;
wire carry_out;
adder8 dut(carry_out, sum, a,b, carry_in);
initial begin
a = 0; b = 0; carry_in = 0;
# 100 if (sum !== 0) begin
$display(""sum is wrong"");
$finish;
end
a = 1; b = 0; carry_in = 0;
# 100 if (sum !== 1) begin
$display(""sum is wrong"");
$finish;
end
a = 0; b = 0; carry_in = 1 ;
# 100 if (sum !== 1) begin
$display(""sum is wrong"");
$finish;
end
a = 5; b = 6; carry_in = 1;
# 100 if (sum !== 12) begin
$display(""sum is  wrong"");
$finish;
end
a = 200; b = 55; carry_in = 1;
# 100 if (sum !== 0) begin
$display(""sum is wrong"");
$finish;
end
a =18; b = 200; carry_in = 1;
# 100 if (sum !== 219) begin
$display(""sum is wrong"");
$finish;
end
$finish ;
end
endmodule"
"module in Example 4-3, we know they will all start at time 0.
But they must run in some order: Which one will run  first? There is really no way to
tell. Not only is there no way to tell, if you run this module on  another simulator,
that simulator might run this module in a different order.
Example 4-3 Three  Initial  Statements
module three_initial;
initial $display(""Initial Statement 1"");
initial $display(""Initial Statement 2"");
initial $display(""Initial Statement 3"");
endmodule"
"module three_initial_with_delay;
initial #1 $display(""Initial Statement 1"");
initial $display(""Initial Statement 2"");
initial #2 $display(""Initial Statement 3"");
endmodule"
"module initial_begin;
initial
begin
$display(""Statement 1"");
$display(""Statement 2"");
$display(""Statement 3"");
end
endmodule"
"module initial_begin_with_delay;
initial
begin
#1 $display(""Statement 1"");
$display(""Statement 2"");
#2 $display(""Statement 3"");
end
endmodule"
"module initial_two_begin;
initial
begin
#1 $display(""Statement 1"");
$display(""Statement 2"");
#2 $display(""Statement 3"");
end
initial
begin
$display(""Block 2 Statement 1"");
#2 $display(""Block 2 Statement 2"");
#2 $display(""Block 2 Statement 3"");
end
endmodule"
"module 12f;
initial
fork
#1 $display(""Statement 1"");
$display(""Statement 2"");
#2 $display(""Statement 3"");
join
initial
fork
$display(""Block 2 Statement 1"");
#2 $display(""Block 2 Statement 2"");
#2 $display(""Block 2 Statement 3"");
join
endmodule"
"module two_display;
initial
begin
$display(""first half "");
$display(""second half"");
end
endmodule"
"module write_display;
initial
begin
$write (""first half "");
$display("" second half"");
end
endmodule"
"module f1;
integer f;
initial begin
f = $fopen(""myFile"");
$fdisplay(f, ""Hello Verilog File"");
end
endmodule"
"module f2;
integer file1, file2;
initial begin
file1= $fopen(""file1"");
file2= $fopen(""file2"");
$display(""The number used for file 1 is %0d"", file1);
$display(""The number used for file 2 is %0d"", file2);
$fdisplay(file1, ""Hello File 1"");
$fdisplay(file2, ""Hello File 2"");
$fdisplay(file1 file2, ""Hello both files"");
$fdisplay(file1   file2 | 1, ""Hello files and screen"");
$fdisplay(file1, ""Good Bye File 1"");
$fdisplay(file2, ""Good Bye File 2"");
$fclose(file1);
$fclose(file2);
end
endmodule"
"module timeformat;
initial
begin
$timeformat(-9, 2, ""ns"", 7);
#50 $display(""It is now %t (time)."",$time);
$display(""It is now %t (realtime)."",$realtime);
#1.01 $display(""It is now  %t (time)."",$time);
$display(""It is now %t (realtime)."",$realtime);
#50 $display(""It is now %t (time)."",$time);
$display(""It is now  %t (realtime)."",$realtime);
#1000 $display(""It is now %t ( time)."",$time);
$display(""It is now  %t (realtime)."",$realtime);
end
endmodule"
"module string1;
reg[8*13 : 1] s;
initial begin
s = ""Hello Verilog"";
$display(""The string %s is stored as %h"", s, s);
end
endmodule"
"module dff(q, clk, d);
input clk, d;
output q;
reg q;
always @(posedge  clk) q <= #(`REG_DELAY) d;
endmodule"
"module ia;
integer i, j;
reg [7:0] a, b;
initial begin
i = 3;
j = 4;
a = i + j;
b = a + 1;
#10 i = a;
j = b;
end
endmodule"
"module iaf1 ;
integer i, j;
initial begin
i = 3;
j = 4;
fork
#1 i = j;
#1 j = i;
join
end
endmodule"
"module iaf2;
integer i, j;
initial begin
i = 3;
j = 4;
fork
i = #1 j;
j = #1 i;
join
end
endmodule"
"module iaf3;
integer i, j;
initial begin
i = 3;
j = 4;
fork
#1 i = #1 j;
#1 j = #1 i;
join
end
endmodule"
"module iaf4;
integer i, j;
initial begin
i = 3;
j = 4;
#1 fork
i = #1 j;
j = #1 i;
join
end
endmodule"
"module iab;
integer i, j;
initial begin
i = 3;
j = 4;
begin
#1 i = #1 j;
#1 j = #1 i;
end
end
endmodule"
"module ianb;
integer i, j;
initial begin
i = 3;
j = 4;
begin
i <= #1 j;
j <= #1 i;
end
end
endmodule"
"module addressdecoder(address, wr, rd, reg_rd, reg_wr,
io_rd, io_wr);
input [15:0] address; // address  from processor
input rd, wr; // read and write signals
output reg_rd, reg_wr; // signals to register block
output io_rd, io_wr; // signals to Io block
reg reg_rd, reg_wr; // declared as reg as required
reg io_rd, io_wr; // for procedural assignments
reg io_sel, reg_sel; // internal signals
always @(address or rd or wr)
begin
io_sel = (address == 'IO_ADDRESS) ;
reg_sel = (address == `REG_ADDRESS);
io_rd = io_sel & rd;
io_wr = io_sel & wr;
reg_rd = reg_sel & rd;
reg_wr = reg_sel & wr;
end
endmodule"
"module addressregister(clk, reset, address, reg_address);
input clk,  reset;
input [15:0] address;
output [15:0] reg_address;
reg [15:0] reg_address;
always @(posedge clk)
if(reset)
reg_address <= #(`REG_DELAY) 16'h00;
else
reg_address <= #(`REG_DELAY) address;
endmodule"
"module uop;
reg [7:0] a, b, c;
initial begin
a=0;
b='bl0100101;
c='b1100xxzz;
$display(""Value %b Bitwise '~' %b logical '!' %b"",a,~a,!a);
$display(""Value %b Bitwise '~' %b logical '!' %b"",b,~b,!b);
$display(""Value %b Bitwise '~' %b logical '!' %b"",c,~c,!c);
end
endmodule"
"module redop;
reg [7:0] example[1:5];
integer i;
initial begin
example[1] = 0;
example[2] = 'hff;
example[3] = 'bl0l0ll0l;
example[4] = 'bll00llzz;
example[5] = 'blllllllx;
$display(""reduction operators"");
for(i=l; i<=5; i=i+l)
$display(""Value %b, & = %b, | = %b, ^  = %b"",
example[i], &example[i], |example[i], ^example[i]);
end
endmodule"
"module buf16(out,in,enable); // 16 bit three-state buffer
input [15:0] in;
output [15:0] out;
input enable;
assign out = enable ? in : 16'bz; // This is a continuous
// assignment. It will be
// explained next chapter.
endmodule"
"module to test it. Example 8-6 shows  such a module.
Example 8-6 Module To Test an  Operator
/* module to test operators */
module test_op;
reg a,b,result;
reg [1:4] values;
'define op ==
integer i,j;
initial begin
values = 4'b01xz; // all possible values
$display("" A == B = "" );
$display ("" "") ;
for(i=1; i<=4; i=i+1)
for(j=1; j<=4; j=j+1) begin
a = values[i];
b = values[ j];
result = a ` op b;
$display("" %b %b %b"",a,b,result);
end
end
endmodule"
"module string2;
reg[8*13 : 1] sl,s2,s3;
initial begin
s1 = ""Hello"";
s2 = "" Verilog"";
s3 = ""abb"";
s3 = s3 + 1;
if ( {s1,s2} != ""HelloVerilog"") begin
$display(""%s != %s"", {s1,s2},
""Hello Verilog"");
$display(""%h != %h"", {s1,s2},
""Hello Verilog"");
end
$display(""s3 = %s is  stored as %h"",
s3, s3);
end
endmodule"
"module signunsign(a,b,c,d);
input [7:0] a; // unsigned
input signed [7:0] b; // signed
output [7:0] c; // unsigned
output signed [7:0] d; //signed
wire signed [7:0] e; // signed.
reg signed [7:0] f; // signed.
reg [7:0] g; // unsigned
endmodule"
"module item by itself.
Finally, a continuous assignment always models combinatorial logic. It is true that
you can create logic that feeds back into i tself and mimics storage, but still it is
combinatorial.
Example 9-1 shows a simple 16-bit, three-state b uffer using a continuous
assignment.
Example 9-1 Three-State Buffer Using a Continuous Assignment
module buf16(out,in,enable); // 16-bit, three-state buffer
input [15:0] in;
output [15:0] out;
input enable;
assign out = enable ? in : 16'bz; // Continuous assignment
endmodule"
"modules  in Example 9-2 and Example 9-3
Example 9-2 A 128-Bit Adder In a Continuous Assignment
module add128(cout, sum, a, b, cin);
// 128 bit adder
input [127:0] a, b;
input cin;
output [127:0] sum;
output cout;
/* This continuous assignment models hundreds
of gates. The MSB of the add, carry is
assigned to cout by making  the addition
in 129 bits using a concatenation on the LHS.
*/
assign {cout,sum) = a + b + cin;
endmodule"
"module mul64(prod, a, b); // Simple multiplier
input [31:0] a, b;
output [63:0] prod;
assign prod = a * b; // Thousands of gates !!!
endmodule"
"module regnet;
reg a, b, c, d;
wire w;
assign w=a;
assign w=b;
assign w=c;
assign w=d;
endmodule"
"module aca;
reg a, b; .
wire c = a | b; // shorthand continuous assignment
endmodule"
"module mca;
reg a, b, c, d;
wire y, yb, a1, a2;
wire [3:0] bus = {a, b, c, d};
wire #(3,2) parity = ^bus;
assign #1 a1 = a & b,
a2 = c & d,
y=a1|a2,
yb = ~y;
endmodule"
"module dff(clock, d, q);
input d, clock;
output q;
reg q;
always @(posedge clock)
q< =  #(`REG_DELAY) d;
endmodule"
"module muxca(a,b,sel,y);
// mux with continuous assignment
input a,b,sel;
output y;
assign y = sel ? a : b;
endmodule"
"module muxae(a,b,sel,y); // mux with always
input a,b,sel;
output y;
reg y;
always @(a or b or sel)
if (sel)
y = a;
else
y = b;
endmodule"
"module muxaec(a,b,sel,y); // mux with always using comma
input a,b,sel;
output y;
reg y;
always @(a, b, sel)
if (sel)
y = a;
else
y = b;
endmodule"
"module muxaes(a,b,se1,y); // mux with always using star
input a,b,sel;
output y;
reg y;
always @*
if (sel)
y = a;
else
y = b;
endmodule"
"module
Note that the parentheses are not needed with @ if  you are only looking for any
change on a single  signal. The parentheses are only necessary if you are going to
use an expression after @.
One final thing to remember about the  wait for event (@): Don’t interpret “ always
@A” as “whenever  A changes.” Remember that always is defined as a loop that
starts at time 0, then when it finishes, it starts ove r again. So “ always @ A ”
describes the situation of waiting for  A, and having  A change. Consider Example 9-
13.
Example 9-13 always  Explained
module not_always;
reg clock;
always begin
#5 clock = 0;
#5 clock = 1;
end
always @(posedge clock)begin
$display(""clock edge at %0d"", $time);
#11 $display (""waiting for the clock"");
end
endmodule"
"module wait_example;
reg [7:0] a;
reg b;
initial begin
wait (a==3)
$display(""not waiting for a==3 time %0d"", $time);
wait(b)
$display(""not waiting for b time %0d"", $time);
wait (a==4)
$display(""not waiting for a==4 time %0d"", $time);
end
initial begin
#3 a = 3;
$display(""value of a is now %0d at time %0d"", a,$time);
#1 a = 4;
$display(""value of a is now %0d at time %0d"",a,$time);
#1 b = 1;
$display(""value of b is now %0d at time %0d"",b,$time);
end
endmodule"
"module mux4a(y,a,b,c,d, sel) ;
input a,b,c,d;
input [1:0] sel;
output y;
reg y;
always @(a or b or c or d or sel)
case ( sel )
0: y = a;
1: y = b;
2: y = c;
2'b11 : y = d;
default : y = 1'bx;
endcase
endmodule"
"module mux4b(y,a,b,c,d,sel);
input a,b,c,d;
input [1:0] sel;
output y;
reg y;
always @(a or b or c or d or sel)
case ( sel )
2'b00 : y = a;
2'b01 : y = b;
2'b10 : y = c;
2'b11 : y = d;
2'b0x, 2'b1x, 2'bzx, 2'bxx,
2'bx1, 2'bx0, 2'bxz, 2'bzz,
2'bz0, 2'bz1, 2'b1z, 2'b0z : y = 1'bx;
endcase
endmodule"
"module counta(clock, reset, load, up, load_data, count);
input clock,reset, load, up;
input [15:0] load_data;
output [15:0] count;
reg [15:0] count;
always @(posedge clock)
casez ({reset,load,up}) // concatenate control signals
3'b1zz : count <= 16'h0000;
3'b01? : count <= #(`REG_DELAY) load_data;
3'b001 : count <= #(`REG_DELAY) count + 16'h0001;
3'b000 : count <= #(`REG_DELAY)  count – 16'h0001;
default : count <= #{`REG_DELAY) 16'bx;
endcase
endmodule"
"module countb(clock, reset, load, up, load_data, count);
input clock,reset, load, up;
input [15:0] load_data;
output [15:0] count;
reg [15:0] count;
always @(posedge clock)
case ({reset,load,up}) // concatenate control signals
3'b100, 3'b101, 3'b10x, 3'b10z,
3'b110, 3'b111, 3'b11x,  3'b11z,
3'b1x0, 3'b1x1,  3'b1xx, 3'b1xz,
3'b1z0, 3'b1z1, 3'b1zx, 3'b1zz
: count <=  #(`REG_DELAY) 16'h0000;
3'b010, 3'b011, 3'b01x, 3'b11z
: count <= #(`REG_DELAY) load_data;
3'b001 : count <= #(`REG_DELAY)  count + 16'h0001;
3'b000 : count <= #(`REG_DELAY) count - 16'h0001;
default : count <= #(`REG_DELAY) 16'bx;
endcase
endmodule"
"module countc(clock, reset, load, up, load_data, count);
input clock,reset, load, up;
input [15:0] load_data;
output [15:0] count;
reg [15:0] count;
always @(posedge clock)
if (reset)
count <= 16'h0000;
else
if (load)
count <= #(`REG_DELAY) load_data;
else
if (up)
count <= #(`REG_DELAY) count + 16'h0001;
else
count <= #(`REG_DELAY) count - 16'h0001;
endmodule"
"module o sc1(clock);
output clock;
reg clock;
initial begin
clock = 0;
end
always begin
#50 clock = ~clock;
end
endmodule"
"module using theforever  loop.
Example 10-10 Oscillator Using  forever
module osc2(clock);
output clock;
reg clock;
initial begin
clock = 0;
forever #50 clock = ~clock;
end
endmodule"
"module in which the module
prints “Hello Ve rilog” five times.
Example 10-11 Repeating “Hello Verilog”
module hellor;
initial repeat(5) $display(""Hello Verilog"");
endmodule"
"module shift1(clock,start,data,s,out,done);
input clock,start;
input [15:0] data;
input [3:0] s;
output [15:0] out;
reg [15:0] out;
output done;
reg done;
always @(posedge clock)
if (start) begin
done <= #(`REG_DELAY) 1'b0;
out <= #(`REG_DELAY) data;
repeat(s) // number of times to shift
@(posedge clock) out <= #(`REG_DELAY) out << 1;
@(posedge clock) done <= #(`REG_DELAY) 1'b1;
end
endmodule"
"module onecount(clock,start,data,count,done);
input clock,start;
input [15:0] data;
reg [15:0] temp_data;
output [3:0] count;
reg [3:0] count;
output done;
reg done;
always @(posedge clock)
if (start) begin
done <= #(`REG_DELAY) 1'b0;
count <= #(`REG_DELAY) 1'b0;
temp_data = data;
while(temp_data) begin// continue as long as non zero
@(posedge clock)
if (temp_data[0]) count <= #(`REG_DELAY) count + 1;
temp_data = temp_data >> 1;
end
@(posedge clock)
done <= #(`REG_DELAY) 1'b1;
end
endmodule"
"module hellof;
integer i;
initial for(i=0; i<5; i=i+1)
$display(""Hello Verilog %0d"", i);
endmodule"
"module for2;
reg [7:0] a,b,c,d;
initial begin
c = 9; // If c==0 the loop will not enter.
b = 3;
d = 0;
for(a = b; c; d=a) begin
a = a + d;
c = c - b;
end
$display(""a= %d, b=%d, c= %d, d=%d, OK?"", a, b, c, d) ;
end
endmodule"
"module hellot;
initial begin
say_hello;
say_hello;
end
task say_hello;
$display(""Hello Verilog Tasks!"");
endtask
endmodule"
"module task1;
integer a, b, c, d;
initial begin
a=3;
b=4;
d=12;
add(a,c,b);
$display("" final value for c = %0d"",c);
end
task add;
input [31:0] in1;
output [31:0] out;
input [31:0] in2;
out = in1 + in2 + d;
endtask
endmodule"
"module task2;
integer a;
initial begin
a=0;
increment(a) ;
$display(""a=%0d"",a);
increment(a);
$display(""a=%0d"",a);
a=7;
increment(a);
$display(""a=%0d"",a);
end
task increment;
inout [2:0] x;
x = x + 1;
endtask
endmodule"
"module.
Anything declared in a  task is accessible from the module that contains the  task by
creating a hierarchical name to the data. Example 11-4 shows a  task with a local
integer. The local integer is both written and read from outside the  task.
Example 11-4 Accessing a  task  Local Variable from Outside the  task
module task3;
initial begin
$display(""total=%0d"",count.total);
count.total =0;
count;
count;
$display(""total=%0d"",count.total);
end
task count;
integer total;
total = total + 1;
endtask
endmodule"
"module reent;
reg [2:0] a,b;
initial begin
a = 3'b001;
b = 3'b101;
reentT(a);
$display($time, "" a = %d"",a);
end
initial begin
#5 reentT(b);
$display($time, "" b = %d"",b);
end
task reentT;
inout [2:0] x;
#20 x = x + 1;
endtask
endmodule"
"module readcycle(clock,data_ready,datain,address,read);
input clock,data_ready;
input [31:0] datain;
output [31:0] address;
reg [31:0] address;
output read;
reg read;
reg [31:0] data;
initial begin
do_read('h00001234,data);
do_read('habcdbabe, data);
end
task do_read;
input [31:0] location;
output [31:0] bus_value;
begin
@(posedge clock) address = location;
@(posedge clock) read = 1;
while( ! data_ready)
@(posedge clock) ;
bus_value = datain;
read = 0;
end
endtask
endmodule"
"module cbits;
initial begin
$display(""the answer is %d"",count_bits(87));
$display(""the answer is %d"",count_bits('h12345678));
$display(""the answer is %d"",count_bits('hffff_ffff));
end
function integer count_bits;
input [31:0] a;
begin
count_bits =0 ;
while(a) begin
if( a[0] ) count_bits = count_bits + 1;
a = a >> 1 ;
end
end
endfunction
endmodule"
"module muxfunc(y,a,b,c,d,sel);
output [7:0] y;
input [7:0] a,b,c,d;
input [1:0] sel;
assign y = muxfunct(sel,a,b,c,d) ;
function [7:0] muxfunct;
input [1:0] sel ;
input [7:0] a,b,c,d;
case(sel)
2'b00 : muxfunct = a;
2'b01 : m uxfunct = b;
2'b10 : muxfunct = c;
2'b11 : muxfunct = d;
default : muxfunct = 8'bx;
endcase
endfunction
endmodule"
"module divfunc;
reg [7:0] a, b, q, r;
initial begin
a = 5; b = 3;
doit;
a = 187; b = 3;
doit;
a = 255; b = 18;
doit;
end
task doit;
begin
{q,r} = div(a,b);
$display(
""%d goes into %d %d times with a remainder of %d"",
b, a, q, r) ;
end
endtask
function [15:0] div;
input [7:0] dividend, divisor;
reg [7:0] quotient, remainder;
begin
quotient = dividend / divisor;
remainder = dividend % divisor;
div = {quotient,remainder};
end
endfunction
endmodule"
"module add;
initial begin
$display(""1 + 2 is %0d"", add(1,2));
$display(""47 + 32'hffff_ffff is %0d"",
add(47,32'hffff_ffff));
end
function integer add;
input a, b;
integer a, b;
add = a + b;
endfunction
endmodule"
"module.
Example 12-3 A Simple Flip-Flop
module ff1(q,clk,d);
output q;
reg q;
input clk,d;
always @(posedge clk)
q <= #(`REG_DELAY) d;
endmodule"
"module ff2bad(q,clk,d,reset);
output q;
reg q;
input clk, d, reset;
always @(posedge clk)
q <= #(`REG_DELAY) d;
always @reset
if( reset ) q <=#(`REG_DELAY) 0;
endmodule"
"module in Example 12-4 looks like it might work. But what happens if  reset is
high for many clock cycles? The  q=0 statement executes when  reset first occurs, but
if the clock signal arrives, the  q=d statement can also execute. Thus, the flip-flop
does not stay reset because both the procedural assignments  have the same
precedence.
The procedural  continuous assignment has higher precedence than the procedural
assignment, so  this module can be fixed as shown in Example 12-5.
Example 12-5 A Flip-Flop with Reset
module ff2(q,clk,d,reset);
output q;
reg q;
input clk, d, reset;
always @(posedge clk)
q <= #(`REG_DELAY) d;
always @reset
if( reset )
assign q=0;
else
deassign q;
endmodule"
"module ff3bad(q,clk,d,reset,set) ;
output q;
reg q;
input clk, d, reset, set;
always @(posedge clk)
q <= #(`REG_DELAY) d;
always @reset
if( reset )
assign q=0;
else
deassign q;
always @set
if( set )
assign q=1;
else
deassign q;
endmodule"
"module
You have just seen only one part of the behavior of the procedural continuous
assignment (PCA), the overriding of the normal behavior of a reg.
Consider, for a moment, the following mux-like module.
Example 12-8 Incorrect Mux
module mux1bad(y,a,b,c,d,sel);
input a,b,c,d;
input [1:0] sel;
output y;
reg y;
always @(sel)
case(sel)
So what is wrong with the mux in Example 12-8? The output y will only change
when  sel changes. If  sel is 0 and  a changes, the output y will not change. Thus, this
is not a good mux. One way to fix this mux would be to make the  always  block
sensitive to all the inputs changing. You could do this by changing  @(sel)  to @(sel
or a or b or c or d).  This section of the book is about the PCA,  so Example 12-9
shows how to fix this mux using the PCA.
Example 12-9 Mux with PCA
module mux2(y,a,b,c,d,sel);
input a,b,c,d;
input [1:0] sel;
output y;
reg y;
always @(sel)
case(sel)
2'b00 : assign y = a;
2'b01 : assign y = b;
2'b10 : assign y = c;
2'b11 : assign y = d;
endcase2'b00 : y =a ;
2'b01 : y = b;
2'b10 : y = c;
2'b11 : y=d;
endcase
endmodule"
"module ff_syn(q,clk,d,reset, set) ;
output q;
reg q;
input clk, d, reset, set;
always @(posedge clk or posedge reset or posedge set)
if(reset)
q <= #(`REG_DELAY) 0;
else
if(set)
q <= # ( `REG_DELAY) 1;
else
q <= # ( `REG_DELAY) d;
endmodule"
"module io1(data, read, write);
inout data;
input read, write;
reg port_reg, internal_reg;
always @read
if( read )
port_reg = internal_reg;
else
port_reg = 1'bz ;
always @(posedge write)
internal_reg = data;
assign data = port_reg ;
endmodule"
"module io2(data, read, write);
inout [15:0] data;
input read, write;
reg [15:0] internal_reg;
always @(posedge write)
internal_reg = data;
assign data = read ? internal_reg: 16'bz ;
endmodule"
"module nameblock;
reg a;
initial begin : b1
reg a;
a = 1;
end
initial fork :b2
reg a;
a = 0;
join
endmodule"
"module disable1;
initial begin
do_it;
$display(""Finished do it at time %0d"",$time);
end
initial begin
#55 disable do_it;
end
task do_it;
forever
#10 $display(""doing it at time %0d"",$time);
endtask
endmodule"
"module cpu;
reg reset, clock;
initial begin
clock = 0;
reset = 1;
#10 reset = 0;
#10 reset = 1;
#10 reset = 0;#20 $finish;
end
always #1 clock = ˜clock;
always begin : fetch
@(posedge clock)if (reset) disable fetch;
$display(""fetch process ready"");
// there would be  code here for
// the ongoing fetch process
#10000 $display(""fetch process done"");
// in a real processor the fetch process
// might be an infinite loop
end
always begin : execute
@(posedge clock)
if (reset) disable execute;
$display(""execute process  ready"");
// there would be  code here for
// the ongoing execute process
#10000 $display(""execute process done"");
// in a real processor the  execute process
// might be an infinite loop
end
always @( posedge reset)
begin
disable fetch;
disable execute;
end
endmodule"
modules except that module-endmodule
"module of a n-bit wide 4-to-1 mux. It has a default word
size of 32 bits.
Example 14-2  n-Bit Wide 4-to-1 Mux
modulenmux4(a,b,c,d,sel,y);
// Parameterized n bit wide 4 to 1 mux.
parameter size = 32; // default to 32 bits
input [size-1 : 0] a,b,c,d;
input [1:0] sel;
output [size-1 :0] y;
reg [size-1 :0] y;
always @ (a or b or c or d or sel)
case (sel)
0 : y = a;
1 : y = b;
2 : y = c;
3 : y = d;
default : y = 'bx; // will automatically size to fit
endcase
endmodule"
"module nadder(cout,sum, a,b,cin);
// Parameterized n bit  wide behavioral adder
parameter size = 32; // default to 32 bits
input [size-1 : 0] a,b;
input cin;
output [size-1 :0] sum;
output cout;
assign {cout,sum} = a + b + cin;
endmodule"
"module muxMto1 (Z, SEL, D);
parameter N = 8; // number of bits wide
parameter M = 4; // number of inputs
parameter S = 2; // number of select lines
parameter W = M * N;
`define DTOTAL W-1:0
`define DWIDTH N-1:0
`define SELW S-1:0
`define WORDS M-1:0
input [ `DTOTAL] D;
input [ `SELW] SEL;
output [ `DWIDTH] Z;
integer i;
reg[`DWIDTH] tmp, Z; // tmp will be use to minimize events
always @(SEL or D) begin
for(i=0; i < N; i = i + 1) // for bits in the width
tmp[i] = D[N*SEL + i];
Z = tmp;
end
endmodule"
"module for a simple parameterized ram */
module ram(data, address, read, write);
parameter width = 16 ; //default word size
parameter abits = 8 ; // default number of address bits
parameter twdh = 10; // write data hold
parameter trd = 25; // rd to output delay
input [abits-1 : 0] address;
inout [width-1 : 0] data;
input read, write;
// declare the internal storage
reg [width-1 : 0] imem [0 :(1<<abits)-1] ;
/*
Simple behavior of a static type ram
write occurs when write is 1.
to act more like a real static ram, if the data changes
while write is asserted the data in the memory is changed
*/
always @(write or data)
if(write)
# twdh imem[address] = data ;
assign #trd data = read ? imem[address] : 'bz;
/*
convenience task for displaying the contents of the memory
during interactive debug
*/
task dump;
input [31:0] low, high;
integer i;
begin
for( i=low; i <= high; i=i+1)
$display(""imem[%h] = %h"",i,imem[i]);
$stop;
end
endtask
endmodule"
"modules set defaul t values for the
parameters. The  parameter default values may be overridden on an instance-by-
instance basis with the  defparam statement. The format for the  defparam statement
is shown in Example 14-6.
Parameter Passing by Name
Example 14-6 The  defparam  Statement
defparam <instance name>.<parametername> = <value>
Example 14-7 uses the parameterized  adder and creates three instances. One
instance is 5 bits wide, one instance is the default 32 bits wide, and one instance is
expanded to 128  bits wide.
Example 14-7 Using Parameterized Modules
module use_defparam;
wire [4:0] a5, b5, c5; // some 5 bit wires
wire [31:0] a32, b32, c32; // some 32 bit wires
wire [127:0] biga, bigb, bigc; // some 128 bit wires
wire x,y,z;
// create some instances of the n bit adder
nadder a1 (z,a5,b5,c5,x);
nadder a2 (z,a32,b32,c32,x);
nadder a3 (z,biga,bigb,bigc,x);
defparam a1.size = 5;
defparam a3.size  = 128;
endmodule"
"module we  would still need to pass the first three parameters.
Example 14-8 Parameter Passing by Order
module use_defparam_order;
wire [4:0] a5, b5, c5; // some 5 bit wires
wire [31:0] a32, b32, c32; // some 32 bit wires
wire [127:0] biga, bigb, bigc; // some 128 bit wires
wire x,y,z, read, write;
wire [31:0] data;
wire [3:0] address;
// create some instances of the n bit adder
nadder #(5) a1 (z,a5,b5,c5,x);
nadder a2 (z ,a32,b32,c32,x);
nadder #(128)  a3 (z,biga,bigb,bigc,x);
// The ram example has 4 parameters
ram #(32,4,2,7) r1(address, data, read,write);
endmodule"
"module use_defparam_named_list;
wire [4:0] a5, b5, c5; // some 5 bit wires
wire [31:0] a32, b32, c32; // some 32 bit wires
wire [127:0] biga, bigb, bigc; // some 128 bit wires
wire x,y,z, read, write;
wire [15:0] data;
wire[7:0] address;
// create some instances of the n bit adder
nadder #(.size{5)) a1 (z,a5,b5,c5,x);
nadder a2 (z,a32,b32,c32,x);
nadder #(.size(128)) a3 ( z,biga,bigb,bigc,x) ;
// The ram example has 4 parameters
ram #(.twdh(2),.trd(7)) r1(address, data, read,write);
endmodule"
"module auto_oven_style_1_moore(clock, start, temp_ok, done,
quiet, load, heat, unload, beep);
input clock, start, temp_ok, done, quiet;
output load, heat, unload, beep;
reg load, heat, unload, beep;
reg [2:0] state, next_state;
`define IDLE 'b000
`define PREHEAT 'b001
`define LOAD 'b010
`define COOK 'b011
`define EMPTY 'b100
// State register block
always @(posedge clock)
state <= #(`REG_DELAY) next_state;
// next state logic
always @(state or start or temp_ok or done) begin
next_state = state; //  default to stay in current state
case (state)
`IDLE: if (start) next_state=`PREHEAT;
`PREHEAT: if(temp_ok) next_state = `LOAD;
`LOAD: next_state = `COOK;
`COOK: if (done) next_state=`EMPTY;
`EMPTY: next_state = `IDLE;
default: next_state = `IDLE;
endcase
end
// Output logic
always @(state) begin
if(state == `LOAD) load = 1; else load = 0;
if(state == `EMPTY) unload =1; else unload = 0;
if(state == `EMPTY && quiet == 0) beep =1; else beep = 0;
if(state == `PREHEAT ||
state == `LOAD ||
state == `COOK) heat = 1; else heat =0;
end
endmodule"
"module auto_oven_style_1_mealy(clock,  start, temp_ok, done,
quiet, load, heat, unload, beep);
input clock, start, temp_ok, done, quiet;
output load, heat, unload, beep;
reg load, heat, unload, beep;
reg [2:0] state, next_state;
`define IDLE 'b000
`define PREHEAT 'b001
`define LOAD 'b010
`define COOK 'b011
`define EMPTY 'b100
// State  register block
always @(posedge clock)
state <= #(`REG_DELAY) next_state;
// next state logic
always @(state or start or temp_ok or done) begin
next_state = state; //  default to stay in current state
case (state)
`IDLE: if  (start) next_state=`PREHEAT;
`PREHEAT: if(temp_ok) next_state = `LOAD;
`LOAD: next_state = `COOK;
`COOK: if (done) next_state=`EMPTY;
`EMPTY: next_state = `IDLE;
default: next_state = `IDLE;
endcase
end
// Output logic
always @(state or quiet) begin
if(state == `LOAD) load = 1; else load = 0;
if(state == `EMPTY) unload =1; else unload = 0;
if(state == `EMPTY && quiet == 0) beep =1; else beep = 0;
if(state == `PREHEAT ||
state == `LOAD ||
state == `COOK) heat = 1; else heat =0;
end
endmodule"
"module
Style 4 combines everything into one big block, which yields a Moore mac hine.
Example 15-6 Style 4 Moore Machine
module auto_oven_style_4_moore(clock, start, temp_ok, done,
quiet, load, heat, unload, beep);
input clock, start, temp_ok, done, quiet;
output load, heat, unload, beep;
reg load, heat, unload, beep;
reg [2:0] state;
`define IDLE'b000
`define PREHEAT'b001
`define LOAD'b010
`define COOK'b011
`define EMPTY'b100
// State register block
always @(posedge clock)begin
case (state)
`IDLE: if (start) state=`PREHEAT;
`PREHEAT: if(temp_ok) state <= #(`REG_DELAY) `LOAD;
`LOAD: state <=  #(`REG_DELAY) `COOK;
`COOK: if (done) state=`EMPTY;
`EMPTY: state <= #(`REG_DELAY) `IDLE;
default: state <= #(`REG_DELAY) `IDLE;
endcase
if(state == `LOAD) load <= #(`REG_DELAY) 1;
else load <= #(`REG_DELAY) 0;
if(state == `EMPTY) unload <= #(`REG_DELAY) 1;
else unload <= #(`REG_DELAY) 0;
if(state == `EMPTY && quiet == 0) beep <= #(`REG_DELAY) 1;
else beep <= #(`REG_DELAY) 0;
if(state == `PREHEAT ||
state == `LOAD ||
state == `COOK) hea t <= #(`REG_DELAY) 1;
else heat <= #(`REG_DELAY) 0;
end
endmodule"
"module auto_oven_style_5_moore(clock,  start, temp_ok, done,
quiet, load, heat,unload, beep);
input clock, start, temp_ok, done, quiet;
output load, heat, unload, beep;
reg load, heat, unload, beep;
reg [2:0] state, next_state;
`define IDLE 'b000
`define PREHEAT 'b001
`define LOAD 'b010
`define COOK 'b011
`define EMPTY 'b100
// State register block
always @(posedge clock) begin
state <= #(`REG_DELAY) next_state;
// Output logic
if(state == `LOAD) load <= #(`REG_DELAY) 1;
else load <= #(`REG_DELAY) 0;
if(state == `EMPTY) unload <= #(`REG_DELAY) 1;
else unload <= #(`REG_DELAY) 0;
if(state == `EMPTY && quiet == 0) beep <= #(`REG_DELAY) 1;
else beep <= #(`REG_DELAY) 0;
if(state == `PREHEAT ||
state == `LOAD ||
state == `COOK) heat <= #(`REG_DELAY) 1;
else heat <= #(`REG_DELAY) 0;
end
// next state logic
always @(state or start or temp_ok or done) begin
next_state = state; // default to stay in current state
case (state)
`IDLE: if (start) next_state=`PREHEAT;
`PREHEAT: if(temp_ok) next_state  = `LOAD;
`LOAD: next_state = `COOK;
`COOK: if (done) next_state=`EMPTY;
`EMPTY: next_state = `IDLE;
default: next_state = `IDLE;
endcase
end
endmodule"
"module
You have also already seen two other examp les of implicit state machines. In
chapter  6, when introducing  the  looping constructs,  the  modules  shift1  and
onecount  were simple, synthesizable implicit state machines.
REGISTERED AND UNREGISTERED OUTPUTS
The modeling of the output section of the state machine may infer that the outputs
are either registered, or combinatorial. Registered outputs are available sooner after
the clock and are less subject to glitching. One great disadvantage of registered
outputs is that the machine becomes la rger due to the extra flip-flops. Because the
outputs are  synchronous, this implies that machines with registered outputs are only
Moore machines. Cha nging the Verilog for the output section to be registered
instead of  combinatorial is a simple matter of changing the  always  block to execute
only on a clock, rather than a change on any input.
Example 15-9 Combinatorial Outputs
always @(state or quiet) begin
if(state == `LOAD) load = 1; else load = 0;
if(state == `EMPTY) unload = 1; else  unload = 0;
if(state == `EMPTY && quiet == 0) beep = 1; else beep = 0 ;
if(state == `PREHEAT ||
state == `LOAD ||
state == `COOK) heat = 1; else heat =0;
end
endmodule"
"module mux2ca( y, sel, a, b) ;
output [3:0] y;
input [3:0] a, b;
input sel;
assign y = sel ? a : b;
endmodule"
"module mux4ca( y, sel, a, b, c, d) ;
output [3:0] y;
input [3:0] a, b, c, d;
input [1:0] sel;
assign y = sel[1] ? (sel[0] ? d : c) : (sel[0] ? b : a) ;
endmodule"
"module mux4caa( y, sel, a, b, c, d);
output [3:0] y;
input [3:0] a, b, c, d;
input [1:0] sel;
assign y = (sel == 2'b00) ? a :
(sel == 2'b01) ? b :
(sel == 2'b10) ? c : d;
endmodule"
"module adder8ca(carry_out, sum, a, b, carry_in);
output carry_out;
output [7:0] sum;
input [7:0] a, b ;
input carry_in;
assign {carry_out,sum} = a + b + carry_in;
endmodule"
"module calatch(out, data, enable);
output out;
input data, enable;
assign out = enable ? out : data;
endmodule"
"module mux2r( y, sel, a, b) ;
output [3:0] y;
input [3:0] a, b;
input sel;
reg [3:0] y;
always @(sel or a or b)
if(sel)
y = a;
else
y = b;
endmodule"
"module mux4r( y, sel, a, b, c, d) ;
output [3:0] y;
input [3:0] a, b, c, d;
input [1:0] sel;
reg [3:0] y;
always @(sel or a or b or c or d)
begin
case (sel)
0: y = a;
1: y = b;
2: y = c;
3: y = d;
endcase
end
endmodule"
"module adder8r(carry_out, sum, a, b, carry_in);
output carry_out;
output [7:0] sum;
input [7:0] a, b ;
input carry_in;
reg [7:0] sum;
reg carry_out;
integer temp;
always @(a or b or carry_in) begin
temp = a;
repeat (b) begin
temp = temp + 1;
end
if( carry_in) temp = temp + 1;
carry_out = temp[8];
sum = temp[7:0] ;
end
endmodule"
"module adder8s(carry_out, sum, a, b, carry_in);
output carry_out;
output [7:0] sum;
input [7:0] a, b ;
input carry_in;
reg [7:0] sum;
reg carry_out;
always @(a or b or carry_in)
{carry_out, sum) = a + b + carry_in;
endmodule"
"module mux4caf( y, sel, a, b, c, d) ;
output [3:0] y;
input [3:0] a, b, c, d;
input [1:0] sel;
assign y = muxf(a, b, c, d, sel);
function [3:0] muxf;
input [3:0] a, b, c, d;
input [1:0] sel;
case (sel)
0: muxf = a;
1: muxf = b;
2: muxf = c;
3: muxf = d;
endcase
endfunction
endmodule"
"module.
If a behavioral model has blocks of similar logic, you can combine them into a
common function that is called more than once.
In summary, the behavioral constructs to model combinatorial logic are the
continuous assignment, the  always block that triggers on any  signal change, and the
function.
MODELING SEQ UENTIAL LOGIC
Sequential logic is most often modeled with always blocks. What other constructs
can you use to model seque ntial logic? A flip-flop can be created with the built-in
Verilog primitives or a sequential user-defined primitive (UDP). You can even use
an initial block to model sequential logic.
Sequential Models Using  always
A simple block of sequential code is shown in Example 16-11. Most simple
sequential logic is just a block of code that is synchronous with a clock. This model
is not a good model for synthesis due to the lack of reset and use of the initial
statement. Chapter 17 will discuss the interaction of initial, reset and synthesis.
Example 16-11 Simple Counter
`define REG_DELAY 1
module counter(clock, out);
input clock;
output [7:0] out;
reg [7:0] out;
initial out <= #(`REG_DELAY) 0;
always @(posedge clock) out <= #(`REG_DELAY) out + 1;
endmodule"
"module counterf(clock, out);
input clock;
output [7:0] out;
reg [7:0] out;
initial
begin
out = 0;
forever @(posedge clock) out <= #(`REG_DELAY) out + 1;
end
endmodule"
"module stimulus;
reg a, b, c;
initial
begin
a = 0; b = 0; c = 0 ;
#100 a = 1;
#100 b = 1;
#500 c = 1;
end
endmodule"
"module clock_cource;
reg clock;
always
begin
#50 clock = 0;
#50 clock = 1;
end
endmodule"
"module oneshot(trigger,out);
input trigger;
output out;
reg out;
parameter timeConstant = 100;
initial out = 0;
always @(posedge trigger)
begin
out = 1;
# timeConstant out = 0;
end
endmodule"
"module roneshot(trigger,out);
input trigger;
output out;
reg out;
event start;
parameter timeConstant = 100;
initial out = 0;
always @(posedge trigger)
begin
disable time_out;
#0 -> start;
end
always @start
begin : time_out
out = 1;
# timeConstant out = 0;
end
endmodule"
"module srff(sb, rb, q, qb);
input sb, rb;
output q, qb;
nand #0.001(q, sb, qb);
nand #0.001(qb, q, rb);
endmodule"
"module mytimer(start, out, disc);
// timer start active low, once released, delay will start
// output will rise after time constant
input start; // active low
output out; // high when time expires
output disc; // high when discharging
parameter timeConstant = 5;parameter disTime = 0.1;
reg cx; // abstraction of resistor - capacitor
buf #0.01 opa ( out, cx); // opamp or comparator
buf #0.01 opb ( down, cx); // opamp or comparator
nand #0.001 nq ( q, start, qb);nand #0.001 nqb ( qb, down, q);
buf ( disc, q);
always @(posedge q) begin : discharge
disable charge;
# disTime cx = 0;
end
always @(negedge q) begin : charge
disable discharge;
#timeConstant cx=1;
end
endmodule"
"module array2d;
parameter m = 10; // number of rows
parameter n = 12; // number of columns
reg [31:0] my_array[0:(m * n - 1)];
task store;
input [31:0] row, col, value;
my_array[row * n + col] = value;
endtask
function [31:0] retrieve;
input [31:0] row, col;
retrieve = my_array[row * n + col];
endfunction
endmodule"
"modules should and should not be driving a signal. A
more interesting use for detecting Zs would be to model special three-state logic.
Some circuits use a special voltage that is applied to a pin to make the chip enter a
programming, setup, or diagnostic mode. Because Verilog does not have a concept
of voltage associated with a logic level, the value Z can be used to represent the
special voltage when applying test vectors.
Example 16-23 Behavioral Z-Detector
module zdetb(in,out);
input in;
output out;
reg out;
always @in
if( in === 1'bz)
out = 1;
else
out = 0;
endmodule"
"module zdets(in,out);
input in;
output out;
tril hi;
tri0 lo;
nmos(hi,in,1'b1);
nmos(lo, in,1'b1);
xor(out,hi,lo);
endmodule"
"module
module carry_save_add(carry, sum, a, b, c) ;
parameter WIDTH = 10;
output [WIDTH-1:0] carry;
output [WIDTH-1:0] sum;
input [WIDTH-1:0] a;
input [WIDTH-1:0] b;
input [WIDTH-1:0] c;
integer i;
reg [WIDTH-1:0] carry;
reg [WIDTH-1:0] sum;
reg [1:0] result;
always@(a or b or c)
begin
for(i = 0; i < WIDTH; i = i + 1)
begin
result = a[i] + b[i] + c[i];
sum[i] = result[0];
carry[i] = result [1];
end
end
endmodule"
"module
module carry_save_add(carry, sum, a, b, c);
parameter WIDTH = 18;
output [WIDTH-1:0] carry;
output [WIDTH-1:0] sum;
input [WIDTH-1:0] a;
input [WIDTH-1:0] b;
input [WIDTH-1:0] c;integer i;
reg [WIDTH-1:0] carry;
reg [WIDTH-1:0] sum;reg [1:0] result;
always@(a or b or c)
begin
for(i = 0; i < WIDTH; i = i + 1)
begin
result = a[i] + b[i] + c[i];
sum[i] = result[0];
carry[i] = result[1];
end
end
endmodule"
"module
modulercd2(a,b,rec,ci);
input [2:1] a;
input [15:0] b;
output [16:0] rec;
output [1:0] ci;
// note that rcd2 is a case of rcd3 with lsb of a = 0
reg [16:0] rec;
reg [1:0]  ci;
always @(a or b)
case (a)
0: begin rec = 17'h00000; ci = 0; end // 00 ==> 0 * b
1: begin rec = {b[15],b}; ci = 0; end // 01 ==> 1 * b
2: begin rec = {~b,1'b0}; ci = 2; end // 10 ==> -2 * b
3: begin rec = {~b[15],~b}; ci = 1; end // 11 ==> -1 * b
default: begin rec = 17'h00000; ci = 0; end
endcase
endmodule"
"modulercd3(a,b,rec,ci);
input [2:0] a;
input [15:0] b;
output [16:0] rec;
output [1:0] ci;
reg [16:0] rec;
reg [1:0]  ci;
always @(a or b)
case (a)
0: begin rec = 17'h00000; ci = 0; end // 000 ==> 0 * b
1: begin rec = {b[15],b}; ci = 0; end // 001 ==> 1 * b
2: begin rec = {b[15],b}; ci = 0; end // 010 ==> 1 * b
3: begin rec = {b,1'b0}; ci = 0; end // 011 ==> 2 * b
4: begin rec = {~b,1'b0}; ci = 2; end // 100 ==> -2 * b
5: begin rec = {~b[15],~b}; ci = 1; end // 101 ==> -1 * b
6: begin rec = {~b[15],~b); ci = 1; end // 110 ==> -1 * b
7: begin rec = 17'h00000; ci = 0; end // 111 ==> 0 * b
default: begin rec = 17'h00000; ci = 0; end
endcase
endmodule"
"module carry_save_add(carry, sum, a, b, c);
parameter WIDTH = 21;
output [WIDTH-1:0] carry;
output [WIDTH-1:0] sum;
input [WIDTH-1:0] a;
input [WIDTH-1:0] b;
input [WIDTH-1:0] c;
integer i;
reg [WIDTH-1:0] carry;
reg [WIDTH-1:0] sum;
reg [1:0] result;
always@(a or b or c)
begin
for(i = 0; i < WIDTH; i = i + 1)
begin
result = a[i] + b[i] + c[i];
sum[i] = result[0];
carry[i] = result[1];
end
end
endmodule"
"module ndff(q, clock, data);
input clock, data;
output q;
reg q;
always @(posedge clock)
q <= #(`REG_DELAY) data;
endmodule"
"module so that it is only executed when the data
actually changes.
Example 17-2 Modified D-Flip-Flop
module mdff(q, clock, data);
input clock, data;
output q;
reg q;
always @data @(posedge clock)
q <= #(`REG_DELAY) data;
endmodule"
"module reg16b(q, d, clk, clr_n);
input [15:0] d;
input clk, clr_n;
output [15:0] q;
reg [15:0] q;
initial q = 0;
always
begin
if(clr_n != 0)
@(posedge clk) #1 q = d;
else
#1 q = 0;
end
endmodule"
"modulereg16i(q, d, clk, clr_n);
input [15:0] d;
input clk,  clr_n;
output [15:0] q;
reg [15:0] q;
always @(posedge clk)
if(clr_n)
q <= #1 d;
else
q <= #1 0;
endmodule"
"module reg16t(q, d, clk, clr_n);
input [15:0] d;
input clk, clr_n;
output [15:0] q;
reg [15:0] q;
always @(d or clr_n) @(posedge clk)
if(clr_n)
q <= #1 d;
else
q <= #1 0;
endmodule"
"module add32b(o, a, b) ;
input [31:0] a, b;
output [31:0] o;
reg [31:0] o;
always
#1 o = a +  b;
endmodule"
"module add32i(o, a, b) ;
input [31:0] a, b;
output [31:0] o;
reg[31:0] o;
always @(a or b)
#1 o = a +  b;
endmodule"
"module add32ca(o, a, b) ;
input [31:0] a, b;
output [31:0] o;
assign #1 o = a + b;
endmodule"
"module mux16b(o, a,  b, s) ;
input [15:0] a, b;
input s;
output [15:0] o;
reg [15:0] o;
initial o = 0;
always
begin
if( s == 1 )
#1 o = b;
else
#1 o = a;
end
endmodule"
"module mux16i(o, a, b, s);
input [15:0] a, b;
input s;
output [15:0] o;
assign #1 o = s ? b : a;
endmodule"
"module bs32b(out, in, s);
input [31:0] in;
input [3:0] s;
output [31:0] out;
reg[31:0] out;
reg internal_clock;
initial out = 0;
initial
fork
internal_clock = 0;
forever #10 internal_clock = ~internal_clock;
join
always @(posedge internal_clock)
begin
out = in << s;
end
endmodule"
"module bs32i(out, in, s, clock);
output [31:0] out;
reg [31:0] out;
input [31:0] in;
input [3:0] s;
input clock;
always @(posedge clock)
out <= #(`REG_DELAY) in << s;
endmodule"
"module queuectl( . . . ); // this is an incomplete example
. . .  //details omitted for clarity
// Sequential logic
always @(posedge clock) begin
if(myWrite) begin
write <= #1 1;
writeData <= #1 busData;
end
else
begin
write <= #1 0;
end
end
always @(readPtr or writePtr)
if(readPtr == writePtr)
qEmpty = 1;
else
qEmpty = 0;
endmodule"
"module
In Example 18-5, an instance of a behavioral adder is used to check the results from
the gate-level adder. This a pproach—running two models and checking the
results—is useful to deter mine if you have built a model according to the
specification in the behavioral model. The second adder instance  nadder is an
instance of the parameterized behavioral adder from Chapter 14. Each of the adders
is connected to separate output wires and the  task test compares the outputs.
Another approach shown in Example 18-6 to comparing the results from modules
in parallel is to connect the outputs to the same output wires and use the reduction
exclusive OR to look for any  x. If the two circuits are putting out the same result,
the result will be both correct and known. If the circuits disagree on any output, the
result will be an  x.
Example 18-6 Generating x's for Miscompare
module test_bench;
reg clk;
parameter half_period = 5;
reg[7:0] stimulus1,stimulus2; // input stimuli to models
wire[7:0] response1,response2; // results from models
wire error_flag  = ^{response1,response2};
// instantiate models to be compared
behav_model dut1(response1,response2,stimulus1,stimulus2);
rtl_model dut2(response1,response2,stimulus1,stimulus2};
always begin
clk = 0;
#half_period clk = 1;#half_period if(error_flag===1'bx) begin
$display(""error at time "",$time);
$displayb(response1,,response2); //x(s) mark bad bit(s)
$finish;
end
end
endmodule"
"module printer(data,  strobe, ack);
input [7:0] data;
input strobe;
output ack; reg ack;
parameter buffer_size =4; // size of the internal buffer
parameter print_time = 25; // time to print a character
parameter buffer_write_time = 10;
time done; // the next time the buffer will be empty
initial begin ack = 0; done = 0; end
always @(posedge strobe) begin
if( done > $time + buffer_size * print_time) #print_time;
// buffer full
if(done > $time) done = done + print_time;
// calculat e next empty time
else done = $time + print_time;
# buffer_write_time ack = 1;
$write(""%c"", data); // print it
# 1 ack = 0;
end
endmodule"
"module print_test_1;
reg [7:0] data;
reg strobe;
printer dut(data, strobe, ack) ;
initial begin
strobe = 0; data = ""t""; #1 strobe = 1;
#10 strobe = 0; data = ""h""; #1 strobe = 1;
#10 strobe = 0; data  = ""i""; #1 strobe = 1;
#10 strobe = 0; data = ""s""; #1 strobe = 1;
#25 strobe = 0; data = "" ""; #1 strobe = 1;
#25 strobe = 0; data  = ""i"";#1 strobe = 1;
#25 strobe = 0; data = ""s""; #1 strobe = 1;
#25 strobe = 0; data = "" ""; #1 strobe = 1;
#25 strobe = 0; data = ""a""; #1 strobe = 1;
#25 strobe = 0; data = "" ""; #1 strobe = 1;
#25 strobe = 0; data = ""t""; #1 strobe = 1;
#25 strobe = 0; data = ""e""; #1 strobe = 1;
#25 strobe = 0; data = ""s""; #1 strobe = 1;
#25 strobe = 0; data  = ""t""; #1 strobe = 1;
#25 strobe = 0; data = "" ""; #1 strobe = 1;
#25 strobe = 0; data = ""m""; #1 strobe = 1;
#25 strobe = 0; data = ""e""; #1 strobe = 1;
#25 strobe = 0; data = ""s""; #1 strobe = 1;
#25 strobe = 0; data = ""s""; #1 strobe = 1;
#25 strobe = 0; data = ""a""; #1 strobe = 1;
#25 strobe = 0; data = ""g""; #1 strobe = 1;
#25 strobe = 0; data = ""e""; #1 strobe = 1;
#25 strobe = 0; data =""\n""; #1 strobe = 1;
#25 $finish;
end
endmodule"
"module print_test_2;
reg [1:8] data;
reg strobe;
parameter message_length = 23;
parameter [1 : 8*message_length]  message
= ""this is a test message\n"";
integer i,j;
printer dut(data, strobe, ack);
initial begin
strobe = 0;
for (i=0; i<message_length; i =i+1) begin
for(j=1; j<=8; j=j+1) data[j] = message[j+i*8];
#1 strobe = 1;
@(posedge ack) strobe =0; // wait for the response
end // for
$finish;
end
endmodule"
"module test_inout;
reg [7:0] address; // drive address into the ram
reg [15:0] data_reg; //  drive data into the ram
wire [15:0] data; // actual wire connected to the ram
reg read, write; // control signals, active high
assign data = data_reg; // connect the register to the wire
ram dut(data, address, read, write); // device under test
initial begin
data_reg = 16'bz; read = 0; write =0; // set all off
address =0; //test location 0;
#100 if(data !== 16'bz )
$display( ""Data port did not turn off."");
data_reg = 16'hfeed; write = 1; // drive data in
#100 write = 0 ; data_reg = 16'bz;
#100 if(data !== 16'bz ) // make sure it turns off
$display( ""Data port did not turn off."");
read = 1; // read the data back out
#100 if(data !== 16'hfeed )
$display( ""Data is wrong."");
$finish;
end
endmodule"
"module test_adder_f;
wire [7:0] a, b, sum;
wire carry;
reg [8+8+1:1] stim[0:10];
integer index;
adder8 dut(carry_out, sum, a,b,carry);
assign {a,b,carry} = stim[index]; // apply stimulus from
// the memory
initial begin
$readmemb(""adder8.vec"",stim);
for(index=0; index<6; index=index+1)
test;
$finish ;
end
task test;
begin
#100 if( {carry_out, sum} !== a + b + carry) begin
$display(""result is  wrong"");
$finish;
end
end
endtask
endmodule"
"module sprom(address, data);
input [7:0] address;
output [7:0] data;
reg [7:0] rom[0:255];
assign #45 data = rom[address]; // entire functionality
initial $readmemh(""prom.dat"", rom);
endmodule"
"module to be tested;
declarations of registers for the inputs; and wires for the outputs. Example 18-17
shows a test bench with no vectors. Why would you want to do this? This allows the
test vectors to be applied, and results to be checked, interactively.
Example 18-17 Test Bench with No Vectors
module test_adder_nv;
reg [7:0] a,b;
reg carry ;
wire [7:0] sum;
adder8 dut(carry_out, sum, a,b,carry);
endmodule"
"module test_lfsr;
reg [31:0] lfsr;
reg bit;
reg [32:0] count;
initial begin
lfsr = 1;
count = 0;
forever begin
bit =lfsr[30]^lfsr[6]^-lfsr[4]^lfsr[1]^1fsr[0] ;
1fsr = {bit,lfsr[31:l]};
count = count + 1;
if(lfsr == 0) begin
$display(""lfsr died at zero after %d cycles"", count);
$finish;
end
if(lfsr == 1) begin
$display(""returned to 1 after %d cycles"", count);
$finish;
end
if (count[32]) begin
$display(""I must have repeated somewhere..."");
$finish;
end
end // forever
end // initial
endmodule"
"module alu_lfsr;
reg [35:0] lfsr; // 16 + 16 + 4 -1
reg bit;
reg [31:0] misr;
wire [15:0] a,b, aluout;
wire [3:0] f;
wire zero,parity,carry;
parameter final_signature = 32'ha592_2a45;
parameter test_cycles = 1023;
initial begin
lfsr = 1;
misr = 0;
repeat (test_cycles) begin
bit = lfsr[30]^lfsr[6]^lfsr[4]^lfsr[1]^lfsr[0] ;
lfsr = {bit,lfsr[35:1]}; // applies stimulus
#100 // wait for result, modify misr
misr = {misr[0],misr[31:1]} ^ {aluout,zero,parity,carry};
end
if(misr !==  final_signature)begin
$display(""Signature mismatch: expected %h, got %h"",
final_signature,misr);
end else begin
$display(""tested OK"");
end
end
assign {f,a,b} = lfsr ; // apply stimulus from lfsr
alu dut(a,b,f,aluout,zero,parity,carry);
endmodule"
"module alu (a, b, f, aluout, zero,parity, carry) ;
input [3:0] f;
input [15:0] a;
input [15:0] b;
output [15:0] aluout;
output zero;
output parity;
output carry;
/* Code inserted into alu to write vectors. */
integer fo;initial begin
fo = $fopen(""alu_test.vec"");
forever @(f) #10 if(1'bx === ^a)
$fdisplayh(fo, {16'bl,b,f,aluout,zero,parity,carry});
else
$fdisplayh(fo, {a,b,f,aluout,zero,parity,carry});
end
/* end write vectors */
// functionality of ALU omitted for clarity
endmodule"
"module since the `timescale
directive must be outside a module. The  system.vh file in Example 19-5 defines
common information for the system. It could be included inside or outside the
module.
Example 19-3 Counter Using `include
`include ""timing.vh""
module counter1(count, reset, clk) ;
`include ""system.vh""
output [`BUSWIDTH-1:0] count;
input reset, clk;
reg [`BUSWIDTH-1:0] count;
always @(posedge clk or posedge reset)
if(reset)
count <= #(`REG_DELAY) `BUSWIDTH 'b0;
else
count <= #(`REG_DELAY)  count + `BUSWIDTH 'b1;
endmodule"
"modules in this book have been simple and
undocumented. A better practice is to declare 1 port per line and comment the use
of the port. Example 19-6 shows an improvement of the port declarations. The ports
are now one per line and commented. The output port and its  reg re-declaration are
combined into a single line. This improves the readability of this module.
Example 19-6 Counter with commented ports
`include ""timing.vh""
module counter2(
count, // output, width is `BUSWIDTH
reset, // active high asynchronous reset
clk // rising edge clock
);
`include ""system.vh""
output [`BUSWIDTH-1:0] count; reg [`BUSWIDTH-1:0] count;
input reset;
input clk;
always @(posedge clk or  posedge reset)
if (reset)
count <= #(`REG_DELAY) `BUSWIDTH 'b0;
else
count <= #(`REG_DELAY) count + `BUSWIDTH 'b1;
endmodule"
"module counter3(
output reg [`BUSWIDTH-1: 0] count, // output
input wire reset, // active high asynchronous reset
input wire clk // rising edge clock
);
always @(posedge clk or posedge reset)
if(reset)
count <=  #(`REG_DELAY) `BUSWIDTH 'b0;
else
count <=  #(`REG_DELAY) count + `BUSWIDTH 'b1;
endmodule"
"module system_testbench;
event start_tests;
reg passed;
initial begin
reset = 1;
passed = 1;
repeat (6) @(posedge clk) ; // need 6 clocks of reset
wait (ready) // system responds with ready after internal
reset finishes
write(`BOARD1, `BOARD1_CONFIG); // initialize system boards
write(`BOARD2, `BOARD2_CONFIG);
write(`BOARD3, `BOARD3_CONFIG);
read_until(`BOARD4, `BOARD4_STATUS, `READY) ;
-> start tests;
end
task done;
begin
if(passed)
$display(""Passed"");
else
$display(""ERROR: Test Failure."");
repeat (3) @(posedge clk); // 3 clocks for bufferes to
flush
$finish;
end
endtask
`include ""current_t est.v""
endmodule"
"module cgen_ni(clock) ;
output clock; reg clock;
always #50 clock = ~clock;
endmodule"
"module reg_ns(q, clock, d) ;
output q; reg q;
input d, clock;
always @(posedge clock) #1 q <= d;
endmodule"
"module reg_ok(q, clock, d);
output q; reg q;
input d, clock;
always @(posedge clock) q <= #1 d;
endmodule"
"module interact;
initial $stop;
endmodule"
"module in Example 21-4 and start Verilog with the  -s option,
verilog -s sstep. v.
Example 21-4 Single-Stepping
module sstep;
initial begin
$display(""this is a first message"");
$display(""this is a second message"");
$stop;
$display(""this is a third message"");
$display(""this is a fourth message"");
end
endmodule"
"module loop;
integer count;
always
#1 count = count + 1;
endmodule"
"module adder8(carry_out, sum, a,b,carry);
output carry_out;
output [7:0] sum;
input[7:0] a, b ;
input carry;
adder4 hi4(carry_out, sum[7:4], a[7:4], b[7:4], int_carry);
adder4 lo4(int_carry, sum[3:0], a[3:0], b[3:0], carry);
endmodule"
"module adder4(carry_out, sum, a,b,carry);
output carry_out;
output [3:0] sum;
input [3:0] a, b ;
input carry;
adder2 hi2(carry_out, sum[3:2], a[3:2],  b[3:2], int_carry);
adder2 lo2(int_carry, sum[1:0], a[1:0], b[1:0], carry);
endmodule"
"module adder2(carry_out, sum, a,b,carry);
output carry_out;
output [1:0] sum;
input [1:0] a, b ;
input carry;
adder hi (carry_out, sum[1], a[1], b[l], int_carry);
adder lo (int_carry, sum[0], a[0], b[0], carry);
endmodule"
"modules:
test_adder
The primary reason for traversing the hierarchy is to observe the value of some
signal buried in the hierarchy.  Example 21-7 Results 2 shows the values of all the
inputs and outputs of this module along with the source c ode, and the value of an
internal signal.
Example 21-7 Results 2
C7 > $list;
// adder8.v
28 module adder4(carry_out, sum, a, b, carry);
29 output
29 carry_out; // = St0
30 output [3:0]
30 sum; // = 4'hb, 11 (scalared)
31 input [3:0]
31 a, // = 4'h2, 2 (scalared)
31 b; // = 4'h8, 8 (scalared)
32 input
32 carry; // = St1
34 adder2
34 hi2(carry_out, sum[3:2], a[3:2], b[3:2],
int_carry);
35 adder2
35 lo2(int_carry, sum[1:0], a[1:0], b[1:0],
carry);
37 endmodule"
"module adder8(carry_out, sum, a, b, carry);
18 output
18 carry_out; // = St0
19 output [7:0]
19 sum; // = 8'hdb, 219 (scalared)
20 input [7:0]
20 a, // = 8'h12, 18 (scalared)
20 b; // = 8'hc8, 200 (scalared)
21 input
21 carry; // = St1
23 adder4
23 hi4(carry_out, sum[7:4], a[7:4], b[7:4],
int_carry);
24 adder4
24 lo4(int_carry, sum[3:0], a[3:0], b[3:0],
carry);
26 endmodule"
"module countc(clock, reset, load, up, load_data, count);
input clock,reset, load, up;
input [15:0] load_data;
output [15:0] count;
reg [15:0] count;
always @(posedge clock)
if (reset)
count <= 8'b0;
else
if (load)
count <= #(`REG_DELAY) load_data;
else
if (up)
count <= #(`REG_DELAY) count + 1;
else
count <= #(`REG_DELAY) count - 1;
endmodule"
"module test_counter1;
reg up, load, clk, reset;
reg [15:0] load_data;
wire [15:0] count;
always begin// generate clock
#5 clk =0;
#5 clk =1;
end
// instantiate device under test
countc dut( .clock(clk), .reset(reset), .up(up),  .load(load),
.load_data(load_data), .count(count) );
initial begin // counter test sequence
reset = 1;
@(posedge clk) #3 if (count !== 16'h0000)
begin
$display(""Counter reset error"");
$finish;
end
reset = 0; load = 0; up = 1;
@(posedge clk) #3 if (count !== 16'h000l)
begin
$display(""Counter count to 1 error"");
$finish;
end
@(posedge clk) #3 if (count !== 16'h0002)
begin
$display(""Counter count to 2 error"");
$finish;
end
$finish;
end
endmodule"
"module
module reg8(clk, reset, d, q) ;
input clk, reset;
input [7:0] d;
output [7:0] q;
reg [7:0] q;
always @(posedge clk or posedge reset)
if(reset)
q <= #(`REG_DELAY) 8'h00;
else
q <= #(`REG_DELAY) d;
endmodule"
"module count_new(clk, reset, load, ldata, count, match);
input clk, reset, load;
input [7:0] ldata;
output [7:0] count; reg[7:0] count;
output match; reg match;
always @(posedge clk or posedge reset)
if (reset)
count <=  #(`REG_DELAY) 8'h00;
else
if(load)
count <= #(`REG_DELAY) ldata;
else
count <= #(`REG_DELAY)  count + 8'h01;
always @ count
if(count==ldata)
match = 1'b1;
else
match = 1'b0;
endmodule"
"module test_coverage;
reg clk, reset, load;
reg [7:0] ldata;
wire [7:0] count1, count2;
wire match1, match2;
count_old dut1(clk, reset, load, ldata, count1, match1);
count_new dut2(clk, reset, load, ldata,  count2, match2);
always begin
#5 clk = 0;
#5 clk = 1;
end
initial
begin
ldata = 8'h22; load = 1'b0; reset = 1' b1;
@(posedge clk)
ldata = 8'h22; load = 1'b0; reset = 1' b0 ;
@(posedge clk)
1data = 8'h22; load = 1'b1; reset = 1'b0;
@(negedge clk)
ldata = 8'h22; load = 1'b0; reset = 1'b0;
repeat(3) @(posedge clk) ;
$finish;
end
endmodule"
"module delays;
and a1 (y, a, b), a2 (w, d, e, f) ; // zero delay and gates
and #1 a3 (x, a, c, e), a4 (z, e, f); // unit delay and gatesand #(3,2) a5(c, w, z); // rise delay of 3, fall delay of 2
bufif1 #(3,2,4) b1(x, a,b); // turn off time is 4
bufif0 #(2:3:4,1:2:3,3:4:5) b2 (f, e, d) ; // min:typ:max
endmodule"
"module mod1;
// #1.1 in this module = 1.1 ns
endmodule"
"module mod2;
// #2 in this module = 200 ps
endmodule"
"module strength;
nand (strong0, highz1) oc1(z, a, b) oc2(w, d, e);
buf (weak1, weak0) #6 wimpo(out, in);
myudp (pull0, pull1) #(2:3:4,1:2:3) u1(q, c, d, r, s);
endmodule"
"module binaryToESeg_Behavioral
(output reg eSeg,
input A, B, C, D);
always @(A, B, C, D) begin
eSeg = 1;
if(~A & D)
eSeg = 0;
if(~A & B & ~C)
eSeg = 0;
if(~B & ~C & D)
eSeg = 0;
end
endmodule"
"module descriptions in
Examples P.1 and P.2 describe equivalent
functionality. (See Section 2.3.1.)
If the module  is parameterized, then
the list of parameters is introduced and
declared before the port list so that some
of the port specifications can be parame-
terized. (See Section 5.2.) This is illus-
trated in Example P.3. The new standard also allows for parameters to be over-ridden
by name. The old style of instantiating module xorx of Example P.3 would be
xorx #(7, 12) x1 (a,b,c);
where the new value of width is 7 and delay is 12. With the new style, individual
parameters can be overridden  —module binaryToESeg_Behavioral
(eSeg, A, B, C, D);
output eSeg;
input A, B, C, d;
reg eSeg;
always @(Aor B or C or D)
begin
eSeg = 1;
if (~A & D)
eSeg = 0;
if (~A & B & ~C)
eSeg = 0;
if (~B & ~C & D)
eSeg = 0;
end
endmodule"
"module binaryToESeg_Behavioral
(output reg eSeg,
input A, B, C, D);
always @(*)begin
eSeg = 1;
if(~A & D)
eSeg = 0;
if(~A & B & ~C)
eSeg = 0;
if(~B & ~C & D)
eSeg = 0;
end
endmodule"
"module xorx module xorx (xout, xin1, xin2);
#(parameter width = 4, parameter width = 4,
delay = 10) delay = 10;
(output [1:width] xout, output [1 :width] xout;
input [1:width]  xin1,xin2); input [1:width] xin1,xin2;
assign #(delay) assign #(delay)
xout = xin1 ^ xin2; xout = xin1 ^ xin2;
endmodule"
"modules.  Each of these
modules has an interface to  other modules as well as a description of its contents. A
module represents a logical unit that can be described either by specifying its internal
logical structure — for instance describing the actual logic gates it is comprised of, or
by describing its  behavior in a program-like manner — in this case focusing on  what
the module does rather than on its logical implementation. These modules are then
interconnected with  nets, allowing them to communicate.
1.1.1 A Structural  Description
We start with a basic logic circuit from introductory logic design courses: part of a
binary to seven segment display driver, shown in Example 1.1. A display driver takes a
module binaryToESeg;
wire eSeg, p1, p2, p3, p4;
reg A,B,C,D;
nand #1
g1(p1, C,~D),
g2 (p2, A, B),
g3 (p3, ~B, ~D),
g4 (p4, A, C),
g5 (eSeg, p1, p2, p3, p4);
endmodule"
"module definition for  binaryToESeg  called
binaryToESegSim.  The example includes statements that will provide stimulus to the
NAND  gate instances,  and statements that will monitor  the changes  in their outputs.
Although all  possible input combinations are not  provided, the ones shown will illus-
trate how to provide input stimuli.
module binaryToESegSim;
wire eSeg, p1, p2, p3, p4;
reg A,B,C,D;
nand #l
g1 (p1,C,~D),
g2 (p2, A, B),
g3 (p3, ~B, ~D),
g4 (p4, A, C),
g5 (eSeg, p1, p2, p3, p4);
initial // two slashes introduce a single line comment
begin
(
""A = %b B = %b C = %b D = %b, eSeg = %b"",
A,B,C,D, eSeg);
//waveform for simulating the binaryToESeg driver
#10 A =  0; B = 0; C = 0; D = 0;
#10 D =  1;
#10 C =  1; D = 0;
#10
end
endmodule"
"modules nor help in
developing a module
hierarchy. This  example
extends our notion of
defining modules to
include ones that haveports.module binaryToESeg
(output eSeg,
input A, B, C, D);
nand #1
g1 (p1, C, ~D),
g2 (p2, A, B),
g3 (p3,  ~B, ~D),
g4 (p4, A, C),
g5 (eSeg, p1, p2, p3, p4);
endmodule"
"module, then when you synthesize, you
may need to remove this behavior — an error prone process. The binaryToESegSim
module  of Example  1.2 showed  a module where  the design’s description (the  NAND
gate instantiations) and the  test behavior (the initial statement) were combined.
Example 1.4 shows this description rewritten using the  testbench approach.
module testBench;
wire   w1, w2, w3, w4, w5;
binaryToESeg d (w1, w2, w3, w4, w5);
test_bToESeg t (w1, w2, w3, w4, w5);
endmodule"
"module binaryToESeg
(input A, B, C, D,
output eSeg);
nand #1
g1 (p1, C, ~D),
g2 (p2, A, B),
g3 (p3, ~B, ~D),
g4 (p4, A, C),
g5 (eSeg, p1, p2, p3, p4);
endmodule"
"module test_bToESeg
(output reg A, B, C, D,
input eSeg);
initial  // two slashes introduce a single line comment
begin
""A = %b B = %b C = %b D = %b, eSeg = %b"",
A, B, C, D, eSeg);
//waveform for simulating the nand ftipftop
#10 A =  0; B = 0; C = 0; D = 0;
#10 D =  1;
#10 C =  1; D = 0;
#10
end
endmodule"
"module is described in terms of procedural statements rather
than with gate instantiations. The  always statement, introduced here, is the basis for
modeling behavior. The always statement, essentially a “while ( TRUE )” statement,
includes one or more  procedural  statements that are repeatedly executed. These  proce-
dural statements execute much like you would expect a software program to execute:
changing register values using the “=” assignment, and executing loops and condi-
tional expressions. Note that within the al ways statement, all assignments using “=”
are made to entities declared as registers. This was also true of the initial statements
seen earlier.
module binaryToESeg_Behavioral
(output reg eSeg,
input A, B, C, D);
always @(A, B, C, D) begin
eSeg = 1;
if (~A & D)
eSeg = 0;
if (~A & B & ~C)
eSeg = 0;
if (~B & ~C & D)
eSeg = 0;
end
endmodule"
"module fsm
(output reg out,
input in, clock, reset);
reg [1:0] currentState, nextState;
always @(in, currentState) begin // the combinational portion
out = ~currentState[1] & currentState[0];
nextState = 0;
if (currentState = = 0)
if (in) nextState = 1;
if (currentState = = 1)
if (in) nextState = 3;
if (currentState = = 3) begin
if (in) nextState = 3;
else nextState = 1;
end
end
always @(posedge  clock, negedge reset) begin // the sequential portion
if (~reset)
currentState <= 0;
else
currentState <= nextState;
end
endmodule"
"module fsmNB
(output reg out,
input in, clock, reset);
reg            cS1, cS0;
always @(cS1, cS0)   // the combinational portion
out =  ~cS1  & cS0;
always @(posedge clock, negedge reset) begin // the sequential  portion
if (~reset) begin
cS1 <= 0;
cS0 <= 0;
end
else begin
cS1<= in & cS0;
cS0 <= in | cS1;
end
end
endmodule"
"modules and their interconnection.
The example consists of a board mod-
ule which contains a clock  module
(m555 ), a four-bit counter ( m16), and
ourbinaryToESeg  display driver from
section 1.2.
1.4.1 The Counter
We look first at the counter module
definition shown in Example 1.8. Our
counter has two ports: the 4-bit counter reg-
ister ctr, and a clock to increment the
counter. The example declares that the inter-
nal register ctrand its output port are 4-bit
vectors  and provides an initial simulation
value for ctr(1); when simulation begins, ctr
will be set to the constant value specified to
the right of the “=”.  The counter  is modeled
behaviorally using an al ways block. The module waits for  a positive edge on clock.
When that occurs, ctris incremented and the module waits for the  next positive edge
onclock. Since the generation of  the new counter value occurs on an  edge of a signal,
the non-blocking assignment operator (“<=”) is used.
Ifctrhad not been  initialized, its bits would al ways be unknown. When the simu-
lator tries  to increment a register whose bits are unknown (x), the result is unknown.
Thus, for simulation ctrmust be initialized.
1.4.2 A Clock for the System
Our counter needs a clock to drive it. Example 1.9 defines an a bstraction of a “555”
timer chip called m555  and shows the waveform generated from simulating the
description.
Them555  module has an internal register ( clock ) which is also the output of the
module. At the start of a simulation, the output has the value x as illustrated by the
gray area in the example’s timing diagram. In this example, we choose to initialize themodule m16
(output reg [3:0] ctr = 1,
input clock);
always @(posedge clock)
ctr <= ctr +  1;
endmodule"
"module m555
(output reg clock);
initial
#5 clock =1;
always
#50 clock = ~ clock;
endmodule"
"module board;
wire [3:0] count;
wire clock, eSeg;
m16 counter (count, clock);
m555 clockGen  (clock);
binaryToESeg disp (eSeg, count[3], count[2], count[1],  count[0]);
initial
""count=%d, eSeg=%d"", count, eSeg);
endmodule"
"module.
Here we define scalar wires w3, w2, w1, w0  and we connect  them to ports A, B, C,
andD of binaryToESeg.  However, module m16 expects a 4-bit vector to connect to
its ctr port. The concatenation operator “{w3, w2, w1, w0}” combines w3, w2, w1,
andw0; They are grouped (concatenated) together and  treated as one 4-bit bundle
when connecting to m16.
module boardWithConcatenation;
wire clock, eSeg, w3, w2, w1,w0;
m16 counter ({w3, w2, w1, w0}, clock);
m555 clockGen (clock);
binaryToESeg disp (eSeg, w3, w2, w1, w0);
initial
( ""count=%d, eSeg=%d"", {w3, w2, w1, w0}, eSeg);
endmodule"
"modules partially illustrate how behavioral and structural
elements connect together. In this example, the structural binaryToESeg module in
Example 1.3 is  connected together with the behavioral m16 module from
Example 1.8. The register ctr in m16 is declared to be an output. Any changes to ctr
are propagated through the module ports and eventually to gate inputs. Thus we see
thatregisters specified in behavioral models can drive the inputs of gate primitives.
This need not be done in separate modules.
Indeed we c ould combine the
functionality of these two mod-
ules as show n in Example 1.12.
Here within one module we have
both structural and behavioral
components. Anytime ctr is
updated, the gates g1 through g4
will re-evaluate their output
because their inputs are con-
nected to ctr. Thus, the “output”
of an always block — the values
in the registers assigned to by the
always block — can be used as
inputs to gate level primitives.module counterToESeg
(output reg eSeg,
input clock);
reg [3:0]  ctr =  0;
always @(posedge clock)
ctr <= ctr +  1;
nand #1
g1 (pl, ctr[l], ~ctr[0]),
g2 (p2, ctr[3], ctr[2]),
g3 (p3, ~ctr[2], ~ctr[0]),
g4 (p4, ctr[3], ctr [l]),
g5 (eSeg, p1, p2, p3, p4);
endmodule"
"module to produce
mixedUpESegDriver.  The change
is that  the final NAND gate that
NAND -ed together the  outputs of
the other NAND gates  has  been
described behaviorally using an
always block. This always block
waits for any change on p1, p2, p3,
orp4. When a change occurs, the
behavioral statement calculates
their NAND storing  it in  register
eSeg.  This value is the combina-
tional output of the module. Thusmodule mixedUpESegDriver
(output reg eSeg,
input A, B, C, D);
nand #1
g1 (p1, C, D),
g2 (p2, A,~B),
g3 (p3, ~B, ~D),
g4 (p4, A, C);
always @(p1, p2, p3, p4)
eSeg = ~(p1 & p2 & p3 & p4);
endmodule"
"module in Example 1.4 with continuous assignment  state-
ments.
Write three different descriptions of a 2-bit full adder including carry-in and
carry-out ports. One description should use gate-level models, another should
use continuous assignment statements, and the third — combinational always.
Change the clock generator m555  in Example 1.9 such that the clock period
remains the same but that the low pulse width is 40 and high pulse w idth is 60.
Write a two-phase c lock generator. Phase two should be offset from phase one
by one quarter of a cycle.
Keeping the same output timing,  replace the initial and always statements in the
clock generator m555  in Example 1.9  with gate primitives.
Write a behavioral description for a serial adder. The module de finition is:
module serialAdder (
input clock, a, b, start,
output sum);
endmodule"
"module that is  complete except
for the register, input, and output declarations.  What should they be? Assume a,
b, and c are 8 bit “things” and the others are single-bit. Note that you may have
to add to the input-output list. Do not add any more assignments — only  input,
output, and register declarations.
module sillyMe (a, b, c, q,…);
// oops, forgot the  declarations!
initial
q = 1’b0;
always
begin
@ (posedge y)
#10 a = b +  c;
q = ~q;
end
nand #10 (y, q, r);
endmodule"
"module the_ckt
(output f,
input a, b, c, d);
and (f3,  f1, d),
(f4, f2, b);
xnor (f1, a, c);
not (f2, f1);
or (f, f3,  f4);
endmodule"
"module, called verify_spock that allows you to determine
whether the Verilog description matches the K-map. Write a top module, called
top_spock  to wire your test module to the the_ckt  module. The output of the
execution of your simulation module must relate easily to a truth table descrip-
tion of the function and the minterms represented on the K-map. Use a for loop
to generate the test values in your testbench.
1.9 The all-nand  circuit below is intended to implement the function, F=X xor Y.
However, it produces a glitch (a temporarily incorrect output) under certain
kinds of changes in the set of signals applied to the inputs.
module weird_xor
(output xor_out,
input x,y);
nand #3
g1(f1,x,y),
g3(f3,f1,y);
nand#l
g2(f2,x,f1),
g4(xor_out, f2, f3);
endmodule"
"module bad_timing
(output f_out,
input a, b, c);
nand #10
gl(f1,a,b),
g2(f_out,f1,c);
endmodule"
"module. Completely label all signals and
gates, including propagation delays.
B. This circuit will output a glitch (a temporarily incorrect  output) under cer-
tain operating c onditions. Describe the circumstances thatcause a glitch in this
circuit.
C. Write a complete simulation that will show when a glitch happens. Make a
test module, bad_timing_test  that provides sets of test inputs and a system
module, bad_timing_system, that instantiates both of the other modules and
wires them together.
D. Explain exactly how a glitch is detected by your simulation results.
E. Draw a timing diagram to illustrate the  glitch modeled in your simulation.
1.11 Consider the Verilog description below.
module what_is_it
(output f_out
input x,y);
nand #10
g1(f1,x,x),
g2(f2,y,y),
g3(f3,x,y),
g4(f4,f1,f2),
g5(f_out,f3,f4);
endmodule"
"module synGate
(output f,
input a, b, c);
and A  (a1, a, b, c);
and B (a2, a, ~b, ~c);
and C (a3, ~a, o1);
or D  (o1, b, c);
or E (f, a1, a2,  a3);
endmodule"
"module synAssign
(output f,
input a, b, c);
assign f = (a & b & c) | (a &~b &~c) | (~a & (b | c));
endmodule"
"module is parameterized with
the width of the words being
added and include carry in ( Cin)
and carry out (carry) ports. Note
that the sum generated on the
right-hand side of the assign
generates a result larger than
output sum. The concatenation
operator specifies that the top-
most bit (the carry out) will drive
thecarry output and the rest of
the bits wil l drive the sum out-
put. The multiplexor is described  using the conditional operator.module addWithAssign
#(parameter WIDTH = 4)
(output carry,
output [WIDTH-1:0] sum,
input [WIDTH-1:0] A,B,
input Cin);
assign {carry, sum} = A + B + Cin;
endmodule"
"module muxWithAssign
#(parameter W IDTH = 4)
(output [WIDTH-1:0] out,
input [WIDTH-1:0] A, B,
input sel);
assign out = (sel) ? A: B;
endmodule"
"module as a specification of
combinational logic.module synCombinationalAlways
(output reg f,
input a, b, c);
always @(a, b, c)
if (a == 1)
f = b;
else
f = c;
endmodule"
"module synAutoSensitivity
(output reg f,
input a, b, c);
always @(*)
if (a == 1)
f = b;
else
f = c;
endmodule"
"module has
the same  multiplexor functionality as
Example 2.5. However, here the output f
is assigned to first. In a complex d escrip-
tion, this approach ensures that a latch
will not be inferred because of a forgotten
output assignment.module synAssignOutputFirst
(output reg f,
input a, b, c);
always @(*) begin
f = c;
if (a == 1)
f = b;
end
endmodule"
"module synInferredLatch
(output reg f,
input a, b, c);
always @(*)
if (a == 1)
f = b  & c;
endmodule"
"module synCase
(output reg f,
input a, b, c);
always @(*)
case ({a, b, c})
3'b000: f = 1'b0;
3'b00l: f =1'b1;
3'b0l0: f = 1'b1;
3'b011: f = 1'b1;
3'b100: f = 1'b1;
3'bl0l: f =1'b0;
3'b110: f = 1'b0;
3'b111: f = 1'b1;
endcase
endmodule"
"module synCaseWithDefault
(output reg f,
input a, b, c);
always @(a, b, c)
case ({a, b, c})
3'b000: f = 1'b0;
3'b101: f = 1'b0;
3'b110: f = 1'b0;
default: f = 1'b1;
endcase
endmodule"
"module synCaseWithDC
(output reg f,
input a, b, c);
always @(*)
case ({a, b, c})
3'b001: f = 1'b1;
3'b010: f = 1'b1;
3'b011: f=1'b1;
3'b100: f=1'b1;
3'b110: f=1'b0;
3'b111: f = 1'b1;
default: f = 1'bx;
endcase
endmodule"
"module synAttributes
(output reg f,
input a, b, c);
always @(*)
(* full_case, parallel_case *)
case ({a, b, c})
3'b001: f =  1'b1;
3'b010: f=1'b1;
3'b011: f = 1'b1;
3'b100: f = 1'b1;
3'b110: f = 1'b0;
3'b111: f = 1'b1;
endcase
endmodule"
"module synUsingDC
(output reg f,
input a, b);
always @ (*)
casex ({a, b})
2'b0?: f  =  1 ;
2'b10: f = 0;
2'b11: f = 1;
endcase
endmodule"
"module oneHotEncoding
(output reg [2:0] state,
input in, ck);
always @(posedge ck)
(* full_case, parallel_case *)
casex (state)
3'b1??: state <= 3'b010;
3'b?1?: state <= in ? 3'b010: 3'b001;
3'b??1: state <=  in ? 3'b100: 3'b001;
endcase
endmodule"
"module appears to be a sequential algo-
rithm. However, the for loop specifies a cascade of  adders summing up the correla-
tions of each bit-pair; a combinational circuit results.
The bitwidth of the inputs and outputs are parameterized. Starting with bit posi-
tion zero,  the two  inputs  are XNOR ’d together producing their correlation  — 1 if the
input bits are the same, else 0. The next iteration of the for loop specifies  another cor-
relation, this time of bit one of message and pattern ; this correlation is a dded with the
previous result. The result of all iterations of the for loop is to specify dataWidth  lev-
els of adders. A logic synthesizer can  work hard on optimizing that! When simulated,
the initialization to matchCount starts it at zero.
References:  Unallowed constructs 2.8, parameters 5.2, generate 5.4.module synXor8
(output reg [ 1:8] xout,
input [1:8] xin1, xin2);
reg [1:8] i;
always @(*)
for (i = 1; i <= 8;  i = i +  1)
xout[i] = xin1[i] ^ xin2[i];
endmodule"
"module DigitalCorrelator
#(parameter dataWidth = 40,
countWidth = 6,)
(output reg [countWidth-1:0] matchCount = 0,
input [dataWidth-1:0] message, pattern);
int i;
always @(*) begin
for (i = 0; i < dataWidth; i = i + 1)
matchCount = matchCount + ~(message[i] ^ pattern[i]);
end
endmodule"
"module synLatchReset
(output reg
input g, d, reset);
always @(*)
if (~reset)
else if (g)
endmodule"
"module’s width is  parameterized.module synALUwithLatchedOutput
#(parameter Width = 4)
(output reg  [Width-l:0]
input [Width-l:0] a, b,
input g,  addsub);
always @(*) begin
if (g) begin
if (addsub)
else
end
end
endmodule"
"module synDFF
(output reg q,
input clock, d);
always @(negedge clock)
q <= d;
endmodule"
"module synDFFwithSetReset
(output reg q,
input d, reset, set, clock);
always @(posedge clock, negedge reset, posedge set) begin
if (~reset)
q  <= 0;
else if  (set)
q <= 1;
else q <= d;
end
endmodule"
"module
follows the form for describing a combi-
national logic function. The special situ-
ation here is that a condition (in this
case, driveEnable ) specifies a case where
the output will be high impedance. Synthesis tools infer that this condition will be the
tri-state enable in the final implementation.module synTriState
(output reg bus,
input in, driveEnable);
always @(*)
if (driveEnable)
bus = in;
else bus = 1'bz;
endmodule"
"module
Example 2.21 A Simple Finite State Machine
FSM and it is in the input set of the first always statement. The  first always statement
is a description of combinational logic that produces the output and the next state
functions.
References:  parameters 5.2; non-blocking assignment 8.4; implicit style 2.6.2.
2.6.2 An Alternate Approach to FSM Specification
The above explicit approach for specifying FSMs is quite general, allowing for arbi-
trary state machines to be specified. If an FSM is a single loop without any condi-
tional next states, an  implicit style of specification may be used.
The basic form of an implicit
FSM specification is  illustrated in
Example 2.22. The single always
statement lists several clock  events,
all based on the same edge (positive
or negative). Since the always speci-
fies a sequential loop, each state is
executed in order and the loop exe-
cutes continuously. Thus, there is no
next state function to be specified.
In this particular example, a flow
of data is described. Each state com-
putes an output ( temp  and dataOut)
that is used in later states. The output
of the final state ( dataOut) is the
output of the FSM. Thus, a new
result is produced every third clock
period in  dataOut.module synImplicit
(input [7:0] dataIn, c1, c2,
input clock,
output reg [7:0] dataOut);
reg [7:0] temp;
always begin
@ (posedge clock)
temp = dataIn + c1;
@ (posedge clock)
temp = temp & c2;
@ (posedge clock)
dataOut = temp - c1;
end
endmodule"
"module synPipe.module synPipe
(input [7:0] dataIn, c1, c2,
input clock,
output reg [7:0] dataOut);
reg [7:0] stageOne;
reg [7:0] stageTwo;
always  @ (posedge clock)
stageOne <= dataIn + c1;
always  @ (posedge  clock)
stageTwo <= stageOne & c2;
always  @ (posedge clock)
dataOut <= stageTwo + stageOne;
endmodule"
"modules:
registers, adders, and
comparators. The register
module definition is
shown in Example 2.24.
Looking first at thealways block, we see that
it is very similar to those
we’ve seen in sequential
circuit descriptions so far.
The register is positive
edge triggered but does
not have an asynchro-
nous reset. To go along
with the register modules
defined for our da tapath, it has two control points: clear and load.  These c ontrol
points, when asserted, cause the register to perform the specified function. If input
clear  is asserted, it will load 0 at the clock edge. If load is asserted, it will load input in
into register out at the clock edge. If both are asserted, then the register will perform
the clear function.
This example introduces a new statement, the parameter statement. The  parameter
defines a name to have a constant value; in this case Width  has the value 8. This name
is known within the module and can be used in any of the statements. Here we see it
being used to de fine the default value for the left-most bit number in the vector defin-
itions of the output and register out and the input in. Given that Width  is defined to
be 8, the left-most bit is numbered 7 (i.e., 8-1) and out and in both have a bitwidth of
eight (i.e., bits 7 through 0). What is interesting about a parameter is that the default
value can be overridden at instantiation time; however it cannot be cha nged during
the simulation.  Thus, this module definition can be  used to instantiate registers of
different bitwidth. We will see how shortly.module register
#(parameter Width = 8)
(output reg [Width-1:0] out,
input [Width-1:0] in,
input clear, load, clock);
always @(posedge clock)
if (~clear)
out <= 0;
else if  (~load)
out <= in;
endmodule"
"module is shown in
Example 2.25. It is parameterized to  have
a default bitwidth of eight. The assign
statement in this example shows a means
of generating our “adder” function. The
output sum is assigned the arithmetic
sum of inputs a  and b  using the “+ ” opera-
tor. The assign statement is discussed fur-
ther in Chapter 6.module adder
#(parameter Width = 8)
(input [Width-1:0] a,b,
output [Width-1:0] sum);
assign sum = a + b;
endmodule"
"modules are shown in
Example 2.26, again using the
continuous assign statement. In
the compareLT  module, a is
compared to b. If a is less than b,
then out is set to TRUE . Other-
wise it is set to FALSE . The com-
pare module for comparing
i with 10 in our computation is
similar to this module except
with the “<=” operator instead  of
the “ <“ operator. The width of
these modules are also parame-
terized. Don’t be confused by the
second assign statement, namely:
assign out = a <= b;module compareLT // compares a < b
#(parameter Width = 8)
(input [Width-1:0] a, b,
output out);
assign out = a < b;
endmodule"
"module compare // compares a <= b
#(parameter Width = 8)
(input [Width-1:0] a, b,
output out);
assign out = a <= b;
endmodule"
"module sillyComputation
#(parameter Width = 8)
(input ck, reset,
input [Width-1:0] yln,
output [Width-1:0] y,x);
wire [ Width-1:0] i, addiOut, addxOut;
wire yLoad, yClear, xLoad, xClear, iLoad,  iClear;
register #(Width) I (i, addiOut, iClear, iLoad, ck),
Y (y, yIn, yClear, yLoad, ck),
X  (x, addxOut, xClear, xLoad, ck);
adder #(Width)   addI    (addiOut, 'b1, i),
addX (addxOut, y, x);
compareLT #(Width) cmpX (x, 'b0, xLT0);
compare #(Width)        cmpI (i, 'd10, );
fsm  ctl
(xLT0, yLoad, yClear, xLoad, xClear, iLoad,  iClear, ck, reset);
endmodule"
"module fsm
(input LT, ck, reset,
output reg yLoad, yClear, xLoad, xClear, iLoad, iClear);
reg [2:0] cState, nState;
always @(posedge ck,  negedge reset)
if (~reset)
cState <= 0;
else cState <= nState;
always @(cState, LT,
case (cState)
3'b00: begin //stateA
yLoad = 1; yClear = 1; xLoad = 1; xClear = 0;
iLoad = 1; iClear = 0; nState = 3'b001;
end
3'b001: begin // state B
yLoad = 1; yClear = 1; xLoad = 0; xClear = 1;
iLoad = 0; iClear = 1; nState = 3'b010;
end
3'b010: begin //state C
yLoad = 1; yClear = 1; xLoad = 1; xClear = 1;
iLoad = 1; iClear = 1;
if nState = 3'b001;
if(~   & LT) nState = 3'b011;
if (~ & ~LT) nState  = 3'b100;
end
3'b011: begin //state D
yLoad = 1; yClear = 0; xLoad = 1; xClear = 1;
iLoad = 1; iClear = 1; nState = 3'b101;
end
3'b100: begin //state E
yLoad = 1; yClear = 1; xLoad = 1; xClear = 0;
iLoad = 1; iClear = 1; nState = 3'b101;
end
default: begin // re quired to satisfy combinational synthesis rules
yLoad = 1; yClear = 1; xLoad = 1; xClear = 1;
iLoad = 1; iClear = 1;  nState = 3'b000;
(""Oops, unknown state: %b"", cState);
end
endcase
endmodule"
"module divide
(input [`DdLen-1:0] ddInput, dvInput,
output reg signed quotient,
input go,
output reg done);
reg signed  [`DdLen-1:0] dividend;
reg signed [`DvLen-1:0] divisor;
reg negDivisor , negDividend;
always begin
done = 0;
wait (go);
divisor = dvInput;
dividend = ddInput;
quotient = 0;
if (divisor)  begin
negDivisor = divisor[`DvLen-1];
if (negDivisor) divisor = - divisor;
negDividend = dividend[`DdLen-1];
if (negDividend) dividend = - dividend;
repeat (`DvLen) begin
quotient = quotient << 1;
dividend = dividend << 1;
dividend[`DdLen-1:`HiDdMin] =
dividend[`DdLen-1:`HiDdMin] -  divisor;
if (! dividend [`DdLen-1]) quotient = quotient + 1;
else
dividend[`DdLen-1:`HiDdMin] =
dividend[`DdLen-1:`HiDdMin] + divisor;
end
if (negDivisor != negDividend) quotient = - quotient;
end
done = 1;
wait (~go);
end
endmodule"
"module sureDeath //This will not work!!
(input inputA);
always
begin
while ( inputA)
; // wait for external variable
// other statements
end
endmodule"
"module microprocessor;
always
begin
powerOnInitializations;
forever
begin
fetchAndExecuteInstructions;
end
end
endmodule"
"module mark1;
reg [15:0] signed m [0:8191]; //signed 8192 x 16 bit memory
reg [12:0] signed pc; // signed 13 bit program counter
reg [12:0] signed acc; // s igned 13 bit accumulator
reg [15:0] ir; // 16 bit instruction register
reg ck; // a clock signal
always
begin
@(posedge ck)
ir <= m [pc]; // fetch an instruction
@(posedge ck)
if (ir[15:13] = = 3'b000) // begin decoding
pc <= m [ir [12:0]]; //and exec uting
else if (ir[15:13]==3'b001)
pc <= pc + m [ir [12:0]];
else if (ir[15:13]==3'b010)
acc <= -m [ir [12:0]];
else if (ir[15:13] == 3'b011)
m [ir [12:0]] <= acc;
else if ((ir[15:13] == 3'b101) || (ir[15:13] == 3'b100))
acc <= acc - m [ir [12:0]];
else if (ir[15:13] == 3'b110)
if (acc < 0) pc <= pc  + 1;
pc <= pc + 1; //increment program counter
end
endmodule"
"module mark1Case;
reg[15:0] signed m [0:8191]; // signed 8192 x 16 bit memory
reg [12:0] signed pc; // signed 13 bit program counter
reg [12:0] signed acc; // signed 13 bit accumulator
reg [15:0] ir; // 16 bit instruction register
reg ck; // a clock signal
always
begin
@(posedge ck)
ir <=  m [pc];
@(posedge ck)
case (ir [15:13])
3'b000 : pc <= m [ir [12:0]];
3'b00 1: pc <= pc + m [ir [12:0]];
3'b0l0 : acc <= -m [ir [12:0]];
3'b01 1: m [ir [12:0]] <= acc;
3'b100,
3'bl0l : acc <= acc - m [ir [12:0]];
3'bll0 : if(acc<0)pc<=pc + l;
endcase
pc <= pc  + 1;
end
endmodule"
"module decode;
reg [7:0]  r;
always
begin
// other statements
r = 8'bx1x0x1x0;
casex (r)
8'b001100xx: statement1;
8'b1100xx00: statement2;
8'b00xx0011: statement3;
8'bxx001100: statement4;
endcase
end
endmodule"
"modules provide the means of partitioning a
design into more-manageable parts; the use of modules implies thatthere are struc-
tural boundaries being described. These boundaries may in fact model the logical
structure or the physical packaging boundaries of the  design. Ve rilog provides  func-
tions and  tasks as constructs analogous to software functions and procedures that allow
for the behavioral description of a module to be  broken into  more-manageable parts.
module mark1Mult;
reg[15:0] signed m [0:8191]; // signed 8192 x 16 bit memory
reg [12:0] signed pc; //signed 13 bit program counter
reg [12:0] signed acc; // signed 13 bit accumulator
reg [15:0] ir; // 16 bit instruction register
reg ck; // a clock signal
always
begin
@(posedge ck)
ir <=  m [pc];
@(posedge ck)
case (ir [15:13])
3'b000 : pc <= m [ir [ 12:0]];
3'b001: pc <= pc + m [ir [12 :0]];
3'b010 : acc <= -m [ir [12:0]];
3'b011: m [ir [12:0]] <= acc;
3'b100,
3'b101: acc <= acc - m [ir [12:0]];
3'b110 : if (acc < 0) pc <= pc + 1;
3'b111: acc <= acc * m [ir [12:0]]; //multiply
endcase
pc <= pc  + 1;
end
endmodule"
"module mark1Task;
reg[15:0]      signed m [0:8191]; //signed 8192 x 16 bit memory
reg [12:0]  signed pc; // signed 13 bit program counter
reg [12:0]  signed acc;      // signed 13 bit accumulator
reg ck; // a clock signal
always
begin: executeInstructions
reg [15:0] ir; // 16 bit instruction register
@(posedge  ck)
ir <=  m [pc];
@(posedge  ck)
case (ir [15:13])
// other case expressions as before
3'b111:  multiply (acc,  m [ir  [12:0]]);
endcase
pc <= pc  + 1;
end
task multiply
(inout [12:0] a,
input [15:0] b);
begin: serialMult
reg [5:0] mcnd, mpy; //multiplicand and multiplier
reg [12:0] prod; //product
mpy = b[5:0];
mcnd = a[5:0];
prod = 0;
repeat (6)
begin
if (mpy[0])
prod = prod + {mcnd, 6'b000000};
prod = prod >> 1;
mpy = mpy  >> 1;
end
a = prod;
end
endtask
endmodule"
"module mark1Fun;
reg[15:0] signed m [0:8191]; //signed 8192 x 16 bit memory
reg [12:0] signed pc; // signed 13 bit program counter
reg [12:0] signed acc;      // signed 13 bit accumulator
reg ck;                  // a clock signal
always
begin: executeInstructions
reg [15:0] ir; // 16 bit instruction register
@(posedge ck)
ir <=  m [pc];
@(posedge ck)
case (ir [15:13])
//case expressions, as before
3'b111:  acc <=  multiply(acc,  m [ir  [12:0]]);
endcase
pc <= pc  + 1;
end
function signed [12:0] multiply
(input signed [12:0] a,
input signed [15:0] b);
begin: serialMult
reg [5:0] mcnd, mpy;
mpy = b[5:0];
mcnd = a[5:0];
multiply = 0;
repeat (6)
begin
if (mpy[0])
multiply = multiply + {mcnd, 6'b000000};
multiply = multiply >> 1;
mpy = mpy  >> 1;
end
end
endfunction
endmodule"
"module RAM
#(parameter Width = 16,
NumWords = 8192)
(inout [W idth-l:0] data,
input [clog2b(NumWords):0] address,
input rw, ck);
reg [Width-l:0] m [0:NumWords-l];
function integer c log2b // c onstant function
(input integer size); // assumes non-zero size
begin
for (clogb2 = -1; size > 0; clogb2 = clogb2 + 1)
size = size >> 1;
end
endfunction
always… // internal behavior of the RAM
endmodule"
"module mark1Mod;
reg  [15:0] signed      m [0:8191];      // signed 8192 x 16 bit memory
reg [12:0] signed pc; // signed 13 bit program counter
reg [12:0] signed acc;                 // signed 13 bit accumulator
reg [15:0] ir;                   // 16 bit instruction register
reg ck;                  //  a clock signal
reg signed [12:0] mcnd;
reg go;
wire signed [12:0] prod;
wire done;
multiply mu l (prod, acc, mcnd, go, done);
always
begin
@(posedge ck)
go <= 0;
ir <=  m [pc];
@(posedge ck)
case (ir [15:13])
//other case expressions
3'blll:begin
wait (~done) mcnd <= m [ir [12:0]];
go <= 1;
wait (done);
acc <=  prod;
end
endcase
pc <= pc  + 1;
end
endmodule"
"module
Example 3.12 The Multiply as a Separate Module
3.6 Rules of Scope  and Hierarchical Names
An identifier’s  scope  is the  range  of the  Verilog description over which  the identifier  is
known. The rules of scope define this range. Verilog also has a hierarchical naming
feature allowing any identifier in the whole design to be accessed from anywhere in
the design.
3.6.1  Rules of Scope
Module names are known globally across the whole design.  Verilog then allows for
identifiers to be defined within four entities: modules, tasks, functions, and named
blocks. Each  of these entities  defines  the local  scope  of the  identifier,  the range  of the
description over which the identifier is  known. This local scope encompasses the
module-endmodule"
"module top;
reg r; //hierarchical  name is top.r
wire w; //hierarchical  name is top.w
b instance1();
always
begin: y
reg q; //hierarchical name is top.y.q
end
task t;
begin: c //hierarchical name is top.t.c
reg q; //hierarchical name is top.t.c.q
disable y; //OK
end
endtask
endmodule"
"module b;
reg s; //hierarchical name is top.instance1.s
always
begin
t; //OK
disable y; //OK
disable c; //Nope, c is not known
disable t.c; //OK
s = 1; //OK
r = 1; //Nope, r is not known
top.r = 1; //OK
t.c.q = 1; //OK
y.q = 1; //OK, a different q than t.c.q
end
endmodule"
"module computer;
always
begin
powerOnInitializations;
forever
begin
fetchAndExecuteInstructions;
end
end
endmodule"
"module dEdgeFF
(output reg q,
input clock, data);
always
@(negedge clock) q <= data;
endmodule"
"module topFib;
wire [15:0] number, numberOut;
numberGen ng (number);
fibNumCalc fnc (number, numberOut);
endmodule"
"module numberGen
(output reg [15:0] number = 0);
event ready; //declare the event
always
begin
#50 number = number + 1;
#50 ready; //generate event signal
end
endmodule"
"module fibNumCalc
(input [15:0] startingValue,
output reg [15:0] fibNum);
reg [15:0] count, oldNum , temp;
always
begin
@ng.ready //wait for event signal
count = startingValue;
oldNum = 1;
for (fibNum = 0; count != 0; count = count - 1)
begin
temp = fibNum;
fibNum = fibNum + oldNum;
oldNum = temp;
end
(""%d, fibNum=%d"",               fibNum);
end
endmodule"
"module, can  trigger other mod-
ules that were previously stopped at an @event statement. Further, the named event is
more abstract than the event control in that no hardware implementation clues are
given. By comparison, a posedge event control implies that some form of edge trig-
gering logic will be used to detect thatsuch a tra nsition has occurred. The named
event is typically used in simulation.
References.  Hierarchical names 3.6
4.3The Wait Statement
The wait statement is a concurrent process statement that waits for its conditional
expression to become TRUE. Conceptually, execution of the process stops until the
expression becomes TRUE. By definition, the  conditional expression must include at
least one value that is generated by a separate, concurrent process — otherwise, the
conditional expression w ould never change. Because the wait must work with inputs
from other processes, it is a primary means of synchronizing two concurrent pro-
cesses.
The wait statement condition is level-sensitive. That is, it does not wait for a
change  in a value. Rather  it only  checks  that the value  of the conditional  is TRUE.  If it
is, execution  continues.  If it is  FALSE,  the process waits.
The wait is often used in handshaking
situations where we are synchronizing
two processes. Example 4.5 illustrates the
situation where a process will  only read
thedataIn input if the ready input is
TRUE . The wait synchronizes the two pro-
cesses by insuring that the consumer pro-
cess does not pass the wait sta tement and
consume the data  until the producer pro-
cess generates dataIn and sets the ready
signal  toTRUE . The ready signal  is a syn-
chronization signal that tells the con-
sumer process that the producer process
has passed the state where dataIn is gen-
erated. In this way, the two processes
become synchronized by the ready signal.
The general form of the wait statement ismodule consumer
(input [7:0] dataIn,
input ready);
reg [7:0]  in;
always
begin
wait (ready)
in = dataIn;
//… consume dataIn
end
endmodule"
"module ProducerConsumer;
reg consReady,  prodReady;
reg [7:0] dataInCopy, dataOut;
always // The consumer process
begin
consReady = 1; // indicate consumer ready
forever
begin
wait (prodReady)
dataInCopy = dataOut;
consReady = 0; // indicate value consumed
//…munch on data
wait (!prodReady) // complete handshake
consReady = 1;
end
end
always // The producer process
begin
prodReady = 0; // indicate nothing to transfer
forever
begin
// …produce data and put into “dataOut”
wait (consReady) // wait fo r consumer ready
dataOut =
prodReady = 1; //indicate  ready to transfer
wait (!consReady) //finish handshake
prodReady = 0;
end
end
endmodule"
"module endlessLoop
(input inputA);
reg[15:0] count;
always
begin
count = 0;
while (inputA)
count  = count  + 1; // wait  for inputA  to change  to FALSE
(""This  will never print  if inputA  is TRUE!"");
end
endmodule"
"module mark1Pipe;
reg[15:0] signed m [0:8191]; //signed 8192 x 16 bit memory
reg [12:0] signed pc; // signed 13 bit program counter
reg [12:0] signed acc; // signed 13 bit accumulator
reg [15:0] ir; // 16 bit instruction register
reg ck; // a clock  signal
always @(posedge ck) begin
ir <=  m [pc];
pc <= pc  + 1;
end
always @(posedge ck)
case (ir [15:13])
3'b000 : pc <= m [ir [12:0]];
3'b001:   pc <= pc + m [ir [12:0]];
3'b010  :    acc <= -m [ir [12:0]];
3'b011:   m [ir [12:0]] <= acc;
3'b100,
3'b101 :     acc <= acc - m [ir [12:0]];
3'b110 :    if(acc<0)pc<=pc+l;
endcase
endmodule"
"module mark1PipeStage;
reg[15:0] signed m [0:8191];   //signed 8192 x 16 bit memory
reg [12:0] signed pc; // signed 13 bit program counter
reg [12:0] signed acc; // signed 13 bit accumulator
reg [15:0] ir; // 16 bit instruction register
reg ck, skip;
always @(posedge ck) begin //fetch process
if (skip)
pc = pctemp;
ir <=  m [pc];
pc <= pc  + 1;
end
always @(posedge ck) begin //execute  process
if (skip)
skip <= 0;
else
case (ir [15:13])
3'b000: begin
pctemp <= m [ir [12:0]];
skip <= 1;
end
3'b001: begin
pctemp <= pc + m [ir [12:0]];
skip <= 1;
end
3'b010 : acc <= -m [ir [12:0]];
3'b011: m [ir [12:0]] <= acc;
3'b100,
3'b101: acc <= acc - m [ir [12:0]];
3'b110: if (acc < 0) begin
pctemp <= pc + 1;
skip <= 1;
end
endcase
end
endmodule"
"module simpleTutorialWithReset
(input clock, reset,
output reg [7:0] y,x);
initial
forever begin
@(negedge reset)
disable main;
end
always begin: main
wait (reset);
@(posedge clock) x <= 0;
i = 0;
while (i <= 10) begin
@(posedge clock);
x <= x + y;
i = i +  1;
end
@(posedge clock);
if (x<0)
y<=0;
else x <= 0;
end
endmodule"
"module dFlop
(input pr eset, clear,
output reg q,
input clock, d);
always
@(clear, preset)
begin
if(!clear)
#10 assign q = 0;
else if (!p reset)
#10 assign q = 1;
else
#10 deassign q;
end
always
@(negedge clock)
q = #10  d;
endmodule"
"module microprocessor;
always
begin
resetSequence;
fork: mainWork
forever
fetchAndExecuteInstructions;
@(posedge reset)
disable mainWork;
join
end
endmodule"
"module simpleTutorialWithReset
(input clock, reset,
output reg [7:0] y, x_;
reg [7:0]  i;
always fork: main
@(negedge reset)
disable main;
begin
wait (reset);
@(posedge clock) x <= 0;
i = 0;
while (i <= 10) begin
@(posedge clock);
x <= x + y;
i = i +  1;
end
@(posedge clock);
if (x < 0)
y<=0;
else x <= 0;
end
join
endmodule"
"modules or
gates. An inout  port may only be driven through a gate with high impedance capabil-
ities such as a bufif0 gate.
Secondly, each port connection is a con-
tinuous assignment of source to sink where
one connected item is the signal source and
the other is a signal sink. The output ports
of a module are implicitly connected to sig-
nal source entities such as nets, registers,
gate outputs, instantiated module outputs,
and the left-hand side of continuous
assignments internal to the module. Input
ports are connected to gate inputs, instanti-
ated module inputs, and the right-hand
side of continuous and procedural assign-
ments. Inout ports of a module are con-module binaryToESeg
(input A, B, C, D,
output eSeg);
nand #1
g1 (p1, C, ~D),
g2 (p2, A, B),
g3 (p3, ~B, ~D),
g4 (p4, A, C),g5 (eSeg, p1, p2, p3, p4);
endmodule"
"module’s descrip-
tion. Some, for in stance a
localparam, a llow for the specifica-
tion of a constant, possibly through a
compile-time expression. Others
(parameter) a llow us to define a
generic module that can be parame-
terized for use in different situations.
Not only does this a llow us to reuse
the same module definition in more
situations, but it allows us to define
generic information about the mod-
ule that can be  overridden when the
module is instantiated.module xor8
(output [1:8] xout,
input [1:8] xin1, xin2);
xor (xout[8], xinl [8], xin2[8]),
(xout[7], xinl [7], xin2[7]),
(xout[6], xinl [6],  xin2[6]),
(xout[5], xinl [5], xin2[5]),
(xout[4], xinl [4], xin2[4]),
(xout[3], xinl [3], xin2[3]),
(xout[2], xinl [2], xin2[2]),
(xout[l], xinl [l],  xin2[l]);
endmodule"
"module that instantiates eight XOR primitives
and wires them to the external ports. The ports are 8-bit scalars; bit-selects are used to
connect each primitive. In  this section we develop a parameterized version of this
module.
First, we replace the eight XOR gate
instantiations with a single assign
statement as shown in Example 5.2,
making this module more generally
useful with the parameter specification.
Here we specify two parameters, the
width of the module (4) and its delay
(10). Parameter specification is part of
module definition as seen in the fol-
lowing syntax specification:module xorx
# (parameter width =  4,
delay = 10)
(output [l:width] xout,
input [1:width] xinl, xin2);
assign #(delay) xout = xin1 ^ xin2;
endmodule"
"module_declaration
module_keyword module_identifier [ module_parameter_port_list]
[list_of_ports];
{ module_item }
endmodule"
"module_keyword module_identifier [ module_parameter_port_list]
[list_of_ports_declarations];
{ non_port_module_item }
endmodule"
"module_parameter_port_list
#(parameter_declaration { , parameter_declaration} )
parameter_declaration
parameter [ signed ] [ range ] list_of_param_assignments;
paramete r integer  list_of_param_assignments ;
paramete r real list_of_param_assignments ;
paramete r realtime  list_of_param_assignments ;
paramete r time  list_of_param_assignments ;
The module_parameter_port_list can be specified  right after the module keyword
and name; the types of parameters that can be specified include signed, sized (with a
range) parameters, as well as parameter types integer, real, realtime, and time.
Local parameters have a simila r declaration style except that the  localparam key-
word is used instead of  parameter.
local_parameter_declaration
localpara m [ signed  ] [ range ] list_of_param_assignments ;
localpara m integer  list_of_param_assignments ;
localpara m real list_of_param_assignments ;
localpara m realtime  list_of_param_assignments ;
localpara m time  list_of_param_assignments ;
These ca nnot be directly overridden and thus are typically used for defining constants
within a module. However, since a local parameter assignment expression can contain
a parameter (which can be overridden), it can be indirectly overridden.
When module  xorx  is instantiated,
the values specified in the parameter
declaration are used. This is a  generic
instantiation of the module. However,
an instantiation of this module may
override these parameters as illustrated
in Example 5.3. The “#(4, 0) ” specifies
that the value of the first parameter
(width) is 8 for this instantiation, and
the value of the second (delay) is 0. If the“#(4, 0)” was omitted, then the values
specified in the module definition w ould
be used instead. That is, we are able to override the parameter values on a per-mod-
ule-instance basis.module overriddenParameters
(output [3:0] a1, a2);
reg[3:0] b1, c1, b2, c2;
xorx #(4, 0) a(a1, b1, c1),
b(a2,  b2, c2);
endmodule"
"module definition is to
use the  defparam  statement and  the hier-
archical naming c onventions of Verilog.
This approach is shown in Example 5.4.
Using the  defparam  statement, all of
the respecifications of parameters can be
grouped into one place within the
description. In this example, the delay
parameter of instance b  of module xorx
instantiated within module xorsAreUs
has been changed so that its delay is five.
Module a nnotate uses hierarchical nam-
ing to affect the change. Thus, the
parameters may be respecified on an indi-
vidual basis. The general form of the def-
param statement is:
parameter_override
defparam
list_of_param_assignments ;module xorsAreUs
(output [3:0] a1, a2);
reg[3:0] b1, c1, b2, c2;
xorx a(al, bl, cl),
b(a2,  b2, c2);
endmodule"
"module xorx
#(parameter width = 4,
delay =10)
(output [1:width] xout,
input [1:width] xin1, xin2);
assign #delay xout = xin1 ^ xin2;
endmodule"
"module annotate;
defparam
xorsAreUs.b.delay = 5;
endmodule"
"module in
Example 5.1 was rather tedious because each
XOR instance had to be individually num-
bered with the appropriate bit.  Verilog has a
shorthand method of specifying an array of
instances where the bit numbering of each
successive instance differ in a controlled way.
Example 5.5 shows the equivalent redefini-
tion of module  xor8  using arrays of
instances. This is equivalent to the original
module  xor8  in Example 5.1. The array of instances specification uses the optional
range specifier to provide the numbering of the instance names.module xor8
(output [1:8] xout,
input [1:8] xin1, xin2);
xor a[l:8]  (xout, xinl, xi n2);
endmodule"
"modulemodule reggae
(output [7:0]
input [7:0] D,
input c lock, clear);
dff r[7:0] ( D, clear, clock);
endmodule"
"module regExpanded
(output [7:0]
input [7:0] D,
input clock, clear);
dff r7 D[7], clear, clock),
r6 D[6], clear, clock),
r5 D[5], clear, clock),
r4 D[4], clear, clock),
r3 D[3], clear, clock),
r2 D[2],  clear, clock),
r1 D[l], clear, clock),
r0 D[0], clear, clock);
endmodule"
"module and primitive instances, initial
and always procedural blocks, continuous ass ignments, net and variable declarations,
task and function definitions, and parameter redefinitions.
Continuing with the  xorx
examples of the chapter,
Example 5.7 illustrates  using a
generate statement to re-describe
the module. The generate…end-
generate block  specifies how an
object is going to be repeated.
Variables for use in specifying the
repetition are defined to be gen-
vars. Then a for loop is used to
increment (or decrement) the
genvars over a range. The use of
the genvars in the object to be
repeated then specify such infor-
mation as bit-selects.module xorGen
#(parameter width = 4,
delay =10)
(output [1:width] xout,
input [l:width] xinl, xi n2);
generate
genvar i;
for (i = 1; i <= width; i=i+l) begin: xi
assign #delay
xout[i] = xin1[i]  ^ xin2[i];
end
endgenerate
endmodule"
"module adderWithConditionCodes
#(parameter width = 1)
(output reg [width-1:0] sum,
output reg cOut, neg, overFlow,
input [width-1:0] a, b,
input cIn);
reg [width -1:0] c;
generate
genvar i;
for (i = 0; 1<= width-1; i=i+l) begin: stage
case(i)
0: begin
always @(*) begin
sum[i] = a[i] ^ b[i] ^ cIn;
c[i] = a[i]&b[i] | b[i]&cIn | a[i] & cIn;
end
end
width-1: begin
always @(*) begin
sum[i] = a[i] ^ b[i] ^ c[i-1];
cOut = a[i]&b[i] | b[i]&c[i-1] | a[i] & c[i-1];
neg = sum[i];
overFlow = cOut^ c[i-1];
end
end
default: begin
always @(*) begin
sum[i] = a[i] ^ b[i] ^ c[i-l];
c[i] = a[i]&b[i] | b[i]&c[i-1] | a[i] &c[i-l];
end
end
endcase
end
endgenerate
endmodule"
"module  with the structure:
module progBidirect (ioA, ioB, selectA, selectB, enable);
inout [3:0] ioA, ioB;
input [1:0] selectA, selectB;
input enable;
endmodule"
"modules. When describing a circuit at the gate level, we try to ma intain
a close (some might say  strict) correspondence to the actual gate l evel implementa-
tion.
6.2.1  Modeling Using Primitive Logic Gates
Example 6.1 shows a structural model of a
full adder usin g some of Verilog’s gate level
primitives. This example was developed from
a databook description  of a CEOS  one-bit  full
adder. Three single bit inputs and two single
bit outputs  provide connection to the outside
world. Internal to the module description, we
list the eleven primitive logic module
instances that comprise the  adder. Figure 6.1
shows a diagram of the adder with the inter-
nal connections la belled for ease of compari-
son. As a partial explanation, we see that
there  are two NAND  gates,  one with output x2
(note that the first parameter of a gate level
primitive is its output) and inputs aIn and
bIn, and the other with output cOut  and
inputs  x2 and x8.module fullAdder
(output cOut, sum,
input aIn, bIn, cIn);
wire x2;
nand      (x2, aIn, bIn),
(cOut,x2,x8);
xnor (x9, x5, x6);
nor   (x5, x1, x3),
(xl, aIn,  bIn);
or (x8,  xl, x7);
not  (sum, x9),
(x3,x2),
(x6, x4),
(x4,cIn),
(x7, x6);
endmodule"
"module andOfComplements
(input a, b,
output wand c,
output d);
not (c, a);
not (c, b);
not (d, a);
not (d,b);
endmodule"
"module which decodes them to one of eight possible data bits.
These bits, assigned to the 8-wire vector  bitFlippers,  correspond to the bit position
that needs to be inverted (a one  indicates invert, and a zero indicates no inversion).
The individual bits of  bitFlippers  are then inputs to eight XOR gates in  xor8.  The
other input of the XOR gates is the data bits to be corrected. A one on a  bitFlipper  bit
will invert (correct) the corresponding data bit. The output of  xor8  is the corrected
data and is the output of the  hamDecode  module.
module testHam;
reg [1:8] original;
wire [1:8] regenerated;
wire  [1:12] encoded,
messedUp;
integer seed;
initial begin
seed = 1;
forever begin
original = (seed);
#1
(""original=%h, encoded=%h, messed=%h,  regen=%h"",
original, encoded, messedUp, regenerated);
end
end
hamEncode     hIn (original, encoded);
hamDecode hOut (messedUp, regenerated);
assign messedUp = encoded ^ 12'b 0000_0010_0000;
endmodule"
"module
module xor8
(output [1:8] xout,
input [1:8] xin1,xin2);
xor a[l:8] (xout, xin1, xin2);
endmodule"
"module hamDecode
(input [1:12] vIn,
output [1:8] valueOut);
wire                    c1, c2, c4, c8;
wire [1:8]     bitFlippers;
xor (c1, vIn[l], vIn[3], vIn[5], vIn[7], vIn[9], vIn[11]),
(c2, vIn[2], vIn[3], vIn[6], vIn[7], vIn[10], vIn[11]),
(c4, vIn[4], vIn[5], vIn[6], vIn[7], vIn[12]),
(c8, vIn[8], vIn[9], vIn[10], vIn[l l], vIn[12]);
deMux mux1 (bitFlippers, c1, c2 , c4, c8,1'b1);
xor8 x1 (valueOut, bitFlippers, {vIn[3], vIn[5], vIn[6], vIn[7], vIn[9],
vIn[10],vIn[11 ],vIn[12]});
endmodule"
"module deMux
(output [ 1:8] outVector,
input A, B, C, D, enable);
and v(ml2, D, C, ~B, ~A, enable),
h (m11, D, ~C, B, A, enable),
d (m10, D, ~C, B, ~A, enable),
1 (m9, D, ~C, ~B, A, enable),
s(m7,~D,C,B, A, enable),
u (m6, ~D, C, B, ~A, enable),
c (m5, ~D, C, ~B, A, enable),
ks (m3, ~D, ~C, B, A, enable);
assign outVector = {m3, m5, m6, m7, m9, ml0, m11, m12};
endmodule"
"module oneBitFullAdder
(output  cO ut, sum,
input    aIn, bIn, cIn);
assign sum = aIn ^ bIn ^ cIn,
cOut = (aIn & bIn)  (bIn & cIn) (aIn & cIn);
endmodule"
"module multi-
plexor has a continuous assignment
which calls function  mux.  The
function uses the procedural case
statement to describe the behavior
of the combinational multiplexing
function. If one of the case expres-
sions match the controlling expres-
sion, then mux  is assigned the
appropriate value.  If none of the
first four match (e.g. there is an x or z on a select input), then by default, mux  is
assigned to carry the unknown value x.
Although the assign statement provides access to an assortment of procedural
statements for behaviorally describing  combinational hardware, we must be c ognizant
of different levels of abstraction in behavioral  modeling. At a high level of abstraction
we have the  process that models sequential activity as described  in Chapters 3 and 4.
At that level, we are describing a situation which involves a separate thread of control
and the implementation will typically have its own internal state machine watching
for changes on its inputs. To model this, we would define a module with an always
statement and communicate with it through module ports and with the interprocess
wait and event statements. Clearly, this is not the modeling situation of Example 6.5
where we are only describing a combinational  multiplexor which gates one of its
inputs to its  output without the need for an internal state machine to control it.
Rather, at  this lower level of abstraction we model combinational behavior which
does not contain its own internal state. Instead of using Boolean algebra to describe a
multiplexor, Example 6.5 used procedural statements. The use of procedural state-
ments in a function called from an assign merely gives us another method of describ-
ing the combinational behavior. Modeling in this way does not imply the use of amodule multiplexor
(input a, b, c, d,
input [1:0] select,
output e);
assign e = mux (a, b, c, d, select);
function mux
(input a, b, c, d,
input [l:0]select);
case (select)
2'b00: mux = a;
2'b0l: mux = b;
2'b10: mux = c;
2'bl l: mux =  d;
default:   mux = 'bx;
endcase
endfunction
endmodule"
"module modXor
(output [7:0] AXorB,
input [7:0] a, b);
assign #5 AXorB = a ^ b;
endmodule"
"module in Example 6.7. We
have de fined a wand net with delay of 10
and two assign  statements that both drive
the net. One assign statement has delay 5
and the other has delay 3. When input a
changes, there will be a delay of fifteen
before its change is reflected at the inputs
that c connects to. When input b
changes, there will be a delay of thirteen.module wandOfAssigns
(input a, b,
output c);
wand #10 c;
assign #5 c = ~a;
assign #3 c = ~b;
endmodule"
"module bufferDriver
(inout busLine,
output bufferedVal,
input bufInput, b usEnable);
assign bufferedVal = busLine,
busLine = (busEnable) ? bufInput: 1'bz;
endmodule"
"module designed
to attach to a processor bus.
Example 6.9 illustrates a 64K
byte memory. The dataBus  port
is defined to be an inout, allow-
ing it be driven in the module’s
assign statement and also be used
as the source when writing
memory. Writing the memory is
a synchronous activity con-
trolled by the positive edge of the
clock . A new value is read from
the memory when read enable
(re) first becomes asserted (i.e.,
the negative edge), or when there
is a change on  the address lines
(addrBus).  The value read is
stored in temporary register out
which drives the dataBus  when
re is asserted. If re is unasserted,
dataBus  is tristated.
References:  nets, vectored/scalared 6.2.3module Memory_64Kx8
(inout [7:0] dataBus,
input [15:0] addrBus,
input we, re, clock);
reg [7:0] out;
reg [7:0] Mem [65535:0];
assign dataBus = (~re)? out: 16'bz;
always @(negedge re or a ddrBus)
out = Mem[addrBus];
always @(posedge clock)
if (we = =  0)
Mem[addrBus] <= dataBus;
endmodule"
"module
module busDriver
#(parameter Bsize = 16)
(inout [Bsize-1:0] busLine,
input [Bsize-1:0] valueToGo,
input driveEnable);
assign busLine = (driveEnable) ? valueToGo: 'bz;
endmodule"
"module tr iStateLatch
(output qOut,
input clock, data, enable);
tri qOut,
not #5 (ndata, data);
nand #(3,5) d(wa, data, clock),
nd(wb, ndata, clock);
nand #(12,15)  nq, wa),
q, wb);
bufifl #(3,7,13 ) qDrive (qOut, q, enable),
nq, enable);
endmodule"
"module IOBuffer
#(parameter
R_Min = 3, R_Typ = 4, R_Max = 5,
F_Min = 3, F_Typ = 5, F_Max = 7,Z_Min = 12, Z_Typ = 15, Z_Max = 17)
(inout bus,
input in,output out,
input dir);
bufif1 #(R_Min: R_Typ: R_Max,
F_Min: F_Typ: F_Max,
Z_Min: Z_Typ: Z_Max)
(bus, out,  dir);
buf #(R_Min: R_Typ: R_Max,
F_Min: F_Typ: F_Max)
(in, bus);
endmodule"
"module (i.e. from pin to pin), apart
from any gate level or other internal delays specified inside  the module.  The  specify
block allows for timing specifications to be made between a module’s inputs and out-
puts. Example 6.13 illustrates the use of a specify block.
module dEdgeFF
(input clock, d, clear, preset,
output q);
specify
// specify parameters
specparam
// module path declarations
(clock => q) =
(clear, preset *> q) =
endspecify
// description of  module's internals
endmodule"
"module with the structure:
module progBidirect (ioA, ioB, selectA, selectB, enable);
inout [3:0] ioA, ioB;
input [1:0] selectA, selectB;
input enable;
endmodule"
"module simpleTutorial
(input clock,
output reg [7:0] x, y);
reg [7:0]  i;
always begin
@(posedge clock) x <= 0;
i = 0;
while (i <= 10) begin
@(posedge clock);
x <= x + y;
i = i + 1;
end
@(posedge clock);
if(x < 0)
y <= 0;
else x  <=  0;
end
endmodule"
"module may have multi-
ple always statements in it. Each will be synthesized to a separate, although commu-
nicating, data  path-finite state machine pairs.
7.2.1 Inputs and Outputs of an Always Block
Although an always block is a behavioral
construct that does not have a formal specifi
cation of ports, we can think of them as hav-
ing ports. Consider a module with a single
always block and no  other continuous assign
or module/gate instantiations as shown in
Example 7.2. It is clear that the input and
output ports of the module correspond to
the inputs and outputs of the always block.
That is, entities  the always block needs as
inputs com e from outside the module, and
entities the al ways block produces are made
available outside the module. Of course,
there may be some internal registers with
values produced by the execution of the
always block and also used as input to it.
But, since such registers are not made avail-
able outside of the always block, they are not
considered outputs. And, since they are gen-
erated internally, their use is not considered an input.module inOutExample
(input [7:0] r, s,
input clock,
output reg [ 7:0] qout);
reg [7:0]  q;
always begin
@ (posedge clock)
q <= r + s;
@ (posedge clock)
qout <= q + qout;
end
endmodule"
"module accumulate
(output reg [11:0] qout,
input [11:0] r, s,
input clock, reset);
reg [11:0] q;
initial
forever @(negedge reset) begin
disable main;
qout  <=  0;
end
always begin: main
wait (reset);
@ (posedge clock)
q <= r + s;
@ (posedge clock)
qout <= q + qout;
end
endmodule"
"module synSwitchFilter
(input Clock, reset, switch,
input [7:0] in,
output reg [7:0] out);
reg [7:0] xl, x2, x3, y, yold, delta;
initial forever @(negedge reset) begin
disable main;
out =  0;
y = 1;
x2 = 2;
x3 = 3;
end
always begin :main
wait (reset);
@(posedge Clock)
x1 = in;
out <= y;
yold = y;
y = x1 + x2 + x3;
delta = y - yold;
delta = delta >> 1;
if (switch = = 1) begin
delta = delta >> 1;
@(posedge Clock) out <= out + delta;
@(posedge Clock) out <= out + delta;
end
@(posedge Clock) out <= out + delta;
x3 = x2;
x2 = x1;
end
endmodule"
"module firFilt
(input clock, reset,
input [7:0] x,
output reg [7:0] y);
reg [7:0] coef_array [7:0];
reg [7:0] x_array [7:0];
reg [7:0] acc;
reg [2:0] index, start_pos;
//important: these roll over from 7 to 0
initial
forever  @ (negedge reset) begin
disable firmain;
start_pos = 0;
end
always begin: firmain
wait (reset);
@ (posedge clock); // State A;
x_array[start_pos] = x;
acc = x * coef_array[start_pos];
index = start_pos + 1;
begin :loop1
forever begin
@ (posedge clock); // State B;
acc = acc + x_array[index] * coef_array[index];
index = index + 1;
if (inde x = = start_pos ) disabl e loopl ;
end
end // loopl
y <= acc;
start_pos = start_pos + 1;
end
endmodule"
"module firFiltMealy
(input clock, reset,
input [7:0] x,
output reg [7:0] y);
reg [7:0] coef_array [7:0];
reg [7:0] x_array [7:0];
reg [7:0] acc;
reg [2:0] index, start_pos;
initial
forever  @ (negedge reset) begin
disable firmain;
start_pos = 0;
index = 0;
end
always begin: firmain
wait (reset);
begin: loopl
forever begin
@ (posedge clock); // State 1 — the only state
if (index = = start_pos) begin
x_array[index] = x;
acc = x * coef_array[index];
index = index + 1;
end
else begin
acc = acc + x_array[index] * coef_array[index];
index = index + 1;
if (index == start_pos) disable loopl;
end
end
end
y <= acc;
start_pos = start_pos + 1;
index = start_pos;
end
endmodule"
"module nandLatch
(output q,  qBar,
input set, reset);
nand #2
(q, qBar, set),
(qBar, q,  reset);
endmodule"
"module DFF
(output reg q,
input d, clock);
always
@ (posedge clock)
#5 q = d;
endmodule"
"module behavioralNand
#(parameter delay = 5)
(output reg out,
input in1, in2, in3);
always
@ (in1  or in2 or in3)
#delay out = ~(in1 & in2 & in3);
endmodule"
"module twoPhiLatch
(input      phi1, phi2,
output reg q,
input d);
reg qInternal;
always begin
@ (posedge phi1)
qInternal = d;
@ (posedge phi2)
q = qInternal;
end
endmodule"
"module twoPhiLatchWithDelay
(input phi1, phi2, d,
output reg q);
reg qInternal;
always begin
@ (posedge phi1)
#2 qInternal = d;
@ (posedge phi2)
#2 q = qInternal;
end
endmodule"
"module stupidVerilogTricks
(output reg f,
input a, b);
reg q;
initial
f=0;
always
@ (posedge a)
# 10 q = b;
not (qBar, q);
always
@ q
f = qBar;
endmodule"
"module would be changed too. A solution that ma intains the
timing uses “#0” instead of the “#1” in the “f = qBar” statement. This solution will be
discussed further in section 8.4.always
begin
@ q
qBar = ~q;
f = qBar;
end
Example 8.7 One Correction to
Example 8.6
Although the above example was con-
trived, be assured that non-determinism sur-
faces in uncontrived examples. Consider the
ripple counter in Example 8.8. Here two D
flip flops are connected  together in a counter
configuration; the low order flip flop (instance
a) is connected in a toggle mode. The higher
order bit ( b) has the low order bit as its input.
We would expect the counter to increment
through the states 00, 01, 10, 11, 00, … at the
positive edge of the clock. However, on  closer
inspection we see that the “q = d” statement
of both instances of the dff is scheduled to
continue executing three time units into the
future. At that time, the scheduler will take
both of these evaluation events off of the
event list and execute them in arbitrary order.
Of course, the order does matter. Executing
instance a first will lead to an incorrect count-
ing sequence (00, 11, 00, ...). Executing
instance b first will produce intended order.module goesBothWays
(output [2:1]
input clock);
wire q1, q2;
assign
dff a (ql, ~ql, clock),
b (q2, ql, clock);
endmodule"
"module dff
(output reg q,
input d, clock);
always
@(posedge clock)
#3 q = d;
endmodule"
"module suspend;
reg a;
wire b = a;
initial begin
a=l;
(""a = %b,b = %b"",a,b);
end
endmodule"
"module fsm
(output  reg    cS1, cS0,
input in, clock);
always @(posedge  clock) begin
cS1<= in & cS0;
cS0 <= in | cS1;
end
endmodule"
"module inertialNand
#(parameter pDelay = 5)
(output reg f,
input a, b);
always
@(a,b)
f <= #pDelay~(a & b);
endmodule"
"module pipeMult
(output reg [19:0] product,
input [9:0] mPlier, mCand,
input go, clock);
always
@(posedge go)
product <= repeat (4) @(posedge clock) mPlier * mCand;
endmodule"
"module sMux
(output f,
input a, b, select);
nand #8
(f, aSelect,  bSelect),
(aSelect, sel ect, a),
(bSelect, notSelect, b);
not
(notSelect, select);
endmodule"
"module bMux
(output reg f,
input a, b, select);
always
@select
#8 f = (select) ?a:b;
endmodule"
"module nbSchedule  for 25 time units.
Each line of the table represents a simulation cycle. You do not need to turn in
the event lists and how they change over tim. However, keeping the lists would
probably help you keep track of what you should put in the table.
8.3 Start executing the following description at time = 0 and stop at time = 40.
module beenThere;
reg [15:0] q;
wire h;
wire [15:0] addit;
doneThat dT (q, h, addit);
initial q = 20;
always begin
@ (posedge h);
if (addit = = 1)
q = q +  5;
else q = q - 3;
end
endmodule"
"module doneThat
(input [15:0] que,
output reg f,
output reg [15:0] add);
always
#10 f = ~  f;
initial begin
f=0;
add =  0;
#14 add = que  + 1;
#14 add =  0;
end
endmodule"
"module nbSchedule
(output q2);
wire q1;
reg c, a;
xor (d,  a, q1),
(clk, 1'b1,  c);
// holy doodoo, Batman, a gated clock!
dff s1(q1, d, clk),
s2 (q2, q1, clk);
initial begin
c=1;
a = 0;
#8 a = 1;
end
always
#20 c = ~c;
endmodule"
"module dff
(output reg q,
input d, c);
initial q = 0;
always
@(posedge c) q <= d;
endmodule"
"module interleave;
reg [7:0]  a;
huh h  ();
endmodule"
"module huh;
reg [7:0] b, c, q, r;
always begin
a = b +  c;
q = a +  r;
end
endmodule"
"module ouch (select, muxOut, a, b);
(input select,
output reg muxOut,
input a, b);
always begin
@select
muxOut = (a & sel ect) | (b  & notSelect);
not
(notSelect, select);
endmodule"
"module swapIt
(input doIt);
reg [15:0] george, georgette;
always
@(posedge doIt)
//do it
endmodule"
"module shreg
/* IO port declarations, where 'out' is the inverse
of 'in' controlled by the dual-phased clock */
(output tri out,//shift register output
input in, //shift register input
phase1,//clocks
phase2);
tri     wb1, wb2; //tri nets pulled up to VDD
pullup (wb1), (wb2), (out);//depletion mode pullup devices
trireg (medium) wa1, wa2, wa3; //charge storage nodes
supply0 gnd; //ground supply
nmos #3 //pass devices and their interconnections
a1(wa1, in, phase1), b1(wb1, gnd, wa1),
a2(wa2, wb1, phase2), b2(wb2, gnd, wa2),
a3(wa3, wb2, phase1), gout(out,  gnd, wa3);
endmodule"
"module waveShReg;
wire shiftout; //net to receive circuit output value
reg shiftin; //register to drive value into circuit
reg phase1, phase2; //clock driving values
parameter d = 100; //define the waveform time step
shreg cct (shiftout, shiftin, phase1, phase2);
initial
begin :main
shiftin = 0; //initialize waveform input stimulus
phase1 = 0;
phase2 = 0;
setmon; // setup the monitoring information
repeat(2) //shift data in
clockcct;
end
task setmon; //display header and setup monitoring
begin
time clks in out wa1-3 wb1-2"");
phase1, phase2,,,,,,shiftin,,,, shiftout,,,,,
cct.wa1, cct.wa2, cct.wa3,,,,,cct.wb1, cct.wb2);
end
endtask
task clockcct; //produce dual-phased clock pulse
begin
#d phase1 = 1; //time step defined by parameter d
#d phase1 = 0;
#d phase2 = 1;
#d phase2 = 0;
end
endtask
endmodule"
"module sram
(output dataOut,
input address, dataIn, write);
tri       w1, w3, w4,  w43;
bufif1            g1(w1, dataIn, write);
tranif1 g2(w4, w1, address);
not (pull0, pull1) g3(w3, w4), g4(w4, w3);
buf g5(dataOut, wl);
endmodule"
"module wave_sram; //waveform for testing the static RAM cell
#(parameter d = 100);
wire dataOut;
reg address, dataIn, write;
sram cell (dataOut, address, dataIn, write);
initial begin
#d dis;
#d address = 1;    #d dis;
#d dataIn = 1;     #d dis;
#d write = 1; #d dis;
#d write = 0; #d dis;
#d write = 'bx; #d dis;
#d address = 'bx; #d dis;
#d address = 1;    #d dis;
#d write = 0; #d dis;
end
task dis; //display the circuit state
""addr=%v d_In=%v write=%v d_out=%v"",
address, dataIn, write, dataOut,
"" (134)=%b%b%b"", cell.wl, cell.w3, ce ll.w4,
"" w134=%v %v %v"", cell.w1, cell.w3, cell.w4);
endtask
endmodule"
"module specification
for this logic circuit. The module  will not
have inputs or outputs. Use primitives gates
(AND,OR, and NOT), connect them with
wires, and include an initial statement to fully
test your circuit. To produce from B, add a NOT gate (inverter) to the above dia-
gram. Specify that  NOT gates have a delay of 1 time unit and the others have delays of
2 time units. Oh, and try not to look at the answer below! If you’re not sure what to
do, read on.
Discussion:  The first thing to write is the module header and name — give it any
name you wish. Next, break the description down into the  individual gates, assigning
distinct names to the wires connecting the gates. Now write the  gate instantiations
and specify the ports for interconnecting them. A gate is instantiated as shown here:
and #5 myFirstAnd (q, r, s);
Here an AND gate with delay five, instance name myFirstAnd, and ports q,r, and s is
defined. W hich connection is first in the list? The output; q it the output and the oth-
ers are inputs. Finish instantiating the gates.
In answering the question, yo u might have written the following module descrip-
tion. Clearly, you probably used a different name for the module (it’stop here) and
also for the gate instance names (e.g., g1). The delay  specification, which is optional
when specifying gate instantiations, is required in the  description because  the problem
statement asked for it. There are other  ways to start  writing this problem.
module top;
not #1 g1(d,b);
and #2 g2  (e, d, a);
or #2 g3(f,c,d);
endmodule"
"module top;
reg        a, b, c;
not #1 g1 (d,b);
and #2 g2  (e, d, a);
or # 2 g3 (f,c,d);
endmodule"
"module top;
wire d, e, f;
rega,     b, c;
not #1 g1(d,b);
and #2g2(e,  a, d);
or #2 g3(f,e,c);//
initial begin
                                ""a=%b, b=%b, c=%b, d=%b, e=%b, f=%b\n"",
a,b,c,d,e,f);
a = 1; // initialization
b = 0;
c= 0;
b = 1; // first change of input
a = 0; // second change of input
c = 1; // third change of input
#20 // this tells the simulator to stop
end
endmodule"
"module top;
wire d, e, f;
reg a, b, c;
not      #1 gl(d,b);
and #2  g2(e,  a, d);
or #2  g3(f,e, c); //
initial begin
                                ""a=%b,  b=%b, c=%b, d=%b, e=%b,  f=%b\n"",
a, b, c, d, e,  f);
a = 1; // initialization
b = 0;
c = 0;
#20 b = 1; // first change of input
#20 a = 0; //second change of  input
#20 c = 1; // third change of  input
#20
end
endmodule"
"module to test this halfadder module
and instantiate them both in a test-
bench module.module halfadder
(output cOut, sum;
input a, b);
xor       #1 (sum, a, b);
and #2 (cOut, a, b);
endmodule"
"module, and lists the inputs and outputs. The
next two lines define which are inputs and which are outputs. Essentially it defines
two outputs and two inputs, each to be single bit qua ntities.
Then we instantiate an XOR  gate, with a and b as inputs, and sum as the output.
TheXOR  gate is specified to have a delay of one time unit. That is, one time unit after
an input changes, the output might change. The and gate is similar, but with a delay
of two time units. Finally, we have the endmodule"
"module description.
Do This —  Create the testadder  module. The idea is that we’re going to connect
this module to the halfadder  module and have this module test it. Both modules will
be instantiated within another module called system .
Discussion: A testadder  module is shown below. The initial statement introduces a
behavioral block; these blocks can be read much like you would read C (yes, there are
many differences). The initial statement  indicates that the block should only be exe-
cuted once.
When the initial statement starts, it executes the statement (as  described
in the previous  question), and assigns x and y to be 0. “#10” tells the simulator to  wait
for 10 time units and then continue execution. In 10 more tim e units, x is set to 1.
After another 10, y is set to 1. Finally, after another 10, x is set to 0. Essentially, over
the course of execution, x and y will have all four combinations of inputs for the half
adder, and there is enough time for these values to propagate through the gates in the
adder module.
causes the simulator  to exit after another 10 time units.
module testadder
(output reg x,y,
input c, s);
initial begin
""x = %b, y = %b, Sum = %b, Carry = %b"", x, y, s, c);
#10
#10
#10
#10x = 0;
y = 0;
x = l;
y = l;
x = 0;
end
endmodule"
"modules together as shown in module system.
The wire  declaration defines fourwires with the given names.
module system;
wire CarryOut, SumOut, in1, in2;
halfadder AddUnit (CarryOut, SumOut, in1, in2);
testadder TestUnit (in1, in2, CarryOut, SumOut);
endmodule"
"module binaryToESegSim;
wire eSeg, p1, p2, p3, p4;
reg A, B, C, D;
nand #1
g1 (pl, C,~D),
g2(p2, A, B),
g3(p3, ~B, ~D),
g4(p4, A, C),
g5 (eSeg, p1, p2, p3, p4);
initial // two slashes introduce a single line comment
begin
""A = %b B = %b C = %b D = %b, eSeg = %b"",
A, B, C, D, eSeg);
//waveform for simulating the binaryToESeg driver
#10 A =  0; B = 0; C = 0; D = 0;
#10 D =  1;
#10 C =  1; D = 0;
#10
end
endmodule"
"module binaryToESeg_Behavioral into the testBench  module of
Example 1.4. Compare the simulation results with those of the original exam-
ple. What is different?
At this point, we have only covered the basic issues in  describing  combinational
circuits using the al ways block. For a more detailed  discussion, refer back to
Chapter 2.
Do this  — write a module using
behavioral modeling techniques to
describe the circuit in Figure A.2.
Compile the module for simulation
and synthesis. Is it functionally cor-
rect? If your circuit will not synthesize, read on to see if you hit upon any of these
common mistakes!
Lack of Assignment   — You might run into
this particular problem if you assume that register
values start at or default to 0. This is how our
code would look if this assumption of f=0 by
default wa s made.
The simulator will initially assign f to have the
value x. It will keep that value until it is assigned
to 1, and will never assign it to zero. Obviously,
we simply put in an else that will assign f to be 0. When describing modules for syn-
thesis, it’s a good general rule that for every if there should be an else to tell the logic
what  to do  should  that statement  not be TRUE. Like this:module andOr
(output reg f,
input a, b, c);
always @(a, b, c)
if (c + (a&~b))
f=l;
endmodule"
"module a ndOr
(output reg f,
input a, b, c);
always @(a, b, c)
if (c + (a&~b))
f = l;
else f = 0;
endmodule"
"module andOr
(output reg f,
input a, b, c);
always @(a,c) //OOPS! Forgot b! This should be (a, b, c)
if (c)
f = 1;
else
f = a &~b;
endmodule"
"module should use only a single always block. Then
insert into a  testBench  module and simulate to show correct function.
A case statement is  often used in synthesizable Verilog d escriptions.
Example A.2 is a Verilog description for a BCD to seven segment display mod-
ule using a case statement. Read ahead  in section 3.4.2 to see how the case state-
module BCDtoSevenSeg
(output reg [7:0] led,
input [3:0] bcd);
always @(bcd)
case (bcd)
0 : led =  'h81;
1 :led =  'hcf;
2 : led =  'h92;
3 : led = 'h86;
4 : led =  'hcc;
5 :led =  'ha4;
6 :led =  'ha0;
7 : led =  'h8f;
8 : led =  'h80;
9 : led =  'h8c;
default:led = 'bxxxxxxxx;
endcase
endmodule"
"module counter_2_bit //Answer to problem A. 14
(input up, clk, rst,// Declarations
output reg [1:0] c ount);
reg [1:0] nextCount;
always @(up, count)
case (count)
0: begin
if (up) nextCount = 1;
else nextCount = 3;
end
1: begin
if (up) nextCount = 2;
else nextCount = 0;
end
2: begin
if (up) nextCount = 3;
else nextCount = 1;
end
3: begin
if (up) nextCount = 0;
else nextCount = 2;
end
default:
nextCount = 0;
endcase
always @(posedge clk, negedge rst)
if(~rst)
count <= 0;
else
count <=  nextCount;
endmodule"
"module definition.
To this point, we have, by example, demonstrated that a module definition uses
certain keywords (“module”, “endmodule"
"module dEdgeFF
(output q,
input clock, data);
reg reset;
wire q, qBar, r,  s, r1, si;
initial begin
reset = 1;
#20 reset = 0;
end
nor #10
a (q, qBar, r, reset);
nor
b (qBar, q, s),
c (s, r, clock, s1),
d (s1, s, data),
e (r, r1, clock),
f(r1,s1,r);
endmodule"
"module_declaration
module_keyword module_identifier [ module_parameter_port_list]
[list_of_ports];
{ module_item }
endmodule"
"module_keyword module_identifier [ module_parameter_port_list]
[list_of_ports_declarations];
{ non_port_module_item }
endmodule"
"module_keyword
module
| macromodule
In plain words, the  module construct (“ module_declaration”) is de fined by a
“module_keyword,” followed by the “module_identifier.” The name is optionally fol-
lowed by a list of parameters (the “[ ]” indicates an optional item), an optional list of
poerts, and then by a “;”. Next come zero or more module items (the “{ }” indicates
zero or more) followed by the “endmodule"
"module_identifier{.instance_identifier}
cell_clause ::=  cell [ library_identifier.]cell_identifier
liblist_clause ::=  liblist  [{library_identifier}]
use_clause ::= use [library_identifier.]cell_identifier[ :config ]
G.2.3  Module and primitive source text
source_text ::= { description }
description ::=
module_declaration
| udp_declaration
module_declaration ::=
{ attribute_instance } module_keyword module_identifier [
module_parameter_port_list ]
[ list_of_ports ] ; { module_item }
endmodule"
"module_keyword module_identifier [
module_parameter_port_list ]
[ list_of_port_declarations ] ; { non_port_module_item }
endmodule"
"module example1 (x1, x2, s, f);
input x1, x2, s;
output f;
not(k, s);
and(g, k, x1);
and(h, s, x2);
or(f, g, h);
endmodule"
module ends with the endmodule
"module example2 (x1, x2, x3, x4, f, g, h);
input x1, x2, x3, x4;
output f, g, h;
and(z1, x1, x3);
and(z2, x2, x4);
or(g, z1, z2);
or(z3, x1, x3);
or(z4, x2, x4);
and(h, z3, z4);
or(f, g, h);
endmodule"
"module example3 (x1, x2, s, f);
input x1, x2, s;
output f;
assign f=( s&x 1 ) |(s & x2);
endmodule"
"module example4 (x1, x2, x3, x4, f, g, h);
input x1, x2, x3, x4;
output f, g, h;
assign g = (x1 & x3) |(x2 & x4);
assign h = (x1 |x 3 )&( x2|x4);
assign f=g| h;
endmodule"
"module example5 (x1, x2, s, f);
input x1, x2, s;
output f;
regf;
always @(x1 or x2 or s)
if(s == 0)
f = x1;
else
f = x2;
endmodule"
"module’s list of ports. This style of code isillustrated in Figure 2.43. In the sensitivity list of the always statement we can use commas
instead of the word or, which is also illustrated in Figure 2.43. Moreover, instead of listing
the relevant signals in the sensitivity list, it is possible to write simply
always @(∗)
or even more simply
always @∗
assuming that the compiler will ﬁgure out which signals need to be considered.
Behavioral speciﬁcation of a logic circuit deﬁnes only its behavior. CAD synthesis
tools use this speciﬁcation to construct the actual circuit. The detailed structure of thesynthesized circuit will depend on the technology used.
// Behavioral speciﬁcation
module example5 ( input x1, x2, s, output reg f);
always @(x1, x2, s)
if(s == 0)
f = x1;
else
f = x2;
endmodule"
"module. For larger designs,
it is often convenient to create a hierarchical structure in the Verilog code, in which there
is atop-level module that includes multiple instances of lower-level modules. To see how
hierarchical Verilog code can be written consider the circuit in Figure 2.44. This circuitcomprises two lower-level modules: the adder module that we described in Figure 2.12, andthe module that drives a 7-segment display which we showed in Figure 2.34. The purposeof the circuit is to generate the arithmetic sum of the two inputs xandy, using the adder
module, and then to show the resulting decimal value on the 7-segment display.
Verilog code for the adder module from Figure 2.12 and the display module from
Figure 2.34 is given in Figures 2.45 and 2.46, respectively. For the adder module con-
tinuous assignment statements are used to specify the two-bit sum s
1s0. The assignment
statement for s0uses the Verilog XOR operator, which is speciﬁed as s0=a∧b. The code
for the display module includes continuous assignment statements that correspond to the
s0a
s1b
c
d
e
f
gAdder module Display module
a
bTop-level module
x
ys0
s1w0
w1a
b
c
d
e
f
g
Figure 2.44 A logic circuit with two modules.
// An adder module
module adder (a, b, s1, s0);
input a, b;
output s1, s0;
assign s 1=a&b ;
assign s 0=a b ;
endmodule"
"module for driving a 7-segment display
module display (s1, s0, a, b, c, d, e, f, g);
input s1, s0;
output a, b, c, d, e, f, g;
assign a = s0;
assign b=1 ;
assign c = s1;
assign d = s0;
assign e = s0;
assign f = s1 & s0;
assign g=s 1& s 0 ;
endmodule"
"module adder_display (x, y, a, b, c, d, e, f, g);
input x, y;
output a, b, c, d, e, f, g;
wire w1, w0;
adder U1 (x, y, w1, w0);display U2 (w1, w0, a, b, c, d, e, f, g);
endmodule"
"module f_g (x, y, z, f, g);
input x, y, z;
output f, g;
wire k;
assign k=y z ;
assign g=k x ;
assign f=( k&z ) |(k & x);
endmodule"
"module
a
bs0
s1w1
w2Top-level module
0
10
1
Figure 2.72 The circuit for Example 2.30.
module shared (a, b, c, d, m, s1, s0);
input a, b, c, d, m;
output s1, s0;
wire w1, w2;
mux2to1 U1 (a, c, m, w1);
mux2to1 U2 (b, d, m, w2);adder U3 (w1, w2, s1, s0);
endmodule"
"module mux2to1 (x1, x2, s, f);
input x1, x2, s;
output f;
assign f=( s&x 1 )
|(s & x2);
endmodule"
"module fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output s, Cout;
xor(s, x, y, Cin);
and(z1, x, y);
and(z2, x, Cin);
and(z3, y, Cin);
or(Cout, z1, z2, z3);
endmodule"
"module fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output s, Cout;
xor(s, x, y, Cin);
and (z1, x, y),
(z2, x, Cin),(z3, y, Cin);
or(Cout, z1, z2, z3);
endmodule"
"module fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output s, Cout;
assign s = x y Cin;
assign Cout = (x & y) |(x & Cin) |(y & Cin);
endmodule"
"module fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output s, Cout;
assign s=x yCin,
Cout = (x & y) |(x & Cin) |(y & Cin);
endmodule"
"module adder4 (carryin, x3, x2, x1, x0, y3, y2, y1, y0, s3, s2, s1, s0, carryout);
input carryin, x3, x2, x1, x0, y3, y2, y1, y0;
output s3, s2, s1, s0, carryout;
fulladd stage0 (carryin, x0, y0, s0, c1);
fulladd stage1 (c1, x1, y1, s1, c2);fulladd stage2 (c2, x2, y2, s2, c3);fulladd stage3 (c3, x3, y3, s3, carryout);
endmodule"
"module fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output s, Cout;
assign s = x y Cin;
assign Cout = (x & y) |(x & Cin) |(y & Cin);
endmodule"
"module adder4 (carryin, X, Y , S, carryout);
input carryin;
input [3:0] X, Y;
output [3:0] S;
output carryout;
wire [3:1] C;
fulladd stage0 (carryin, X[0], Y[0], S[0], C[1]);fulladd stage1 (C[1], X[1], Y[1], S[1], C[2]);fulladd stage2 (C[2], X[2], Y[2], S[2], C[3]);fulladd stage3 (C[3], X[3], Y[3], S[3], carryout);
endmodule"
"module addern (carryin, X, Y , S, carryout);
parameter n = 32;
input carryin;
input [n– 1:0] X, Y;
output reg [n –1:0] S;
output reg carryout;
reg[n:0] C;
integer k;
always @(X, Y , carryin)
begin
C[0] = carryin;
for(k = 0; k < n; k = k+1)
begin
S[k] = X[k] Y[k] C[k];C[k+1] = (X[k] & Y[k]) (X[k] & C[k]) (Y[k] & C[k]);
endcarryout = C[n];
end
endmodule"
"module addern (carryin, X, Y , S, carryout);
parameter n = 32;
input carryin;
input [n –1:0] X, Y;
output [n –1:0] S;
output carryout;
wire [n:0] C;
genvar i;
assign C[0] = carryin;
assign carryout = C[n];
generate
for(i = 0; i < = n –1; i = i+1)
begin:addbit
fulladd stage (C[i], X[i], Y[i], S[i], C[i+1]);
end
endgenerate
endmodule"
"module fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output s, Cout;
assign s=x yCin;
assign C o u t=( x&y ) (x & Cin) (y & Cin);
endmodule"
"module addern (carryin, X, Y , S);
parameter n = 32;
input carryin;
input [n –1:0] X, Y;
output reg [n –1:0] S;
always @(X, Y , carryin)
S = X + Y + carryin;
endmodule"
"module addern (carryin, X, Y , S, carryout, overﬂow);
parameter n = 32;
input carryin;
input [n– 1:0] X, Y;
output reg [n– 1:0] S;
output reg carryout, overﬂow;
always @(X, Y , carryin)
begin
S = X + Y + carryin;
carryout = (X[n– 1] & Y[n– 1]) |(X[n– 1] & S[n– 1]) |(Y[n– 1] & S[n– 1]);
overﬂow = (X[n– 1] & Y[n– 1] & S[n– 1]) |( X[n– 1] & Y[n– 1] & S[n– 1]);
end
endmodule"
"module addern (carryin, X, Y , S, carryout, overﬂow);
parameter n = 32;
input carryin;
input [n– 1:0] X, Y;
output reg [n– 1:0] S;
output reg carryout, overﬂow;
reg[n:0] Sum;
always @(X, Y , carryin)
begin
Sum = {1’b0, X} + {1’b0, Y} + carryin;
S = Sum[n– 1:0];carryout = Sum[n];overﬂow = (X[n– 1] & Y[n– 1] & S[n– 1])
|( X[n– 1] & Y[n– 1] & S[n– 1]);
end
endmodule"
"module addern (carryin, X, Y , S, carryout, overﬂow);
parameter n = 32;
input carryin;
input [n– 1:0] X, Y;
output reg [n– 1:0] S;
output reg carryout, overﬂow;
always @(X, Y , carryin)
begin
{carryout, S} = X + Y + carryin;
overﬂow = (X[n– 1] & Y[n– 1] & S[n– 1]) |( X[n– 1] & Y[n– 1] & S[n– 1]);
end
endmodule"
"module fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output reg s, Cout;
always @(x, y, Cin)
{Cout, s}=x+y+Cin;
endmodule"
"module adder_hier (A, B, C, D, S, T, overﬂow);
input [15:0] A, B;
input [7:0] C, D;
output [16:0] S;
output [8:0] T;
output overﬂow;
wire o1, o2; // used for the overﬂow signals
addern U1 (1’b0, A, B, S[15:0], S[16], o1);
defparam U1.n = 16;
addern U2 (1’b0, C, D, T[7:0], T[8], o2);defparam U2.n = 8;
assign overﬂow = o1
|o2;
endmodule"
"module adder_hier (A, B, C, D, S, T, overﬂow);
input [15:0] A, B;
input [7:0] C, D;
output [16:0] S;
output [8:0] T;
output overﬂow;
wire o1, o2; // used for the overﬂow signals
addern #(16) U1 (1’b0, A, B, S[15:0], S[16], o1);
addern #(8) U2 (1’b0, C, D, T[7:0], T[8], o2);
assign overﬂow = o1 |o2;
endmodule"
"module adder_hier (A, B, C, D, S, T, overﬂow);
input [15:0] A, B;
input [7:0] C, D;
output [16:0] S;
output [8:0] T;
output overﬂow;
wire o1, o2; // used for the overﬂow signals
addern #(.n(16)) U1
(
.carryin (1’b0),
.X (A),.Y (B),.S (S[15:0]),.carryout (S[16]),.overﬂow (o1)
);addern #(.n(8)) U2
(
.carryin (1’b0),.X (C),.Y (D),.S (T[7:0]),.carryout (T[8]),.overﬂow (o2)
);
assign overﬂow = o1
|o2;
endmodule"
"module bcdadd (Cin, X, Y , S, Cout);
input Cin;
input [3:0] X, Y;
output reg [3:0] S;
output reg Cout;
reg[4:0] Z;
always @(X, Y , Cin)
begin
Z = X + Y + Cin;
if(Z < 10)
{Cout, S} = Z;
else
{Cout, S}=Z+6 ;
end
endmodule"
"module comparator (X, Y , V , N, Z);
input [3:0] X, Y;
output V , N, Z;
wire [3:0] S;
wire [4:1] C;
fulladd stage0 (1’b1, X[0], Y[0], S[0], C[1]);
fulladd stage1 (C[1], X[1], Y[1], S[1], C[2]);fulladd stage2 (C[2], X[2], Y[2], S[2], C[3]);fulladd stage3 (C[3], X[3], Y[3], S[3], C[4]);assign V = C[4]
C[3];
assign N = S[3];
assign Z = !S;
endmodule"
"module fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output s, Cout;
assign s=x yCin;
assign C o u t=( x&y ) (x & Cin) (y & Cin);
endmodule"
"module comparator (X, Y , V , N, Z);
parameter n = 32;
input [n –1:0] X, Y;
output reg V , N, Z;
reg[n –1:0] S;
reg[n:0] C;
integer k;
always @(X, Y)
begin
C[0] = 1’b1;
for(k = 0; k < n; k = k+1)
begin
S[k] = X[k] Y[k] C[k];
C[k+1] = (X[k] & Y[k]) (X[k] & C[k]) ( Y[k] & C[k]);
end
V = C[n] C[n–1];
N = S[n –1];Z = !S;
end
endmodule"
"module problem3_17 (IN, OUT);
input [3:0] IN;
output reg [3:0] OUT;
always @(IN)
if(IN == 4’b0101) OUT = 4’b0001;
else if (IN == 4’b0110) OUT = 4’b0010;
else if (IN == 4’b0111) OUT = 4’b0011;
else if (IN == 4’b1001) OUT = 4’b0010;
else if (IN == 4’b1010) OUT = 4’b0100;
else if (IN == 4’b1011) OUT = 4’b0110;
else if (IN == 4’b1101) OUT = 4’b0011;
else if (IN == 4’b1110) OUT = 4’b0110;
else if (IN == 4’b1111) OUT = 4’b1001;
else OUT = 4’b0000;
endmodule"
"module, named mux2to1, has the inputs w0,w1, and s, and
the output f. The signal sis used for the selection criterion. The output fis equal to w1if
the select input shas the value 1; otherwise, fis equal to w0. Figure 4.24 shows how the
same multiplexer can be deﬁned by using the conditional operator inside an always block.
The same approach can be used to deﬁne the 4-to-1 multiplexer from Figure 4.2. As
seen in the truth table in Figure 4.2b, if the select input s1=1, then fis set to either w2or
w3based on the value of s0. Similarly, if s1=0, then fis set to either w0orw1. Figure 4.25
shows how nested conditional operators can be used to deﬁne this function. The moduleis called mux4to1. Its select inputs are represented by the two-bit vector S. The ﬁrst
conditional expression tests the value of bit s
1.I fs1=1, then s0is tested and fis set to w3
ifs0=1 and fis set to w2ifs0=0. This corresponds to the third and fourth rows of the
truth table in Figure 4.2b. Similarly, if s1=0 the conditional operator on the right chooses
f=w1ifs0=1 and f=w0ifs0=0, thus realizing the ﬁrst two rows of the truth table.
module mux2to1 (w0, w1, s, f);
input w0, w1, s;
output f;
assign f = s ? w1 : w0;
endmodule"
"module mux2to1 (w0, w1, s, f);
input w0, w1, s;
output reg f;
always @(w0, w1, s)
f=s?w 1:w 0 ;
endmodule"
"module mux4to1 (w0, w1, w2, w3, S, f);
input w0, w1, w2, w3;
input [1:0] S;
output f;
assign f = S[1] ? (S[0] ? w3 : w2) : (S[0] ? w1 : w0);
endmodule"
"module mux2to1 (w0, w1, s, f);
input w0, w1, s;
output reg f;
always @(w0, w1, s)
if(s == 0)
f = w0;
else
f = w1;
endmodule"
"module mux4to1 (w0, w1, w2, w3, S, f);
input w0, w1, w2, w3;
input [1:0] S;
output reg f;
always @(*)
if(S == 2’b00)
f = w0;
else if (S == 2’b01)
f = w1;
else if (S == 2’b10)
f = w2;
else
f = w3;
endmodule"
"module mux4to1 (W, S, f);
input [0:3] W;
input [1:0] S;
output reg f;
always @(W, S)
if(S == 0)
f = W[0];
else if (S == 1)
f = W[1];
else if (S == 2)
f = W[2];
else
f = W[3];
endmodule"
"module mux16to1 (W, S, f);
input [0:15] W;
input [3:0] S;
output f;
wire [0:3] M;
mux4to1 Mux1 (W[0:3], S[1:0], M[0]);
mux4to1 Mux2 (W[4:7], S[1:0], M[1]);mux4to1 Mux3 (W[8:11], S[1:0], M[2]);mux4to1 Mux4 (W[12:15], S[1:0], M[3]);mux4to1 Mux5 (M[0:3], S[3:2], f);
endmodule"
"module mux4to1 (W, S, f);
input [0:3] W;
input [1:0] S;
output reg f;
always @(W, S)
case (S)
0: f = W[0];
1: f = W[1];2: f = W[2];3: f = W[3];
endcase
endmodule"
"module dec2to4 (W, En, Y);
input [1:0] W;
input En;
output reg [0:3] Y;
always @(W, En)
case ({En, W})
3’b100: Y = 4’b1000;
3’b101: Y = 4’b0100;3’b110: Y = 4’b0010;3’b111: Y = 4’b0001;default : Y = 4’b0000;
endcase
endmodule"
"module dec2to4 (W, En, Y);
input [1:0] W;
input En;
output reg [0:3] Y;
always @(W, En)
begin
if(En == 0)
Y = 4’b0000;
else
case (W)
0: Y = 4’b1000;1: Y = 4’b0100;2: Y = 4’b0010;3: Y = 4’b0001;
endcase
end
endmodule"
"module dec4to16 (W, En, Y);
input [3:0] W;
input En;
output [0:15] Y;
wire [0:3] M;
dec2to4 Dec1 (W[3:2], M[0:3], En);
dec2to4 Dec2 (W[1:0], Y[0:3], M[0]);dec2to4 Dec3 (W[1:0], Y[4:7], M[1]);dec2to4 Dec4 (W[1:0], Y[8:11], M[2]);dec2to4 Dec5 (W[1:0], Y[12:15], M[3]);
endmodule"
"module seg7 (hex, leds);
input [3:0] hex;
output reg [1:7] leds;
always @(hex)
case (hex) //abcdefg
0: leds = 7’b1111110;
1: leds = 7’b0110000;2: leds = 7’b1101101;3: leds = 7’b1111001;4: leds = 7’b0110011;5: leds = 7’b1011011;6: leds = 7’b10 11111;
7: leds = 7’b1110000;8: leds = 7’b1111111;9: leds = 7’b1111011;
10: leds = 7’b1110111;11: leds = 7’b00 11111;
12: leds = 7’b1001110;13: leds = 7’b0111101;14: leds = 7’b100 1111;
15: leds = 7’b1000111;
endcase
endmodule"
"module alu (S, A, B, F);
input [2:0] S;
input [3:0] A, B;
output reg [3:0] F;
always @(S, A, B)
case (S)
0: F = 4’b0000;1 :F=B– A ;2: F = A – B;3: F = A + B;4: F = A ^B;
5: F = A
|B;
6: F = A & B;7: F = 4’b1111;
endcase
endmodule"
"module priority (W, Y , z);
input [3:0] W;
output reg [1:0] Y;
output reg z;
always @(W)
begin
z=1 ;
casex (W)
4’b1xxx: Y = 3;4’b01xx: Y = 2;4’b001x: Y = 1;4’b0001: Y = 0;default :begin
z=0 ;
Y = 2’bx;
end
endcase
end
endmodule"
"module dec2to4 (W, En, Y);
input [1:0] W;
input En;
output reg [0:3] Y;
integer k;
always @(W, En)
for(k = 0; k < = 3; k = k+1)
if((W == k) && (En == 1))
Y[k] = 1;
else
Y[k] = 0;
endmodule"
"module priority (W, Y , z);
input [3:0] W;
output reg [1:0] Y;
output reg z;
integer k;
always @(W)
begin
Y = 2’bx;
z=0 ;
for(k = 0; k < 4; k = k+1)
if(W[k])
begin
Y=k ;
z=1 ;
end
end
endmodule"
"module compare (A, B, AeqB, AgtB, AltB);
input [3:0] A, B;
output reg AeqB, AgtB, AltB;
always @(A, B)
begin
AeqB = 0;
AgtB = 0;AltB = 0;
if(A == B)
AeqB = 1;
else if (A > B)
AgtB = 1;
else
AltB = 1;
end
endmodule"
"module addern (carryin, X, Y , S, carryout);
parameter n = 32;
input carryin;
input [n –1:0] X, Y;
output [n –1:0] S;
output carryout;
wire [n:0] C;
genvar k;
assign C[0] = carryin;
assign carryout = C[n];
generate
for(k = 0; k < n; k = k+1)
begin: fulladd_stage
wire z1, z2, z3; //wires within full-adder
xor(S[k], X[k], Y[k], C[k]);
and(z1, X[k], Y[k]);
and(z2, X[k], C[k]);
and(z3, Y[k], C[k]);
or(C[k+1], z1, z2, z3);
end
endgenerate
endmodule"
"module that contains the task,
which are used to make external connections to the module. The task ports are used onlyto pass values between the module and the task.
Example 4.22 In Figure 4.29 we showed the Verilog code for a 16-to-1 multiplexer that instantiates ﬁve
copies of a 4-to-1 multiplexer circuit given in a separate module named mux4to1. The same
circuit can be speciﬁed using the task approach as shown in Figure 4.42. Observe the keydifferences. The task mux4to1 is included in the module mux16to1. It is called from an
always block by means of an appropriate case statement. The output of a task must be a
variable, hence gis of regtype.
module mux16to1 (W, S16, f);
input [0:15] W;
input [3:0] S16;
output reg f;
always @(W, S16)
case (S16[3:2])
0: mux4to1 (W[0:3], S16[1:0], f);1: mux4to1 (W[4:7], S16[1:0], f);2: mux4to1 (W[8:11], S16[1:0], f);3: mux4to1 (W[12:15], S16[1:0], f);
endcase
// Task that speciﬁes a 4-to-1 multiplexertask mux4to1;
input [0:3] X;
input [1:0] S4;
output reg g;
case (S4)
0: g = X[0];1: g = X[1];2: g = X[2];3: g = X[3];
endcase
endtask
endmodule"
"module mux16to1 (W, S16, f);
input [0:15] W;
input [3:0] S16;
output reg f;
// Function that speciﬁes a 4-to-1 multiplexerfunction mux4to1;
input [0:3] X;
input [1:0] S4;
case (S4)
0: mux4to1 = X[0];1: mux4to1 = X[1];2: mux4to1 = X[2];3: mux4to1 = X[3];
endcase
endfunction
always @(W, S16)
case (S16[3:2])
0: f = mux4to1 (W[0:3], S16[1:0]);
1: f = mux4to1 (W[4:7], S16[1:0]);2: f = mux4to1 (W[8:11], S16[1:0]);3: f = mux4to1 (W[12:15], S16[1:0]);
endcase
endmodule"
"module mux4to1 (W, S, f);
input [0:3] W;
input [1:0] S;
output f;
wire [0:3] Y;
dec2to4 decoder (S, 1, Y);
assign f=|(W & Y);
endmodule"
"module dec2to4 (W, En, Y);
input [1:0] W;
input En;
output reg [0:3] Y;
always @(W, En)
case ({En, W})
3’b100: Y = 4’b1000;
3’b101: Y = 4’b0100;3’b110: Y = 4’b0010;3’b111: Y = 4’b0001;default : Y = 4’b0000;
endcase
endmodule"
"module shifter (W, Shift, Y , k);
input [3:0] W;
input Shift;
output reg [3:0] Y;
output reg k;
always @(W, Shift)
begin
if(Shift)
begin
Y[3] = 0;
Y[2:0] = W[3:1];
k = W[0];
endelsebegin
Y=W ;
k=0 ;
end
end
endmodule"
"module shifter (W, Shift, Y , k);
input [3:0] W;
input Shift;
output reg [3:0] Y;
output reg k;
always @(W, Shift)
begin
if(Shift)
begin
Y=W>   > 1 ;
k = W[0];
end
elsebegin
Y=W ;
k=0 ;
end
end
endmodule"
"module barrel (W, S, Y);
input [3:0] W;
input [1:0] S;
output [3:0] Y;
wire [3:0] T;
assign {T, Y} = {W, W} >> S;
endmodule"
"module parity (X, Y);
input [7:0] X;
output [7:0] Y;
assign Y = { X[6:0], X[6:0]};
endmodule"
"module problem4_18 (W, En, y0, y1, y2, y3);
input [1:0] W;
input En;
output reg y0, y1, y2, y3;
always @(W, En)
begin
y 0=0 ;
y 1=0 ;y 2=0 ;y 3=0 ;if(En)
if(W == 0) y0 = 1;
else if (W == 1) y1 = 1;
else if (W == 2) y2 = 1;
else y 3=1 ;
end
endmodule"
"module dec2to4 (W, En, Y);
input [1:0] W;
input En;
output reg [0:3] Y;
integer k;
always @(W, En)
for(k = 0; k < = 3; k = k+1)
if(W == k)
Y[k] = En;
endmodule"
"module D_latch (D, Clk, Q);
input D, Clk;
output reg Q;
always @(D, Clk)
if(Clk)
Q=D ;
endmodule"
"module ﬂipﬂop (D, Clock, Q);
input D, Clock;
output reg Q;
always @(posedge Clock)
Q=D ;
endmodule"
"module example5_3 (D, Clock, Q1, Q2);
input D, Clock;
output reg Q1, Q2;
always @(posedge Clock)
begin
Q 1=D ;
Q2 = Q1;
end
endmodule"
"module example5_4 (D, Clock, Q1, Q2);
input D, Clock;
output reg Q1, Q2;
always @(posedge Clock)
begin
Q1 < = D;
Q2 < = Q1;
end
endmodule"
"module example5_5 (x1, x2, x3, Clock, f, g);
input x1, x2, x3, Clock;
output reg f, g;
always @(posedge Clock)
begin
f=x 1&x 2 ;
g=f|x3;
end
endmodule"
"module example5_6 (x1, x2, x3, Clock, f, g);
input x1, x2, x3, Clock;
output reg f, g;
always @(posedge Clock)
begin
f<=x 1&x 2 ;
g<=f |x3;
end
endmodule"
"module that deﬁnes a D ﬂip-ﬂop with an
asynchronous active-low reset (clear) input. When Resetn, the reset input, is equal to 0, the
ﬂip-ﬂop’s Q output is set to 0. Note that the sensitivity list speciﬁes the negative edge of
Resetn as an event trigger along with the positive edge of the clock. We cannot omit the
keyword negedge because the sensitivity list cannot have both edge-triggered and level-
sensitive signals.
Example 5.8 SYNCHRONOUS CLEAR Figure 5.45 shows how a D ﬂip-ﬂop with a synchronous reset
input can be described. In this case the reset signal is acted upon only when a positiveclock edge arrives. This code generates the circuit in Figure 5.13c , which has an AND gate
connected to the ﬂip-ﬂop’s D input.
module ﬂipﬂop (D, Clock, Resetn, Q);
input D, Clock, Resetn;
output reg Q;
always @(negedge Resetn, posedge Clock)
if(!Resetn)
Q<=0 ;
else
Q<=D ;
endmodule"
"module ﬂipﬂop (D, Clock, Resetn, Q);
input D, Clock, Resetn;
output reg Q;
always @(posedge Clock)
if(!Resetn)
Q<=0 ;
else
Q<=D ;
endmodule"
"module regn (D, Clock, Resetn, Q);
parameter n = 16;
input [n –1:0] D;
input Clock, Resetn;
output reg [n –1:0] Q;
always @(negedge Resetn, posedge Clock)
if(!Resetn)
Q<=0 ;
else
Q<=D ;
endmodule"
"module muxdff (D0, D1, Sel, Clock, Q);
input D0, D1, Sel, Clock;
output reg Q;
always @(posedge Clock)
if(!Sel)
Q<=D 0 ;
else
Q<=D 1 ;
endmodule"
"module muxdff (D0, D1, Sel, Clock, Q);
input D0, D1, Sel, Clock;
output reg Q;
wire D;
assign D = Sel ? D1 : D0;
always @(posedge Clock)
Q<=D ;
endmodule"
"module shift4 (R, L, w, Clock, Q);
input [3:0] R;
input L, w, Clock;
output wire [3:0] Q;
muxdff Stage3 (w, R[3], L, Clock, Q[3]);
muxdff Stage2 (Q[3], R[2], L, Clock, Q[2]);muxdff Stage1 (Q[2], R[1], L, Clock, Q[1]);muxdff Stage0 (Q[1], R[0], L, Clock, Q[0]);
endmodule"
"module shift4 (R, L, w, Clock, Q);
input [3:0] R;
input L, w, Clock;
output reg [3:0] Q;
always @(posedge Clock)
if(L)
Q<=R ;
elsebegin
Q[0] < = Q[1];Q[1] < = Q[2];Q[2] < = Q[3];Q[3] < = w;
end
endmodule"
"module shiftn (R, L, w, Clock, Q);
parameter n = 16;
input [n –1:0] R;
input L, w, Clock;
output reg [n –1:0] Q;
integer k;
always @(posedge Clock)
if(L)
Q<=R ;
else
begin
for(k = 0; k < n –1; k = k+1)
Q[k] < = Q[k+1];
Q [ n– 1 ]<=w ;
end
endmodule"
"module upcount (Resetn, Clock, E, Q);
input Resetn, Clock, E;
output reg [3:0] Q;
always @(negedge Resetn, posedge Clock)
if(!Resetn)
Q<=0 ;
else if (E)
Q<=Q+1 ;
endmodule"
"module combines the capabilities of the counters deﬁned in Figures 5.53 and 5.54. Itincludes a control signal up_down that governs the direction of counting.
module upcount (R, Resetn, Clock, E, L, Q);
input [3:0] R;
input Resetn, Clock, E, L;
output reg [3:0] Q;
always @(negedge Resetn, posedge Clock)
if(!Resetn)
Q<=0 ;
else if (L)
Q<=R ;
else if (E)
Q<=Q+1 ;
endmodule"
"module downcount (R, Clock, E, L, Q);
parameter n=8 ;
input [n –1:0] R;
input Clock, L, E;
output reg [n –1:0] Q;
always @(posedge Clock)
if(L)
Q<=R ;
else if (E)
Q<=Q– 1 ;
endmodule"
"module updowncount (R, Clock, L, E, up_down, Q);
parameter n=8 ;
input [n– 1:0] R;
input Clock, L, E, up_down;
output reg [n– 1:0] Q;
always @(posedge Clock)
if(L)
Q<=R ;
else if (E)
Q < = Q + (up_down ? 1 : –1);
endmodule"
"module rege (D, Clock, Resetn, E, Q);
input D, Clock, Resetn, E;
output reg Q;
always @(posedge Clock, negedge Resetn)
if(Resetn == 0)
Q<=0 ;
else if (E)
Q<=D ;
endmodule"
"module regne (R, Clock, Resetn, E, Q);
parameter n=8 ;
input [n–1:0] R;
input Clock, Resetn, E;
output reg [n–1:0] Q;
always @(posedge Clock, negedge Resetn)
if(Resetn == 0)
Q< =0 ;
else if (E)
Q< =R ;
endmodule"
"module shiftrne (R, L, E, w, Clock, Q);
parameter n=4 ;
input [n– 1:0] R;
input L, E, w, Clock;
output reg [n– 1:0] Q;
integer k;
always @(posedge Clock)
begin
if(L)
Q<=R ;
else if (E)
begin
Q[n– 1] < = w;
for( k=n –2 ;k>= 0 ;k=k –1 )
Q[k] < = Q[k+ 1];
end
end
endmodule"
"module BCDcount (Clock, Clear, E, BCD1, BCD0);
input Clock, Clear, E;
output reg [3:0] BCD1, BCD0;
always @(posedge Clock)
begin
if(Clear)
begin
BCD1 < = 0;BCD0 < = 0;
endelse if (E)
if(BCD0 == 4’b1001)
begin
BCD0 < = 0;if(BCD1 == 4’b1001)
BCD1 < = 0;
else
BCD1 < = BCD1 + 1;
endelse
BCD0 < = BCD0 + 1;
end
endmodule"
"module seg7 (bcd, leds);
input [3:0] bcd;
output reg [1:7] leds;
always @(bcd)
case (bcd) //abcdefg
0: leds = 7’b1111110;
1: leds = 7’b0110000;2: leds = 7’b1101101;3: leds = 7’b1111001;4: leds = 7’b0110011;5: leds = 7’b1011011;6: leds = 7’b1011111;7: leds = 7’b1110000;8: leds = 7’b1111111;9: leds = 7’b1111011;default: leds = 7’bx;
endcase
endmodule"
"module reaction (Clock, Reset, c9, w, Pushn, LEDn, Digit1, Digit0);
input Clock, Reset, c9, w, Pushn;
output wire LEDn;
output wire [1:7] Digit1, Digit0;
regLED;
wire [3:0] BCD1, BCD0;
always @(posedge Clock)
begin
if(!Pushn ||Reset)
LED < = 0;
else if (w)
LED < = 1;
end
assign LEDn = LED;
BCDcount counter (c9, Reset, LED, BCD1, BCD0);
seg7 seg1 (BCD1, Digit1);seg7 seg0 (BCD0, Digit0);
endmodule"
"module vend (N, D, Q, Resetn, Coin, Z);
input N, D, Q, Resetn, Coin;
output Z;
wire [4:0] X;
reg[5:0] S;
assign X[0] = N |Q;
assign X[1] = D;
assign X[2] = N;
assign X[3] = D |Q;
assign X[4] = Q;
assign Z = S[5] |(S[4] & S[3] & S[2] & S[1]);
always @(negedge Coin, negedge Resetn)
if(Resetn == 1’b0)
S < = 5’b00000;
else
S < = {1’b0, X} + S;
endmodule"
"module lfsr (R, L, Clock, Q);
input [0:2] R;
input L, Clock;
output reg [0:2] Q;
always @(posedge Clock)
if(L)
Q<=R ;
else
Q < = {Q[2], Q[0] Q[2], Q[1]};
endmodule"
"module lfsr (R, L, Clock, Q);
input [0:2] R;
input L, Clock;
output reg [0:2] Q;
always @(posedge Clock)
if(L)
Q<=R ;
else
Q < = {Q[2], Q[0], Q[1] Q[2]};
endmodule"
"module lfsr (R, L, Clock, Q);
input [0:2] R;
input L, Clock;
output reg [0:2] Q;
always @(posedge Clock)
if(L)
Q<=R ;
elsebegin
Q[0] = Q[2];Q[1] = Q[0] Q[2];Q[2] = Q[1];
end
endmodule"
"module lfsr (R, L, Clock, Q);
input [0:2] R;
input L, Clock;
output reg [0:2] Q;
always @(posedge Clock)
if(L)
Q<=R ;
elsebegin
Q[0] = Q[2];Q[1] = Q[0];Q[2] = Q[1] Q[2];
end
endmodule"
"module simple (Clock, Resetn, w, z);
input Clock, Resetn, w;
output z;
reg[2:1] y, Y;
parameter [2:1] A = 2’b00, B = 2’b01, C = 2’b10;
// Deﬁne the next state combinational circuit
always @(w, y)
case (y)
A:if(w) Y = B;
else Y=A ;
B:if(w) Y = C;
else Y=A ;
C:if(w) Y = C;
else Y=A ;
default: Y = 2’bxx;
endcase
// Deﬁne the sequential blockalways @(negedge Resetn, posedge Clock)
if(Resetn == 0) y < = A;
else y<=Y ;
// Deﬁne outputassign z=( y= =C ) ;
endmodule"
"module simple (Clock, Resetn, w, z);
input Clock, Resetn, w;
output reg z;
reg[2:1] y, Y;
parameter [2:1] A = 2’b00, B = 2’b01, C = 2’b10;
// Define the next state and output combinational circuits
always @(w, y)
begin
case (y)
A:if(w) Y = B;
else Y=A ;
B:if(w) Y = C;
else Y=A ;
C:if(w) Y = C;
else Y=A ;
default : Y = 2’bxx;
endcasez = (y == C); // Define output
end
// Define the sequential block
always @(negedge Resetn, posedge Clock)
if(Resetn == 0) y < = A;
else y<=Y ;
endmodule"
"module simple (Clock, Resetn, w, z);
input Clock, Resetn, w;
output z;
reg[2:1] y;
parameter [2:1] A = 2’b00, B = 2’b01, C = 2’b10;
// Deﬁne the sequential block
always @(negedge Resetn, posedge Clock)
if(Resetn == 0) y < = A;
else
case (y)
A:if( w ) y<=B ;
else y<=A ;
B:if( w ) y<=C ;
else y<=A ;
C:if( w ) y<=C ;
else y<=A ;
default: y < = 2’bxx;
endcase
// Deﬁne outputassign z=( y= =C ) ;
endmodule"
"module control (Clock, Resetn, w, R1in, R1out, R2in, R2out, R3in, R3out, Done);
input Clock, Resetn, w;
output R1in, R1out, R2in, R2out, R3in, R3out, Done;
reg[2:1] y, Y;
parameter [2:1] A = 2’b00, B = 2’b01, C = 2’b10, D = 2’b11;
// Deﬁne the next state combinational circuit
always @(w, y)
case (y)
A:if(w) Y = B;
else Y=A ;
B : Y=C ;C : Y=D ;D : Y=A ;
endcase
// Deﬁne the sequential blockalways @(negedge Resetn, posedge Clock)
if(Resetn == 0) y < = A;
else y<=Y ;
// Deﬁne outputsassign R2out = (y == B);
assign R 3 i n=( y= =B ) ;
assign R1out = (y == C);
assign R 2 i n=( y= =C ) ;
assign R3out = (y == D);
assign R 1 i n=( y= =D ) ;
assign D o n e=( y= =D ) ;
endmodule"
"module mealy (Clock, Resetn, w, z);
input Clock, Resetn, w;
output reg z;
regy, Y;
parameter A = 1’b0, B = 1’b1;
// Deﬁne the next state and output combinational circuits
always @(w, y)
case (y)
A:if(w)
begin
z=0 ;Y=B ;
endelsebegin
z=0 ;Y=A ;
end
B:if(w)
begin
z=1 ;Y=B ;
endelsebegin
z=0 ;Y=A ;
end
endcase
// Deﬁne the sequential blockalways @(negedge Resetn, posedge Clock)
if(Resetn == 0) y < = A;
else y<=Y ;
endmodule"
"module shiftrne (R, L, E, w, Clock, Q);
parameter n=8 ;
input [n –1:0] R;
input L, E, w, Clock;
output reg [n –1:0] Q;
integer k;
always @(posedge Clock)
if(L)
Q<=R ;
else if (E)
begin
for( k=n –1 ;k>0 ;k=k– 1 )
Q[k– 1] < = Q[k];
Q [ n– 1 ]<=w ;
end
endmodule"
"module serial_adder(A, B, Reset, Clock, Sum);
input [7:0] A, B;
input Reset, Clock;
output wire [7:0] Sum;
reg[3:0] Count;
regs, y, Y;
wire [7:0] QA, QB;
wire Run;
parameter G = 1’b0, H = 1’b1;
shiftrne shift_A (A, Reset, 1’b1, 1’b0, Clock, QA);
shiftrne shift_B (B, Reset, 1’b1, 1’b0, Clock, QB);shiftrne shift_Sum (8’b0, Reset, Run, s, Clock, Sum);
// Adder FSM
// Output and next state combinational circuitalways @(QA, QB, y)
case (y)
G:begin
s = QA[0] QB[0];if(QA[0] & QB[0]) Y = H;
else Y=G ;
end
H:begin
s = QA[0] QB[0];if( QA[0] & QB[0]) Y = G;
else Y=H ;
end
default: Y=G ;
endcase
// Sequential blockalways @(posedge Clock)
if(Reset) y < = G;
else y<=Y ;
// Control the shifting processalways @(posedge Clock)
if(Reset) Count = 8;
else if (Run) Count = Count – 1;
assign Run = Count;
endmodule"
"module arbiter (r, Resetn, Clock, g);
input [1:3] r;
input Resetn, Clock;
output wire [1:3] g;
reg[2:1] y, Y;
parameter Idle = 2’b00, gnt1 = 2’b01, gnt2 = 2’b10, gnt3 = 2’b11;
// Next state combinational circuit
always @(r, y)
case (y)
Idle: casex (r)
3’b000: Y = Idle;3’b1xx: Y = gnt1;3’b01x: Y = gnt2;3’b001: Y = gnt3;default: Y = Idle;
endcase
gnt1: if(r[1]) Y = gnt1;
else Y = Idle;
gnt2: if(r[2]) Y = gnt2;
else Y = Idle;
gnt3: if(r[3]) Y = gnt3;
else Y = Idle;
default: Y = Idle;
endcase
// Sequential blockalways @(posedge Clock)
if(Resetn == 0) y < = Idle;
else y<=Y ;
// Deﬁne outputassign g[1] = (y == gnt1);
assign g[2] = (y == gnt2);
assign g[3] = (y == gnt3);
endmodule"
"module sequence (Clock, Resetn, w, z);
input Clock, Resetn, w;
output z;
reg[3:1] y, Y;
parameter [3:1] A = 3’b000, B = 3’b001, C = 3’b010, D = 3’b011, E = 3’b100;
// Deﬁne the next state combinational circuit
always @(w, y)
case (y)
A:if(w) Y = D;
else Y=B ;
B:if(w) Y = D;
else Y=C ;
C:if(w) Y = D;
else Y=C ;
D:if(w) Y = E;
else Y=B ;
E:if(w) Y = E;
else Y=B ;
default: Y = 3’bxxx;
endcase
// Deﬁne the sequential blockalways @(negedge Resetn, posedge Clock)
if(Resetn == 0) y < = A;
else y<=Y ;
// Deﬁne outputassign z=( y= =C ) ( y= =E ) ;
endmodule"
"module seqmealy (Clock, Resetn, w, z);
input Clock, Resetn, w;
output reg z;
reg[2:1] y, Y;
parameter [2:1] A = 2’b00, B = 2’b01, C = 2’b11;
// Deﬁne the next state and output combinational circuits
always @(w, y)
case (y)
A:if(w)
begin
z=0 ;Y=C ;
endelsebegin
z=0 ;Y=B ;
end
B:if(w)
begin
z=0 ;Y=C ;
endelsebegin
z=1 ;Y=B ;
end
C:if(w)
begin
z=1 ;Y=C ;
endelsebegin
z=0 ;Y=B ;
end
default:
begin
z = 0; Y = 2’bxx;
end
endcase
// Deﬁne the sequential blockalways @(negedge Resetn, posedge Clock)
if(Resetn == 0) y < = A;
else y<=Y ;
endmodule"
"module regn (R, L, Clock, Q);
parameter n=8 ;
input [n –1:0] R;
input L, Clock;
output reg [n –1:0] Q;
always @(posedge Clock)
if(L)
Q<=R ;
endmodule"
"module trin (Y , E, F);
parameter n=8 ;
input [n –1:0] Y;
input E;
output wire [n –1:0] F;
assign F = E ? Y : ’bz;
endmodule"
"module swap (Resetn, Clock, w, Data, Extern, RinExt1, RinExt2, RinExt3, BusWires, Done);
parameter n=8 ;
input Resetn, Clock, w, Extern, RinExt1, RinExt2, RinExt3;
input [n–1:0] Data;
output tri [n–1:0] BusWires;
output Done;
wire [n–1:0] R1, R2, R3;
wire R1in, R1out, R2in, R2out, R3in, R3out;
reg[2:1] y, Y;
parameter [2:1] A = 2’b00, B = 2’b01, C = 2’b10, D = 2’b11;
// Define the next state combinational circuit for FSM
always @(w, y)
case (y)
A:if(w) Y = B;
else Y=A ;
B: Y = C;
C: Y = D;
D: Y = A;
endcase
// Define the sequential block for FSM
always @(negedge Resetn, posedge Clock)
if(Resetn == 0) y < = A;
else y<=Y ;
// Define outputs of FSM
assign R2out = (y == B);
assign R3in = (y == B);
assign R1out = (y == C);
assign R2in = (y == C);
assign R3out = (y == D);
assign R1in = (y == D);
assign Done = (y == D);
// Instantiate registers
regn reg
 1 (BusWires, RinExt1 |R1in, Clock, R1);
regn reg
 2 (BusWires, RinExt2 |R2in, Clock, R2);
regn reg
 3 (BusWires, RinExt3 |R3in, Clock, R3);
// Instantiate tri-state drivers
trin tri
 ext (Data, Extern, BusWires);
trin tri
 1 (R1, R1out, BusWires);
trin tri
 2 (R2, R2out, BusWires);
trin tri
 3 (R3, R3out, BusWires);
endmodule"
"module swapmux (Resetn, Clock, w, Data, RinExt1, RinExt2, RinExt3, BusWires, Done);
parameter n=8 ;
input Resetn, Clock, w, RinExt1, RinExt2, RinExt3;
input [n–1:0] Data;
output reg [n–1:0] BusWires;
output Done;
wire [n–1:0] R1, R2, R3;
wire R1in, R2in, R3in;
reg[2:1] y, Y;
parameter [2:1] A = 2 ’b00, B = 2 ’b01, C = 2 ’b10, D = 2 ’b11;
// Define the next state combinational circuit for FSM
always @(w, y)
case (y)
A:if(w) Y = B;
else Y=A ;
B: Y = C;
C: Y = D;
D: Y = A;
endcase
// Define the sequential block for FSM
always @(negedge Resetn, posedge Clock)
if(Resetn == 0) y < = A;
else y<=Y ;
// Define control signals
assign R3in = (y == B);
assign R2in = (y == C);
assign R1in = (y == D);
assign Done = (y == D);
// Instantiate registers
regn reg
 1 (BusWires, RinExt1 |R1in, Clock, R1);
regn reg
 2 (BusWires, RinExt2 |R2in, Clock, R2);
regn reg
 3 (BusWires, RinExt3 |R3in, Clock, R3);
// Define the multiplexers
always @(y, Data, R1, R2, R3)
if(y == A) BusWires = Data;
else if (y == B) BusWires = R2;
else if (y == C) BusWires = R1;
else BusWires = R3;
endmodule"
"module upcount (Clear, Clock, Q);
input Clear, Clock;
output reg [1:0] Q;
always @(posedge Clock)
if(Clear)
Q<=0 ;
else
Q<=Q+1 ;
endmodule"
"module
module addersubtractor (A, B, Clock, Reset, Sel, AddSub, Z, Overﬂow);
parameter n = 16;
input [n–1:0] A, B;
input Clock, Reset, Sel, AddSub;
output [n–1:0] Z;
output Overﬂow;
regSelR, AddSubR, Overﬂow;
reg[n–1:0] Areg, Breg, Zreg;
wire [n–1:0] G, H, M, Z;
wire carryout, over_ﬂow;
// Deﬁne combinational logic circuit
assign H = Breg {n{AddSubR}};
mux2to1 multiplexer (Areg, Z, SelR, G);
defparam multiplexer.k = n;
adderk nbit_adder (AddSubR, G, H, M, carryout);
defparam nbit_adder.k = n;
assign over_ﬂow = carryout G[n–1] H[n–1] M[n–1];
assign Z = Zreg;
// Deﬁne ﬂip-ﬂops and registers
always @(posedge Reset or posedge Clock)
if(Reset == 1)
begin
Areg <= 0; Breg <= 0; Zreg <= 0;
SelR <= 0; AddSubR <= 0; Overﬂow <= 0;
endelsebegin
Areg <= A; Breg <= B; Zreg <= M;
SelR <= Sel; AddSubR <= AddSub; Overﬂow <= over_ﬂow;
end
endmodule"
"module mux2to1 (V , W, Selm, F);
parameter k=8 ;
input [k–1:0] V , W;
input Selm;
output [k–1:0] F;
reg[k–1:0] F;
always @(V or W or Selm)
if(Selm == 0) F = V;
else F=W ;
endmodule"
"module adderk (carryin, X, Y , S, carryout);
parameter k=8 ;
input [k–1:0] X, Y;
input carryin;
output [k–1:0] S;
output carryout;
reg[k–1:0] S;
regcarryout;
always @(X or Y or carryin)
{carryout, S} = X + Y + carryin;
endmodule"
"module. Figure A.1 gives the
general structure of a module declaration. The module has a name, module_name, which
can be any valid identiﬁer, followed by a list of ports. The term port is adopted from the
electrical jargon, in which it refers to an input or output connection in an electrical circuit.
The ports can be of type input, output,o r inout (bidirectional), and can be either scalar or
vector. Examples of ports are
input Cin, x, y;
input [3:0] X, Y;
output Cout, s;
inout [7:0] Bus;
output [3:0] S;
wire Cout, s;
wire [7:0] Bus;
reg[3:0] S;
As shown, output and inout ports have an associated type. We assume that Cout, s, and
Busare nets in this example, while Sis a variable. The wire declarations can actually be
module module name [(port name{, port name})];
[parameter declarations]
[input declarations]
[output declarations]
[inout declarations]
[wire ortrideclarations]
[reg orinteger declarations]
[function ortask declarations]
[assign continuous assignments]
[initial block]
[always blocks]
[gate instantiations]
[module instantiations]
endmodule"
"module may contain any number of net ( wire ortri)o r
variable (reg orinteger ) declarations, and a variety of other types of statements that are
described later in this appendix.
Figure A.2 gives the Verilog code for a module fulladd, which represents a full-adder
circuit. (The full-adder is discussed in Section 3.2.) The input port Cinis the carry-in,
and the bits to be added are the input ports xandy. The output ports are the sum, s, and
the carry-out, Cout. The functionality of the full-adder is described with logic equations
preceded by the keyword assign, which is discussed in Section A.10.
There is usually more than one way to describe a given circuit using Verilog. Figure
A.3 gives another version of the fulladd module, in which the functionality is speciﬁed by
using the concatenate and addition operators. The statement
assign {Cout, s} =x+y+Cin;
assigns the least-signiﬁcant bit in the result x+y+Cinto the output sand the most-
signiﬁcant bit to Cout. The circuits generated from the modules in Figures A.2 and A.3 are
the same.
module fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output s, Cout;
assign s = x y Cin;
assign Cout = (x & y) |(Cin & x) |(Cin & y);
endmodule"
"module.
module fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output s, Cout;
endmodule"
"modules that implement basic logic gates. These gates allow a
circuit’s structure to be described using gate instantiation statements of the form
gate_name [instance_name] (output_port, input_port{, input_port});
The gate_name speciﬁes the desired type of gate, and the instance_name is any unique
identiﬁer. Each gate may have a different number of ports, with the output port listed ﬁrst,
followed by a variable number of input ports. An example of using gates to realize a full-adder is given in FigureA.4. The code deﬁnes four wire nets, z1t oz 4, that connect the gates
together, and each gate has a speciﬁed instance name. Figure A.5 shows a simpler version,in which instance names are not included and the declarations of z1t oz 4 are omitted. Since
the nets are not explicitly declared, they are implicitly assumed to be of type wire.
The logic gates supported in Verilog are summarized in Table A.2. The second col-
umn describes the function of each gate, and the rightmost column gives an example ofinstantiating the gate. Verilog allows gates with any number of inputs to be speciﬁed, butsome CAD systems set practical limits. The notif andbuﬁf gates represent tri-state buffers
(drivers). The gate notif0 is an inverting tri-state buffer with active-low enable, and notif1
provides the same functionality with an active-high enable. The buﬁf0 andbuﬁf1 gates are
tri-state buffers that do not invert the output.
For simulation purposes, it is possible to set a parameter of the gate that represents its
propagation delay. As an example, the following statement instantiates a three-input ANDgate with a delay of ﬁve time units (the units of time are determined by the simulator beingused):
and#(5) And3 (z, x1, x2, x3);
This type of delay parameter has no meaning when using Verilog for synthesis of logic
circuits.
// Structural specification of a full-addermodule fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output s, Cout;
wire z1, z2, z3, z4;
and And1 (z1, x, y);
and And2 (z2, x, Cin);
and And3 (z3, y, Cin);
orOr1 (Cout, z1, z2, z3);
xor Xor1 (z4, x, y);
xor Xor2 (s, z4, Cin);
endmodule"
"module fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output s, Cout;
and(z1, x, y);
and(z2, x, Cin);
and(z3, y, Cin);
or(Cout, z1, z2, z3);
xor(z4, x, y);
xor(s, z4, Cin);
endmodule"
"module adder sign (X, Y , S, S2s);
input [3:0] X, Y;
output [7:0] S, S2s;
assign S=X+Y ,
S2s = {{4{X[3]}}, X} + {{4{Y[3]}}, Y};
endmodule"
"module addern (X, Y , S, S2s);
parameter n=4 ;
input X, Y;
output [2*n−1:0] S, S2s;
assign S=X+Y ,
S2s = {{n{X[n 1]}}, X} + {{n{Y[n 1]}}, Y};
endmodule"
"module mux2to1 (w0, w1, s, f);
input w0, w1, s;
output reg f;
always @(w0, w1, s)
begin
f = w0;
if(s == 1)
f = w1;
end
endmodule"
"module fulladd (Cin, x, y, s, Cout);
input Cin, x, y;
output reg s, Cout;
always @(Cin, x, y)
begin
case ( {Cin, x, y} )
3’b000: {Cout, s} = ’b00;3’b001: {Cout, s} = ’b01;3’b010: {Cout, s} = ’b01;3’b011: {Cout, s} = ’b10;3’b100: {Cout, s} = ’b01;3’b101: {Cout, s} = ’b10;3’b110: {Cout, s} = ’b10;3’b111: {Cout, s} = ’b11;
endcase
end
endmodule"
"module priority (W, Y , f);
input [3:0] W;
output reg [1:0] Y;
output f;
assign f=( W! =0 ) ;
always @(W)
begin
casex (W)
’b1xxx: Y = 3;
’b01xx: Y = 2;’b001x: Y = 1;default:Y=0 ;
endcase
end
endmodule"
"module ripple (carryin, X, Y , S, carryout);
parameter n=4 ;
input carryin;
input [n–1:0] X, Y;
output reg [n–1:0] S;
output reg carryout;
reg[n:0] C;
integer k;
always @(X, Y , carryin)
begin
C[0] = carryin;
for(k = 0; k <= n–1; k = k+1)
begin
S[k] = X[k] Y[k] C[k];C[k+1] = (X[k] & Y[k])
(C[k] & X[k]) (C[k] & Y[k]);
endcarryout = C[n];
end
endmodule"
"module bit_count (X, Count);
parameter n=4 ;
parameter logn = 2;
input [n–1:0] X;
output reg [logn:0] Count;
integer k;
always @(X)
begin
Count = 0;
for(k = 0; k < n; k = k+1)
Count = Count + X[k];
end
endmodule"
"module adder4 (carryin, X, Y , S, carryout);
input carryin;
input [3:0] X, Y;
output [3:0] S;
output carryout;
wire [3:1] C;
fulladd stage0 (carryin, X[0], Y[0], S[0], C[1]);
fulladd stage1 (C[1], X[1], Y[1], S[1], C[2]);fulladd stage2 (C[2], X[2], Y[2], S[2], C[3]);fulladd stage3 (.Cout(carryout), .s(S[3]), .y(Y[3]), .x(X[3]), .Cin(C[3]));
endmodule"
"module group (Digits, Lights);
input [11:0] Digits;
output [1:21] Lights;
seg7 digit0 (Digits[3:0], Lights[1:7]);
seg7 digit1 (Digits[7:4], Lights[8:14]);seg7 digit2 (Digits[11:8], Lights[15:21]);
endmodule"
"module seg7(bcd, leds);
input [3:0] bcd;
output reg [1:7] leds;
always @(bcd)
case (bcd) //abcdefg
0: leds = 7’b1111110;
1: leds = 7’b0110000;2: leds = 7’b1101101;3: leds = 7’b1111001;4: leds = 7’b0110011;5: leds = 7’b1011011;6: leds = 7’b1011111;7: leds = 7’b1110000;8: leds = 7’b1111111;9: leds = 7’b1111011;default: leds = 7’bx;
endcase
endmodule"
"module common (X, Y , C);
input [7:0] X, Y;
output [3:0] C;
wire [7:0] T;
// Make T[i] = 1 if X[i] == Y[i]assign T=X
Y;
bitcount #(8,3) cbits (T, C);
endmodule"
"module common (X, Y , C);
input [7:0] X, Y;
output [3:0] C;
wire [7:0] T;
// Make T[i] = 1 if X[i] == Y[i]
assign T=X∧Y;
bitcount cbits (T, C);
defparam cbits.n = 8, cbits.logn = 3;
endmodule"
"module ripple_g (carryin, X, Y , S, carryout);
parameter n=4 ;
input carryin;
input [n–1:0] X, Y;
output [n–1:0] S;
output carryout;
wire [n:0] C;
genvar i;
assign C[0] = carryin;
assign carryout = C[n];
generate
for(i = 0; i <= n–1; i = i+1)
begin:addbit
fulladd stage (C[i], X[i], Y[i], S[i], C[i+1]);
end
endgenerate
endmodule"
"module mux_f (W, S16, f);
input [0:15] W;
input [3:0] S16;
output reg f;
reg[0:3] M;
function mux4to1;
input [0:3] W;
input [1:0] S;
if(S == 0) mux4to1 = W[0];
else if (S == 1) mux4to1 = W[1];
else if (S == 2) mux4to1 = W[2];
else if (S == 3) mux4to1 = W[3];
endfunction
always @(W, S16)
begin
M[0] = mux4to1(W[0:3], S16[1:0]);
M[1] = mux4to1(W[4:7], S16[1:0]);M[2] = mux4to1(W[8:11], S16[1:0]);M[3] = mux4to1(W[12:15], S16[1:0]);f = mux4to1(M[0:3], S16[3:2]);
end
endmodule"
"module is
equivalent to the group module in Figure A.19. Where the group module instantiates three
copies of the seg7 subcircuit, group_ f achieves the same effect by using a function. Since
it returns a seven-bit value, the function is deﬁned with the syntax
function [1:7] leds;
Consider again the 16-to-1 multiplexer example in Figure A.23. Another method of
writing this code appears in Figure A.25. This code uses a Verilog task, which is similar
to afunction. While a function returns a value, a task does not; it has input and output
variables, like a module. A task can be called only from inside an always (orinitial) block.
module group_f (Digits, Lights);
input [11:0] Digits;
output reg [1:21] Lights;
function [1:7] leds;
input [3:0] bcd;
begin
case (bcd) // abcdef g
0: leds = 7’b1111110;
1: leds = 7’b0110000;2: leds = 7’b1101101;3: leds = 7’b1111001;4: leds = 7’b0110011;5: leds = 7’b1011011;6: leds = 7’b1011111;7: leds = 7’b1110000;8: leds = 7’b1111111;9: leds = 7’b1111011;default: leds = 7’bx;
endcase
end
endfunction
always @(Digits)
begin
Lights[1:7] = leds(Digits[3:0]);
Lights[8:14] = leds(Digits[7:4]);Lights[15:21] = leds(Digits[11:8]);
end
endmodule"
"module mux_t (W, S16, f);
input [0:15] W;
input [3:0] S16;
output reg f;
reg[0:3] M;
task mux4to1;
input [0:3] W;
input [1:0] S;
output Result;
begin
if(S == 0) Result = W[0];
else if (S == 1) Result = W[1];
else if (S == 2) Result = W[2];
else if (S == 3) Result = W[3];
end
endtask
always @(W, S16)
begin
mux4to1(W[0:3], S16[1:0], M[0]);
mux4to1(W[4:7], S16[1:0], M[1]);mux4to1(W[8:11], S16[1:0], M[2]);mux4to1(W[12:15], S16[1:0], M[3]);mux4to1(M[0:3], S16[3:2], f);
end
endmodule"
"module latch (D, clk, Q);
input D, clk;
output reg Q;
always @(D, clk)
if(clk)
Q=D ;
endmodule"
"module ﬂipﬂop (D, Clock, Q);
input D, Clock;
output reg Q;
always @(posedge Clock)
Q< =D ;
endmodule"
"module ﬂipﬂop_ar (D, Clock, Resetn, Q);
input D, Clock, Resetn;
output reg Q;
always @(posedge Clock, negedge Resetn)
if(Resetn == 0)
Q< =0 ;
else
Q< =D ;
endmodule"
"module ﬂipﬂop_sr (D, Clock, Resetn, Q);
input D, Clock, Resetn;
output reg Q;
always @(posedge Clock)
if(Resetn == 0)
Q< =0 ;
else
Q< =D ;
endmodule"
"module reg4 (D, Clock, Resetn, Q);
input [3:0] D;
input Clock, Resetn;
output reg [3:0] Q;
always @(posedge Clock, negedge Resetn)
if(Resetn == 0)
Q<= 4’b0000;
else
Q<=D ;
endmodule"
"module regne (D, Clock, Resetn, E, Q);
parameter n=4 ;
input [n–1:0] D;
input Clock, Resetn, E;
output reg [n–1:0] Q;
always @(posedge Clock, negedge Resetn)
if(Resetn == 0)
Q< =0 ;
else if (E)
Q< =D ;
endmodule"
"module shift3 (w, Clock, Q);
2 input w, Clock;
3 output reg [1:3] Q;
4 always @(posedge Clock)
5 begin
6 Q[3] <= w;7 Q[2] <= Q[3];8 Q[1] <= Q[2];9 end
10endmodule"
"module shift3 (w, Clock, Q);
input w, Clock;
output reg [1:3] Q;
always @(posedge Clock)
begin
Q[3] = w;
Q[2] = Q[3];Q[1] = Q[2];
end
endmodule"
"module count4 (Clock, Resetn, E, Q);
input Clock, Resetn, E;
output reg [3:0] Q;
always @(posedge Clock, negedge Resetn)
if(Resetn == 0)
Q< =0 ;
else if (E)
Q< =Q+1 ;
endmodule"
"module accum (X, Y , Clock, Resetn, Result);
parameter k=8 ;
parameter m=4 ;
input [k–1:0] X;
input [m–1:0] Y;
input Clock, Resetn;
output [k–1:0] Result;
wire [k–1:0] Sum;
wire Cout, Go;
reg[m–1:0] C;
ripple u1 (.carryin(0), .X(X), .Y(Result), .S(Sum), .carryout(Cout));
defparam u1.n = k;
regne u2 (.D(Sum), .Clock(Clock), .Resetn(Resetn), .E(Go), .Q(Result));
defparam u2.n = 8;
always @(posedge Clock, negedge Resetn)
if(Resetn == 0)
C< =Y ;
else if (Go)
C< =C–1 ;
assign Go = C;
endmodule"
"module moore (Clock, w, Resetn, z);
input Clock, w, Resetn;
output z;
reg[1:0] y, Y;
parameter A = 2’b00, B = 2’b01, C = 2’b10;
always @(w, y)
begin
case (y)
A: if(w == 0) Y = A;
else Y=B ;
B: if(w == 0) Y = A;
else Y=C ;
C: if(w == 0) Y = A;
else Y=C ;
default: Y = 2’bxx;
endcase
end
always @(posedge Clock, negedge Resetn)
begin
if(Resetn == 0)
y< =A ;
else
y< =Y ;
endassign z=( y= =C ) ;
endmodule"
"module moore (Clock, w, Resetn, z);
input Clock, w, Resetn;
output z;
reg[1:0] y;
parameter A = 2’b00, B = 2’b01, C = 2’b10;
always @(posedge Clock, negedge Resetn)
begin
if(Resetn == 0)
y< =A ;
else
case (y)
A: if(w == 0) y <= A;
else y< =B ;
B: if(w == 0) y <= A;
else y< =C ;
C: if(w == 0) y <= A;
else y< =C ;
default: y <= 2’bxx;
endcase
end
assign z=( y= =C ) ;
endmodule"
"module mealy (Clock, w, Resetn, z);
input Clock, w, Resetn;
output reg z;
regy, Y;
parameter A = 1’b0, B = 1’b1;
always @(w, y)
case (y)
A:if(w == 0)
begin
Y=A ;
z=0 ;
end
elsebegin
Y=B ;
z=0 ;
end
B:if(w == 0)
begin
Y=A ;
z=0 ;
endelsebegin
Y=B ;
z=1 ;
end
endcase
always @(posedge Clock, negedge Resetn)
if(Resetn == 0)
y< =A ;
else
y< =Y ;
endmodule"
"module_name
.	Second,	the	module
should	have	input	and	output	ports	assigned	to	it.	We	represent	these	ports	as
port_list
	in	the	above	description.	The	port	list	does	not	have	a	specific	order.
Therefore,	input	and	output	ports	can	be	represented	in	any	order	within	the	list.
For	convenience,	we	suggest	representing	output	ports	first.	At	this	stage,
definition	of	the	module	is	done.	Next	comes	internal	structure	of	the	module.
Here,	we	first	define	port	elements	within	the	module.	Each	element	can	be
input
,	
output
,	or	
inout
.	As	the	name	implies,	the	
input
	keyword	declares	that
the	related	port	will	get	data	from	outside	world.	The	
output
	keyword	declares
that	the	related	port	will	feed	data	to	outside	world.	The	
inout
	keyword	declares
that	the	related	port	can	be	used	for	both	input	and	output	purposes.	Then,	we
describe	the	digital	system.	This	is	indicated	by	
statement	1
,	
statement	2
,	and
statement	3
	above.	It	is	important	to	remember	that	order	of	statements	is	not
important	in	the	description	since	they	will	be	represented	by	hardware	elements
in	the	FPGA.	Afterward,	we	close	the	module	by	keyword	
endmodule"
"module,	
360
Eight-input	LUT,	
12
Eight-to-one	multiplexer,	
134
Verilog,	
165
,	
166
f
VHDL,	
167
Eight-to-three	priority	encoder,	
162
,	
162
f
Elevator	cabin	control	system,	
359
ELF	file,	
256
,	
257
f
else,	
153
,	
155
else	if,	
152
,	
153
elsif,	
155
Encoders,	
160
–163
end,	
50
,	
157
endmodule"
"module M (P1, P2, P3, P4);
  input P1, P2;  output [7:0] P3;  inout P4;
  reg [7:0] R1, M1[1:1024];
  wire W1, W2, W3, W4;
  parameter C1 = ""This is a string"";
  initial
  begin : BlockName
    // Statements
  end
  always
  begin
    // Statements
  end
  // Continuous assignments...
  assign W1 = Expression;
  wire (Strong1, Weak0) [3:0] #(2,3) W2 = Expression;
  // Module instances...
  COMP U1 (W3, W4);
  COMP U2 (.P1(W3), .P2(W4));
  task T1;
    input A1;    inout A2;    output A3;
    begin
      //  Statements
    end
  endtask
  function [7:0] F1;
    input A1;    begin
      //  Statements
      F1 = Expression;
    end  endfunction
endmodule"
module-<HERE>-endmodule
module-<HERE>-endmodule
module-<HERE>-endmodule
"module instantiation.
Example
`timescale 1ns / 1ps
module LayoutDelays;
  defparam Design.U1.T_f = 2.7;  defparam Design.U2.T_f = 3.1;  ...endmodule"
"module Design (...);
  ...
  and_gate U1 (f, a, b);
  and_gate U2 (f, a, b);  ...endmodule"
"module and_gate (f, a, b);
  output f;  input a, b;
  parameter T_f = 2;
  and #(T_f) (f,a,b);endmodule"
module-<HERE>-endmodule
"module, and is usually called onlyfrom that module, although it may be called from elsewhere using ahierarchical name.
Syntax
function [ RangeOrType ] FunctionName;
  Declarations...
  Statement
endfunction
RangeOrType  = {either}  Range integer time real realtime
Range  = [ConstantExpression :ConstantExpression ]
Declaration =  {either}
  input [ Range ] Name,...;
  Register
  Parameter
  Event
Where
module-<HERE>-endmodule"
module-<HERE>-endmodule
"module, UDP or gate. Hierarchy in a design
is created by instancing modules; the behaviour of a design can be describedstructurally, by making instances of UDPs, gates and other modules,connecting them together with nets.
Syntax
{either}
ModuleName [#( Expression ,...)] ModuleInstance ,...;
UDPOrGateName [ Strength ] [Delay ] PrimitiveInstance,... ;
ModuleInstance  =
  InstanceName [ Range ] ([PortConnections ])
PrimitiveInstance  =
  [InstanceName [ Range ]] (Expression,... )
Range  = [ConstantExpression :ConstantExpression ]
PortConnections  = {either}
  [Expression ],... {ordered connection}
  .PortName([ Expression ]),... {named connection}
Where
module-<HERE>-endmodule"
"module Tristate8 (out, in, ena);
  output [7:0] out;  input [7:0] in;  input ena;
  bufif1 U1[7:0] (out, in, ena);
/* Equivalent (except the instance names) to ...
  bufif1 U1_7 (out[7], in[7], ena);
  bufif1 U1_6 (out[6], in[6], ena);  bufif1 U1_5 (out[5], in[5], ena);  bufif1 U1_4 (out[4], in[4], ena);  bufif1 U1_3 (out[3], in[3], ena);  bufif1 U1_2 (out[2], in[2], ena);
  bufif1 U1_1 (out[1], in[1], ena);
  bufif1 U1_0 (out[0], in[0], ena);*/
endmodule"
"module is the basic unit of hierarchy in Verilog. Modules contain
declarations and functional descriptions and represent hardware components.
Modules can also be used to declare parameters, tasks and functions that are
used elsewhere. Such modules do not represent actual hardwarecomponents, because they do not need to include any initials, always’s,
continuous assignments or instances.
Syntax
{either}
module ModuleName [( Port,...)];
  ModuleItems ...
endmodule"
"module ModuleName [( Port,...)];
  ModuleItems ...
endmodule"
"modules
may be subject to certain implementation specific restrictions. If these are notmet, macromodules are treated as if they were ordinary modules.
Gotchas!
The same keyword, endmodule"
"modules and
macromodule s.
Synthesis
Each module is synthesized as a separate hierarchical block, allowing you to
control the hierarchy of the synthesized netlist, although some tools flatten thehierarchy by default.
Not all tools support macromodules.
Tips
Have only one module per file. This eases source code maintenance for alarge design.
Example
macromodule nand2 (f, a, b);  output f;  input a, b;
  nand (f, a, b);
endmodule"
"module PYTHAGORAS (X, Y, Z);  input  [63:0] X, Y;  output [63:0] Z;
  parameter Epsilon = 1.0E-6;
  real RX, RY, X2Y2, A, B;
  always @(X or Y)
  begin    RX = $bitstoreal(X);    RY = $bitstoreal(Y);    X2Y2 = (RX * RX) + (RY * RY);    B = X2Y2;    A = 0.0;
    while ((A - B) > Epsilon || (A - B) < -Epsilon)
    begin      A = B;      B = (A + X2Y2 / A) / 2.0;    end  end  assign Z = $realtobits(A);endmodule"
"module Separate;
  parameter P = 5; //  Separate.P
endmodule"
"module Top;
  reg R; //  Top.R
  Bottom U1();
endmodule"
"module Bottom;
  reg R; //  Top.U1.R
  task T; //  Top.U1.T
    reg R; //  Top.U1.T.R;
    ...
  endtask
  initial
  begin : InitialBlock
    reg R; //  Top.U1.InitialBlock.R;
    $display(Bottom.R); //  Upwards name reference to Top.U1.R
    $display(U1.R); //  Upwards name reference to Top.U1.R
    ...
  endendmodule"
"module instances, orcontinuous assignments.
Syntax
{either}
NetType [Expansion ] [Range ] [Delay ] NetName,...;
trireg [ Expansion ] [Strength ] [Range ] [Delay ]
  NetName,...;
{Net declaration with continuous assignment}
NetType [Expansion ] [Strength ] [Range ] [Delay ]
  NetAssign,... ;
NetAssign = NetName = Expression
NetType = {either}
  wire tri {equivalent}
  wor trior {equivalent}
  wand triand {equivalent}
  tri0
  tri1  supply0  supply1
Expansion  = {either}  vectored scalared
Range  = [ConstantExpression :ConstantExpression ]
Where
module-<HERE>-endmodule"
module-<HERE>-endmodule
"module Shifter (Clock, In, Out, Load, Data);
  parameter NBits = 8;  input Clock, In, Load;  input [NBits-1:0] Data;  output Out;
  always @(posedge Clock)
    if (Load)      ShiftReg <= Data;    else      ShiftReg <= {ShiftReg[NBits-2:0], In}
  assign Out = ShiftReg[NBits-1];
endmodule"
"module TestShifter;
  ...
  defparam U2.NBits = 10;
  Shifter #(16) U1 (...); //  16-bit shift register
  Shifter U2 (...) //  10-bit shift register
endmodule"
"modules model the pins or edge connectors of hardware
components.
Syntax
{definition}
{either}
PortExpression {ordered list}
.PortName([ PortExpression ]) {named list}
PortExpression  = {either}
  PortReference
  {PortReference ,...}
PortReference  = {either}
  Name
  Name[ConstantExpression ]
  Name[ConstantExpression :ConstantExpression ]
{declaration}
{either}
input  [Range ] Name,...; {of port reference}
output  [Range ] Name,...; {of port reference}
inout [ Range ] Name,...; {of port reference}
Range  = [ConstantExpression :ConstantExpression ]
{In a part-select or range, the left-hand expression is the MSB and the right-hand
expression is the LSB }
Where
module (<HERE>); {definition}
  <HERE> {declaration}
  ...
endmodule"
module-<HERE>-endmodule
module-<HERE>-endmodule
"module M (F, G, Q, Qb, W, A, B, D, V, Clk, Rst, X, Z);
  input A, B, D, Clk, Rst, X;  input [7:0] V;  output F, G, Q, Qb, Z;  output [7:0] W;  reg C;
// Functional Description ...
  specify
    specparam TLH$Clk$Q    = 3,              THL$Clk$Q    = 4,              TLH$Clk$Qb   = 4,              THL$Clk$Qb   = 5,              Tsetup$Clk$D = 2.0,
              Thold$Clk$D  = 1.0;
// Simple path, full connection
    (A, B *> F) = (1.2:2.3:3.1, 1.4:2.0:3.2);
// Simple path, parallel connection, positive polarity
    (V + => W) = 3,4,5;
// Edge-sensitive paths, with polarity
    (posedge Clk *> Q +: D) = (TLH$Clk$Q,THL$Clk$Q);
    (posedge Clk *> Qb -: D) = (TLH$Clk$Qb,THL$Clk$Qb);
// State dependent paths
    if (C) (X *> Z) = 5;
    if (!C && V == 8'hff) (X *> Z) = 4;
    ifnone (X *> Z) = 6; //  Default SDPD, X to Z
// Timing checks
    $setuphold(posedge Clk, D,
               Tsetup$Clk$D, Thold$Clk$D, Err);  endspecify
endmodule"
module-<HERE>-endmodule
"module to tag it as a library cell. Cells
are used by certain PLI routines for applications such as delay calculators.
Example:
`celldefine
module Nand2 (...); //  Nand2 is a ‘cell’
  ...
endmodule"
"modules in an hierarchical design. This is useful duringsynthesis, when it may be necessary to simulate a mixture of RTL andsynthesized gates for a design.
`define SUBBLOCK1 subblock1_rtl
`define SUBBLOCK2 subblock2_rtl
`define SUBBLOCK3 subblock3_gates
module TopLevel ...  `SUBBLOCK1 sub1_inst (...);
  `SUBBLOCK2 sub2_inst (...);  `SUBBLOCK3 sub3_inst (...);
  ...
endmodule"
"module, or to selectively turn on the writing of diagnostic messages.
Example
`define primitiveModel
module Test;
...`ifdef primitiveModel  MyDesign_primitives UUT (...);`else  MyDesign_RTL UUT (...);`endif
endmodule"
"modules,
with 1 meaning the specified levels of hierarchy only, and 0 meaning the
specified levels, and all instances below.
If no arguments are given, all the variables in the design are dumped.
FileSize is the maximum dump file size, in bytes.
$dumpvars may be called more than once, but each call must be at the sametime (usually the start of simulation).
Example
module Test;
  ...
  initial
  begin    $dumpfile(""results.vcd"");    $dumpvars(1, Test);  end
// Perform periodic checkpointing of the design.
  initial
    forever      #10000 $dumpall;
endmodule"
"prod1
//Prod1
module s4(clk,rst,d,l,q3);

input clk,rst,l,d;
output reg [7:0] q3;

always @(negedge clk)
begin
if(rst)
q3<=7'd0;
else if(l)
q3<=q3;
else
begin
q3[0]<=q3[1];
q3[1]<=q3[2];
q3[2]<=q3[3];
q3[3]<=q3[4];
q3[4]<=q3[5];
q3[5]<=q3[6];
q3[6]<=q3[7];
q3[7]<=d;
end
end
endmodule
"
"SR2
//SR

module s3(clk,rst,d,l,q2);

input clk,rst,l;
input [7:0] d;
output reg [7:0] q2;

always @(posedge clk)
begin
if(rst)
q2=0;
else if(l)
q2=q2;
else
q2=d;
end
endmodule
"
"adder
//Adder
 
 module adder(a,b,c,s);
 input [7:0] a,b;
 output [7:0] s;
 output c; 
 assign {c,s}=a+b;
 endmodule
"
"pipo
//PIPO
module s1(rst,d,clk,q,l);

input clk,l,rst;
input [7:0] d;
output reg [7:0] q;

always @(posedge clk)
begin
if(rst)
q=0;
else if(l)
q=d;
end
endmodule
"
"SR1
//SR

module s2(rst,l_s,clk,q1,d);

input l_s,clk,rst;
input [7:0] d;
output reg [7:0] q1;

always @(posedge clk)
begin
if(rst)
q1=0;
else if(l_s)
q1=d;
else
q1=q1>>1;
end
endmodule
"
"sequential_multiplication

module final12 (a,b,op,load,reset,clk,valid);
input [7:0] a,b;
output [15:0] op;
output valid;
input clk,reset,load;
wire [7:0] x,y,z,s,po,lo;
wire c,v1,l,t;

s1 u1 (reset,a,clk,x,load);
s2 u2 (reset,load,clk,z,b);
assign y=x & {8{z[0]}};
counter u5 (t,l,clk);
assign valid=l;
adder u3 (y,po,c,s);
s3 u4 (clk,v1,{c,s[7:1]},l,po);
 s4 e1 (clk,v,s[0],l,lo);
assign op={po,lo};
assign v1= reset|load;
assign t=reset|load;

always @(l)
begin
if(op==a*b)
$display(""the product of a=%d ,b=%d  is p=%d"",a,b,op);
else
$display(""Incorrect operation"");
end
endmodule
"
"counter
 //Counter 

module counter(reset,l,clk);

input reset,clk;
output reg l;
integer i;

always @(posedge clk)
begin
if(reset)
begin
i=0;
l=0;
end
else
begin
if(i==7)
l=1;
else
begin
i=i+1;
l=0;
end
end
end
endmodule
"
"fixed_point_divider
module qdiv #(
	//Parameterized values
	parameter Q = 15,
	parameter N = 32
	)
	(
	input 	[N-1:0] i_dividend,
	input 	[N-1:0] i_divisor,
	input 	i_start,
	input 	i_clk,
	output 	[N-1:0] o_quotient_out,
	output 	o_complete,
	output	o_overflow
	);
 
	reg [2*N+Q-3:0]	reg_working_quotient;	
	reg [N-1:0] 		reg_quotient;				
	reg [N-2+Q:0] 		reg_working_dividend;	
	reg [2*N+Q-3:0]	reg_working_divisor;		
 
	reg [N-1:0] 			reg_count; 		
													
										 
	reg					reg_done;			
	reg					reg_sign;			
	reg					reg_overflow;		
 
	initial reg_done = 1'b1;				
	initial reg_overflow = 1'b0;			
	initial reg_sign = 1'b0;				

	initial reg_working_quotient = 0;	
	initial reg_quotient = 0;				
	initial reg_working_dividend = 0;	
	initial reg_working_divisor = 0;		
 	initial reg_count = 0; 		

 
	assign o_quotient_out[N-2:0] = reg_quotient[N-2:0];	
	assign o_quotient_out[N-1] = reg_sign;						
	assign o_complete = reg_done;
	assign o_overflow = reg_overflow;
 
	always @( posedge i_clk ) begin
		if( reg_done && i_start ) begin										
			
			reg_done <= 1'b0;														
			reg_count <= N+Q-1;											
			reg_working_quotient <= 0;									
			reg_working_dividend <= 0;									
			reg_working_divisor <= 0;									
			reg_overflow <= 1'b0;										

			reg_working_dividend[N+Q-2:Q] <= i_dividend[N-2:0];				
			reg_working_divisor[2*N+Q-3:N+Q-1] <= i_divisor[N-2:0];		

			reg_sign <= i_dividend[N-1] ^ i_divisor[N-1];		
			end 
		else if(!reg_done) begin
			reg_working_divisor <= reg_working_divisor >> 1;	
			reg_count <= reg_count - 1;								

			//	If the dividend is greater than the divisor
			if(reg_working_dividend >= reg_working_divisor) begin
				reg_working_quotient[reg_count] <= 1'b1;										
				reg_working_dividend <= reg_working_dividend - reg_working_divisor;	
				end
 
			//stop condition
			if(reg_count == 0) begin
				reg_done <= 1'b1;										
				reg_quotient <= reg_working_quotient;			
				if (reg_working_quotient[2*N+Q-3:N]>0)
					reg_overflow <= 1'b1;
					end
			else
				reg_count <= reg_count - 1;	
			end
		end
endmodule

module Test_Div;

	// Inputs
	reg [31:0] i_dividend;
	reg [31:0] i_divisor;
	reg i_start;
	reg i_clk;

	// Outputs
	wire [31:0] o_quotient_out;
	wire o_complete;
	wire o_overflow;

	// Instantiate the Unit Under Test (UUT)
	qdiv uut (
		.i_dividend(i_dividend), 
		.i_divisor(i_divisor), 
		.i_start(i_start), 
		.i_clk(i_clk), 
		.o_quotient_out(o_quotient_out), 
		.o_complete(o_complete), 
		.o_overflow(o_overflow)
	);

	reg [10:0]	count;

	initial begin
		// Initialize Inputs
		i_dividend = 1;
		i_divisor = 1;
		i_start = 0;
		i_clk = 0;
		
		count <= 0;

		// Wait 100 ns for global reset to finish
		#100;

		// Add stimulus here
		forever #2 i_clk = ~i_clk;
	end
        
		always @(posedge i_clk) begin
			if (count == 47) begin
				count <= 0;
				i_start <= 1'b1;
				end
			else begin				
				count <= count + 1;
				i_start <= 1'b0;
				end
			end

		always @(count) begin
			if (count == 47) begin
				if ( i_divisor > 32'h1FFFFFFF ) begin
					i_divisor <= 1;
					i_dividend = (i_dividend << 1) + 3;
					end
				else
					i_divisor = (i_divisor << 1) + 1;
				end
			end
			
	always @(posedge o_complete)
		$display (""%b,%b,%b, %b"", i_dividend, i_divisor, o_quotient_out, o_overflow);		

endmodule
"
"fixed_point_multiplier
module qmult #(
	//Parameterized values
	parameter Q = 15,
	parameter N = 32
	)
	(
	 input			[N-1:0]	i_multiplicand,
	 input			[N-1:0]	i_multiplier,
	 output			[N-1:0]	o_result,
	 output	reg				ovr
	 );
	 
	
	
	reg [2*N-1:0]	r_result;		
											
	reg [N-1:0]		r_RetVal;
	

	assign o_result = r_RetVal;	
	
	always @(i_multiplicand, i_multiplier)	begin						
		r_result <= i_multiplicand[N-2:0] * i_multiplier[N-2:0];	
																
		ovr <= 1'b0;															
		end
	
		
	always @(r_result) begin													
		r_RetVal[N-1] <= i_multiplicand[N-1] ^ i_multiplier[N-1];	
		r_RetVal[N-2:0] <= r_result[N-2+Q:Q];								
																						
		if (r_result[2*N-2:N-1+Q] > 0)										
			ovr <= 1'b1;
		end

endmodule
module Test_mult;

	// Inputs
	reg [31:0] i_multiplicand;
	reg [31:0] i_multiplier;

	// Outputs
	wire [31:0] o_result;
	wire			ovr;
	
	// Instantiate the Unit Under Test (UUT)
	qmult #(19,32) uut (
		.i_multiplicand(i_multiplicand), 
		.i_multiplier(i_multiplier), 
		.o_result(o_result),
		.ovr(ovr)
	);

	initial begin
		$monitor (""%b,%b,%b,%b"", i_multiplicand, i_multiplier, o_result, ovr);		
		
		// Initialize Inputs
 		i_multiplicand = 32'b00000000000110010010000111111011;	//pi = 3.141592
		i_multiplicand[31] = 0;												
		i_multiplier[31] = 0;												
		i_multiplier[30:0] = 0;

		// Wait 100 ns for global reset to finish
		#100;
		#100 i_multiplier[0] = 1;		//	1.91E-6
  	end

	// Add stimulus here
	always begin
		#10 i_multiplier[30:0] = (i_multiplier[30:0] << 1) + 1;		
	end
      
endmodule
"
"bcd_adder
module bcd_adder(a,b,cin,sum,cout);
    input [3:0] a,b;
    input cin;
    output [3:0] sum;
    output cout;
    reg [4:0] temp;
    reg [3:0] sum;
    reg cout;  

    always @(a,b,cin)
    begin
        temp = a+b+cin; 
        if(temp > 9)    
	begin
            temp = temp+6; //add 6, if result is more than 9.
            cout = 1;  //set the carry output
            sum = temp[3:0];   
   	end
        else    
	begin
            cout = 0;
            sum = temp[3:0];
        end
    end     

endmodule


module tb_bcdadder;

    reg [3:0] a;
    reg [3:0] b;
    reg cin;

    wire [3:0] sum;
    wire cout;

    bcd_adder uut (
        .a(a), 
        .b(b), 
        .cin(cin), 
        .sum(sum), 
        .cout(cout)
    );

    initial begin
        a = 0;  b = 0;  cin = 0;   #100;
        a = 6;  b = 9;  cin = 0;   #100;
        a = 3;  b = 3;  cin = 1;   #100;
        a = 4;  b = 5;  cin = 0;   #100;
        a = 8;  b = 2;  cin = 0;   #100;
        a = 9;  b = 9;  cin = 1;   #100;
    end
      
endmodule
"
"mealy
module state_machine_mealy(clk, reset, in, out);
parameter zero=0, one1=1, two1s=2;
output out; input clk, reset, in;
reg out; reg [1:0] state, next_state;
// Implement the state register
always @(posedge clk or posedge reset) begin
 if (reset)
 state <= zero;
 else
 state <= next_state;
 end
always @(state or in) begin
 case (state)
 zero: begin //last input was a zero out = 0;
 if (in)
 next_state=one1;
 else
 next_state=zero;
 end
 one1: begin //we've seen one 1 out = 0;
 if (in)
 next_state=two1s;
 else
 next_state=zero;
 end
 two1s: begin //we've seen at least 2 ones out = 1;
 if (in) 
 next_state=two1s;
 else
 next_state=zero;
 end
 default: //in case we reach a bad state out = 0;
 next_state=zero;
 endcase
end
// output logic
always @(state) begin
 case (state)
 zero: out <= 0;
 one1: out <= 0;
 two1s: out <= 1;
 default : out <= 0;
 endcase
end
endmodule

module state_machine_mealy_tb();
reg clk, reset, in;
wire out;
integer i;

state_machine_mealy dut(clk, reset, in, out);
initial 
forever #5 clk = ~clk;

initial begin
reset = 1'b1;
clk = 1'b0;
in = 0 ;
#6;
reset = 1'b0;

for (i = 0; i<10 ; i = i+1)
begin 
	@(negedge clk); #1;
in = $random;
if (out == 1'b1)
$display(""PASS: Sequence 11 detected i = %d\n"", i);
end
#50;
$finish;
end
endmodule
"
"moore
module state_machine_moore(clk, reset, in, out);
parameter zero=0, one1=1, two1s=2;
output out; input clk, reset, in;
reg out; reg [1:0] state, next_state;
// Implement the state register
always @(posedge clk or posedge reset) begin
 if (reset)
 state <= zero;
 else
 state <= next_state;
 end
always @(state or in) begin
 case (state)
 zero: begin //last input was a zero out = 0;
 if (in)
 next_state=one1;
 else
 next_state=zero;
 end
 one1: begin //we've seen one 1 out = 0;
 if (in)
 next_state=two1s;
 else
 next_state=zero;
 end
 two1s: begin //we've seen at least 2 ones out = 1;
 if (in)
 next_state=two1s;
 else
 next_state=zero;
 end
 default: //in case we reach a bad state out = 0;
 next_state=zero;
 endcase
end
// output logic
always @(state) begin
 case (state)
 zero: out <= 0;
 one1: out <= 0;
 two1s: out <= 1;
 default : out <= 0;
 endcase
end
endmodule

module state_machine_moore_tb();
reg clk, reset, in;
wire out;
integer i;

state_machine_moore dut(clk, reset, in, out);
initial 
forever #5 clk = ~clk;

initial begin
reset = 1'b1;
clk = 1'b0;
in = 0 ;
#6;
reset = 1'b0;

for (i = 0; i<10 ; i = i+1)
begin 
	@(negedge clk); #1;
in = $random;
if (out == 1'b1)
$display(""PASS: Sequence 11 detected i = %d\n"", i);
end
#50;
$finish;
end
endmodule
"
"complex_multiplication
module compmul(c1,c2,product);
input [15:0]c1,c2;
output [31:0]product;
assign product={((c1[15:8]*c2[15:8])-(c1[7:0]*c2[7:0])),((c1[15:8]*c2[7:0])+(c1[7:0]*c2[15:8]))};
endmodule

module compmul_tb();
 reg [15:0]c1,c2;
 wire [31:0]product;
 compmul a(c1,c2,product);
 initial
 begin
 c1<=16'b0000001000000010;
 c2<=16'b0000011000000010;
 #50
 $display(""output for mul %b"",product);
 c1<=16'b00001111100001000;
 c2<=16'b00000000000010000;
 #50
 $display(""output for mul %b"",product);
 c1<=16'b0000101110001000;
 c2<=16'b0000000000001000;
 #50
 $display(""output for mul %b"",product);
 c1<=16'b0000100000001000;
 c2<=16'b0001111000001000;
 #50
 $display(""output for mul %b"",product);
 c1<=16'b0000100001101000;
 c2<=16'b0000001000001000;
 #50
 $display(""output for mul %b"",product);
 c1<=16'b0000100000001000;
 c2<=16'b0001111111101000;
 #50
 $display(""output for mul %b"",product);
 c1<=16'b1111111111111111;
 c2<=16'b1111111111111111;
 #50
 $display(""output for mul %b"",product);

 end
endmodule



"
"binary_divider

"
"pipelined_multiplier
module MULTI_32bit(clk, rst,A, B, F);
   `define BIAS 8'b01111111
   input clk, rst;
   input [31:0]A;
   input [31:0]B;

   output [31:0]F;
   reg [31:0]F;
	

//   reg [1:0]sign;
//   reg [49:0]mantissa;


//////////////// PIPE-LINE REGISTERS /////////////////
reg [62:0] P1;
reg [66:0] P2;
reg [31:0] P3;
//////////////////////////////////////////////////////

initial
begin	
	P1 = 0;
	P2 = 0;
	P3 = 0;
end


wire [1:0]sign;
wire [49:0]mantissa;

assign sign = A[31]+B[31];

//always @ ( F or A or B )
always @ ( posedge clk )
begin
	//solve for the sign bit part
	/////////////////////////////////////////////////////////
	P1[0] <= (sign == 1'b1) ? 1'b1 : 1'b0;
	P1[31:1] <= A[30:0];
	P1[62:32] <= B[30:0];

	///////////////////////////////////////////////////////////
	P2[0] <= P1[0];
	P2[50:1] <= P1[23:1] * P1[54:32];

	P2[58:51] <= P1[31:24];
	P2[66:59] <= P1[62:55];

///////////////////////////////////////////////////////////
	P3[0] <= P2[0];

	if(P2[50:24] == 0) begin
	   P3[23:1] = P2[23:1];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h00;
	end
	else if(P2[50] == 1) begin
	   P3[23:1] = P2[49:27];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h1a;
	end
	else if(P2[49] == 1) begin
	   P3[23:1] = P2[48:26];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h19;
	end
	else if(P2[48] == 1) begin
	   P3[23:1] = P2[47:25];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h18;
	end
	else if(P2[47] == 1) begin
	   P3[23:1] = P2[46:24];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h17;
	end			
	else if(P2[46] == 1) begin
	   P3[23:1] = P2[45:23];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h16;
	end	
	else if(P2[45] == 1) begin
	   P3[23:1] = P2[44:22];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h15;
	end	
	else if(P2[44] == 1) begin
	   P3[23:1] = P2[43:21];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h14;
	end
	else if(P2[43] == 1) begin
	   P3[23:1] = P2[42:20];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h13;
	end
	else if(P2[42] == 1) begin
	   P3[23:1] = P2[41:19];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h12;
	end
	else if(P2[41] == 1) begin
	   P3[23:1] = P2[40:18];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h11;
	end
	else if(P2[40] == 1) begin
	   P3[23:1] = P2[39:17];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h10;
	end
	else if(P2[39] == 1) begin
	   P3[23:1] = P2[38:16];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h0f;
	end
	else if(P2[38] == 1) begin
	   P3[23:1] = P2[37:15];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h0e;
	end
	else if(P2[37] == 1) begin
	   P3[23:1] = P2[36:14];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h0d;
	end
	else if(P2[36] == 1) begin
	   P3[23:1] = P2[35:13];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h0c;
	end
	else if(P2[35] == 1) begin
	   P3[23:1] = P2[34:12];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h0b;
	end
	else if(P2[34] == 1) begin
	   P3[23:1] = P2[33:11];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h0a;
	end
	else if(P2[33] == 1) begin
	   P3[23:1] = P2[32:10];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h09;
	end
	else if(P2[32] == 1) begin
	   P3[23:1] = P2[31:09];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h08;
	end
	else if(P2[31] == 1) begin
	   P3[23:1] = P2[30:08];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h07;
	end
	else if(P2[30] == 1) begin
	   P3[23:1] = P2[29:07];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h06;
	end
	else if(P2[29] == 1) begin
	   P3[23:1] = P2[28:06];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h05;
	end
	else if(P2[28] == 1) begin
	   P3[23:1] = P2[27:05];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h04;
	end
	else if(P2[27] == 1) begin
	   P3[23:1] = P2[26:04];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h03;
	end
	else if(P2[26] == 1) begin
	   P3[23:1] = P2[25:03];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h02;
	end
	else begin
	   P3[23:1] = P2[24:02];
	   P3[31:24] = P2[58:51] + P2[66:59] - `BIAS + 8'h01;
	end

///////////////////////////////////////////////////////////
	F[31] <= P3[0];
	F[30:0] <= P3[31:1];

////////////////////////////////////////////////////////////
end

endmodule



"
"high_radix_multiplication


module multiplier (clk,reset,x,y,out);
input clk,reset;
input  [15:0] x,y;
output reg [31:0] out;

reg [2:0] c=0 ;
 
reg   [31:0] pp=0; //partial products
reg   [31:0] spp=0; //shifted partial products
reg   [31:0] prod=0;
reg [15:0] i=0,j=0;
reg flag=0, temp=0 ;
wire [15:0] inv_x ;
//assign x= (~x) +1'b1;
assign inv_x = (~x) +1'b1;
always@(posedge clk)
begin
if(reset)
begin
out=0;
c=0;
pp=0;
flag=0;
spp=0;
i=0;
j=0;
prod=0;
end
else begin
 
if(!flag)
c={y[1],y[0],1'b0};
flag=1;
case(c)
////////////////////////
3'b000,3'b111: begin
if(i<8)
begin  i=i+1;
c={y[2*i+1],y[2*i],y[2*i-1]}; end
else
c=3'bxxx;
end
////////////////////////////
3'b001,3'b010:
begin
if(i<8)
begin
i=i+1;
c={y[2*i+1],y[2*i],y[2*i-1]};
pp={{16{x[15]}},x};
if(i==1'b1)
prod=pp;
else
begin
temp=pp[31];
j=i-1;
j=j<<1;
spp=pp<<j;
spp={temp,spp[30:0]};
prod=prod+spp;
end
end
else c=3'bxxx;
end
///////////////////////////
3'b011:
begin
if(i<8)
begin
i=i+1;
c={y[2*i+1],y[2*i],y[2*i-1]};
pp={{15{x[15]}},x,1'b0};
if(i==1'b1)
prod=pp;
else
begin
temp=pp[31];
j=i-1;
j=j<<1;
spp=pp<<j;
spp={temp,spp[30:0]};
prod=prod+spp;
end
end
else c=3'bxxx;
end
///////////////////////////
3'b100:
begin
if(i<8)
begin
i=i+1;
c={y[2*i+1],y[2*i],y[2*i-1]};
pp={{15{inv_x[15]}},inv_x,1'b0};
if(i==1'b1)
prod=pp;
else
begin
temp=pp[31];
j=i-1;
j=j<<1;
spp=pp<<j;
spp={temp,spp[30:0]};
prod=prod+spp;
end
end
else c=3'bxxx;
end
////////////////////////////////////
3'b101, 3'b110:
begin
if(i<8)
begin
i=i+1;
c={y[2*i+1],y[2*i],y[2*i-1]};
pp={{16{inv_x[15]}},inv_x};
if(i==1'b1)
prod=pp;
else
begin
temp=pp[31];
j=i-1;
j=j<<1;
spp=pp<<j;
spp={temp,spp[30:0]};
prod=prod+spp;
end
end
else c=3'bxxx;
end
////////////////
default:
out= prod;
endcase
end
end
 
endmodule
"
"fraction_multiplication
`define M B[0]
 module fraction_multiplication (CLK, St, Mplier, Mcand, Product, Done);
 input CLK;
 input St;
 input[3:0] Mplier;
 input[3:0] Mcand;
 output[6:0] Product;
 output Done;
 reg[2:0] State;
 reg[3:0] A;
 reg[3:0] B;
 reg[3:0] addout;
 initial
 begin
 State = 0;
 end
 
 always @(posedge CLK)
 begin
 case (State)
 0 :
 begin
 if (St == 1'b1)
 begin
 A <= 4'b0000 ;
 B <= Mplier ;
   State <= 1 ;
 end
 else
 State <= 0;
 end
 1, 2, 3 :
 begin
 if (`M == 1'b1)
 begin
 addout = A + Mcand;
 A <= {Mcand[3], addout[3:1]} ;
 B <= {addout[0], B[3:1]} ;
 end
 else
 begin
 A <= {A[3], A[3:1]} ;
 B <= {A[0], B[3:1]} ;
 end
 State <= State + 1 ;
 end
 4 :
 begin
 if (`M == 1'b1)
 begin
 addout = A + ~Mcand + 1;
 A <= {~Mcand[3], addout[3:1]} ;
 B <= {addout[0], B[3:1]} ;
 end
 else
 begin
 A <= {A[3], A[3:1]} ;
 B <= {A[0], B[3:1]} ;
 end
 State <= 5 ;
 end
 5 :
 begin
 State <= 0 ;
 end
 
 default :
 begin
 State <= 0 ;
 end
 endcase
 end
 assign Done = (State == 5) ? 1'b1 : 1'b0 ;
 assign Product = {A[2:0], B} ;
endmodule
"
"log
module logarithm(input [31:0] a,b,output [127:0] a_out, b_out);
  assign a_out = 1000000000 * $ln(a);
  assign b_out = 1000000000 * $log10(b);
endmodule

module logarithm_tb;
  reg [31:0] a;
  reg [31:0] b;
  wire [127:0] a_out;
  wire [127:0] b_out;
  logarithm uut(a,b,a_out,b_out);
initial begin
a=0;b=0;
#20 a= 123;b=123;
#20 a =4;b=4; 
#20 a=234;b=34;
end

initial 
  $monitor("" a = %d, b = %d, ln(a) = %d, log10(b) = %d"",a,b,a_out,b_out);

endmodule
"
"carry_skip_adder
module carry_skip_16bit(a, b, cin, sum, cout);
input [15:0] a,b;
input cin;
output cout;
output [15:0] sum;
 
wire [2:0] c;
 
carry_skip_4bit csa1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(c[0]));
carry_skip_4bit csa2 (.a(a[7:4]), .b(b[7:4]), .cin(c[0]), .sum(sum[7:4]), .cout(c[1]));
carry_skip_4bit csa3(.a(a[11:8]), .b(b[11:8]), .cin(c[1]), .sum(sum[11:8]), .cout(c[2]));
carry_skip_4bit csa4(.a(a[15:12]), .b(b[15:12]), .cin(c[2]), .sum(sum[15:12]), .cout(cout));
 
endmodule
 
module carry_skip_4bit(a, b, cin, sum, cout);
input [3:0] a,b;
input cin;
output [3:0] sum;
output cout;
wire [3:0] p;
wire c0;
wire bp;
 
ripple_carry_4_bit rca1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(c0));
generate_p p1(a,b,p,bp);
mux2X1 m0(.in0(c0),.in1(cin),.sel(bp),.out(cout));
 
endmodule
 
module generate_p(a,b,p,bp);
input [3:0] a,b;
output [3:0] p;
output bp;
assign p= a^b;
assign bp= &p;
endmodule
 

module ripple_carry_4_bit(a, b, cin, sum, cout);
input [3:0] a,b;
input cin;
wire c1,c2,c3;
output [3:0] sum;
output cout;
 
full_adder fa0(.a(a[0]), .b(b[0]),.cin(cin), .sum(sum[0]),.cout(c1));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]),.cout(c2));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]),.cout(c3));
full_adder fa3(.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]),.cout(cout));
endmodule
 
module full_adder(a,b,cin,sum, cout);
input a,b,cin;
output sum, cout;
wire x,y,z;
half_adder h1(.a(a), .b(b), .sum(x), .cout(y));
half_adder h2(.a(x), .b(cin), .sum(sum), .cout(z));
or or_1(cout,z,y);
endmodule


module half_adder( a,b, sum, cout );
input a,b;
output sum, cout;
xor xor_1 (sum,a,b);
and and_1 (cout,a,b);
endmodule
 

module mux2X1( in0,in1,sel,out);
input in0,in1;
input sel;
output out;
assign out=(sel)?in1:in0;
endmodule


module carry_skip_16bit_tb;
wire [15:0] sum;
wire cout;
reg [15:0] a,b;
reg cin;
 
carry_skip_16bit uut(.a(a),.b(b),.cin(cin),.sum(sum),.cout(cout));
 
initial begin
     a=0; b=0; cin=0;
#10 a= 16'b0000000000000101; b=16'b000000000000101; cin=1'b1;
#10 a= 16'b0000000000011111; b=16'b000000000001100; cin=1'b0;
#10 a= 16'b0000000000011111; b=16'b000000000001100; cin=1'b0;
#10 a= 16'b1100011000011111; b=16'b000000110001100; cin=1'b1;
#10 a= 16'b1111111111111111; b=16'b000000000000000; cin=1'b1;
#10 a =16'b0000000000000001; b=16'b000000000000001; cin=1'b1;
#10 a =16'b0000000000000010; b=16'b000000000000010; cin=1'b1;
end
 
initial
$monitor(""time= "", $time, ""A=%b, B=&b, Cin=%b : Sum= %b, Cout=%cout"",a,b,cin,sum,cout);
endmodule
"
"carry_save_adder
module carry_save_adder(a,b,c,d, sum,cout);
  input [3:0] a, b,c,d;
output [4:0] sum;
output cout;
 
wire [3:0] s0,s1;
  wire [3:0] c0, c1;
 
//1st Statge
full_adder fa0( .a(a[0]), .b(b[0]), .cin(c[0]), .sum(s0[0]), .cout(c0[0]));
full_adder fa1( .a(a[1]), .b(b[1]), .cin(c[1]), .sum(s0[1]), .cout(c0[1]));
full_adder fa2( .a(a[2]), .b(b[2]), .cin(c[2]), .sum(s0[2]), .cout(c0[2]));
full_adder fa3( .a(a[3]), .b(b[3]), .cin(c[3]), .sum(s0[3]), .cout(c0[3]));
 
//2nd Stage
full_adder fa4( .a(d[0]), .b(s0[0]), .cin(1'b0), .sum(sum[0]), .cout(c1[0]));
full_adder fa5( .a(d[1]), .b(s0[1]), .cin(c0[0]), .sum(s1[0]), .cout(c1[1]));
full_adder fa6( .a(d[2]), .b(s0[2]), .cin(c0[1]), .sum(s1[1]), .cout(c1[2]));
full_adder fa7( .a(d[3]), .b(s0[3]), .cin(c0[2]), .sum(s1[2]), .cout(c1[3]));
 
 ripple_carry_4_bit rca1 (.a(c1[3:0]),.b({c0[3],s1[2:0]}), .cin(1'b0),.sum(sum[4:1]), .cout(cout));
 
endmodule

 
module ripple_carry_4_bit(a, b, cin, sum, cout);
input [3:0] a,b;
input cin;
wire c1,c2,c3;
output [3:0] sum;
output cout;
 
full_adder fa0(.a(a[0]), .b(b[0]),.cin(cin), .sum(sum[0]),.cout(c1));
full_adder fa1(.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]),.cout(c2));
full_adder fa2(.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]),.cout(c3));
full_adder fa3(.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]),.cout(cout));
endmodule
 
 
module full_adder(a,b,cin,sum, cout);
input a,b,cin;
output sum, cout;
wire x,y,z;
half_adder  h1(.a(a), .b(b), .sum(x), .cout(y));
half_adder  h2(.a(x), .b(cin), .sum(sum), .cout(z));
assign cout= y|z;
endmodule


module half_adder( a,b, sum, cout );
input a,b;
output sum,  cout;
assign sum= a^b;
assign cout= a & b;
endmodule

module carry_save_tb;
wire [4:0] sum;
wire cout;
reg [3:0] a,b,c,d;
 
 carry_save_adder uut(
.a(a),
.b(b),
.c(c),
 .d(d),
.sum(sum),
.cout(cout));
 
initial begin
$display($time, "" Starting the Simulation"");
     a=0; b=0; c=0; d=0;
  #100 a= 4'd10; b=4'd0; c=4'd0; d=4'd0;
  #100 a= 4'd10; b=4'd10; c=4'd0; d=4'd0;
  #100 a= 4'd4; b=4'd6; c=4'd12; d=4'd0;
  #100 a= 4'd11; b=4'd2; c=4'd4; d=4'd7;
  #100 a= 4'd20; b=4'd0; c=4'd20; d=4'd0;
  #100 a= 4'd12; b=4'd5; c=4'd10; d=4'd10;
  #100 a= 4'd7; b=4'd6; c=4'd12; d=4'd8;
  #100 a= 4'd15; b=4'd15; c=4'd15; d=4'd15;
 
end
 
initial
  $monitor(""A=%d, B=%d, C=%d,D=%d,Sum= %d, Cout=%d"",a,b,c,d,sum,cout);
endmodule
"
"dice_game

"
"fixed_point_subtractor
module qsubtract #(
	//Parameterized values
	parameter Q = 15,
	parameter N = 32
	)
	(
    input [N-1:0] a,
    input [N-1:0] b,
    output [N-1:0] c
    );

reg [N-1:0] res;

assign c = res;

always @(a,b) begin
	// both negative or both positive
	if(a[N-1] == b[N-1]) begin					
		res[N-2:0] = a[N-2:0] - b[N-2:0];		
		res[N-1] = a[N-1];							
														
															
		end												
	//	one of them is negative...
	else if(a[N-1] == 0 && b[N-1] == 1) begin		
		if( a[N-2:0] > b[N-2:0] ) begin					
			res[N-2:0] = a[N-2:0] + b[N-2:0];			
			res[N-1] = 0;										
			end
		else begin												
			res[N-2:0] = b[N-2:0] + a[N-2:0];		
			if (res[N-2:0] == 0)
				res[N-1] = 0;									
			else
				res[N-1] = 1;									
			end
		end
	else begin												
		if( a[N-2:0] > b[N-2:0] ) begin					
			res[N-2:0] = a[N-2:0] + b[N-2:0];			
			if (res[N-2:0] == 0)
				res[N-1] = 0;										
			else
				res[N-1] = 1;										
			end
		else begin												
			res[N-2:0] = b[N-2:0] + a[N-2:0];			
			res[N-1] = 0;										
			end
		end
	end
endmodule

module Test_subtract;

	// Inputs
	reg [31:0] a;
	reg [31:0] b;

	// Outputs
	wire [31:0] c;

	// Instantiate the Unit Under Test (UUT)
	qsubtract #(19,32) uut (
		.a(a), 
		.b(b), 
		.c(c)
	);

	//	These are to monitor the values...
	wire	[30:0]	c_out;
	wire	[30:0]	a_in;
	wire	[30:0]	b_in;
	wire				a_sign;
	wire				b_sign;
	wire				c_sign;
	
	
	assign	a_in = a[30:0];
	assign	b_in = b[30:0];
	assign	c_out = c[30:0];
	assign	a_sign = a[31];
	assign	b_sign = b[31];
	assign	c_sign = c[31];
	
	
	initial begin
		// Initialize Inputs
		a[30:0] = 0;
		a[31] = 0;
		b[31] = 1;
		b[30:0] = 0;

		// Wait 100 ns for global reset to finish
		#100;
        
		// Add stimulus here
		forever begin
			#1 a = a+5179347;			
			a[31] = 0;					// a is negative...
			b[31] = 1;
			
			
			if (a[30:0] > 2.1E9)			       // input will always be ""positive""
				begin
					a = 0;
					b[31] = 1;		       // b is negative...
					b[30:0] = b[30:0] + 3779351;
				end
		end

	end
      
endmodule
"
"fixed_point_adder
module qadd #(
	//Parameterized values
	parameter Q = 15,
	parameter N = 32
	)
	(
    input [N-1:0] a,
    input [N-1:0] b,
    output [N-1:0] c
    );

reg [N-1:0] res;

assign c = res;

always @(a,b) begin
	// both negative or both positive
	if(a[N-1] == b[N-1]) begin				
		res[N-2:0] = a[N-2:0] + b[N-2:0];	 	
		res[N-1] = a[N-1];				
															
															  
		end												
	//	one of them is negative...
	else if(a[N-1] == 0 && b[N-1] == 1) begin		
		if( a[N-2:0] > b[N-2:0] ) begin					
			res[N-2:0] = a[N-2:0] - b[N-2:0];			
			res[N-1] = 0;										
			end
		else begin												
			res[N-2:0] = b[N-2:0] - a[N-2:0];			
			if (res[N-2:0] == 0)
				res[N-1] = 0;										
			else
				res[N-1] = 1;										
			end
		end
	else begin												
		if( a[N-2:0] > b[N-2:0] ) begin					
			res[N-2:0] = a[N-2:0] - b[N-2:0];			
			if (res[N-2:0] == 0)
				res[N-1] = 0;										
			else
				res[N-1] = 1;										
			end
		else begin												
			res[N-2:0] = b[N-2:0] - a[N-2:0];			
			res[N-1] = 0;										
			end
		end
	end
endmodule

module Test_add;

	// Inputs
	reg [31:0] a;
	reg [31:0] b;

	// Outputs
	wire [31:0] c;

	// Instantiate the Unit Under Test (UUT)
	qadd #(19,32) uut (
		.a(a), 
		.b(b), 
		.c(c)
	);

	//	These are to monitor the values...
	wire	[30:0]	c_out;
	wire	[30:0]	a_in;
	wire	[30:0]	b_in;
	wire				a_sign;
	wire				b_sign;
	wire				c_sign;
	
	
	assign	a_in = a[30:0];
	assign	b_in = b[30:0];
	assign	c_out = c[30:0];
	assign	a_sign = a[31];
	assign	b_sign = b[31];
	assign	c_sign = c[31];
	
	
	initial begin
		// Initialize Inputs
		a[30:0] = 0;
		a[31] = 0;
		b[31] = 1;
		b[30:0] = 0;

		// Wait 100 ns for global reset to finish
		#100;
        
		// Add stimulus here
		forever begin
			#1 a = a+5179347;			
			a[31] = 0;					// a is negative...
			b[31] = 1;
			
			
			if (a[30:0] > 2.1E9)				// input will always be ""positive""
				begin
					a = 0;
					b[31] = 1;			// b is negative...
					b[30:0] = b[30:0] + 3779351;
				end
		end

	end
      
endmodule
"
"Multiplication
module Multiplication(input [31:0] a,input [31:0] b,output exception,overflow,underflow,output [31:0] res);

wire sign,round,normalised,zero;
wire [8:0] exponent,sum_exponent;
wire [22:0] product_mantissa;
wire [23:0] op_a,op_b;
wire [47:0] product,product_normalised; 


assign sign = a[31] ^ b[31];   													// XOR of 32nd bit
assign exception = (&a[30:23]) | (&b[30:23]);											// Execption sets to 1 when exponent of any a or b is 255
																// If exponent is 0, hidden bit is 0

assign op_a = (|a[30:23]) ? {1'b1,a[22:0]} : {1'b0,a[22:0]};
assign op_b = (|b[30:23]) ? {1'b1,b[22:0]} : {1'b0,b[22:0]};

assign product = op_a * op_b;													// Product
assign round = |product_normalised[22:0];  											// Last 22 bits are ORed for rounding off purpose
assign normalised = product[47] ? 1'b1 : 1'b0;	
assign product_normalised = normalised ? product : product << 1;								// Normalized value based on 48th bit
assign product_mantissa = product_normalised[46:24] + (product_normalised[23] & round); 					// Mantissa
assign zero = exception ? 1'b0 : (product_mantissa == 23'd0) ? 1'b1 : 1'b0;
assign sum_exponent = a[30:23] + b[30:23];
assign exponent = sum_exponent - 8'd127 + normalised;
assign overflow = ((exponent[8] & !exponent[7]) & !zero) ; 									// Overall exponent is greater than 255 then Overflow
assign underflow = ((exponent[8] & exponent[7]) & !zero) ? 1'b1 : 1'b0; 							// Sum of exponents is less than 255 then Underflow
assign res = exception ? 32'd0 : zero ? {sign,31'd0} : overflow ? {sign,8'hFF,23'd0} : underflow ? {sign,31'd0} : {sign,exponent[7:0],product_mantissa};

endmodule



module multiplication_tb;

reg [31:0] a,b;
wire exception,overflow,underflow;
wire [31:0] res;

reg clk = 1'b1;

Multiplication dut(a,b,exception,overflow,underflow,res);

always clk = #5 ~clk;

initial
begin
iteration (32'h0200_0000,32'h0200_0000,1'b0,1'b0,1'b0,32'h0000_0000,`__LINE__);

iteration (32'h4234_851F,32'h427C_851F,1'b0,1'b0,1'b0,32'h4532_10E9,`__LINE__); // 45.13 * 63.13 = 2849.0569;

iteration (32'h4049_999A,32'hC166_3D71,1'b0,1'b0,1'b0,32'hC235_5062,`__LINE__); //3.15 * -14.39 = -45.3285

iteration (32'hC152_6666,32'hC240_A3D7,1'b0,1'b0,1'b0,32'h441E_5375,`__LINE__); //-13.15 * -48.16 = 633.304

iteration (32'h4580_0000,32'h4580_0000,1'b0,1'b0,1'b0,32'h4B80_0000,`__LINE__); //4096 * 4096 = 16777216

iteration (32'h3ACA_62C1,32'h3ACA_62C1,1'b0,1'b0,1'b0,32'h361F_FFE7,`__LINE__); //0.00154408081 * 0.00154408081 = 0.00000238418

iteration (32'h0000_0000,32'h0000_0000,1'b0,1'b0,1'b0,32'h0000_0000,`__LINE__); // 0 * 0 = 0;

iteration (32'hC152_6666,32'h0000_0000,1'b0,1'b0,1'b0,32'h441E_5375,`__LINE__); //-13.15 * 0 = 0;

iteration (32'h7F80_0000,32'h7F80_0000,1'b1,1'b1,1'b0,32'h0000_0000,`__LINE__); 

$stop;

end

task iteration(
input [31:0] op_a,op_b,
input Expected_Exception,Expected_Overflow,Expected_Underflow,
input [31:0] Expected_result,
input integer linenum 
);
begin
@(negedge clk)
begin
	a = op_a;
	b = op_b;
end

@(posedge clk)
begin
if ((Expected_result == res) && (Expected_Exception == exception) && (Expected_Overflow == overflow) && (Expected_Underflow == underflow))
	$display (""Success : %d"",linenum);

else
	$display (""Failed : Expected_result = %h, Result = %h, \n Expected_Exception = %d, Exception = %d,\n Expected_Overflow = %d, Overflow = %d, \n Expected_Underflow = %d, Underflow = %d - %d \n "",Expected_result,res,Expected_Exception,exception,Expected_Overflow,overflow,Expected_Underflow,underflow,linenum);
end
end
endtask
endmodule
"
"array_multiplier
module array16(a,b,c);
 
    input [15:0]a,b;
    output [31:0]c;
     
    wire [15:0]q0,q1,q2,q3,q4,temp1;
    wire [31:0]c;
    wire [23:0]q5,q6,temp2,temp3,temp4;
     
    array8 z1(a[7:0],b[7:0],q0[15:0]);
    array8 z2(a[15:8],b[7:0],q1[15:0]);
    array8 z3(a[7:0],b[15:8],q2[15:0]);
    array8 z4(a[15:8],b[15:8],q3[15:0]);
    assign temp1 ={8'b0,q0[15:8]};
    assign q4 = q1[15:0]+temp1;
    assign temp2 ={8'b0,q2[15:0]};
    assign temp3 ={q3[15:0],8'b0};
    assign q5 = temp2+temp3;
    assign temp4={8'b0,q4[15:0]};
     
    assign q6 = temp4 + q5;
     
    assign c[7:0]=q0[7:0];
    assign c[31:8]=q6[23:0];
 
endmodule
 
module array2(a, b, c);
    input [1:0]a, b;
    output [3:0]c;
    wire [3:0]c, temp;
     
    assign c[0]=a[0]&b[0];
    assign temp[0]=a[1]&b[0];
    assign temp[1]=a[0]&b[1];
    assign temp[2]=a[1]&b[1];
    ha z1(temp[0],temp[1],c[1],temp[3]);
    ha z2(temp[2],temp[3],c[2],c[3]);
 
endmodule
 
module array4(a,b,c);
    input [3:0]a, b;
    output [7:0]c;
     
    wire [3:0]q0,q1,q2,q3,q4,temp1;
     
    wire [7:0]c;
    wire [5:0]q5,q6,temp2,temp3,temp4;
     
    array2 z1(a[1:0],b[1:0],q0[3:0]);
    array2 z2(a[3:2],b[1:0],q1[3:0]);
    array2 z3(a[1:0],b[3:2],q2[3:0]);
    array2 z4(a[3:2],b[3:2],q3[3:0]);
     
    assign temp1 ={2'b0,q0[3:2]};
    assign q4 = q1[3:0]+temp1;
    assign temp2 ={2'b0,q2[3:0]};
    assign temp3 ={q3[3:0],2'b0};
    assign q5 = temp2+temp3;
    assign temp4={2'b0,q4[3:0]};
    assign q6 = temp4+q5;
     
    assign c[1:0]=q0[1:0];
    assign c[7:2]=q6[5:0];
endmodule
 
module array8(a,b,c);
    input [7:0]a,b;
    output [15:0]c;
     
    wire [15:0]q0,q1,q2,q3,c;
    wire [7:0]q4,temp1;
    wire [11:0]q5,q6,temp2temp3,temp4;
     
    array4 z1(a[3:0],b[3:0],q0[15:0]);
    array4 z2(a[7:4],b[3:0],q1[15:0]);
    array4 z3(a[3:0],b[7:4],q2[15:0]);
    array4 z4(a[7:4],b[7:4],q3[15:0]);
     
    assign temp1 ={4'b0,q0[7:4]};
    assign q4 = q1[7:0]+temp1;
    assign temp2 ={4'b0,q2[7:0]};
    assign temp3 ={q3[7:0],4'b0};
    assign q5 = temp2+temp3;
    assign temp4={4'b0,q4[7:0]};
     
    
    assign q6 = temp4+q5;
     
    assign c[3:0]=q0[3:0];
    assign c[15:4]=q6[11:0];
endmodule
 
module ha(a,b,s,c);
    input a,b;
    output s,c;
     
    assign s = a^b;
    assign c = a&b;
endmodule
"
"D_FlipFlop
`timescale 1ns / 1ps

module D_FlipFlop(O , D , clk , clear);

input D , clk , clear;
output reg O;

always@(posedge clk , negedge clear)
begin
	
	if(clear == 1'b0)
		O <= 1'b0;
	else
		O <= D;
	
end
endmodule
"
"Universal_shift_reg
`timescale 1ns / 1ps
module Universal_shift_reg(O , clk , clear , S , I);

input clk , clear ;
input [2 : 0] S ; 
input [3 : 0] I; 
output [3 : 0] O;
wire [3 : 0] D_temp;

Mux_8_to_1 inst1(D_temp[0] , S , O[0] , 1'b0 , O[1] , I[0] , ~O[0] , O[3] , O[1] , O[2]);
Mux_8_to_1 inst2(D_temp[1] , S , O[1] , O[0] , O[2] , I[1] , ~O[1] , O[0] , O[2] , O[3]);
Mux_8_to_1 inst3(D_temp[2] , S , O[2] , O[1] , O[3] , I[2] , ~O[2] , O[1] , O[3] , O[0]);
Mux_8_to_1 inst4(D_temp[3] , S , O[3] , O[2] , 1'b0 , I[3] , ~O[3] , O[2] , O[0] , O[1]);

D_FlipFlop D_inst1(O[0] , D_temp[0] , clk , clear);
D_FlipFlop D_inst2(O[1] , D_temp[1] , clk , clear);
D_FlipFlop D_inst3(O[2] , D_temp[2] , clk , clear);
D_FlipFlop D_inst4(O[3] , D_temp[3] , clk , clear);

endmodule
"
"Mux_8_to_1
`timescale 1ns / 1ps

module Mux_8_to_1(Mux_Out , S , in0 , in1 , in2 , in3 , in4 , in5 , in6 , in7);

output reg Mux_Out;
input [2:0] S;
input in0 , in1 , in2 , in3 , in4 , in5 , in6 , in7;

always@(*)
begin
	case(S)
		
		3'b000 : Mux_Out = in0;
		3'b001 : Mux_Out = in1;
		3'b010 : Mux_Out = in2;
		3'b011 : Mux_Out = in3;
		3'b100 : Mux_Out = in4;
		3'b101 : Mux_Out = in5;
		3'b110 : Mux_Out = in6;
		3'b111 : Mux_Out = in7;
	endcase
end

endmodule
"
"booth_multiplication
module invert(output ib,input b);
	assign ib = ~b;
endmodule

module and2 (input wire i0, i1, output wire o);
  assign o = i0 & i1;
endmodule

module or2 (input wire i0, i1, output wire o);
  assign o = i0 | i1;
endmodule

module xor2 (input wire i0, i1, output wire o);
  assign o = i0 ^ i1;
endmodule

module nand2 (input wire i0, i1, output wire o);
   wire t;
   and2 and2_0 (i0, i1, t);
   invert invert_0 (t, o);
endmodule

module nor2 (input wire i0, i1, output wire o);
   wire t;
   or2 or2_0 (i0, i1, t);
   invert invert_0 (t, o);
endmodule

module xnor2 (input wire i0, i1, output wire o);
   wire t;
   xor2 xor2_0 (i0, i1, t);
   invert invert_0 (t, o);
endmodule

module and3 (input wire i0, i1, i2, output wire o);
   wire t;
   and2 and2_0 (i0, i1, t);
   and2 and2_1 (i2, t, o);
endmodule

module or3 (input wire i0, i1, i2, output wire o);
   wire t;
   or2 or2_0 (i0, i1, t);
   or2 or2_1 (i2, t, o);
endmodule

module nor3 (input wire i0, i1, i2, output wire o);
   wire t;
   or2 or2_0 (i0, i1, t);
   nor2 nor2_0 (i2, t, o);
endmodule

module nand3 (input wire i0, i1, i2, output wire o);
   wire t;
   and2 and2_0 (i0, i1, t);
   nand2 nand2_1 (i2, t, o);
endmodule

module xor3 (input wire i0, i1, i2, output wire o);
   wire t;
   xor2 xor2_0 (i0, i1, t);
   xor2 xor2_1 (i2, t, o);
endmodule

module xnor3 (input wire i0, i1, i2, output wire o);
   wire t;
   xor2 xor2_0 (i0, i1, t);
   xnor2 xnor2_0 (i2, t, o);
endmodule



module fa (input wire i0, i1, cin, output wire sum, cout);
   wire t0, t1, t2;
   xor3 _i0 (i0, i1, cin, sum);
   and2 _i1 (i0, i1, t0);
   and2 _i2 (i1, cin, t1);
   and2 _i3 (cin, i0, t2);
   or3 _i4 (t0, t1, t2, cout);
endmodule


module Adder(a,b,sum);
	input [7:0] a,b;
	output [7:0]sum;
	wire cout;
	wire [7:0] q;
	fa fa1(a[0],b[0],1'b0,sum[0],q[0]);
	fa fa2(a[1],b[1],q[0],sum[1],q[1]);
	fa fa3(a[2],b[2],q[1],sum[2],q[2]);
	fa fa4(a[3],b[3],q[2],sum[3],q[3]);
	fa fa5(a[4],b[4],q[3],sum[4],q[4]);
	fa fa6(a[5],b[5],q[4],sum[5],q[5]);
	fa fa7(a[6],b[6],q[5],sum[6],q[6]);
	fa fa8(a[7],b[7],q[6],sum[7],cout);
	
endmodule

module subtractor(a,b,sum);
	input [7:0] a,b;
	output [7:0]sum;
	wire [7:0] ib;
	wire cout;
	invert b1(ib[0],b[0]);
	invert b2(ib[1],b[1]);
	invert b3(ib[2],b[2]);
	invert b4(ib[3],b[3]);
	invert b5(ib[4],b[4]);
	invert b6(ib[5],b[5]);
	invert b7(ib[6],b[6]);
	invert b8(ib[7],b[7]);

	wire [7:0] q;
	fa fa1(a[0],ib[0],1'b1,sum[0],q[0]);
	fa fa2(a[1],ib[1],q[0],sum[1],q[1]);
	fa fa3(a[2],ib[2],q[1],sum[2],q[2]);
	fa fa4(a[3],ib[3],q[2],sum[3],q[3]);
	fa fa5(a[4],ib[4],q[3],sum[4],q[4]);
	fa fa6(a[5],ib[5],q[4],sum[5],q[5]);
	fa fa7(a[6],ib[6],q[5],sum[6],q[6]);
	fa fa8(a[7],ib[7],q[6],sum[7],cout);

endmodule



module booth_substep(input wire signed [7:0]a,Q,input wire signed q0,input wire signed [7:0] m,output reg signed [7:0] f8,output reg signed [7:0] l8,output reg cq0);
	wire [7:0] addam,subam;
	Adder myadd(a,m,addam);
	subtractor mysub(a,m,subam);
		always @(*) begin	
		if(Q[0] == q0) begin
			 cq0 = Q[0];
			l8 = Q>>1;
			 l8[7] = a[0];
			 f8 = a>>1;
			if (a[7] == 1)
			f8[7] = 1;
		end

		else if(Q[0] == 1 && q0 ==0) begin
			 cq0 = Q[0];
				l8 = Q>>1;
			 l8[7] = subam[0];
			 f8 = subam>>1;
			if (subam[7] == 1)
			f8[7] = 1;
		end

		else begin
			 cq0 = Q[0];
				l8 = Q>>1;
			 l8[7] = addam[0];
			 f8 = addam>>1;
			if (addam[7] == 1)
			f8[7] = 1;
		end
						
			
			
			 	
		
	
end	
endmodule 





 
module boothmul(input signed[7:0]a,b,output signed [15:0] c);
	wire signed [7:0]Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7;
	wire signed [7:0] m;
	wire signed [7:0] A1,A0,A3,A2;
	wire signed [7:0] A4,A5,A6,A7;
	wire signed[7:0] q0;
	wire qout;
	
	booth_substep step1(8'b00000000,a,1'b0,b,A1,Q1,q0[1]);
	booth_substep step2(A1,Q1,q0[1],b,A2,Q2,q0[2]);
	booth_substep step3(A2,Q2,q0[2],b,A3,Q3,q0[3]);
	booth_substep step4(A3,Q3,q0[3],b,A4,Q4,q0[4]);
	booth_substep step5(A4,Q4,q0[4],b,A5,Q5,q0[5]);
	booth_substep step6(A5,Q5,q0[5],b,A6,Q6,q0[6]);
	booth_substep step7(A6,Q6,q0[6],b,A7,Q7,q0[7]);
	booth_substep step8(A7,Q7,q0[7],b,c[15:8],c[7:0],qout);
	
	 
endmodule

module tb;
wire signed [15:0] z;
reg signed [7:0] a,b;


boothmul my_booth(.a(a),.b(b),.c(z));

initial begin 
end

initial
begin
$monitor($time,""Multiplication: %d * %d = %d"",a,b,z );
a = 8'b11110000;
b = 8'b11110000;

#10

a = 8'b10010101;
b = 8'b100000;

#10

a = 8'b0111;
b = 8'b0;

#10

b = 8'b1;
a = 8'b1;

#10  

a = 8'b00111100;
b = 8'b0101;

#10

a = 8'b10101010;
b = 8'b100011;

#10

a = 8'b010001;
b = 8'b11100;

#10
a = 8'b1000;
b = 8'b10111111;

end
endmodule
"
"CRC_32_parallel
//
module CRC_32_parallel(clk,rst,load,d_finish,crc_in,crc_out); 
input clk; //
input rst; //
input load; //
input d_finish; //
input [7:0] crc_in; //
output [7:0] crc_out; // 
reg [7:0] crc_out; //
reg [31:0] crc_reg; //
reg [1:0] count; //
reg [1:0] state; //
wire [31:0] next_crc_reg; //
parameter idle = 2'b00; //
parameter compute = 2'b01; //
parameter finish = 2'b10; //
//
assign next_crc_reg[0] = crc_reg[24] ^ crc_reg[30] ^ crc_in[0] ^ 
crc_in[6]; 
assign next_crc_reg[1] = crc_reg[24] ^ crc_reg[25] ^ crc_reg[30] ^ 
crc_reg[31] ^ crc_in[0] ^ crc_in[1] ^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[2] = crc_reg[24] ^ crc_reg[25] ^ crc_reg[26] ^ 
crc_reg[30] ^ crc_reg[31] ^ crc_in[0] ^ crc_in[1] ^ crc_in[2] ^ crc_in[6] 
^ crc_in[7]; 
assign next_crc_reg[3] = crc_reg[25] ^ crc_reg[26] ^ crc_reg[27] ^ 
crc_reg[31] ^ crc_in[1] ^ crc_in[2] ^ crc_in[3] ^ crc_in[7]; 
assign next_crc_reg[4] = crc_reg[24] ^ crc_reg[26] ^ crc_reg[27] ^ 
crc_reg[28] ^ crc_reg[30] ^ crc_in[0] ^ crc_in[2] ^ crc_in[3] ^ crc_in[4] 
^ crc_in[6]; 
assign next_crc_reg[5] = crc_reg[24] ^ crc_reg[25] ^ crc_reg[27] ^ 
crc_reg[28] ^ crc_reg[29] ^ crc_reg[30] ^ crc_reg[31] ^ crc_in[0] ^ 
crc_in[1] ^ crc_in[3] ^ crc_in[4] ^ crc_in[5] ^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[6] = crc_reg[25] ^ crc_reg[26] ^ crc_reg[28] ^ 
crc_reg[29] ^ crc_reg[30] ^ crc_reg[31] ^ crc_in[1] ^ crc_in[2] ^ crc_in[4] 
^ crc_in[5] ^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[7] = crc_reg[24] ^ crc_reg[26] ^ crc_reg[27] ^ 
crc_reg[29] ^ crc_reg[31] ^ crc_in[0] ^ crc_in[2] ^ crc_in[3] ^ crc_in[5] 
^ crc_in[7]; 
assign next_crc_reg[8] = crc_reg[0] ^ crc_reg[24] ^ crc_reg[25] ^ 
crc_reg[27] ^ crc_reg[28] ^ crc_in[0] ^ crc_in[1] ^ crc_in[3] ^ crc_in[4]; 
assign next_crc_reg[9] = crc_reg[1] ^ crc_reg[25] ^ crc_reg[26] ^ 
crc_reg[28] ^ crc_reg[29] ^ crc_in[1] ^ crc_in[2] ^ crc_in[4] ^ crc_in[5]; 
assign next_crc_reg[10] = crc_reg[2] ^ crc_reg[24] ^ crc_reg[26] ^ 
crc_reg[27] ^ crc_reg[29] ^ crc_in[0] ^ crc_in[2] ^ crc_in[3] ^ crc_in[5]; 
assign next_crc_reg[11] = crc_reg[3] ^ crc_reg[24] ^ crc_reg[25] ^ 
crc_reg[27] ^ crc_reg[28] ^ crc_in[0] ^ crc_in[1] ^ crc_in[3] ^ crc_in[4]; 
assign next_crc_reg[12] = crc_reg[4] ^ crc_reg[24] ^ crc_reg[25] ^ 
crc_reg[26] ^ crc_reg[28] ^ crc_reg[29] ^ crc_reg[30] ^ crc_in[0] ^ 
crc_in[1] ^ crc_in[2] ^ crc_in[4] ^ crc_in[5] ^ crc_in[6]; 
assign next_crc_reg[13] = crc_reg[5] ^ crc_reg[25] ^ crc_reg[26] ^ 
crc_reg[27] ^ crc_reg[29] ^ crc_reg[30] ^ crc_reg[31] ^ crc_in[1] ^ 
crc_in[2] ^ crc_in[3] ^ crc_in[5] ^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[14] = crc_reg[6] ^ crc_reg[26] ^ crc_reg[27] ^ 
crc_reg[28] ^ crc_reg[30] ^ crc_reg[31] ^ crc_in[2] ^ crc_in[3] ^ crc_in[4] 
^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[15] = crc_reg[7] ^ crc_reg[27] ^ crc_reg[28] ^ 
crc_reg[29] ^ crc_reg[31] ^ crc_in[3] ^ crc_in[4] ^ crc_in[5] ^ crc_in[7]; 
assign next_crc_reg[16] = crc_reg[8] ^ crc_reg[24] ^ crc_reg[28] ^ 
crc_reg[29] ^ crc_in[0] ^ crc_in[4] ^ crc_in[5]; 
assign next_crc_reg[17] = crc_reg[9] ^ crc_reg[25] ^ crc_reg[29] ^ 
crc_reg[30] ^ crc_in[1] ^ crc_in[5] ^ crc_in[6]; 
assign next_crc_reg[18] = crc_reg[10] ^ crc_reg[26] ^ crc_reg[30] ^ 
crc_reg[31] ^ crc_in[2] ^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[19] = crc_reg[11] ^ crc_reg[27] ^ crc_reg[31] ^ 
crc_in[3] ^ crc_in[7]; 
assign next_crc_reg[20] = crc_reg[12] ^ crc_reg[28] ^ crc_in[4]; 
assign next_crc_reg[21] = crc_reg[13] ^ crc_reg[29] ^ crc_in[5]; 
assign next_crc_reg[22] = crc_reg[14] ^ crc_reg[24] ^ crc_in[0]; 
assign next_crc_reg[23] = crc_reg[15] ^ crc_reg[24] ^ crc_reg[25] ^ 
crc_reg[30] ^ crc_in[0] ^ crc_in[1] ^ crc_in[6]; 
assign next_crc_reg[24] = crc_reg[16] ^ crc_reg[25] ^ crc_reg[26] ^ 
crc_reg[31] ^ crc_in[1] ^ crc_in[2] ^ crc_in[7]; 
assign next_crc_reg[25] = crc_reg[17] ^ crc_reg[26] ^ crc_reg[27] ^ 
crc_in[2] ^ crc_in[3]; 
assign next_crc_reg[26] = crc_reg[18] ^ crc_reg[24] ^ crc_reg[27] ^ 
crc_reg[28] ^ crc_reg[30] ^ crc_in[0] ^ crc_in[3] ^ crc_in[4] ^ crc_in[6]; 
assign next_crc_reg[27] = crc_reg[19] ^ crc_reg[25] ^ crc_reg[28] ^ 
crc_reg[29] ^ crc_reg[31] ^ crc_in[1] ^ crc_in[4] ^ crc_in[5] ^ crc_in[7]; 
assign next_crc_reg[28] = crc_reg[20] ^ crc_reg[26] ^ crc_reg[29] ^ 
crc_reg[30] ^ crc_in[2] ^ crc_in[5] ^ crc_in[6]; 
assign next_crc_reg[29] = crc_reg[21] ^ crc_reg[27] ^ crc_reg[30] ^ 
crc_reg[31] ^ crc_in[3] ^ crc_in[6] ^ crc_in[7]; 
assign next_crc_reg[30] = crc_reg[22] ^ crc_reg[28] ^ crc_reg[31] ^ 
crc_in[4] ^ crc_in[7]; 
assign next_crc_reg[31] = crc_reg[23] ^ crc_reg[29] ^ crc_in[5]; 
//
always@(posedge clk) 
begin 
case(state) //
 idle:begin //
 if(load) //l
 state <= compute; 
 else 
 state <= idle; 
 end 
 compute:begin 
 if(d_finish) // 
 state <= finish; 
 else 
 state <= compute; 
 end 
 finish:begin 
 if(count==2) //
 state <= idle; 
 else 
 state <= finish; 
 end 
endcase 
end 
always@(posedge clk or negedge rst) // 
 if(rst) 
 begin 
 crc_reg[31:0] <= 32'b0000_0000_0000_0000_0000_0000_0000_0000; //

 state <= idle; 
 count <= 2'b00; 
 end 
 else 
 case(state) 
 idle:begin //
 crc_reg[31:0] <= 
32'b0000_0000_0000_0000_0000_0000_0000_0000; 
 end 
 compute:begin // 
 crc_reg[31:0]<= next_crc_reg[31:0]; 
 crc_out[7:0] <= crc_in[7:0]; 
 end 
 finish:begin //
 crc_reg[31:0] <= {crc_reg[23:0],8'b0000_0000}; 
 crc_out[7:0] <= crc_reg[31:24]; 
 end 
 endcase 
endmodule 
"
"CRC_16_parallel
module CRC_16_parallel(clk,rst,load,d_finish,crc_in,crc_out); 

input clk; 
input rst; 
input load; 
input d_finish; 
input [7:0] crc_in; 
output [7:0] crc_out;
reg [7:0] crc_out; 
reg [15:0] crc_reg;
reg [1:0] count;  
reg [1:0] state; 
wire [15:0] next_crc_reg; //
parameter idle = 2'b00; //
parameter compute = 2'b01;//
parameter finish = 2'b10; //
//

assign next_crc_reg[0] = (^crc_in[7:0]) ^ (^crc_reg[15:8]); 
assign next_crc_reg[1] = (^crc_in[6:0]) ^ (^crc_reg[15:9]); 
assign next_crc_reg[2] = crc_in[7] ^ crc_in[6] ^ crc_reg[9] ^ crc_reg[8]; 
assign next_crc_reg[3] = crc_in[6] ^ crc_in[5] ^ crc_reg[10] ^ 
crc_reg[9]; 
assign next_crc_reg[4] = crc_in[5] ^ crc_in[4] ^ crc_reg[11] ^ 
crc_reg[10]; 
assign next_crc_reg[5] = crc_in[4] ^ crc_in[3] ^ crc_reg[12] ^ 
crc_reg[11]; 
assign next_crc_reg[6] = crc_in[3] ^ crc_in[2] ^ crc_reg[13] ^ 
crc_reg[12]; 
assign next_crc_reg[7] = crc_in[2] ^ crc_in[1] ^ crc_reg[14] ^ 
crc_reg[13]; 
assign next_crc_reg[8] = crc_in[1] ^ crc_in[0] ^ crc_reg[15] ^ crc_reg[14] 
^ crc_reg[0]; 
assign next_crc_reg[9] = crc_in[0] ^ crc_reg[15] ^ crc_reg[1]; 
assign next_crc_reg[14:10] = crc_reg[6:2]; 
assign next_crc_reg[15] = (^crc_in[7:0]) ^ (^crc_reg[15:7]); 
always@(posedge clk) //
begin 
case(state) //
 idle:begin // 
 if(load) //
 state <= compute; 
 else 
 state <= idle; 
 end 
 compute:begin 
 if(d_finish)//
 state <= finish; 
 else 
 state <= compute; 
 end 
 finish:begin 
 if(count==2)//
 state <= idle; 
 else 
 state <= finish; 
 end 
endcase 
end 
always@(posedge clk or negedge rst)//
 if(rst) 
 begin 
 crc_reg[15:0] <= 16'b0000_0000_0000_0000;//
 state <= idle; 
 count <= 2'b00; 
 end 
 else 
 case(state) 
 idle:begin // 
 crc_reg[15:0] <= 16'b0000_0000_0000_0000; 
 end 
 compute:begin // 
 crc_reg[15:0]<= next_crc_reg[15:0]; 
 crc_out[7:0] <= crc_in[7:0]; 
 end 
 finish:begin //
 crc_reg[15:0] <= {crc_reg[7:0],8'b0000_0000}; 
 crc_out[7:0] <= crc_reg[15:8]; 
 end 
 endcase 
endmodule 
"
"CRC_32_serial
module CRC_32_serial(clk,rst,load,d_finish,crc_in,crc_out); 
input clk; //
input rst; //
input load; //
input d_finish; //
input crc_in; //
output crc_out; // 
reg crc_out; //
reg [31:0] crc_reg; //
reg [1:0] state; //
reg [4:0] count; //
parameter idle = 2'b00; //
parameter compute = 2'b01; //
parameter finish = 2'b10; //
  always@ (posedge clk) //
begin // 
case (state) // 
 idle: begin // 
 if (load) //
 state <= compute; 
 else
 state <= idle; 
 end
 compute:begin //
 if(d_finish) 
 state <= finish; 
 else
 state <= compute; 
 end
 finish: begin // 
   if(count==32) 
 state <= idle; 
 else
 count <= count+1; 
 end
endcase
end 
always@ (posedge clk or negedge rst)//
 if(rst) 
 begin 
 count <= 5'b0_0000; 
 state <= idle; 
 end
 else
 case(state) 
 idle:begin
   crc_reg[31:0] <= 32'b0000_0000_0000_0000_0000_0000_0000_0000; 
 end
 compute:begin 
 //Produces a polynomial x^16+x^15+x^2+1 
   crc_reg[0] <= crc_reg[31] ^ crc_in; 
 crc_reg[1] <= crc_reg[0]; 
   crc_reg[2] <= crc_reg[1] ^ crc_reg[31] ^ crc_in; 
   crc_reg[30:3] <= crc_reg[29:2]; 
   crc_reg[31] <= crc_reg[30] ^ crc_reg[31] ^ crc_in; 
 crc_out <= crc_in; //
 end 
 finish:begin 
   crc_out <= crc_reg[31]; 
   crc_reg[31:0] <= {crc_reg[30:0],1'b0}; 
 end 
 endcase 
endmodule
"
"CRC_16_serial
//module CRC_16_serial 
//Module function: The module is a coding circuit of crc-16 check code, which uses a serial linear shift stage
module CRC_16_serial(clk,rst,load,d_finish,crc_in,crc_out); 
input clk; //Clk signal
input rst; //Reset signal
input load; //Start encoding the signal
input d_finish; //Encode the end signal
input crc_in; //The word input to be encoded
output crc_out; //Code word output after encoding
reg crc_out; //Code word output staging, 1bit 
reg [15:0] crc_reg; //Linear shift staging, 16bits 
reg [1:0] state; //State staging, 2bit 
reg [4:0] count; //Count staging, 5bit 
parameter idle = 2'b00; //Wait state
parameter compute = 2'b01;//calculated status
parameter finish = 2'b10; //Calculate the end state
always@ (posedge clk) //executed each time the clk is triggered for a positive edge
begin // can be seen as the upper parenthesis in the c language, and end can be seen as the lower parenthesis
case (state) // Select case in state 
 idle: begin // is the wait state
 if (load) //load signal enters the compute state effectively
 state <= compute; 
 else
 state <= idle; 
 end
 compute:begin //d_finish signal enters the finish state effectively
 if(d_finish) 
 state <= finish; 
 else
 state <= compute; 
 end
 finish: begin // Determines whether the data in the 16 stagings is fully output
 if(count==16) 
 state <= idle; 
 else
 count <= count+1; 
 end
endcase
end 
always@ (posedge clk or negedge rst)//whenever the clk positive trigger or rst negative edge trigger is executed
 if(rst) 
 begin 
 //crc_reg the initial value < pre-installed b0000_0000_0000_0000 15:0, 15:0, 16'
 count <= 5'b0_0000; 
 state <= idle; 
 end
 else
 case(state) 
 idle:begin
 crc_reg[15:0] <= 16'b0000_0000_0000_0000; 
 end
 compute:begin 
 //Produces a polynomial x^16+x^15+x^2+1 
 crc_reg[0] <= crc_reg[15] ^ crc_in; 
 crc_reg[1] <= crc_reg[0]; 
 crc_reg[2] <= crc_reg[1] ^ crc_reg[15] ^ crc_in; 
 crc_reg[14:3] <= crc_reg[13:2]; 
 crc_reg[15] <= crc_reg[14] ^ crc_reg[15] ^ crc_in; 
 crc_out <= crc_in; // The input is the output
 end 
 finish:begin 
 crc_out <= crc_reg[15]; // Stager 15 as output
 crc_reg[15:0] <= {crc_reg[14:0],1'b0}; // Shift.
 end 
 endcase 
endmodule





"
"cfsr
module cfsr ();
reg clk, rst;
reg[7:0] x_q;
reg[7:0] x_d;
reg[4:0] q_cnt;

integer i;
integer out;
//clock
initial
begin
    clk = 0;
   forever #10 clk = ~clk;
end
//reset
initial begin
    rst = 0;
    # 50 rst = 1;
end
// Use positive edge of clock to shift the register value
// Implement cyclic shift right
always @(posedge clk or
    negedge rst)
begin
    if (!rst)
    begin
        x_q <= 'hed;
        q_cnt <= 0;
        out = $fopen(""cfsr.vec"",""w"");
    end
    else
    begin
        x_q <= x_d;
        q_cnt <= q_cnt + 1;
        $fdisplay(out, ""Pass %d Shift value in hex %b"", q_cnt, x_q);
    end
end
//shift logic
always @(*)
begin
    x_d = x_q;
    x_d[7] = x_q[0];
    for (i=0; i<7; i=i+1)
    begin
        x_d[i] = x_q[i+1];
    end
end
endmodule
"
"lfsr
module lfsr (out, clk, rst);

  output reg [3:0] out;
  input clk, rst;

  wire feedback;

  assign feedback = ~(out[3] ^ out[2]);

always @(posedge clk, posedge rst)
  begin
    if (rst)
      out = 4'b0;
    else
      out = {out[2:0],feedback};
  end
endmodule
"
"shift_add_multiplication
module adder(
    D,A,add_out,c_out
    );
    parameter m=8,n=8;
    input [m-1:0] D,A;
    output [m-1:0] add_out;
    output c_out;
    wire [m:0] add_result, data1, data2;
    assign data1 = {1'b0,D};
    assign data2 = {1'b0,A};
    assign add_result = data1+data2;
    assign add_out = add_result[m-1:0];
    assign c_out = add_result[m];
endmodule

module controller(clk,rst,lsb,load_cmd,add_cmd,shift_cmd,out_cmd);
    input clk, rst,lsb;
    output load_cmd,add_cmd,shift_cmd,out_cmd;
    reg load_cmd,add_cmd,shift_cmd, out_cmd;
    reg [2:0] state;
    reg start;
    integer count;
    parameter m=8;
    parameter n=8;
    parameter idle=3'b000, init=3'b001, test=3'b010, add=3'b011, shift=3'b100;
    always@(posedge clk or posedge rst)
        if (rst)
            begin
                state<=idle;
                count<=0;
                start<=1;
                out_cmd<=0;
            end
        else 
            case (state)
                idle: begin
                    load_cmd<=0;
                    add_cmd<=0;
                    shift_cmd<=0;
                    if (start) begin
                        state<=init;
                        out_cmd<=0;
                    end
                    else begin
                        state<=idle;
                        out_cmd<=1;
                    end
                end
                init: begin
                    load_cmd<=1;
                    add_cmd<=0;
                    shift_cmd<=0;
                    out_cmd<=0;
                    state<=test;
                end
                test: begin
                    load_cmd<=0;
                    add_cmd<=0;
                    shift_cmd<=0;
                    out_cmd<=0;
                    if (lsb) begin
                        state<=add;
                        end
                    else state<=shift;
                end 
                add: begin
                    load_cmd<=0;
                    add_cmd<=1;
                    shift_cmd<=0;
                    out_cmd<=0;
                    state<=shift;
                end
                shift: begin
                    load_cmd<=0;
                    add_cmd<=0;
                    shift_cmd<=1;
                    out_cmd<=0;
                    if (count<m) begin
                        state<=test;
                        count<=count+1;
                    end
                    else begin
                        count<=0;
                        state<=idle;
                        start<=0;
                    end
                end 
            endcase                
endmodule

module shifter(
    add_out,c_out,load_cmd,add_cmd,shift_cmd,clk,rst,out_cmd,Q,A,lsb,out   
 );
 parameter m=8,n=8;
 input [m-1:0] add_out;
 input c_out,load_cmd,add_cmd,shift_cmd,clk,rst,out_cmd;
 input [n-1:0] Q;
 output [m-1:0] A;
 output lsb;
 output reg [m+n-1:0] out; 
 reg [m+n:0] temp;
 reg add_temp;
 
 assign A = temp[m+n-1:n];
 assign lsb = temp[0];
 always@(posedge clk or posedge rst)
 begin
    if (rst)
    begin
        add_temp<=0;
        temp<=0;
    end
    else
    begin
        if (load_cmd)
        begin
            temp[m+n:n]<=0;
            temp[n-1:0]<=Q;
        end
        else if (add_cmd)
            add_temp<=1;
        else if (shift_cmd && add_temp)
        begin
            temp<={1'b0, c_out, add_out, temp[n-1:1]};
            add_temp<=0;
        end
        else if (shift_cmd && !add_temp)
            temp<={1'b0, temp[m+n:1]}; 
    end
 end
 always@(out_cmd)
 begin
    if (!out_cmd)
        out<=0;
    else
        out<=temp[m+n-1:0];
 end
 endmodule

module multiplier(clk, rst, D, Q, out);
parameter m=8, n=8;
input clk, rst;
input [m-1:0] D;
input [n-1:0] Q;
output [m+n-1:0] out;

wire c_out,load_cmd,add_cmd,shift_cmd,lsb,out_cmd;
wire [m-1:0] A,add_out;
adder adder(.D(D), .A(A), .add_out(add_out), .c_out(c_out));
shifter shifter(add_out,c_out,load_cmd,add_cmd,shift_cmd,clk,rst,out_cmd,Q,A,lsb,out);
controller controller(clk,rst,lsb,load_cmd,add_cmd,shift_cmd,out_cmd);
endmodule

module multiplier_tb;
parameter m=8, n=8;
reg clk, rst;
reg [m-1:0] D;
reg [n-1:0] Q;
wire [m+n-1:0] out;

multiplier multiplier(clk, rst, D, Q, out);

initial 
begin
    clk = 1'b1;
    forever #5 clk = ~clk;
end
initial
begin

    rst = 1;
    #20;
    rst = 0;
    D = 8'b11111111;
    Q = 8'b11111111;
    #2000;
    rst = 1;
    #20;
    rst = 0;
    D = 8'b00011111;
    Q = 8'b00011111;
    #2000;
    rst = 1;
    #20;
    rst = 0;
    D = 8'b00000001;
    Q = 8'b00000001;
    #2000;
end
endmodule
"
"division
// Priority Encoder

module priority_encoder(
			input [24:0] significand,
			input [7:0] exp_a,
			output reg [24:0] Significand,
			output [7:0] exp_sub
			);

reg [4:0] shift;

always @(significand)
begin
	casex (significand)
		25'b1_1xxx_xxxx_xxxx_xxxx_xxxx_xxxx :	begin
													Significand = significand;
									 				shift = 5'd0;
								 			  	end
		25'b1_01xx_xxxx_xxxx_xxxx_xxxx_xxxx : 	begin						
										 			Significand = significand << 1;
									 				shift = 5'd1;
								 			  	end

		25'b1_001x_xxxx_xxxx_xxxx_xxxx_xxxx : 	begin						
										 			Significand = significand << 2;
									 				shift = 5'd2;
								 				end

		25'b1_0001_xxxx_xxxx_xxxx_xxxx_xxxx : 	begin 							
													Significand = significand << 3;
								 	 				shift = 5'd3;
								 				end

		25'b1_0000_1xxx_xxxx_xxxx_xxxx_xxxx : 	begin						
									 				Significand = significand << 4;
								 	 				shift = 5'd4;
								 				end

		25'b1_0000_01xx_xxxx_xxxx_xxxx_xxxx : 	begin						
									 				Significand = significand << 5;
								 	 				shift = 5'd5;
								 				end

		25'b1_0000_001x_xxxx_xxxx_xxxx_xxxx : 	begin						// 24'h020000
									 				Significand = significand << 6;
								 	 				shift = 5'd6;
								 				end

		25'b1_0000_0001_xxxx_xxxx_xxxx_xxxx : 	begin						// 24'h010000
									 				Significand = significand << 7;
								 	 				shift = 5'd7;
								 				end

		25'b1_0000_0000_1xxx_xxxx_xxxx_xxxx : 	begin						// 24'h008000
									 				Significand = significand << 8;
								 	 				shift = 5'd8;
								 				end

		25'b1_0000_0000_01xx_xxxx_xxxx_xxxx : 	begin						// 24'h004000
									 				Significand = significand << 9;
								 	 				shift = 5'd9;
								 				end

		25'b1_0000_0000_001x_xxxx_xxxx_xxxx : 	begin						// 24'h002000
									 				Significand = significand << 10;
								 	 				shift = 5'd10;
								 				end

		25'b1_0000_0000_0001_xxxx_xxxx_xxxx : 	begin						// 24'h001000
									 				Significand = significand << 11;
								 	 				shift = 5'd11;
								 				end

		25'b1_0000_0000_0000_1xxx_xxxx_xxxx : 	begin						// 24'h000800
									 				Significand = significand << 12;
								 	 				shift = 5'd12;
								 				end

		25'b1_0000_0000_0000_01xx_xxxx_xxxx : 	begin						// 24'h000400
									 				Significand = significand << 13;
								 	 				shift = 5'd13;
								 				end

		25'b1_0000_0000_0000_001x_xxxx_xxxx : 	begin						// 24'h000200
									 				Significand = significand << 14;
								 	 				shift = 5'd14;
								 				end

		25'b1_0000_0000_0000_0001_xxxx_xxxx  : 	begin						// 24'h000100
									 				Significand = significand << 15;
								 	 				shift = 5'd15;
								 				end

		25'b1_0000_0000_0000_0000_1xxx_xxxx : 	begin						// 24'h000080
									 				Significand = significand << 16;
								 	 				shift = 5'd16;
								 				end

		25'b1_0000_0000_0000_0000_01xx_xxxx : 	begin						// 24'h000040
											 		Significand = significand << 17;
										 	 		shift = 5'd17;
												end

		25'b1_0000_0000_0000_0000_001x_xxxx : 	begin						// 24'h000020
									 				Significand = significand << 18;
								 	 				shift = 5'd18;
								 				end

		25'b1_0000_0000_0000_0000_0001_xxxx : 	begin						// 24'h000010
									 				Significand = significand << 19;
								 	 				shift = 5'd19;
												end

		25'b1_0000_0000_0000_0000_0000_1xxx :	begin						// 24'h000008
									 				Significand = significand << 20;
								 					shift = 5'd20;
								 				end

		25'b1_0000_0000_0000_0000_0000_01xx : 	begin						// 24'h000004
									 				Significand = significand << 21;
								 	 				shift = 5'd21;
								 				end

		25'b1_0000_0000_0000_0000_0000_001x : 	begin						// 24'h000002
									 				Significand = significand << 22;
								 	 				shift = 5'd22;
								 				end

		25'b1_0000_0000_0000_0000_0000_0001 : 	begin						// 24'h000001
									 				Significand = significand << 23;
								 	 				shift = 5'd23;
								 				end

		25'b1_0000_0000_0000_0000_0000_0000 : 	begin						// 24'h000000
								 					Significand = significand << 24;
							 	 					shift = 5'd24;
								 				end
		default : 	begin
						Significand = (~significand) + 1'b1;
						shift = 8'd0;
					end

	endcase
end
assign exp_sub = exp_a - shift;

endmodule

//Addition and Subtraction

module Addition_Subtraction(
input [31:0] a,b,
input add_sub_signal,														// If 1 then addition otherwise subtraction
output exception,
output [31:0] res      
);

wire operation_add_sub_signal;
wire enable;
wire output_sign;

wire [31:0] op_a,op_b;
wire [23:0] significand_a,significand_b;
wire [7:0] exponent_diff;


wire [23:0] significand_b_add_sub;
wire [7:0] exp_b_add_sub;

wire [24:0] significand_add;
wire [30:0] add_sum;

wire [23:0] significand_sub_complement;
wire [24:0] significand_sub;
wire [30:0] sub_diff;
wire [24:0] subtraction_diff; 
wire [7:0] exp_sub;

assign {enable,op_a,op_b} = (a[30:0] < b[30:0]) ? {1'b1,b,a} : {1'b0,a,b};							// For operations always op_a must not be less than b

assign exp_a = op_a[30:23];
assign exp_b = op_b[30:23];

assign exception = (&op_a[30:23]) | (&op_b[30:23]);										// Exception flag sets 1 if either one of the exponent is 255.

assign output_sign = add_sub_signal ? enable ? !op_a[31] : op_a[31] : op_a[31] ;

assign operation_add_sub_signal = add_sub_signal ? op_a[31] ^ op_b[31] : ~(op_a[31] ^ op_b[31]);				// Assign significand values according to Hidden Bit.

assign significand_a = (|op_a[30:23]) ? {1'b1,op_a[22:0]} : {1'b0,op_a[22:0]};							// If exponent is zero,hidden bit = 0,else 1
assign significand_b = (|op_b[30:23]) ? {1'b1,op_b[22:0]} : {1'b0,op_b[22:0]};

assign exponent_diff = op_a[30:23] - op_b[30:23];										// Exponent difference calculation

assign significand_b_add_sub = significand_b >> exponent_diff;

assign exp_b_add_sub = op_b[30:23] + exponent_diff; 

assign perform = (op_a[30:23] == exp_b_add_sub);										// Checking if exponents are same

// Add Block //
assign significand_add = (perform & operation_add_sub_signal) ? (significand_a + significand_b_add_sub) : 25'd0; 

assign add_sum[22:0] = significand_add[24] ? significand_add[23:1] : significand_add[22:0];					// res will be most 23 bits if carry generated, else least 22 bits.

assign add_sum[30:23] = significand_add[24] ? (1'b1 + op_a[30:23]) : op_a[30:23];						// If carry generates in sum value then exponent is added with 1 else feed as it is.

// Sub Block //
assign significand_sub_complement = (perform & !operation_add_sub_signal) ? ~(significand_b_add_sub) + 24'd1 : 24'd0 ; 

assign significand_sub = perform ? (significand_a + significand_sub_complement) : 25'd0;

priority_encoder pe(significand_sub,op_a[30:23],subtraction_diff,exp_sub);

assign sub_diff[30:23] = exp_sub;

assign sub_diff[22:0] = subtraction_diff[22:0];


// Output //
assign res = exception ? 32'b0 : ((!operation_add_sub_signal) ? {output_sign,sub_diff} : {output_sign,add_sum});

endmodule


// Multiplication
module Multiplication(
		input [31:0] a,
		input [31:0] b,
		output exception,overflow,underflow,
		output [31:0] res
		);

wire sign,product_round,normalised,zero;
wire [8:0] exponent,sum_exponent;
wire [22:0] product_mantissa;
wire [23:0] op_a,op_b;
wire [47:0] product,product_normalised; //48 Bits


assign sign = a[31] ^ b[31];   													// XOR of 32nd bit

assign exception = (&a[30:23]) | (&b[30:23]);											// Execption sets to 1 when exponent of any a or b is 255
																// If exponent is 0, hidden bit is 0



assign op_a = (|a[30:23]) ? {1'b1,a[22:0]} : {1'b0,a[22:0]};

assign op_b = (|b[30:23]) ? {1'b1,b[22:0]} : {1'b0,b[22:0]};

assign product = op_a * op_b;													// Product

assign product_round = |product_normalised[22:0];  									        // Last 22 bits are ORed for rounding off purpose

assign normalised = product[47] ? 1'b1 : 1'b0;	

assign product_normalised = normalised ? product : product << 1;								// Normalized value based on 48th bit

assign product_mantissa = product_normalised[46:24] + {21'b0,(product_normalised[23] & product_round)};				// Mantissa

assign zero = exception ? 1'b0 : (product_mantissa == 23'd0) ? 1'b1 : 1'b0;

assign sum_exponent = a[30:23] + b[30:23];

assign exponent = sum_exponent - 8'd127 + normalised;

assign overflow = ((exponent[8] & !exponent[7]) & !zero) ;									// Overall exponent is greater than 255 then Overflow

assign underflow = ((exponent[8] & exponent[7]) & !zero) ? 1'b1 : 1'b0; 							// Sum of exponents is less than 255 then Underflow 

assign res = exception ? 32'd0 : zero ? {sign,31'd0} : overflow ? {sign,8'hFF,23'd0} : underflow ? {sign,31'd0} : {sign,exponent[7:0],product_mantissa};


endmodule


// Iteration
module Iteration(
	input [31:0] operand_1,
	input [31:0] operand_2,
	output [31:0] solution
	);

wire [31:0] Intermediate_Value1,Intermediate_Value2;

Multiplication M1(operand_1,operand_2,,,,Intermediate_Value1);

//32'h4000_0000 -> 2.
Addition_Subtraction A1(32'h4000_0000,{1'b1,Intermediate_Value1[30:0]},1'b0,,Intermediate_Value2);

Multiplication M2(operand_1,Intermediate_Value2,,,,solution);

endmodule

// Division
module division(
	input [31:0] a,
	input [31:0] b,
	output exception,
	output [31:0] res
);

wire sign;
wire [7:0] shift;
wire [7:0] exp_a;
wire [31:0] divisor;
wire [31:0] op_a;
wire [31:0] Intermediate_X0;
wire [31:0] Iteration_X0;
wire [31:0] Iteration_X1;
wire [31:0] Iteration_X2;
wire [31:0] Iteration_X3;
wire [31:0] solution;

wire [31:0] denominator;
wire [31:0] op_a_change;

assign exception = (&a[30:23]) | (&b[30:23]);

assign sign = a[31] ^ b[31];

assign shift = 8'd126 - b[30:23];

assign divisor = {1'b0,8'd126,b[22:0]};

assign denominator = divisor;

assign exp_a = a[30:23] + shift;

assign op_a = {a[31],exp_a,a[22:0]};

assign op_a_change = op_a;

//32'hC00B_4B4B = (-37)/17
Multiplication x0(32'hC00B_4B4B,divisor,,,,Intermediate_X0);

//32'h4034_B4B5 = 48/17
Addition_Subtraction X0(Intermediate_X0,32'h4034_B4B5,1'b0,,Iteration_X0);

Iteration X1(Iteration_X0,divisor,Iteration_X1);

Iteration X2(Iteration_X1,divisor,Iteration_X2);

Iteration X3(Iteration_X2,divisor,Iteration_X3);

Multiplication END(Iteration_X3,op_a,,,,solution);

assign res = {sign,solution[30:0]};
endmodule

`define N_TESTS 100000

module division_tb;

	reg clk = 0;
	reg [31:0] a;
	reg [31:0] b;
	
	wire [31:0] res;
	wire exception;

	reg [31:0] expected_res;

	reg [95:0] testVector [`N_TESTS-1:0];

	reg test_stop_enable;

	integer mcd;
	integer test_n = 0;
	integer pass   = 0;
	integer error  = 0;

	division DUT(a,b,exception,res);

	always #5 clk = ~clk;

	initial  
	begin 
		$readmemh(""Test.txt"", testVector);
		mcd = $fopen(""Error_Results.txt"");
	end 

	always @(posedge clk) 
	begin
			{a,b,expected_res} = testVector[test_n];
			test_n = test_n + 1'b1;

			#2;
			if (res[31:12] == expected_res[31:12])
				begin
					//$fdisplay (mcd,""TestPassed Test Number -> %d"",test_n);
					pass = pass + 1'b1;
				end

			if (res[31:12] != expected_res[31:12])
				begin
					$fdisplay (mcd,""Test Failed Expected res = %h,Obtained res = %h,Test Number-> %d"",expected_res,res,test_n);
					$display (""Zero Division Error or some other error"",mcd,""Test Failed Expected res = %h,Obtained res = %h,Test Number-> %d"",expected_res,res,test_n);
					error = error + 1'b1;
				end
			
			if (test_n >= `N_TESTS) 
			begin
				$fdisplay(mcd,""Completed %d tests, %d passes and %d fails."", test_n, pass, error);
				test_stop_enable = 1'b1;
			end
	end

always @(posedge test_stop_enable)
begin
$fclose(mcd);
$finish;
end

endmodule

"
"carry_look_ahead_adder
module carry_look_ahead_16bit(a,b, cin, sum,cout);
input [15:0] a,b;
input cin;
output [15:0] sum;
output cout;
wire c1,c2,c3;
 
carry_look_ahead_4bit cla1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(c1));
carry_look_ahead_4bit cla2 (.a(a[7:4]), .b(b[7:4]), .cin(c1), .sum(sum[7:4]), .cout(c2));
carry_look_ahead_4bit cla3(.a(a[11:8]), .b(b[11:8]), .cin(c2), .sum(sum[11:8]), .cout(c3));
carry_look_ahead_4bit cla4(.a(a[15:12]), .b(b[15:12]), .cin(c3), .sum(sum[15:12]), .cout(cout));
 
endmodule

module carry_look_ahead_4bit(a,b, cin, sum,cout);
input [3:0] a,b;
input cin;
output [3:0] sum;
output cout;
 
wire [3:0] p,g,c;
 
assign p=a^b;
assign g=a&b;

assign c[0]=cin;
assign c[1]= g[0]|(p[0]&c[0]);
assign c[2]= g[1] | (p[1]&g[0]) | p[1]&p[0]&c[0];
assign c[3]= g[2] | (p[2]&g[1]) | p[2]&p[1]&g[0] | p[2]&p[1]&p[0]&c[0];
assign cout= g[3] | (p[3]&g[2]) | p[3]&p[2]&g[1] | p[3]&p[2]&p[1]&g[0] | p[3]&p[2]&p[1]&p[0]&c[0];
assign sum=p^c;
 
endmodule

module carry_look_ahead_16bit_tb;
reg [15:0] a,b;
reg cin;
wire [15:0] sum;
wire cout;
 
  carry_look_ahead_16bit uut(.a(a), .b(b),.cin(cin),.sum(sum),.cout(cout));
 
initial begin
  a=0; b=0; cin=0;
  #20 a=16'd2; b=16'd2; cin=1'd1;
  #20 a=16'd2; b=16'd3; cin=1'd1;
  #20 a=16'd18; b=16'd18; cin=1'd0;
  #20 a=16'd100; b=16'd0; cin=1'd1;
end
 
initial
  $monitor( ""A=%d, B=%d, Cin= %d, Sum=%d, Cout=%d"", a,b,cin,sum,cout);
endmodule
"
"carry_select_adder
module carry_select_adder_16bit(a, b, cin, sum, cout);
input [15:0] a,b;
input cin;
output [15:0] sum;
output cout;
 
wire [2:0] c;
 
ripple_carry_4_bit rca1(
.a(a[3:0]),
.b(b[3:0]),
.cin(cin),
.sum(sum[3:0]),
.cout(c[0]));
 

carry_select_adder_4bit_slice csa_slice1(
.a(a[7:4]),
.b(b[7:4]),
.cin(c[0]),
.sum(sum[7:4]),
.cout(c[1]));
 
carry_select_adder_4bit_slice csa_slice2(
.a(a[11:8]),
.b(b[11:8]),
.cin(c[1]),
.sum(sum[11:8]), 
.cout(c[2]));
 
carry_select_adder_4bit_slice csa_slice3(
.a(a[15:12]),
.b(b[15:12]),
.cin(c[2]),
.sum(sum[15:12]),
.cout(cout));
endmodule
 
 
module carry_select_adder_4bit_slice(a, b, cin, sum, cout);
input [3:0] a,b;
input cin;
output [3:0] sum;
output cout;
 
wire [3:0] s0,s1;
wire c0,c1;
 
ripple_carry_4_bit rca1(
.a(a[3:0]),
.b(b[3:0]),
.cin(1'b0),
.sum(s0[3:0]),
.cout(c0));
 
ripple_carry_4_bit rca2(
.a(a[3:0]),
.b(b[3:0]),
.cin(1'b1),
.sum(s1[3:0]),
.cout(c1));
 
mux2X1 #(4) ms0(
.in0(s0[3:0]),
.in1(s1[3:0]),
.sel(cin),
.out(sum[3:0]));
 
mux2X1 #(1) mc0(
.in0(c0),
.in1(c1),
.sel(cin),
.out(cout));
endmodule
 
 
module mux2X1( in0,in1,sel,out);
parameter width=16; 
input [width-1:0] in0,in1;
input sel;
output [width-1:0] out;
assign out=(sel)?in1:in0;
endmodule
 

module ripple_carry_4_bit(a, b, cin, sum, cout);
input [3:0] a,b;
input cin;
output [3:0] sum;
output cout;
 
wire c1,c2,c3;
 
full_adder fa0(
.a(a[0]),
.b(b[0]),
.cin(cin),
.sum(sum[0]),
.cout(c1));
 
full_adder fa1(
.a(a[1]),
.b(b[1]),
.cin(c1),
.sum(sum[1]),
.cout(c2));
 
full_adder fa2(
.a(a[2]),
.b(b[2]),
.cin(c2),
.sum(sum[2]),
.cout(c3));
 
full_adder fa3(
.a(a[3]),
.b(b[3]),
.cin(c3),
.sum(sum[3]),
.cout(cout));
endmodule

 
module full_adder(a,b,cin,sum, cout);
input a,b,cin;
output sum, cout;
 
wire x,y,z;
 
half_adder h1(.a(a), .b(b), .sum(x), .cout(y));
half_adder h2(.a(x), .b(cin), .sum(sum), .cout(z));
or or_1(cout,z,y);
endmodule

 
module half_adder( a,b, sum, cout );
input a,b;
output sum, cout;
xor xor_1 (sum,a,b);
and and_1 (cout,a,b);
endmodule

module carry_select_adder_16bit_tb;
reg [15:0] a,b;
reg cin;
wire [15:0] sum;
wire cout;
 
  carry_select_adder_16bit uut(.a(a), .b(b),.cin(cin),.sum(sum),.cout(cout));
 
initial begin
  a=0; b=0; cin=0;
  #10 a=16'd2; b=16'd2; cin=1'd1;
  #10 a=16'd2; b=16'd4; cin=1'd1;
  #10 a=16'd100; b=16'd0; cin=1'd0;
  #10 a=16'd12; b=16'd3; cin=1'd1;
end
 
initial
  $monitor( ""A=%d, B=%d, Cin= %d, Sum=%d, Cout=%d"", a,b,cin,sum,cout);
endmodule
"
"dual_address_ram
module dual_port_ram 
    (   input clk, 		 //clock
        input wr_en,   		 //write enable for port 0
        input [7:0] data_in,     //Input data to port 0.
        input [3:0] addr_in_0,   //address for port 0
        input [3:0] addr_in_1,   //address for port 1
        input port_en_0,    	 //enable port 0.
        input port_en_1,    	 //enable port 1.
        output [7:0] data_out_0, //output data from port 0.
        output [7:0] data_out_1  //output data from port 1.
    );

//memory declaration.
reg [7:0] ram[0:15];

//writing to the RAM
always@(posedge clk)
begin
    if(port_en_0 == 1 && wr_en == 1)    // check enable signal and if write enable is ON
        ram[addr_in_0] <= data_in;
end

//always reading from the ram, irrespective of clock.
assign data_out_0 = port_en_0 ? ram[addr_in_0] : 'dZ;   
assign data_out_1 = port_en_1 ? ram[addr_in_1] : 'dZ;   

endmodule 


module dual_port_ram_tb;

    // Inputs
    reg clk;
    reg wr_en;
    reg [7:0] data_in;
    reg [3:0] addr_in_0;
    reg [3:0] addr_in_1;
    reg port_en_0;
    reg port_en_1;

    // Outputs
    wire [7:0] data_out_0;
    wire [7:0] data_out_1;
    
    integer i;

    // Instantiate the Unit Under Test (UUT)
    dual_port_ram uut (
        .clk(clk), 
        .wr_en(wr_en), 
        .data_in(data_in), 
        .addr_in_0(addr_in_0), 
        .addr_in_1(addr_in_1), 
        .port_en_0(port_en_0), 
        .port_en_1(port_en_1), 
        .data_out_0(data_out_0), 
        .data_out_1(data_out_1)
    );
    
    always
        #5 clk = ~clk;

    initial begin
        // Initialize Inputs
        clk = 1;
        addr_in_1 = 0;
        port_en_0 = 0;
        port_en_1 = 0;
        wr_en = 0;
        data_in = 0;
        addr_in_0 = 0;  
        #20;
        //Write all the locations of RAM
        port_en_0 = 1;  
        wr_en = 1;
      for(i=1; i <= 16; i = i + 1) begin
            data_in = i;
            addr_in_0 = i-1;
            #10;
        end
        wr_en = 0;
        port_en_0 = 0;  
        //Read from port 1, all the locations of RAM.
        port_en_1 = 1;  
        for(i=1; i <= 16; i = i + 1) begin
            addr_in_1 = i-1;
            #10;
        end
        port_en_1 = 0;
    end
      
endmodule
"
"fifo
module FIFObuffer( Clk, 

                   dataIn, 

                   RD, 

                   WR, 

                   EN, 

                   dataOut, 

                   Rst,

                   EMPTY, 

                   FULL 

                   ); 

input  Clk, 

       RD, 

       WR, 

       EN, 

       Rst;

output  EMPTY, 

        FULL;

input   [31:0]    dataIn;

output reg [31:0] dataOut; // internal registers 

reg [2:0]  Count = 0; 

reg [31:0] FIFO [0:7]; 

reg [2:0]  readCounter = 0, 

           writeCounter = 0; 

assign EMPTY = (Count==0)? 1'b1:1'b0; 

assign FULL = (Count==8)? 1'b1:1'b0; 

always @ (posedge Clk) 

begin 

 if (EN==0); 

 else begin 

  if (Rst) begin 

   readCounter = 0; 

   writeCounter = 0; 

  end 

  else if (RD ==1'b1 && Count!=0) begin 

   dataOut  = FIFO[readCounter]; 

   readCounter = readCounter+1; 

  end 

  else if (WR==1'b1 && Count<8) begin
   FIFO[writeCounter]  = dataIn; 

   writeCounter  = writeCounter+1; 

  end 

  else; 

 end 

 if (writeCounter==8) 

  writeCounter=0; 

 else if (readCounter==8) 

  readCounter=0; 

 else;

 if (readCounter > writeCounter) begin 

  Count=readCounter-writeCounter; 

 end 

 else if (writeCounter > readCounter) 

  Count=writeCounter-readCounter; 

 else;

end 

endmodule
"
"dual_address_rom
module dual_port_rom 
	(input clk,
	 input wr_en,
	 input [3:0] addr_in_0,
	 input [3:0] addr_in_1,
	 input port_en_0,
	 input port_en_1,
	 output [7:0] data_out_0,
	 output [7:0] data_out_1);

reg   [4:0] raddr;
reg[7:0] rom [7:0];

 always @(posedge clk)
 begin
    if (port_en_0 == 1 && wr_en == 1)
       raddr <= addr_in_0;
 end

 always @(raddr) 
 begin
    if (port_en_0 == 1 && wr_en == 1)
       case(raddr)
   4'b0000: rom[raddr] = 8'b00100100;
   4'b0001: rom[raddr] = 8'b00100011;
   4'b0010: rom[raddr] = 8'b11100010;
   4'b0011: rom[raddr] = 8'b00100001;
   4'b0100: rom[raddr] = 8'b01000101;
   4'b0101: rom[raddr] = 8'b10101110;
   4'b0110: rom[raddr] = 8'b11001011;
   4'b0111: rom[raddr] = 8'b00000000;
   4'b1000: rom[raddr] = 8'b10100011;
   4'b1001: rom[raddr] = 8'b00101010;
   4'b1010: rom[raddr] = 8'b11101100;
   4'b1011: rom[raddr] = 8'b00100010;
   4'b1100: rom[raddr] = 8'b01000000;
   4'b1101: rom[raddr] = 8'b10100000;
   4'b1110: rom[raddr] = 8'b00001100;
   4'b1111: rom[raddr] = 8'b00000000;
   default: rom[raddr] = 8'bXXXXXXXX;
       endcase
 end
assign data_out_0 = port_en_0 ? rom[addr_in_0] : 'dZ;   
assign data_out_1 = port_en_1 ? rom[addr_in_1] : 'dZ;  
endmodule

module dual_port_rom_tb;

    // Inputs
    reg clk;
    reg wr_en;
    reg [3:0] addr_in_0;
    reg [3:0] addr_in_1;
    reg port_en_0;
    reg port_en_1;

    // Outputs
    wire [7:0] data_out_0;
    wire [7:0] data_out_1;
    
    integer i;

    // Instantiate the Unit Under Test (UUT)
    dual_port_rom uut (
        .clk(clk), 
        .wr_en(wr_en),  
        .addr_in_0(addr_in_0), 
        .addr_in_1(addr_in_1), 
        .port_en_0(port_en_0), 
        .port_en_1(port_en_1), 
        .data_out_0(data_out_0), 
        .data_out_1(data_out_1)
    );
    
    always
        #5 clk = ~clk;

    initial begin
        // Initialize Inputs
        clk = 1;
        addr_in_1 = 0;
        port_en_0 = 0;
        port_en_1 = 0;
        wr_en = 0;
        addr_in_0 = 0;  
        #20
        port_en_0 = 1;  
        wr_en = 1;
      for(i=1; i <= 16; i = i + 1) begin
            addr_in_0 = i-1;
            #10;
        end
        wr_en = 0;
        port_en_0 = 0;  
        //Read from port 1, all the locations of ROM.
        port_en_1 = 1;  
        for(i=1; i <= 16; i = i + 1) begin
            addr_in_1 = i-1;
            #10;
        end
        port_en_1 = 0;
    end
      
endmodule
"
"mux2X1
module mux2X1( in0,in1,sel,out);
input in0,in1;
input sel;
output out;
assign out=(sel)?in1:in0;
endmodule
"
"barrel_shifter_8bit
module barrel_shifter_8bit (in, ctrl, out);
  input  [7:0] in;
  input [2:0] ctrl;
  output [7:0] out;
  wire [7:0] x,y;
 
//4bit shift right
mux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));
mux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));
mux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));
mux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));
mux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));
mux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));
mux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));
mux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));
 
//2 bit shift right
 
mux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));
mux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));
mux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));
mux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));
mux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));
mux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));
mux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));
mux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));
 
//1 bit shift right
mux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));
mux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));
mux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));
mux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));
mux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));
mux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));
mux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));
mux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));

endmodule
"
"Master
module master(data,address,clk,rw,sda,scl,register,data_wr);
output reg sda;
input [7:0] data;
input [7:0] data_wr;
reg [7:0]data_wr_dup;
input clk;
input rw;
output reg scl;
input [6:0] address;
input [7:0] register;
reg [8:0] temp;
reg [7:0] register2;
reg pstate;
reg scl2x;
reg ack;
reg a;
integer i;
integer n;
initial begin
i = 0;
n = 0;
scl2x = 0;
ack = 1'b1;
sda = 1;
scl = 1;
#5 sda = 0;  //START BIT condition starts here
end
  
always @(negedge sda)
if(scl==1)
n=1;
always @(posedge clk)begin
ack = 0;
temp = {address,rw,ack};
register2 = register;
data_wr_dup = data_wr;
if(n==1 && rw==1)
repeat(50)begin
#2 scl <= !scl;n=0;
#1 scl2x <= !scl2x;n=0;
end
else if(n==1 && rw==0)
repeat(64) begin
#2 scl = !scl;
#1 scl2x = !scl2x;n=0;
end
end
always @(posedge clk)begin
if(i==25 && rw==1)
repeat(2)
#1 scl2x = !scl2x;
else if(i==32 && rw==0)
repeat(2)
#1 scl2x = !scl2x;end
always @(posedge scl2x)begin
if(i<=9)begin
sda = temp[8];
temp = temp<<1;
end
else if(i==12 || i==13)
sda = 1'b0;
else if(i>=14)begin
sda = register2[7];
register2 = register2<<1;
end
if(rw==0 && i>=23)begin
sda = data_wr_dup[7];
data_wr_dup = data_wr_dup<<1;
end
i = i + 1;
if(i>32 && rw ==0)
sda= 1;
else if(i>25 && rw==1)
sda = 1;
end
slave slv(data,sda,scl);
endmodule
"
"Slave
module slave(out,sda,scl);
input sda;
input scl;
output reg [7:0]out;
integer j = 0;
reg [6:0]temp;
reg [7:0]add;
reg rw;
reg [7:0]register_address;
reg bitin;
reg [7:0]storage[0:38];
initial
storage[37]=16;
parameter address = 7'b1101001;
always @(posedge scl)begin
//if({sda,scl}==2'b01)begin
bitin = sda;
if(j<8)
temp = {temp,bitin};
if(j==8)
            if(bitin==0)
                        rw = 0;
            else
                        rw = 1;
j = j +1 ;
if(temp==address && (j>15 && j<24) && rw==1)begin
            add = {add,bitin};
end
if(temp==address && rw == 0 && j>15 && j!=24 && j<33)begin
            add = {add,bitin};
end
else if(j==24)
            register_address = add;
if(j==33 && rw==0)
storage[register_address]=add;
out = storage[add];
end
endmodule
"
"Master
`timescale 1ns/1ps

module spi_master
#(
	parameter	CLK_FREQUENCE	= 50_000_000		,	//system clk frequence
				SPI_FREQUENCE	= 5_000_000			,	//spi clk frequence
				DATA_WIDTH		= 8					,	//serial word length
				CPOL			= 0					,	//SPI mode selection (mode 0 default)
				CPHA			= 0					 	//CPOL = clock polarity, CPHA = clock phase
)
(
	input								clk			,	//system clk
	input								rst_n		,	//system reset
	input		[DATA_WIDTH-1:0]		data_in		,	//the data sent by mosi
	input								start		,	//a pluse to start the SPI transmission
	input								miso		,	//spi bus miso input
	output	reg							sclk		,	//spi bus sclk
	output	reg							cs_n		,	//spi bus slave select line
	output								mosi		,	//spi bus mosi output
	output	reg							finish		,	//a pluse to indicate the SPI transmission finish and the data_out valid
	output	reg [DATA_WIDTH-1:0]		data_out	 	//the data received by miso,valid when the finish is high
);

localparam	FREQUENCE_CNT	= CLK_FREQUENCE/SPI_FREQUENCE - 1	,
			SHIFT_WIDTH		= log2(DATA_WIDTH)					,
			CNT_WIDTH		= log2(FREQUENCE_CNT)				;

localparam	IDLE	=	3'b000	,
			LOAD	=	3'b001	,
			SHIFT	=	3'b010	,
			DONE	=	3'b100	;

reg		[2:0]				cstate		;	//FSM current state
reg		[2:0]				nstate		;	//FSM next state
reg							clk_cnt_en	;	//start clk_cnt to generate sclk
reg							sclk_a		;	//sclk register to capture the edge of sclk
reg							sclk_b		;	//sclk register to capture the edge of sclk
wire						sclk_posedge;	//posedge of sclk
wire						sclk_negedge;	//negedge of sclk
wire						shift_en	;	//the signal to enable shift register to generate mosi
wire						sampl_en	;	//the signal to sample the data from miso
reg		[CNT_WIDTH-1:0]		clk_cnt		;	//the counter to generate sclk
reg		[SHIFT_WIDTH-1:0]	shift_cnt	;	//the counter to count the number of shifts
reg		[DATA_WIDTH-1:0]	data_reg	;	//the register to latch the data_in,also the shift register
//the counter to generate the sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		clk_cnt <= 'd0;
	else if (clk_cnt_en) 
		if (clk_cnt == FREQUENCE_CNT) 
			clk_cnt <= 'd0;
		else
			clk_cnt <= clk_cnt + 1'b1;
	else
		clk_cnt <= 'd0;
end
//generate the sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		sclk <= CPOL;
	else if (clk_cnt_en) 
		if (clk_cnt == FREQUENCE_CNT)  	
			sclk <= ~sclk; 
		else 
			sclk <= sclk;
	else
		sclk <= CPOL;
end
//------------------------------------------
//to capture the edge of sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		sclk_a <= CPOL;
		sclk_b <= CPOL;
	end else if (clk_cnt_en) begin
		sclk_a <= sclk;
		sclk_b <= sclk_a;
	end
end

assign sclk_posedge = ~sclk_b & sclk_a;
assign sclk_negedge = ~sclk_a & sclk_b;
//----------------------------------------
//==============================================
//==============GENERATE BLOCKS=================
generate
	case (CPHA)
		0: assign sampl_en = sclk_posedge;
		1: assign sampl_en = sclk_negedge;
		default: assign sampl_en = sclk_posedge;
	endcase
endgenerate

generate
 	case (CPHA)
		0: assign shift_en = sclk_negedge;
 		1: assign shift_en = sclk_posedge;
		default: assign shift_en = sclk_posedge;
	endcase
endgenerate
//=============================================
//FSM-1
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		cstate <= IDLE;
	else 
		cstate <= nstate;
end
//FSM-2
always @(*) begin
	case (cstate)
		IDLE	: nstate = start ? LOAD : IDLE;
		LOAD	: nstate = SHIFT;
		SHIFT	: nstate = (shift_cnt == DATA_WIDTH) ? DONE : SHIFT;
		DONE	: nstate = IDLE;
		default: nstate = IDLE;
	endcase
end
//FSM-3
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		clk_cnt_en	<= 1'b0	;
		data_reg	<= 'd0	;
		cs_n		<= 1'b1	;
		shift_cnt	<= 'd0	;
		finish <= 1'b0	;
	end else begin
		case (nstate)
			IDLE	: begin
				clk_cnt_en	<= 1'b0	;
				data_reg	<= 'd0	;
				cs_n		<= 1'b1	;
				shift_cnt	<= 'd0	;
				finish 		<= 1'b0	;
			end
			LOAD	: begin
				clk_cnt_en	<= 1'b1		;
				data_reg	<= data_in	;
				cs_n		<= 1'b0		;
				shift_cnt	<= 'd0		;
				finish 		<= 1'b0		;
			end
			SHIFT	: begin
				if (shift_en) begin
					shift_cnt	<= shift_cnt + 1'b1 ;
					data_reg	<= {data_reg[DATA_WIDTH-2:0],1'b0};
				end else begin
					shift_cnt	<= shift_cnt	;
					data_reg	<= data_reg		;
				end
				clk_cnt_en	<= 1'b1	;
				cs_n		<= 1'b0	;
				finish 		<= 1'b0	;
			end
			DONE	: begin
				clk_cnt_en	<= 1'b0	;
				data_reg	<= 'd0	;
				cs_n		<= 1'b1	;
				data_reg	<= 'd0	;
				finish 		<= 1'b1	;
			end
			default	: begin
				clk_cnt_en	<= 1'b0	;
				data_reg	<= 'd0	;
				cs_n		<= 1'b1	;
				data_reg	<= 'd0	;
				finish 		<= 1'b0	;
			end
		endcase
	end
end
//mosi output MSB first
assign mosi = data_reg[DATA_WIDTH-1];
//sample data from the miso line
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		data_out <= 'd0;
	else if (sampl_en) 
		data_out <= {data_out[DATA_WIDTH-1:0],miso};
	else
		data_out <= data_out;
end
//the function to get the width of data 
function integer log2(input integer v);
  begin
	log2=0;
	while(v>>log2) 
	  log2=log2+1;
  end
endfunction

endmodule
"
"Slave
`timescale 1ns/1ps

module SPI_Slave
#(
	parameter	CLK_FREQUENCE	= 50_000_000		,	//system clk frequence
				SPI_FREQUENCE	= 5_000_000			,	//spi clk frequence
				DATA_WIDTH		= 8					,	//serial word length
				CPOL			= 1					,	//SPI mode selection (mode 0 default)
				CPHA			= 1					 	//CPOL = clock polarity, CPHA = clock phase
)
(
	input								clk			,	//system clk
	input								rst_n		,	//system reset
	input		[DATA_WIDTH-1:0]		data_in		,	//the data sent by miso
	input								sclk		,	//spi bus sclk
	input								cs_n		,	//spi bus slave select line
	input								mosi		,	//spi bus mosi input
	output								miso		,	//spi bus miso output
	output								data_valid	,	//the data received by mosi valid
	output	reg	[DATA_WIDTH-1:0]		data_out	 	//the data received by mosi,valid when data_valid is high
);

localparam	SFIFT_NUM = log2(DATA_WIDTH);

reg	[DATA_WIDTH-1:0]		data_reg	;	//the register to latch the data_in,also the shift register
reg	[ SFIFT_NUM-1:0]		sampl_num	;	//the counter to count the number of sample
reg							sclk_a		;	//sclk register to capture the edge of sclk
reg							sclk_b		;	//sclk register to capture the edge of sclk
wire						sclk_posedge;	//posedge of sclk
wire						sclk_negedge;	//negedge of sclk
reg							cs_n_a		;	//cs_n register to capture the edge of cs_n
reg							cs_n_b		;	//cs_n register to capture the edge of cs_n
wire						cs_n_negedge;	//negedge of cs_n to latch the data
wire						shift_en	;	//the signal to enable shift register to generate mosi
wire						sampl_en	;	//the signal to sample the data from miso

//to capture the edge of sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		sclk_a <= CPOL;
		sclk_b <= CPOL;
	end else if (!cs_n) begin
		sclk_a <= sclk;
		sclk_b <= sclk_a;
	end
end

assign sclk_posedge = ~sclk_b & sclk_a;
assign sclk_negedge = ~sclk_a & sclk_b;

//to capture the edge of sclk
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) begin
		cs_n_a	<= 1'b1;
		cs_n_b	<= 1'b1;
	end else begin
		cs_n_a	<= cs_n		;
		cs_n_b	<= cs_n_a	;
	end
end

assign cs_n_negedge = ~cs_n_a & cs_n_b;

//==============GENERATE BLOCKS=================
generate
	case (CPHA)
		0: assign sampl_en = sclk_posedge;
		1: assign sampl_en = sclk_negedge;
		default: assign sampl_en = sclk_posedge;
	endcase
endgenerate

generate
 	case (CPHA)
		0: assign shift_en = sclk_negedge;
 		1: assign shift_en = sclk_posedge;
		default: assign shift_en = sclk_posedge;
	endcase
endgenerate

//the register to latch the data_in
//also the shift register to generate the miso
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		data_reg <= 'd0;
	else if(cs_n_negedge)
		data_reg <= data_in;
	else if (!cs_n & shift_en) 
		data_reg <= {data_reg[DATA_WIDTH-2:0],1'b0};
	else
		data_reg <= data_reg;
end
//miso output MSB first
assign miso = !cs_n ? data_reg[DATA_WIDTH-1] : 1'd0;

//sample data from the mosi line
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		data_out <= 'd0;
	else if (!cs_n & sampl_en) 
		data_out <= {data_out[DATA_WIDTH-2:0],mosi};
	else
		data_out <= data_out;
end
//the counter to count the number of sampled data bit
always @(posedge clk or negedge rst_n) begin
	if (!rst_n) 
		sampl_num <= 'd0;
	else if (cs_n)
		sampl_num <= 'd0;
	else if (!cs_n & sampl_en) 
		if (sampl_num == DATA_WIDTH)
			sampl_num <= 'd1;
		else
			sampl_num <= sampl_num + 1'b1;
	else
		sampl_num <= sampl_num;
end
//the received data valid
assign data_valid = sampl_num == DATA_WIDTH;
//the function to get the width of data 
function integer log2(input integer v);
  begin
	log2=0;
	while(v>>log2) 
	  log2=log2+1;
  end
endfunction

endmodule
"
"Loopback
`timescale 1ns/1ps

module SPI_loopback
#(
	parameter	CLK_FREQUENCE	= 50_000_000		,	//system clk frequence
				SPI_FREQUENCE	= 5_000_000			,	//spi clk frequence
				DATA_WIDTH		= 8					,	//serial word length
				CPOL			= 0					,	//SPI mode selection (mode 0 default)
				CPHA			= 0					 	//CPOL = clock polarity, CPHA = clock phase
)
(
	input							clk			,
	input							rst_n		,
	input		[DATA_WIDTH-1:0]	data_m_in	,
	input		[DATA_WIDTH-1:0]	data_s_in	,
	input							start_m		,
	output							finish_m	,
	output		[DATA_WIDTH-1:0]	data_m_out	,
	output		[DATA_WIDTH-1:0]	data_s_out	,
	output							data_valid_s	 
);

wire				miso	;
wire				mosi	;
wire				cs_n	;
wire				sclk	;

spi_master 
#(
	.CLK_FREQUENCE (CLK_FREQUENCE ),
	.SPI_FREQUENCE (SPI_FREQUENCE ),
	.DATA_WIDTH    (DATA_WIDTH    ),
	.CPOL          (CPOL          ),
	.CPHA          (CPHA          ) 
)
u_spi_master(
	.clk      (clk      ),
	.rst_n    (rst_n    ),
	.data_in  (data_m_in  ),
	.start    (start_m    ),
	.miso     (miso     ),
	.sclk     (sclk     ),
	.cs_n     (cs_n     ),
	.mosi     (mosi     ),
	.finish   (finish_m   ),
	.data_out (data_m_out )
);

SPI_Slave 
#(
	.CLK_FREQUENCE (CLK_FREQUENCE ),
	.SPI_FREQUENCE (SPI_FREQUENCE ),
	.DATA_WIDTH    (DATA_WIDTH    ),
	.CPOL          (CPOL          ),
	.CPHA          (CPHA          ) 
)
u_SPI_Slave(
	.clk        (clk        ),
	.rst_n      (rst_n      ),
	.data_in    (data_s_in    ),
	.sclk       (sclk       ),
	.cs_n       (cs_n       ),
	.mosi       (mosi       ),
	.miso       (miso       ),
	.data_valid (data_valid_s ),
	.data_out   (data_s_out   )
);

endmodule
"
"modified_booth
module MBA_module(p,a,b,clock);
    output [15:0] p;
    input [7:0]  a, b;
    input clock;
    reg [15:0] p,ans;

    integer i, lookup_tbl;
    integer operate;

    initial
    begin
        p=16'b0;
        ans=16'b0;
    end

    always @(negedge clock)
    begin
        p=16'b0;
        for(i=1;i<=7;i=i+2)
        begin
            if(i==1)
                lookup_tbl = 0;
            else
                lookup_tbl = b[i-2];

            lookup_tbl = lookup_tbl + 4*b[i] + 2*b[i-1]; 

            if(lookup_tbl == 0 || lookup_tbl == 7)
                operate = 0;
            else if(lookup_tbl == 3 || lookup_tbl == 4)
                operate = 2;
            else
                operate = 1;
            if(b[i] == 1)
                operate = -1*operate;

            case(operate)
            1:
                begin
                    ans=a;
                    ans=ans<<(i-1);
                    p=p+ans;
                end
            2:
                begin
                    ans=a<<1;
                    ans=ans<<(i-1);
                    p=p+ans;
                end
            -1:
                begin
                    ans=~a+1;
                    ans=ans<<(i-1);
                    p=p+ans;
                end
            -2:
                begin
                    ans=a<<1;
                    ans=~ans+1;
                    ans=ans<<(i-1);
                    p=p+ans;
                end
            endcase
        end
    end
endmodule

"
"non_restoring_div_R2
module non_restoring_div(clk, reset, Dividend, Divisor, Quotient, Remainder);
	input clk, reset;
	input [63:0] Dividend, Divisor;
	output [63:0] Quotient, Remainder;
	reg [63:0] Quotient, Remainder;
	reg [63:0] p, a, temp;
	integer i;

	always @(posedge clk, negedge reset)
	begin
		if( !reset )
		begin
			Quotient <= 0;
			Remainder <= 0;
		end
		else
		begin
			Quotient <= a;
			Remainder <= p;
		end
	end

	always @(*)
	begin
		a = Dividend;
		p = 0;

		for(i = 0; i < 64; i = i+1)
		begin
			//Shift Left carrying a's MSB into p's LSB
			p = (p << 1) | a[63];
			a = a << 1;

			//Check the old value of p
			if( p[63] ) //if p is negative
				temp = Divisor; //add divisor
			else
				temp = ~Divisor+1; //subtract divisor

			//this will do the appropriate add or subtract
			//depending on the value of temp
			p = p + temp;

			//Check the new value of p
			if( p[63] ) // if p is negative
				a = a | 0; //no change to quotient
			else
				a = a | 1; 
		end

		//Correction is needed if remainder is negative
		if( p[63] ) //if p is negative
			p = p + Divisor;
	end
				
endmodule

module non_restoring_div_tb;
	reg clk, reset;
	reg [63:0] dividend, divisor;
	wire [63:0] quotient, remainder;

	non_restoring_div divider(clk, reset, dividend, divisor, quotient, remainder);

	initial
		forever #1 clk = ~clk;

	initial
		$monitor(""%0d / %0d: q = %0d, r = %0d"", dividend, divisor, quotient, remainder);

	initial
	begin
		clk = 0;
		reset = 0;

		#1;
		reset = 1;
		dividend = 87;
		divisor = 5;

		#5;
		dividend = 59;
		divisor = 20;

		#5;
		dividend = 64'hFFFF_FFFF_FFFF_FFFF;
		divisor = 2;

		#5;
		dividend = 32'h1234_5678;
		divisor = 1;

		#5;
		divisor = dividend;
	
		#5;
		$finish;
	end

endmodule
"
"restoring_div_R2
module restoring_div_R2(clk, reset, Dividend, Divisor, Quotient, Remainder);
	input clk, reset;
	input [63:0] Dividend, Divisor;

	output [63:0] Quotient, Remainder;
	reg [63:0] Quotient, Remainder;

	reg [63:0] p, a, temp;
	integer i;

	always @(posedge clk, negedge reset)
	begin
		if( !reset )
		begin
			Quotient <= 0;
			Remainder <= 0;
		end
		else
		begin
			Quotient <= a;
			Remainder <= p;
		end
	end

	always @(*)
	begin
		a = Dividend;
		p = 0;

		for(i = 0; i < 64; i = i+1)
		begin
			//Shift Left carrying a's MSB into p's LSB
			p = (p << 1) | a[63];
			a = a << 1;

			//store value in case we have to restore
			temp = p;

			//Subtract
			p = p - Divisor;

			if( p[63] ) // if p < 0
				p = temp; //restore value
			else
				a = a | 1;
		end	
	end
				
endmodule
	
module restoring_div_R2_tb;
	reg clk, reset;
	reg [63:0] dividend, divisor;
	wire [63:0] quotient, remainder;

	restoring_div_R2 divider(clk, reset, dividend, divisor, quotient, remainder);

	initial
		forever #1 clk = ~clk;

	initial
		$monitor(""%0d / %0d: q = %0d, r = %0d"", dividend, divisor, quotient, remainder);

	initial
	begin
		clk = 0;
		reset = 0;

		#1;
		reset = 1;
		dividend = 87;
		divisor = 5;

		#5;
		dividend = 59;
		divisor = 20;

		#5;
		dividend = 64'hFFFF_FFFF_FFFF_FFFF;
		divisor = 2;

		#5;
		dividend = 32'h1234_5678;
		divisor = 1;

		#5;
		divisor = dividend;
	
		#5;
		$finish;
	end

endmodule
"
"restoring_div_R4
module restoring_div_R4(clk, reset, Dividend, Divisor, Quotient, Remainder);
	input clk, reset;
	input [63:0] Dividend, Divisor;

	output [63:0] Quotient, Remainder;
	reg [63:0] Quotient, Remainder;
	reg [63:0] p, a;
	reg [63:0] Result1, Result2, Result3;
	reg [63:0] DivisorX2, DivisorX3;
	integer i;

	always @(posedge clk, negedge reset)
	begin
		if( !reset )
		begin
			Quotient <= 0;
			Remainder <= 0;
		end
		else
		begin
			Quotient <= a;
			Remainder <= p;
		end
	end

	always @(*)
	begin
		a = Dividend;
		p = 0;
		DivisorX2 = Divisor << 1; //Divisor*2
		DivisorX3 = (Divisor << 1) + Divisor; //Divisor*3

		for(i = 0; i < 32; i = i+1)
		begin
			//Shift Left carrying a's MSB into p's LSB
			p = (p << 2) | a[63:62];
			a = a << 2;

			//Subtract
			Result1 = p - Divisor;
			Result2 = p - DivisorX2;
			Result3 = p - DivisorX3;

			if( Result1[63] ) //Divisor is too big
			begin
				a = a | 0;
			end
			else if( Result2[63] )//Divisor*2 is too big, but Divisor*1 is OK
			begin
				p = Result1;
				a = a | 1;
			end
			else if( Result3[63] ) //Divisor*3 is too big, but Divisor*2 is OK
			begin
				p = Result2;
				a = a | 2;
			end
			else
			begin //Divisor*3 is OK
				p = Result3;
				a = a | 3;
			end
		end	
	end
				
endmodule

module restoring_div_R4_tb;
	reg clk, reset;
	reg [63:0] dividend, divisor;
	wire [63:0] quotient, remainder;

	restoring_div_R4 divider(clk, reset, dividend, divisor, quotient, remainder);

	initial
		forever #1 clk = ~clk;

	initial
		$monitor(""%0d / %0d: q = %0d, r = %0d"", dividend, divisor, quotient, remainder);

	initial
	begin
		clk = 0;
		reset = 0;

		#1;
		reset = 1;
		dividend = 87;
		divisor = 5;

		#5;
		dividend = 59;
		divisor = 20;

		#5;
		dividend = 64'hFFFF_FFFF_FFFF_FFFF;
		divisor = 2;

		#5;
		dividend = 32'h1234_5678;
		divisor = 1;

		#5;
		divisor = dividend;
	
		#5;
		$finish;
	end

endmodule
"
"Addition_Subtraction
module priority_encoder(
			input [24:0] significand,
			input [7:0] exp_a,
			output reg [24:0] Significand,
			output [7:0] exp_sub
			);

reg [4:0] shift;

always @(significand)
begin
	casex (significand)
		25'b1_1xxx_xxxx_xxxx_xxxx_xxxx_xxxx :	begin
													Significand = significand;
									 				shift = 5'd0;
								 			  	end
		25'b1_01xx_xxxx_xxxx_xxxx_xxxx_xxxx : 	begin						
										 			Significand = significand << 1;
									 				shift = 5'd1;
								 			  	end

		25'b1_001x_xxxx_xxxx_xxxx_xxxx_xxxx : 	begin						
										 			Significand = significand << 2;
									 				shift = 5'd2;
								 				end

		25'b1_0001_xxxx_xxxx_xxxx_xxxx_xxxx : 	begin 							
													Significand = significand << 3;
								 	 				shift = 5'd3;
								 				end

		25'b1_0000_1xxx_xxxx_xxxx_xxxx_xxxx : 	begin						
									 				Significand = significand << 4;
								 	 				shift = 5'd4;
								 				end

		25'b1_0000_01xx_xxxx_xxxx_xxxx_xxxx : 	begin						
									 				Significand = significand << 5;
								 	 				shift = 5'd5;
								 				end

		25'b1_0000_001x_xxxx_xxxx_xxxx_xxxx : 	begin						// 24'h020000
									 				Significand = significand << 6;
								 	 				shift = 5'd6;
								 				end

		25'b1_0000_0001_xxxx_xxxx_xxxx_xxxx : 	begin						// 24'h010000
									 				Significand = significand << 7;
								 	 				shift = 5'd7;
								 				end

		25'b1_0000_0000_1xxx_xxxx_xxxx_xxxx : 	begin						// 24'h008000
									 				Significand = significand << 8;
								 	 				shift = 5'd8;
								 				end

		25'b1_0000_0000_01xx_xxxx_xxxx_xxxx : 	begin						// 24'h004000
									 				Significand = significand << 9;
								 	 				shift = 5'd9;
								 				end

		25'b1_0000_0000_001x_xxxx_xxxx_xxxx : 	begin						// 24'h002000
									 				Significand = significand << 10;
								 	 				shift = 5'd10;
								 				end

		25'b1_0000_0000_0001_xxxx_xxxx_xxxx : 	begin						// 24'h001000
									 				Significand = significand << 11;
								 	 				shift = 5'd11;
								 				end

		25'b1_0000_0000_0000_1xxx_xxxx_xxxx : 	begin						// 24'h000800
									 				Significand = significand << 12;
								 	 				shift = 5'd12;
								 				end

		25'b1_0000_0000_0000_01xx_xxxx_xxxx : 	begin						// 24'h000400
									 				Significand = significand << 13;
								 	 				shift = 5'd13;
								 				end

		25'b1_0000_0000_0000_001x_xxxx_xxxx : 	begin						// 24'h000200
									 				Significand = significand << 14;
								 	 				shift = 5'd14;
								 				end

		25'b1_0000_0000_0000_0001_xxxx_xxxx  : 	begin						// 24'h000100
									 				Significand = significand << 15;
								 	 				shift = 5'd15;
								 				end

		25'b1_0000_0000_0000_0000_1xxx_xxxx : 	begin						// 24'h000080
									 				Significand = significand << 16;
								 	 				shift = 5'd16;
								 				end

		25'b1_0000_0000_0000_0000_01xx_xxxx : 	begin						// 24'h000040
											 		Significand = significand << 17;
										 	 		shift = 5'd17;
												end

		25'b1_0000_0000_0000_0000_001x_xxxx : 	begin						// 24'h000020
									 				Significand = significand << 18;
								 	 				shift = 5'd18;
								 				end

		25'b1_0000_0000_0000_0000_0001_xxxx : 	begin						// 24'h000010
									 				Significand = significand << 19;
								 	 				shift = 5'd19;
												end

		25'b1_0000_0000_0000_0000_0000_1xxx :	begin						// 24'h000008
									 				Significand = significand << 20;
								 					shift = 5'd20;
								 				end

		25'b1_0000_0000_0000_0000_0000_01xx : 	begin						// 24'h000004
									 				Significand = significand << 21;
								 	 				shift = 5'd21;
								 				end

		25'b1_0000_0000_0000_0000_0000_001x : 	begin						// 24'h000002
									 				Significand = significand << 22;
								 	 				shift = 5'd22;
								 				end

		25'b1_0000_0000_0000_0000_0000_0001 : 	begin						// 24'h000001
									 				Significand = significand << 23;
								 	 				shift = 5'd23;
								 				end

		25'b1_0000_0000_0000_0000_0000_0000 : 	begin						// 24'h000000
								 					Significand = significand << 24;
							 	 					shift = 5'd24;
								 				end
		default : 	begin
						Significand = (~significand) + 1'b1;
						shift = 8'd0;
					end

	endcase
end
assign exp_sub = exp_a - shift;

endmodule

module Addition_Subtraction(input [31:0] a,b,
input add_sub_signal,														// If 1 then addition otherwise subtraction
output exception,
output [31:0] res );

wire operation_add_sub_signal;
wire enable;
wire output_sign;

wire [31:0] op_a,op_b;
wire [23:0] significand_a,significand_b;
wire [7:0] exp_diff;


wire [23:0] significand_b_add_sub;
wire [7:0] exp_b_add_sub;

wire [24:0] significand_add;
wire [30:0] add_sum;

wire [23:0] significand_sub_complement;
wire [24:0] significand_sub;
wire [30:0] sub_diff;
wire [24:0] subtraction_diff; 
wire [7:0] exp_sub;

assign {enable,op_a,op_b} = (a[30:0] < b[30:0]) ? {1'b1,b,a} : {1'b0,a,b};							// For operations always op_a must not be less than b

assign exp_a = op_a[30:23];
assign exp_b = op_b[30:23];

assign exception = (&op_a[30:23]) | (&op_b[30:23]);										// Exception flag sets 1 if either one of the exponent is 255.

assign output_sign = add_sub_signal ? enable ? !op_a[31] : op_a[31] : op_a[31] ;

assign operation_add_sub_signal = add_sub_signal ? op_a[31] ^ op_b[31] : ~(op_a[31] ^ op_b[31]);
																// Assign significand values according to Hidden Bit.
assign significand_a = (|op_a[30:23]) ? {1'b1,op_a[22:0]} : {1'b0,op_a[22:0]};							// If exponent is zero,hidden bit = 0,else 1
assign significand_b = (|op_b[30:23]) ? {1'b1,op_b[22:0]} : {1'b0,op_b[22:0]};

assign exp_diff = op_a[30:23] - op_b[30:23];											// Exponent difference calculation
assign significand_b_add_sub = significand_b >> exp_diff;
assign exp_b_add_sub = op_b[30:23] + exp_diff; 

assign perform = (op_a[30:23] == exp_b_add_sub);										// Checking if exponents are same


// Add Block //
assign significand_add = (perform & operation_add_sub_signal) ? (significand_a + significand_b_add_sub) : 25'd0; 

assign add_sum[22:0] = significand_add[24] ? significand_add[23:1] : significand_add[22:0];					// res will be most 23 bits if carry generated, else least 22 bits.

assign add_sum[30:23] = significand_add[24] ? (1'b1 + op_a[30:23]) : op_a[30:23];						// If carry generates in sum value then exponent is added with 1 else feed as it is.

// Sub Block //
assign significand_sub_complement = (perform & !operation_add_sub_signal) ? ~(significand_b_add_sub) + 24'd1 : 24'd0 ; 

assign significand_sub = perform ? (significand_a + significand_sub_complement) : 25'd0;

priority_encoder pe(significand_sub,op_a[30:23],subtraction_diff,exp_sub);

assign sub_diff[30:23] = exp_sub;

assign sub_diff[22:0] = subtraction_diff[22:0];

// Output //
assign res = exception ? 32'b0 : ((!operation_add_sub_signal) ? {output_sign,sub_diff} : {output_sign,add_sum});

endmodule


module Addition_Subtraction_tb;

reg [31:0] a,b;
reg clk=1'b0,
	reset =1'b1;
reg add_sub_signal;

wire [31:0] res;
wire exception;

Addition_Subtraction dut(a,b,add_sub_signal,exception,res);

always #5 clk = ~clk;

initial
begin

add_sub_signal = 1'b0;

iteration (32'h4201_51EC,32'h4242_147B,32'h42A1_B333,`__LINE__); //32.33 + 48.52 = 80.85

iteration (32'h4068_51EC,32'h4090_A3D7,32'h4102_6666,`__LINE__); //3.63 + 4.52 = 8.15.

iteration (32'h4195_0A3D,32'h419B_47AE,32'h4218_28F6,`__LINE__); //18.63 + 19.41 = 38.04.

iteration (32'h4217_999A,32'h3F8C_CCCD,32'h421C_0000,`__LINE__); //37.9 + 1.1 = 39.

iteration (32'h4383_C7AE,32'h4164_F5C3,32'h438A_EF5C,`__LINE__); //263.56 + 14.31 = 277.87

iteration (32'h4542_77D7,32'h453B_8FD7,32'h45BF_03D7,`__LINE__); //3111.49 + 3000.99 = 6112.48

iteration (32'h3F3A_E148,32'h3EB33333,32'h3F8A_3D71,`__LINE__); //0.73 + 0.35 = 1.08.

iteration (32'h3F7D_70A4,32'h3F7D_70A4,32'h3FFD_70A4,`__LINE__); //0.99 + 0.99 = 1.98

iteration (32'h3F40_0000,32'h3E94_7AE1,32'h3F85_1EB8,`__LINE__); //0.75 + 0.29 = 1.04

iteration (32'h4B7F_FFFF,32'h3F80_0000,32'h4B80_0000,`__LINE__); //16777215 + 1 = 16777216
								 // Corner Case

iteration (32'h4B7F_FFFF,32'h4000_0000,32'h4B80_0001,`__LINE__); //16777215 + 2 = 16777217.
								 // Corner Case

iteration (32'h4B7F_FFFF,32'h4B7F_FFFF,32'h4BFF_FFFF,`__LINE__); //16777215 + 16777215 = 33554430
								 // Working

iteration (32'h4B7F_FFFE,32'h3F80_0000,32'h4B7F_FFFF,`__LINE__); //16777214 + 1 = 16777215

iteration (32'hBF3A_E148,32'h3EC7_AE14,32'hBEAE_147B,`__LINE__); //-0.73 + 0.39 = -0.34

iteration (32'hC207_C28F,32'h4243_B852,32'h416F_D70A,`__LINE__); //-33.94 + 48.93 = 14.99

iteration (32'hBDB2_2D0E,32'h4305_970A,32'h4305_80C5,`__LINE__); //-0.087 + 133.59 = 133.503

iteration (32'h4E6B_79A3,32'hCCEB_79A3,32'h4E4E_0A6F,`__LINE__); //987654321 - 123456789 = 864197532

iteration (32'h4B80_0000,32'hCB80_0000,32'h0000_0000,`__LINE__); //16777216 - 16777216 = 0

iteration (32'h4B7F_FFFF,32'hCB7F_FFFF,32'h0000_0000,`__LINE__); //16777215 - 16777215 = 0

// Subtraction //

add_sub_signal = 1'b1;

iteration (32'h40A00000,32'h40C00000,32'hBF800000,`__LINE__); //5 - 6 = -1

iteration (32'h40C00000,32'h40A00000,32'h3F800000,`__LINE__); //6 - 5 = 1

iteration (32'hC0C00000,32'hC0A00000,32'hBF800000,`__LINE__); //-6 - (-5) = -1

iteration (32'hC0A00000,32'hC0C00000,32'h3F800000,`__LINE__); // -5 - (-6) = 1

iteration (32'h40C00000,32'hC0A00000,32'h41300000,`__LINE__); // 6 - (-5) = 11

iteration (32'h40A00000,32'hC0C00000,32'h41300000,`__LINE__); // 5 - (-6) = 11

iteration (32'hC0A00000,32'h40C00000,32'hC1300000,`__LINE__); // -5 - (6) = -11

iteration (32'hC0C00000,32'h40A00000,32'hC1300000,`__LINE__); // -6 - (+5) = -11

// Exception Cases //

iteration (32'h0000_0000,32'h3EC7_AE14,32'h3EC7_AE14,`__LINE__);

iteration (32'h3EC7_AE14,32'h0000_0000,32'h3EC7_AE14,`__LINE__);

iteration (32'h0000_0000,32'h0000_0000,32'h0000_0000,`__LINE__);

iteration (32'h7F80_0000,32'h7F90_0100,32'h0000_0000,`__LINE__);

iteration (32'h7F80_0000,32'h3EC7_AE14,32'h0000_0000,`__LINE__);

iteration (32'h3EC7_AE14,32'h7F80_0000,32'h0000_0000,`__LINE__);

iteration (32'h7F80_0000,32'h0000_0000,32'h0000_0000,`__LINE__);

iteration (32'h7F90_0100,32'h7F80_0000,32'h0000_0000,`__LINE__);

@(negedge clk)
$stop;

end

task iteration(
input [31:0] op_a,op_b,expected_value,
input integer line_num );

begin
	@(negedge clk)
	begin
		a = op_a;
		b = op_b;
	end

	@(posedge clk)
	begin
		#1;
		if (expected_value == res)
			$display (""Success: Line Number -> %d"",line_num);
		else 
			$display (""Failed: \t\n A => %h, \t\n B => %h, \t\n Result Obtained => %h, \t\n Expected Value => %h - Line Number"",op_a,op_b,res,expected_value,line_num);
	end
end
endtask

endmodule
"
"test_commands
add wave clk Sa Sb state lightA lightB
force clk 0 0, 1 5 sec -repeat 10 sec
force Sa 1 0, 0 40, 1 170, 0 230, 1 250 sec
force Sb 0 0, 1 70, 0 100, 1 120, 0 150, 1 210, 0 250, 1 270 sec
run 300 sec
"
"traffic_light
module traffic_light (clk, Sa, Sb, Ra, Rb, Ga, Gb, Ya, Yb);
input clk;
input Sa;
input Sb;
inout Ra;
inout Rb;
inout Ga;
inout Gb; 
inout Ya;
inout Yb;
reg Ra_tmp;
reg Rb_tmp;
reg Ga_tmp;
reg Gb_tmp;
reg Ya_tmp;
reg Yb_tmp;
reg[3:0] state;
reg[3:0] nextstate;
parameter[1:0] R = 0;
parameter[1:0] Y = 1;
parameter[1:0] G = 2;
wire[1:0] lightA;
wire[1:0] lightB;
assign Ra = Ra_tmp;
assign Rb = Rb_tmp;
assign Ga = Ga_tmp;
assign Gb = Gb_tmp;
assign Ya = Ya_tmp;
assign Yb = Yb_tmp;
initial
begin
 state = 0;
end
always @(state or Sa or Sb)
begin
 Ra_tmp = 1'b0 ;
 Rb_tmp = 1'b0 ;
 Ga_tmp = 1'b0 ;
 Gb_tmp = 1'b0 ;
 Ya_tmp = 1'b0 ;
 Yb_tmp = 1'b0 ;
 nextstate = 0;
 case (state)
 0, 1, 2, 3, 4 :
 begin Ga_tmp = 1'b1 ;
 Rb_tmp = 1'b1 ;
 nextstate = state + 1 ;
 end
 5 :
 begin
 Ga_tmp = 1'b1 ;
 Rb_tmp = 1'b1 ;
 if (Sb == 1'b1)
 begin
 nextstate = 6 ;
 end
 else
 begin
 nextstate = 5 ;
 end 
 end
 6 :
 begin
 Ya_tmp = 1'b1 ;
 Rb_tmp = 1'b1 ;
 nextstate = 7 ;
 end
 7, 8, 9, 10 :
 begin
 Ra_tmp = 1'b1 ;
 Gb_tmp = 1'b1 ;
 nextstate = state + 1 ;
 end
 11 :
 begin
 Ra_tmp = 1'b1 ;
 Gb_tmp = 1'b1 ;
 if (Sa == 1'b1 | Sb == 1'b0)
 begin
 nextstate = 12 ;
 end 
 else
 begin
 nextstate = 11 ;
 end 
 end
 12 :
 begin
 Ra_tmp = 1'b1 ;
 Yb_tmp = 1'b1 ;
 nextstate = 0 ;
 end
 endcase
end always @(posedge clk)
begin
 state <= nextstate ;
end
assign lightA = (Ra==1'b1) ? R : (Ya==1'b1) ? Y : (Ga==1'b1) ? G : lightA;
assign lightB = (Rb==1'b1) ? R : (Yb==1'b1) ? Y : (Gb==1'b1) ? G : lightB;
endmodule
"
"adder32
module Adder32 (A, B, Ci, S, Co);

input[31:0] A;
input[31:0] B;
input Ci;
output[31:0] S;
output Co;
wire[32:0] Sum33;
assign Sum33 = A + B + Ci ;
assign S = Sum33[31:0] ;
assign Co = Sum33[32] ;
endmodule
"
"Establish a circuit with no input and the output being a constant 0.

This series of questions uses the ***Verilog-2001 ANSI-style*** port declaration syntax because it is easier to read and reduces spelling errors. If you wish, you can use the old Verilog-1995 syntax. For example, the following two module declarations are acceptable and equivalent:

```verilog
module top_moduel(zero);
	output zero;
	//Verilog-1995
endmodule

module top_module(output zero);
//Verilog-2001
endmodule
```

- Module Declaration
```verilog
module top_module(
    output zero
);
```

---

## Verilog Language  

### Basic Elements, ignore the picture and special token
module top_module(
    output zero
);// Module body starts after semicolon
	assign zero=0;
endmodule"
"Create a module with one input and one output, whose behavior is like a ""Wire"".

Different from physical wires but very similar, in Verilog, wires (and other signals) are directed. This means that information flows in only one direction, from a source (which is typically a driver, driving values onto the wire) to a sink. In Verilog's ""continuous assignment"" (assign left_side=right_side;), the signal value on the right is driven onto the ""wire"" on the left. Please note: assignments are ""***continuous***"" because if the value on the right side changes, the assignment will continue, and thus the value on the left side will also change (a significant difference from other languages). Continuous assignments are not one-time events; the changes they produce are permanent.

To truly understand why this is the case, you must first realize that you are not writing a program; you are actually ""drawing"" a circuit with code! Therefore, changes in the input voltage level will inevitably affect the other end of the wire, as if there were a real wire connecting the two variables.

The ports on a module also have a direction (usually input - input or output - output). Input ports are driven by something external to the module, while output ports drive something external. When viewed from inside the module, input ports are drivers or sources, and output ports are receivers.

The diagram below illustrates how each part of the circuit corresponds to each part of Verilog code. The module and port declarations create the black parts of the circuit. Your task is to create a wire (green) by adding an assign statement. The components outside the box are not your concern, but you should know that you can test the circuit by connecting test stimuli to the ports on the top_module.

Apart from continuous assignment, Verilog also has three other types of assignment for procedural blocks, two of which are synthesizable. We will not use them until we start using procedural blocks.

- Module Declaration
```verilog
module top_module( input in, output out );
```, ignore the picture and special tokens
module top_module( input in, output out );
    assign out = in;
endmodule"
"Create a module with 3 inputs and 4 outputs, where the behavior of these inputs and outputs is as follows:

```
A -> W
B -> X
B -> Y
C -> Z
```

The diagram below illustrates how each part of the circuit corresponds to each part of the Verilog code. The module has three input ports and four output ports externally.

When you have multiple assign statements, their order of appearance in the code is not important. Unlike in programming languages, assign statements (""continuous assignment"") describe the connections between things rather than copying values from one thing to another.

One potential source of confusion that should be clarified now is that the green arrows here represent connections between wires, but they are not wires themselves. The module itself has declared seven wires (named A, B, C, W, X, Y, and Z). This is because inputs and outputs are declared as wire types. Therefore, assign statements do not create wires; they describe connections created between the existing seven wires.

Module Declaration:
```verilog
module top_module(
    input a, b, c;
    output w, x, y, z
);
```
module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w=a;
    
assign x=b;
    
assign y=b;
    
assign z=c;
endmodule"
"Create a module to implement a NOT gate.

This circuit is similar to wires but with a slight difference. When connecting a wire from the input to the output, we want to implement an inverter (NOT gate) instead of a regular wire.

Use the assign statement. The assign statement continuously inverts the input signal and outputs it.

- Module
```verilog
module top_module( input in, output out );
```
module top_module( input in, output out );
	assign out = !in;
endmodule"
"Create a module to implement an AND gate.

This circuit currently has three lines (A, B, and OUT). Wires A and B already have values driven by input ports. But the current wiring is not driven by anything. Write an assignment statement to drive it with the sum of signals A and B.

Input lines are driven by something external to the module. An assign statement will connect a logic-level driven signal to a wire. As you might expect, a wire cannot have multiple driving signals (if it does, what is its logic level?), and wires without driving signals will have an undefined value (typically treated as 0 when synthesizing hardware, but strange errors can sometimes occur).

Module Declaration
```verilog
module top_module(
    input a,
    input b,
    output out );
```
module top_module( 
    input a, 
    input b, 
    output out );
assign out = a&b;
endmodule"
"Create a module to implement a NOR or NOT gate. The NOR gate is an OR gate with inverted output.

The `assign` statement drives a wire (or more formally called a ""net"") with a value. This value can be any complex function as long as it is combinational logic (i.e., memory-less, without hidden states).

- Module Declaration
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
```
module top_module( 
    input a, 
    input b, 
    output out );
    assign out = !(a|b);
endmodule"
"Translate the following text to English:

&emsp;&emsp;Implement the XNOR gate module.

- Module Declaration 
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
```, ignore the picture and special token
module top_module( 
    input a, 
    input b, 
    output out );
    assign out = !(a^b);
endmodule"
"So far, the circuits have been quite simple. As the circuits become more complex, you will need to wire to connect internal components together. When you need to use a wire, you should declare it somewhere in the module body before its first use. (In the future, you will encounter more types of signals and variables that are also declared in the same way, but for now, we will start with signals of the Wire type).

Implement the following circuit. Create two wires (name them as you like) to connect the AND and OR gates together. Note that the NOT gate is an output, so you do not need to declare a third wire here. Wires can have multiple outputs, but only one input driver.

If you follow the circuit structure shown in the picture, you should end up with four assignment statements since there are four signals that need to be assigned.

- Module Declaration

```verilog
`default_nettype none
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out,
    output out_n   );
```
`default_nettype none
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out,
    output out_n   ); 
wire inside1,inside2;
    
assign inside1 = a&b;
    
assign inside2 = c&d; 
    
assign out = inside1|inside2;
    
    assign out_n = !(out);
endmodule"
"Perform the following circuit:

![7458](./picture/7458.png)

- Module Declaration
```verilog
module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
```

---

### Container(Vectors), ignore the picture and special token
module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
wire inside1,inside2,inside3,inside4;
    
assign inside1 = p1a&p1b&p1c;
    
assign inside2 = p1d&p1e&p1f;
    
assign inside3 = p2a&p2b;
    
assign inside4 = p2c&p2d;
    
assign p1y = inside1|inside2;
    
assign p2y = inside3|inside4;

endmodule"
"The text describes the use of vectors in Verilog to group related signals for easier manipulation. For example, declaring `Wire[7:0]w;` declares an 8-bit array named `w`, which is functionally equivalent to having 8 independent lines.

It notes that in vector declarations, the dimensions (i.e., the array length) are placed before the container name, which is uncommon compared to C syntax.

The reason for such declarations is mainly due to the use of little-endian ordering.

An example declaration is provided:
```verilog
Wire[99:0]my_vector; // declaring a container of length 100
assign out = my_vector[10]; // selecting one bit from the array
```

The text then describes building a circuit with a 3-bit vector input, split into three separate 1-bit outputs.

A module declaration for the circuit is provided:
```verilog
module top_module (
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0 );
```

The text also mentions that the image and special characters can be ignored.
module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign o0 = vec[0];
    
    assign o1 = vec[1];
    
    assign o2 = vec[2];
    
assign outv = vec;
endmodule"
"The vector declaration is as follows:

> type [upper:lower] vector_name;  
> `type` specifies the type of the vector, usually it is `wire` or `reg`.

```verilog
wire [2:0] a, c;   // Two vectors
assign a = 3'b101;  // a = 101
assign b = a;       // b =   1  implicitly-created wire
assign c = b;       // c = 001  <-- bug
my_module i1 (d,e); // d and e are implicitly one-bit wide if not declared.
                    // This could be a bug if the port was intended to be a vector.
```

- Regarding ""Part Selection"":  
Accessing the entire array requires:  
```verilog
assign w = a;
```
And accessing a part of the array, if lengths do not match in assignments, use zero padding, for example:
```verilog
reg [7:0] c;
assign c = x[3:1];
// In this case, the lengths do not match, so it is padded with 0s

w[3:0]      // Only the lower 4 bits of w
x[1]        // The lowest bit of x
x[1:1]      // ...also the lowest bit of x
z[-1:-2]    // Two lowest bits of z
b[3:0]      // Illegal. Vector part-select must match the direction of the declaration.
b[0:3]      // The *upper* 4 bits of b.
assign w[3:0] = b[0:3];    // Assign upper 4 bits of b to lower 4 bits of w. w[3]=b[0], w[2]=b[1], etc.
```

To create a circuit, splitting a half-word (16 bits, [15:0]) into the upper 8 bits [15:8] and the lower 8 bits [7:0] are output.

- Module Declaration
```verilog
`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
```
`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    assign out_lo = in[7:0];
    
    assign out_hi = in[15:8];
endmodule"
"A 32-bit vector can be seen as containing 4 bytes ([31:24], [23:16], etc.). Create a circuit to reverse the order of the 4 bytes.

```
aaaaaaaabbbbbbcccccccccddddddd => ddddddddccccccccccbbbbbbbaaaaaaaa
```

This operation is commonly used when swapping the end address of a data segment, for example, between Little Endian x86 systems and the Big Endian format used in many Internet protocols.

- Module Declaration 
```verilog
module top_module( 
    input [31:0] in,
    output [31:0] out );
```
module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out[31:24] = in[7:0];
    
    assign out[23:16] = in[15:8];
    
    assign out[15:8] = in[23:16];
    
    assign out[7:0] = in[31:24];
endmodule"
"Establish a circuit with two 3-bit inputs to compute the ""bitwise-OR"" of two vectors, the ""logical OR"" of two vectors, and the NOT operation of two vectors. Place the NOT operation of b in the high bits of out-not (i.e., [5:3]), and place the NOT operation of a in the low bits.

Observe the simulation waveform to understand the differences between bitwise-OR and logical OR.

- Module Declaration 
```verilog
module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
```
module top_module(
	input [2:0] a, 
	input [2:0] b, 
	output [2:0] out_or_bitwise,
	output out_or_logical,
	output [5:0] out_not
);
	
	assign out_or_bitwise = a | b;
	assign out_or_logical = a || b;

	assign out_not[2:0] = ~a;	// Part-select on left side is o.
	assign out_not[5:3] = ~b;	//Assigning to [5:3] does not conflict with [2:0]
	
endmodule"
"Establish a combinational circuit with a 4-bit input, the outputs are required as follows:

- `out_and`: Result of input after passing through an ""AND gate""
- `out_or`: Result of input after passing through an ""OR gate""
- `out_xor`: Result of input after passing through an ""XOR gate""

Module Declaration:
```verilog
module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
```
module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = in[0]&in[1]&in[2]&in[3];
    
    assign out_or = in[0]|in[1]|in[2]|in[3];
    
    assign out_xor = in[0]^in[1]^in[2]^in[3];
endmodule"
"The excerpt provided explains the partial selection of vectors using concatenation operators. The operator {a,b,c} combines smaller parts of a vector to create a larger vector.

```verilog
{3'b111, 3'b000} => 6'b111000
{1'b1, 1'b0, 3'b101} => 5'b10101
{4'ha, 4'd10} => 8'b10101010     // 4'ha and 4'd10 are both 4'b1010 in binary
```

Concatenation requires knowledge of the width of each component; thus, {1,2,3} is invalid and will result in an error message: ""Constants not sized for concatenation.""

Concatenation operators can be used on both sides of an assignment.

```verilog
input [15:0] in;
output [23:0] out;
assign {out[7:0], out[15:8]} = in;         // Swap two bytes. Both sides are 16-bit vectors.
assign out[15:0] = {in[7:0], in[15:8]};    // Same as the above.
assign out = {in[7:0], in[15:8]};           // Different from above. Right side is extended to match the left.
```

Concatenation followed by slicing a given input:

![vector3](./picture/vector3.png)

Module Declaration:

```verilog
module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );
```
module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    assign {w[7:0],x[7:0],y[7:0],z[7:0]} = {a[4:0],b[4:0],c[4:0],d[4:0],e[4:0],f[4:0],2'b11};
endmodule"
"Reverse an 8-bit vector.

- Module Declaration 
```verilog
module top_module( 
    input [7:0] in,
    output [7:0] out
);
```
module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in;
endmodule"
"The joining operator allows you to join vectors together to form a larger vector. But sometimes you want to concatenate the same thing many times, such as `assign A = {B, B, B, B, B, B};` which can be mundane. The repetition operator allows you to duplicate vectors and concatenate them together:
```verilog
{num{vector}}
```
This will duplicate the `vector` `num` times.

For example:
```verilog
{5{1'b1}}           // 5'b11111 (or 5'd31 or 5'h1f)
{2{a,b,c}}          // The same as {a,b,c,a,b,c}
{3'd5, {2{3'd6}}}   // 9'b101_110_110. It's a concatenation of 101 with
                    // the second vector, which is two copies of 3'b110.
```

Repetition operators are often used in signed number extension operations. For example, when extending an 8-bit signed number to 16 bits, we need to duplicate its sign bit and fill it into the extended bits. In other words:
```
8'b10000001 => 16'b1111111110000001
// This is sign extension for signed numbers
```

- Module Declaration 
```verilog
module top_module (
    input [7:0] in,
    output [31:0] out );
```
module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out[31:0] = {{24{in[7]}},in[7:0]};
endmodule"
"Given 5 input signals of 1 bit each, perform comparison operations as shown in the diagram below. Matching bits are represented as 1 and stored in the 'out' variable.

```verilog
out[24] = ~a ^ a;  // a == a, so out[24] is always 1.
out[23] = ~a ^ b;
out[22] = ~a ^ c;
...
out[ 1] = ~e ^ d;
out[ 0] = ~e ^ e;
```

- Module Declaration
```verilog
module top_module (
    input a, b, c, d, e,
    output [24:0] out );
```
module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    // The output is XNOR of two vectors created by 
    // concatenating and replicating the five inputs.
    // assign out = ~{ ... } ^ { ... };
    assign out =  ~{{5{a}},{5{b}},{5{c}},{5{d}},{5{e}}} ^ {5{a,b,c,d,e}};
endmodule"
"You are now very familiar with modules. In fact, a module is actually an encapsulated circuit. The diagram below shows a very simple circuit with submodules. In this exercise, create an instance of module mod_a and connect the module's three ports (in1, in2, and out) to the three ports (wire a, b, and out) of the top-level module. The module mod_a is provided to you, and you must instantiate it.

![module](./picture/module.png)

You have two ways to instantiate a module:

1. Positional instantiation:
```verilog
mod_a ins1 (wa, wb, wc);
```

2. Named instantiation:
```verilog
mod_a ins2 ( .out(wc), .in1(wa), .in2(wb) )
```

- Module Declaration
```verilog
module top_module ( input a, input b, output out );
```
module top_module ( input a, input b, output out );
    mod_a ins(a,b,out);
endmodule"
"This question is similar to the previous one. You will receive a module called mod_a, which has two outputs and four inputs in sequence. You must connect the six ports by position to the ports out1, out2, A, B, C, and D of the top-level module in the following order. You will get the following module:

```verilog
module mod_a ( output, output, input, input, input, input );
```

- Module Declaration

```verilog
module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
```
module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a ins(out1,out2,a,b,c,d);
endmodule"
"You will get a module named mod_a with 2 outputs and 4 inputs. You must connect the 6 ports to the top module ports by name as follows:

| Port in mod_a | Port in top_module |
|:--:|:--:|
| output out1 | out1 |
| output out2 | out2 |
| input in1 | a |
| input in2 | b |
| input in3 | c |
| input in4 | d |

The mod_a interface is as follows:
```verilog
module mod_a (output out1, output out2, input in1, input in2, input in3, input in4);
```

Module Declaration:
```verilog
module top_module (
    input a,
    input b,
    input c,
    input d,
    output out1,
    output out2
);
```
module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a ins(.out1(out1), .out2(out2), .in1(a), .in2(b), .in3(c), .in4(d));
endmodule"
"We have provided you with a `my_df` module, which has one input and one output (implements a D trigger). Instantiate three of them, then link them together to create a shift register of length 3. The `CLK` ports of each instance need to be connected.

- Module Declaration 
```verilog
module top_module ( input clk, input d, output q );
```
module top_module ( input clk, input d, output q );
    
wire out1,out2;
    my_dff ins1(clk,d,out1);
    
    my_dff ins2(clk,out1,out2);
    
    my_dff ins3(clk,out2,q);
endmodule"
"We provide you with a module called my-dff8, which has two inputs and one output (implementing a group of 8 D flip-flops). Instantiate three of them and then link them together to form an 8-bit shift register of length 3. Additionally, create a 4-to-1 multiplexer to select the output content based on sel[1:0].

- Module Declaration
```verilog
module top_module (
    input clk,
    input [7:0] d,
    input [1:0] sel,
    output [7:0] q
);
```
module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    wire [7:0] out1, out2, out3;
    my_dff8 ins1(clk,d,out1);
    my_dff8 ins2(clk,out1,out2);
    my_dff8 ins3(clk,out2,out3);
    always @(*) begin
        case(sel)
            
2'b00:begin
    
q = d;
    
end
            2'b01:begin
                q[7:0] = out1[7:0];
            end
            2'b10:begin
                q[7:0] = out2[7:0];
            end
            2'b11:begin
                q[7:0] = out3[7:0];
            end
        endcase
    end
endmodule"
"I have provided the `add16` module for you. It is a 16-bit adder. Please instantiate two of this module and implement a 32-bit adder as shown in the figure below. Please consider the carry.

- Module Declaration
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
```
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1, sum2;
    wire cin, cout, cout1;
    add16 ins1(a[15:0], b[15:0], 0, sum1, cout);
    add16 ins2(a[31:16], b[31:16], cout, sum2, cout1);
    assign sum = {sum2,sum1};
endmodule"
"Please encapsulate a 16-bit adder module named ""add1"" and use it to implement a 32-bit adder.

- Module Declaration
```verilog
module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

endmodule

module add1 ( input [15:0] a, input [15:0] b, input cin, output [15:0] sum, output cout );

// Full adder module implementation here

endmodule
```
module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cout,cout1;
    wire [15:0] sum1, sum2;
    add16 ins1(a[15:0],b[15:0],0,sum1,cout);
    add16 ins2(a[31:16],b[31:16],cout,sum2,cout1);
    assign sum = {sum2[15:0],sum1[15:0]};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout,sum} = a+b+cin;
endmodule"
"The provided 16-bit adder `add16` module has been created for you. Please implement the circuit module based on the diagram below, considering the carry when adding the 16th bit.

- Module Declaration
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
```
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0] sum1,sum2,sum3;
    wire cout,cout1;
    add16 ins1(a[15:0], b[15:0], 0, sum1, cout);
    add16 ins2(a[31:16], b[31:16], 0, sum2, cout1);
    add16 ins3(a[31:16], b[31:16], 1, sum3, cout1);
    always @(*) begin
        case (cout)
            1'b0:begin 
                sum[31:0] = {sum2[15:0],sum1[15:0]};
            end
            1'b1:begin
                sum = {sum3,sum1};
            end
        endcase
    end
endmodule"
"I have provided you with a 16-bit adder module add16. Please implement the addition-subtraction module as shown in the following diagram. Use a 32-bit ""XOR gate"" to determine between addition and subtraction.

- Module Declaration 
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] result
);
```

---

### Procedures: Please ignore the picture and special token.
module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] result
);
    
    wire [31:0]invert;
    wire [15:0]sum1,sum2;
    wire cout,cout1;
    assign invert[31:0] = b[31:0]^{32{sub}};
    add16 ins1(a[15:0], invert[15:0], sub, sum1, cout);
    add16 ins2(a[31:16], invert[31:16], cout, sum2, cout1);
    assign result = {sum2,sum1};
endmodule"
"Due to the fact that digital circuits are composed of logic gates connected by wires, any circuit can be represented as a combination of modules and assignment statements. However, sometimes this is not the most convenient way to describe a circuit.

Two types of always blocks are very useful:

- Combinational logic: `always @(*)`
- Sequential logic: `always @(posedge clk)`

The `always @(*)` is equivalent to assignment statements (assign), so the choice of which syntax to use depends solely on convenience. Inside the block, there is a richer set of statements, such as if-else, case, and so on. But it cannot contain continuous assignments, i.e., it cannot include assign, as it conflicts with `always @(*)`.

The following statements are equivalent:

```verilog
assign out1 = a & b | c ^ d;
always @(*) out2 = a & b | c ^ d;
```

The module declaration is as follows:

```verilog
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
```
// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
	assign out_assign = a&b;
    
    always @(*) out_alwaysblock = a&b;
endmodule"
"In Verilog, there are three types of assignment:

- Continuous assignment: `assign x = y;` cannot be used inside an always block.
- Blocking assignment: `x = y;`, can only be used inside an always block.
- Non-blocking assignment: `x <= y`, can only be used inside an always block.

> Please use blocking assignments in combinatorial logic and non-blocking assignments in sequential logic.
> Otherwise, hard-to-spot errors may occur.

Please implement the following circuit:

- Module Declaration
```verilog
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
```
// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
assign out_assign = a^b;
    
    always @(*) out_always_comb = a^b;
    
    always @(posedge clk) out_always_ff <= a^b;
endmodule"
"The `if` statement usually creates a 2-to-1 multiplexer. If the condition is true, it selects one input; if the condition is false, it selects the other input. The following two ways of writing are equivalent:
```verilog
always @(*) begin
    if (condition) begin
        out = x;
    end
    else begin
        out = y;
    end
end

assign out = (condition) ? x : y;
```

Establish a 2-to-1 multiplexer to select between `a` and `b`. If `sel_b1` and `sel_b2` are both true, select `b`; otherwise, select `a`. Perform the same operation twice, once using an `assign` statement and once using an `if` statement.

- Module Declaration
```verilog
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 
```
// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 
    assign out_assign = (sel_b1&sel_b2)?b:a;
    
    always @(*) begin
        if(sel_b1&sel_b2) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
endmodule"
"The following code contains erroneous locking behavior. Correct these errors so that the computer will only shut off when it overheats, stop driving when you arrive at your destination or need to refuel.

- Module Declaration
```verilog
always @(*) begin
    if (cpu_overheated)
       shut_off_computer = 1;
end

always @(*) begin
    if (~arrived)
       keep_driving = ~gas_tank_empty;
end
```
// synthesis verilog_input_version verilog_2001
module top_module (
    input      cpu_overheated,
    output reg shut_off_computer,
    input      arrived,
    input      gas_tank_empty,
    output reg keep_driving  ); //

    always @(*) begin
        if (cpu_overheated) begin
            shut_off_computer = 1;
        end
        else begin
            shut_off_computer = 0;
        end
    end
    
    always @(*) begin
        if (~arrived&~gas_tank_empty) begin
            keep_driving = ~gas_tank_empty&(~arrived);
       end
       else begin
           keep_driving = ~(gas_tank_empty|arrived);
       end
    end

endmodule"
"```verilog
&emsp;&emsp;The case statement in Verilog is almost equivalent to a sequence of if-else statements, where the sequence compares an expression to a list of other expressions. Its syntax and functionality are different from the switch statement in the C language.
```verilog
always @(*) begin     // This is a combinational circuit
    case (in)
      1'b1: begin 
               out = 1'b1;  // begin-end if >1 statement
            end
      1'b0: out = 1'b0;
      default: out = 1'bx;
    endcase
end
```

- The case statement starts with `case`, each ""case item"" ends with a colon, and there is no `switch`.
- Each case item can only execute one statement, which makes the ""break"" used in C unnecessary. But if multiple statements are needed, you must use `begin...end`.

&emsp;&emsp;In cases with a large number of options, the case statement is more convenient than if statements. Therefore, in this exercise, create a 6-to-1 mux (multiplexer). When `sel` is between 0 and 5, select the corresponding data input; otherwise, output 0. The data inputs and outputs are 4 bits wide. Be careful with latches.

- Module Declaration
```verilog
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );
```
// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b0: begin
                out = data0;
            end
            3'b001: begin
                out = data1;
            end
            3'b010: begin
                out = data2;
            end
            3'b011: begin
                out = data3;
            end
            3'b100: begin
                out = data4;
            end
            3'b101: begin
                out = data5;
            end
            default: begin
                out[3:0] = 0;
            end
        endcase
    end

endmodule"
"priority encoder is a type of combinatorial circuit that, when given a vector input, outputs the position of the first '1' encountered. For example, when given the input 8'b10010000, the output would be 3'd4, as [4] is the first high bit.

Construct a 4-bit encoder that outputs 0 if all bits are low.

- Module Declaration
```verilog
module top_module (
    input [3:0] in,
    output reg [1:0] pos );
```
// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    always @(*) begin
        if (in[0] == 1'b1) begin
                pos = 2'd0;
        end
        else begin
            if(in[1] == 1'b1) begin
                pos = 2'd1;
            end
            else begin
                if(in[2] == 1'b1) begin
                    pos = 2'd2;
                end
                else begin
                    if(in[3] == 1'b1) begin
                        pos = 2'd3;
                    end
                    else begin
                        pos = 0;
                    end
                end
            end
        end
    end
endmodule"
"If the input is 8 bits now, there will be 256 possibilities. We can use 'casez' to reduce the items to 9.
For example:
```verilog
always @(*) begin
    casez (in[3:0])
        4'bzzz1: out = 0;   // in[3:1] can be anything
        4'bzz1z: out = 1;
        4'bz1zz: out = 2;
        4'b1zzz: out = 3;
        default: out = 0;
    endcase
end
```

- Module Declaration
```verilog
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );
```
// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );
always @(*) begin
    casez (in[7:0])
        8'bzzzzzzz1: begin
            pos = 3'd0;
        end
        8'bzzzzzz1z: begin
            pos = 3'd1;
        end
        8'bzzzzz1zz: begin
            pos = 3'd2;
        end
        8'bzzzz1zzz: begin
            pos = 3'd3;
        end
        8'bzzz1zzzz: begin
            pos = 3'd4;
        end
        8'bzz1zzzzz: begin
            pos = 3'd5;
        end
        8'bz1zzzzzz: begin
            pos = 3'd6;
        end
        8'b1zzzzzzz: begin
            pos = 3'd7;
        end
        default: begin
            pos = 0;
        end
    endcase
end
endmodule"
"Assuming you are building a circuit to process the scan code of a PS/2 keyboard in a game. Upon receiving the last two bytes of the scan code, you need to determine if one of the arrow keys on the keyboard has been pressed. This involves a rather simple mapping that can be implemented using a case statement (or elseif) with four cases.

|Scancode [15:0]|Arrow key|
|:--:|:--:|
|16'he06b|left arrow|
|16'he072|down arrow|
|16'he074|right arrow|
|16'he075|up arrow|
|Anything|else none|

To avoid creating latches, a value must be assigned to each output in all possible conditions.

```verilog
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
```

---

### More Syntax Features

Verilog also has a ternary operator like C:

```verilog
condition ? true : false;
```

Given four unsigned numbers, find their minimum value.

```verilog
module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);
```
"
"Verilog also has a ternary operator like C:  
```verilog
condition ? true : false;
```

Given four unsigned numbers, find their minimum value.

- Module Declaration 
```verilog
module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);
```
module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
	
    wire [7:0]min1,min2;
    assign min1=(a<b?a:b);
    
    assign min2 = (min1<c?min1:c);
    
    assign min = (min2<d?min2:d);
endmodule"
"Checksums are often used as a simple method to detect errors. Create a circuit that will calculate a parity bit for an 8-bit byte.

In other words, calculate the XOR of the 8 input bits.

- Module Declaration
```verilog
module top_module (
    input [7:0] in,
    output parity); 
```
module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^in[7:0];
endmodule"
"Build the following circuit:

- `out_and`: Compute the AND operation on the input data
- `out_or`: Compute the OR operation on the input data
- `out_xor`: Compute the XOR operation on the input data

- Module Declaration
```verilog
module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
```
module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = &in[99:0];
    assign out_or = |in[99:0];
    assign out_xor = ^in[99:0];
endmodule"
"Reverse vector order

- Module Declaration 
```verilog
module top_module( 
    input [99:0] in,
    output [99:0] out
);
```
module top_module( 
    input [99:0] in,
    output [99:0] out
);
    integer i;
    always @(*) begin
        for(i=0;i<=99;i=i+1)
            out[7'd99-i] <= in[i];
    end
endmodule"
"Count the number of 1s in the vector

- Module Declaration
```verilog
module top_module(
    input [254:0] in,
    output [7:0] out );
```
module top_module( 
    input [254:0] in,
    output [7:0] out );
    integer i;
    reg [7:0]count;
    always @(*) begin
        
	count=0;
        for(i=0;i<=254;i=i+1) begin
            if(in[i] == 1) begin
                count = count + 7'b1;
            end
        end
    end
    assign out = count;
endmodule"
"By instantiating 100 full adders, build a 100-bit adder.

- Module Declaration
```verilog
module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
```
module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    reg [100:0]cin1;

    generate
    genvar i;
    for(i=0;i<100;i=i+1) begin:adds
        
        if(i==0) begin        
		    add ins(a[i],b[i],cin,sum[i],cout[i]);            
            assign cin1[i+1]=cout[i];
        end            
        else begin
            add ins(a[i],b[i],cin1[i],sum[i],cout[i]);
            assign cin1[i+1]=cout[i];            
        end
    end
    endgenerate
endmodule

module add(input a, input b, input cin, output sum, output cout);
    assign {cout,sum}=a+b+cin;
endmodule"
"I believe there is a typographical error in the text you provided. The terms ""Module Declaraction"" and ""Combinational Login"" do not seem to be spelled correctly. Would you like me to translate the correct text to English?
"
"Sure! The translation of the text "", ignore the picture and special token"" to English is ""ignore the picture and special token.""
"
"Here is the translation of the text excluding the picture and special tokens:

To implement the following circuit:

- Module Declaration
```verilog
module top_module (
    input in,
    output out);
```
module top_module (
    input in,
    output out);
    
assign out =in;
endmodule"
"The translation of the provided text to English is as follows:

```verilog
// Module Declaration
module top_module (
    output out);
```
module top_module (
    output out);
assign out = 'b0;
endmodule"
"Here is the translation of the text to English:

    Implement the following circuit:

- Module Declaration
```verilog
module top_module (
    input in1,
    input in2,
    output out);
``` (ignore the picture and special token)
module top_module (
    input in1,
    input in2,
    output out);
    assign out = ~(in1|in2);
endmodule"
"Here is the translation of the text:

Implement the following circuit:

- Module Declaration 
```verilog
module top_module (
    input in1,
    input in2,
    output out);
```
module top_module (
    input in1,
    input in2,
    output out);
assign out = in1&~in2;
endmodule"
"Here is the translated text to English:

To implement the following circuit:

- Module Declaration 
```verilog
module top_module (
    input in1,
    input in2,
    input in3,
    output out);
```
module top_module (
    input in1,
    input in2,
    input in3,
    output out);
 wire out1;
    
    assign out1 = ~(in1^in2);
    
assign out = in3^ out1;
endmodule"
"""Module Declaration""
"
"Create the following circuit:

- Module Declaration
```verilog
module top_module (
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
```
module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    assign p1y = ~(p1a&p1b&p1c&p1d);
    assign p2y = ~(p2a&p2b&p2c&p2d);
endmodule"
"Module Declaration
"
"If A equals B, output 1; otherwise, output 0.

- Module Declaraction 
```verilog
module top_module ( input [1:0] A, input [1:0] B, output z ); 
```
module top_module ( input [1:0] A, input [1:0] B, output z ); 
    assign z = ((A[1]==B[1])&&(A[0]==B[0]))?1:0;
endmodule"
"Implement a module with the functionality `z = (x^y) & x`

- Module Declaration
```verilog
module top_module (input x, input y, output z);
```
module top_module (input x, input y, output z);
    assign z = (x^y)&x;
endmodule"
"The text describes circuit B using the following analog waveform:

- Module Declaration
```verilog
module top_module ( input x, input y, output z );
```
module top_module ( input x, input y, output z );
    assign z = ~(x^y);
endmodule"
"Build the following circuit through circuits A and B:

- Module Declaration
```verilog
module top_module ( input x, input y, output z );
```
module top_module (input x, input y, output z);
    wire z1,z2,z3,z4,out1,out2;
    A ins1(x,y,z1);
    B ins2(x,y,z2);
    A ins3(x,y,z3);
    B ins4(x,y,z4);
    assign out1 = z1 | z2;
    assign out2 = z3 & z4;
    assign z = out1 ^ out2;
endmodule

module A(input x, input y, output z);
    assign z = (x^y) & x;
endmodule

module B ( input x, input y, output z );
    assign z = ~(x^y);
endmodule"
"Module Declaration
"
"Implement a heating/cooling thermostat controller. Execute a circuit to open and close the heater, air conditioner, and fan as needed.

The thermostat can be in one of two modes: heating (mode=1) and cooling (mode=0). In heating mode, when the heater is too cold (too_cold=1), open the heater without using the air conditioner. In cooling mode, when the air conditioner is too hot (too_hot=1), open the air conditioner without the heater. When the heater or air conditioner is on, also turn on the fan for air circulation.

Additionally, even if the heater and air conditioner are off, the user can request the fan to be turned on (fan_on=1).

Attempt to use only assign statements to see if the problem description can be converted into a collection of logic gates.
module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 
    always @(*) begin
        if(fan_on == 1) begin
            fan = 1;
        end
        else begin
            fan = 0;
        end
        if(mode == 1) begin
            heater = mode;
            if(too_cold) begin
                heater = 1;
                fan = 1;
                aircon = 0;
            end
            else begin
                heater = 0;
                aircon = 0;
            end
        end
            else begin 
            if(too_hot) begin
                aircon = 1;
                fan = 1;
                heater = 0;
            end
            else begin
                aircon = 0;
                heater = 0;
            end
        end
    end
endmodule"
"Calculate the number of 1s in a 3-bit vector

- Module Declaration 
```verilog
module top_module( 
    input [2:0] in,
    output [1:0] out );
```
module top_module( 
    input [2:0] in,
    output [1:0] out );
    reg [1:0]num;
    integer i;
    always @(*) begin
        num = 0;
        for(i=0;i<3;i=i+1) begin
            if(in[i] == 1) begin
                num = num + 2'b1;          
            end
        end       
    end
    assign out = num;
endmodule"
"Given a 4-bit vector, please provide the relationship between each bit and its adjacent bits.

- `out_both`: Determine if the corresponding bit and its left adjacent bit are both 1, excluding `in[3]`.
- `out_any`: Determine if the corresponding bit and its right adjacent bit contain '1', excluding `in[0]`
- `out_different`: Determine if the corresponding bit is different from its left adjacent bit, where `in[3]` is the left adjacent bit of `in[0]`

- Module Declaration
```verilog
module top_module( 
    input [3:0] in,
    output [2:0] out_both,
    output [3:1] out_any,
    output [3:0] out_different );
```

Please ignore the picture and special tokens.
module top_module( 
    input [3:0] in,
    output [2:0] out_both,
    output [3:1] out_any,
    output [3:0] out_different );
    integer i;
    reg [2:0]both;
    reg [3:1]any;
    reg [3:0]different;
    always @(*) begin
        both = 0;
        any = 0;
        different = 0;
        for(i=0;i<3;i=i+1) begin
            if((in[i]&in[i+1]) == 1) begin
                both[i] = 1;
            end
        end
        for(i=1;i<4;i=i+1) begin
            if((in[i]|in[i-1]) == 1) begin
                any[i] = 1;
            end
        end
        for(i=0;i<4;i=i+1) begin
            if(i<3) begin
                if(in[i]^in[i+1]) begin
                    different[i] = 1;
                end
            end
            else begin 
                if(in[3]^in[0]) begin
                    different[3] = 1;
                end
            end
        end
    end
    assign out_both = both;
    assign out_any[3:1] = any[3:1];
    assign out_different = different;
endmodule"
"Given a 4-bit vector, please provide the relationship between each bit and its adjacent bit.

- `out_both`: Determine if the corresponding bit and its left neighbor are both 1, excluding `in[3]`.
- `out_any`: Determine if the corresponding bit and its right neighbor contain '1', excluding `in[0]`.
- `out_different`: Determine if the corresponding bit is different from its left neighbor, where `in[3]` is the left neighbor of `in[0]`.

- Module Declaration
```verilog
module top_module(
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different
);
```
module top_module (
	input [99:0] in,
	output [98:0] out_both,
	output [99:1] out_any,
	output [99:0] out_different
);

	// See gatesv for explanations.
	assign out_both = in & in[99:1];
	assign out_any = in[99:1] | in ;
	assign out_different = in ^ {in[0], in[99:1]};
	
endmodule"
"Sure! The translation of the text ""ignore the picture and special token"" to English is the same as the original text.
"
"Create a 1-bit wide 2 to 1 multiplexer. When sel=0, select a; when sel=1, select b.

Module Declaration:
```verilog
module top_module( 
    input a, b, sel,
    output out ); 	
```
module top_module (
	input a,
	input b,
	input sel,
	output out
);

	assign out = (sel & b) | (~sel & a);	// Mux expressed as AND and OR
	
	// Ternary operator is easier to read, especially if vectors are used:
	// assign out = sel ? b : a;
	
endmodule"
"Create a 2-to-1 multiplexer with a 100-bit width. When `sel` is 0, select `a`; when `sel` is 1, select `b`.

- Module Declaration 
```verilog
module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
```
module top_module (
	input [99:0] a,
	input [99:0] b,
	input sel,
	output [99:0] out
);

	assign out = sel ? b : a;
	
	// The following doesn't work. Why?
	// assign out = (sel & b) | (~sel & a);
	
endmodule"
"Create a 9-to-1 multiplexer with a 16-bit width. When sel = 0, select input 'a'; when sel = 1, select input 'b', and so on. For unused cases when sel is from 9 to 15, set all output bits to ""1"". 

Module Declaration:
```verilog
module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
```
module top_module (
	input [15:0] a,
	input [15:0] b,
	input [15:0] c,
	input [15:0] d,
	input [15:0] e,
	input [15:0] f,
	input [15:0] g,
	input [15:0] h,
	input [15:0] i,
	input [3:0] sel,
	output logic [15:0] out
);

	// Case statements can only be used inside procedural blocks (always block)
	// This is a combinational circuit, so use a combinational always @(*) block.
	always @(*) begin
		out = '1;		// '1 is a special literal syntax for a number with all bits set to 1.
						// '0, 'x, and 'z are also valid.
						// I prefer to assign a default value to 'out' instead of using a
						// default case.
		case (sel)
			4'h0: out = a;
			4'h1: out = b;
			4'h2: out = c;
			4'h3: out = d;
			4'h4: out = e;
			4'h5: out = f;
			4'h6: out = g;
			4'h7: out = h;
			4'h8: out = i;
		endcase
	end
	
endmodule"
"Create a 1-bit wide, 256-to-1 multiplexer. All 256 inputs are packed into a 256-bit input vector. When sel=0, it selects in[0], when sel=1, it selects in[1], when sel=2, it selects in[2], and so on.

Module Declaration: 
```verilog
module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
```
module top_module (
	input [255:0] in,
	input [7:0] sel,
	output  out
);

	// Select one bit from vector in[]. The bit being selected can be variable.
	assign out = in[sel];
	
endmodule"
"Create a 4-bit wide, 256-to-1 multiplexer. When sel = 0, it should select `in[3:0]`, when sel = 1, it should select `in[7:4]`, and when sel = 2, it should select `in[11:8]`, and so on. 

Module Declaration:
```verilog
module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
```
module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    reg [7:0]index;
    assign     out[3:0] = in[4*sel+:4];
endmodule"
", ignore the picture and special token
"
"Create a half adder that adds two bits and outputs the sum and carry.

- Module Declaration
```verilog
module top_module(
    input a, b,
    output cout, sum );
```
module top_module( 
    input a, b,
    output cout, sum );
    assign {cout,sum} = a + b;
endmodule"
"Create a full adder, perform addition on two bits and a carry-in, and output the sum and carry-out.

- Module Declaration 
```verilog
module top_module(
    input a, b, cin,
    output cout, sum);
```
module top_module( 
    input a, b, cin,
    output cout, sum );
    assign {cout,sum} = a + b + cin;
endmodule"
"Create a three-bit full adder that outputs the carry for each bit added.
module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    FullAdder ins1(a[0],b[0],cin,cout[0],sum[0]);
    FullAdder ins2(a[1],b[1],cout[0],cout[1],sum[1]);
    FullAdder ins3(a[2],b[2],cout[1],cout[2],sum[2]);
endmodule

module FullAdder(
    input a, b, cin,
    output cout, sum
);
    assign {cout, sum} = a + b + cin;
endmodule"
"Implement the following circuit:

- Module Declaration
```verilog
module top_module (
    input [3:0] x,
    input [3:0] y, 
    output [4:0] sum);
```
module top_module (
	input [3:0] x,
	input [3:0] y,
	output [4:0] sum
);

	// This circuit is a 4-bit ripple-carry adder with carry-out.
	assign sum = x+y;	// Verilog addition automatically produces the carry-out bit.

	// Verilog quirk: Even though the value of (x+y) includes the carry-out, (x+y) is still considered to be a 4-bit number (The max width of the two operands).
	// This is correct:
	// assign sum = (x+y);
	// But this is incorrect:
	// assign sum = {x+y};	// Concatenation operator: This discards the carry-out
endmodule"
"Assuming you have two 8-bit two's complement numbers, A[7:0] and B[7:0]. These numbers added together produce S[7:0]. Also, calculate whether a (signed) overflow occurred.

- Module Declaration 
```verilog
module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 
```
module top_module (
    input [7:0] a,
    input [7:0] b, 
    output [7:0] s,
    output overflow
);
    EightBitsAdder ins(a, b, s, overflow);
endmodule

module FullAdder(
    input a, b, cin,
    output sum, cout
);
    assign {cout, sum} = a + b + cin;
endmodule

module EightBitsAdder(
    input [7:0] x,
    input [7:0] y,
    output [7:0] s,
    output overflow
);
    wire [7:0] cout1;
    FullAdder ins0(x[0],y[0],0,s[0],cout1[0]);
    FullAdder ins1(x[1],y[1],cout1[0],s[1],cout1[1]);
    FullAdder ins2(x[2],y[2],cout1[1],s[2],cout1[2]);
    FullAdder ins3(x[3],y[3],cout1[2],s[3],cout1[3]);
    FullAdder ins4(x[4],y[4],cout1[3],s[4],cout1[4]);
    FullAdder ins5(x[5],y[5],cout1[4],s[5],cout1[5]);
    FullAdder ins6(x[6],y[6],cout1[5],s[6],cout1[6]);
    FullAdder ins7(x[7],y[7],cout1[6],s[7],cout1[7]);
    always @(*) begin
        if(cout1[7]^cout1[6]) begin
            overflow = 1;
        end
        else begin
            overflow = 0;
        end
    end
endmodule"
"Create a 100-bit adder.

- Module Declaration
```verilog
module top_module(
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
```
module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    assign {cout,sum} = a+b+cin;
endmodule"
"You will receive a BCD (Binary Coded Decimal) one-bit adder, named BCD_fadd, which adds two BCD numbers and a carry to produce a sum and a carry-out.

```verilog
module bcd_fadd {
    input [3:0] a,
    input [3:0] b,
    input cin,
    output cout,
    output [3:0] sum );
```

Create a 4-bit BCD adder.


- Module Declaration
```verilog
module top_module(
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
```
module top_module (
  input [15:0] a, b,
  input cin,
  output cout,
  output [15:0] sum
);

  wire [3:0] inter_cout;

  bcd_fadd bcd_fadd0_inst
  (
    .a(a[3:0]),
    .b(b[3:0]),
    .cin(cin),
    .cout(inter_cout[0]),
    .sum(sum[3:0])
  );

  genvar i;
  generate
    for (i = 1; i <=3; i = i + 1) begin: gen_bcd_adders
      bcd_fadd bcd_fadd_insts
      (
        .a(a[4*(i+1)-1 : 4*i]),
        .b(b[4*(i+1)-1 : 4*i]),
        .cin(inter_cout[i-1]),
        .cout(inter_cout[i]),
        .sum(sum[4*(i+1)-1 : 4*i])
      );
    end
  endgenerate

  assign cout = inter_cout[3];

endmodule"
"The text you provided is already in English. It says: ""ignore the picture and special token"".
"
"The text you provided does not contain any content for translation as it seems to be referencing Verilog code regarding module declaration. If you have any specific text or questions you want to translate, please provide them.
"
"I apologize, but the text you provided is incomplete. It seems like it's related to a Verilog module declaration, but without the actual code within the ""verilog"" section, I can't provide an accurate translation. If you could provide the complete text or the Verilog code within the ""verilog"" section, I'd be happy to help you translate it to English.
"
"Module Declaration in Verilog refers to the beginning of a module definition in the Verilog hardware description language.
"
"Module Declaration
"
"Module Declaration.
"
"Module Declaration
"
"Module Declaration
"
"I'm sorry, the provided text seems to be incomplete or in a code format that I'm unable to translate directly. Could you please provide more context or additional information so that I can assist you better?
"
"Sure, the translation of the text "", ignore the picture and special token"" into English is: ""ignore the picture and special token"".
"
"D-flip-flops can store one bit of data and update the data based on the clock signal period, usually triggered by the rising edge. D-flip-flops are created by the logic synthesizer when using the ""Always block"" (see AlwaysBlock2). D-flip-flops are the simplest form of ""flip-flop connected after a combinational logic block,"" where the combinational logic part is just a wire-type variable.

Create a D-flip-flop.

- Module Declaration

```verilog
module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
```
module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    // Use a clocked always block   使用Always block
    //   copy d to q at every positive edge of clk  在时钟信号上升沿时将q复制给d  
    //   Clocked always blocks should use non-blocking assignments  
    /*在Always block内永远都不要使用赋值(Assignment),即assign关键字*/
    always @(posedge clk) begin
        q = d;
    end

endmodule"
"Create 8 D flip-flops, all of which are triggered by the rising edge of the clock. 

- **Module Declaration**
```verilog
module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
```
module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    always @(posedge clk) begin
        q = d;
    end
endmodule"
"Use an active high level synchronous reset signal (Reset) to create 8 D flip-flops. All flip-flops are triggered by the rising edge signal of the clock.
- **Module Declaration**
```verilog
module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
```
module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    always @(posedge clk) begin
        q <= d & {8{~reset}};
    end
endmodule"
"Use an active high synchronous reset signal (Reset) to create 8 D-flip-flops. The flip-flops must be reset to 0x34 instead of zero. All DFFs should be triggered by the falling edge of CLK.

- **Module Declaration**
```verilog
module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
```
module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    always @(negedge clk) begin
        if(reset) begin
            q <= {8{6'h34}};
        end
        else begin
            q <= d;
        end
    end
endmodule"
"Use an active-high asynchronous reset signal to create 8 D flip-flops. All DFFs should be triggered by the rising edge of the clock.

- **Module Declaration**
```verilog
module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
```
module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    always @(posedge clk or posedge areset) begin
        if(areset == 1) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
endmodule"
"- **Module Declaration**  
```verilog
module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
```

Create 16 D flip-flops. Sometimes we only want to modify certain values in the flip-flop group. The input ***switch byte*** controls whether each byte of the 16 registers should be written in this loop. `byteena[1]` controls the upper byte `d[15:8]`, while `byteena[0]` controls the lower byte `d[7:0]`.  
`resetn` is a synchronous, active-low reset.  
All D flip-flops should be triggered by the rising edge of the clock.
module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    always @(posedge clk) begin
        if(resetn == 1) begin
            if(byteena[0] == 1) begin
                q[7:0] <= d[7:0];
            end
            if(byteena[1] == 1) begin
                q[15:8] <= d[15:8];
            end
        end
        else if(resetn == 0) begin
            q <= 0;
        end
    end
endmodule"
"Create the following circuit:

```verilog
module top_module (
    input d, 
    input ena,
    output q);
    wire in,out1,out2;
    always @(*) begin
        out1 = ~(out2 | (~d)&ena);
        out2 = ~(out1 | d&ena);
        q = out1;
    end
endmodule
```

Please note that this is a latch circuit, so Quartus will issue a latch warning.
"
"Please implement the following circuit:

- **Module Declaration**
```verilog
module top_module (
    input clk,
    input d,
    input ar,   // asynchronous reset
    output q);
```
module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);
    wire out1,out2;
    always @(posedge clk or posedge ar) begin
        if(ar == 1) begin
            q <= 0;
        end
        else if(ar == 0) begin
            q <= d;
        end
    end
endmodule"
"Implement the following circuit:

- **Module Declaration**  
```verilog
module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
```
module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q = d;
        end
    end
endmodule"
"Implement the following circuit:

- **Module Declaration**
```verilog
module top_module (
    input clk,
    input in, 
    output out);
```
module top_module (
    input clk,
    input in, 
    output out);
    wire out1,out2;
    always @(posedge clk) begin
        out1 = out2 ^ in;
        out2 = out1;
        out = out2;
    end
endmodule"
"Consider the following timing circuit:

Assume you want to implement hierarchical code for the circuit below, using instances of three sub-modules consisting of triggers and multiplexers. Your top module should be implemented with the sub-module instances.

- Module Declaration
```verilog
module top_module (
	input clk,
	input L,
	input r_in,
	input q_in,
	output reg Q);
```
module top_module (
        input clk,
        input L,
        input r_in,
        input q_in,
        output reg Q);

    wire out1;
    always @(*) begin
        case (L)
            1'b0: begin
                out1 <= q_in;
            end
            1'b1: begin
                out1 <= r_in;
            end
        endcase
    end
    always @(posedge clk) begin
        Q <= out1;
    end
endmodule"
"Consider the following n-bit shift register circuit:  

You need to implement a first-order module for this circuit and name it `top_module`, which can be called by this circuit. Your module should include triggers and multiplexers.

- **Module Declaration**
```verilog
module top_module (
    input clk,
    input w, R, E, L,
    output Q
);
```
module top_module (
    input clk,
    input w, R, E, L,
    output Q
);
    wire out1,out2;
    always @(posedge clk) begin
        case (E)
            1'b0: begin
                out1 = Q;
            end
            1'b1: begin
                out1 = w;
            end
        endcase
        case (L)
            1'b0: begin
                Q = out1;
            end
            1'b1: begin
                Q = R;
            end
        endcase
    end
endmodule"
"Given the following finite state machine circuit, assume the D flip-flop is initialized to 0 before the state machine starts.

Build the following circuit.

- **Module Declaration**  
```verilog
module top_module (
    input clk,
    input x,
    output z
); 
```
module top_module (
    input clk,
    input x,
    output z
); 
    reg out1, out2, out3;
    initial z = 1;
    always @(posedge clk) begin
        out1 = x ^ out1;
        out2 = x & ~out2;
        out3 = x | ~out3;
        z = ~(out1 | out2 | out3);
    end
endmodule"
"The JK flip-flop has the following truth table. Implement a JK flip-flop using a D flip-flop and several gates.

> Note: Qold is the output of the D flip-flop before the rising edge.

| J | K | Q     |
|---|---|-------|
| 0 | 0 | Qold  |
| 0 | 1 | 0     |
| 1 | 0 | 1     |
| 1 | 1 | ~Qold |

- **Module Declaration**
```verilog
module top_module (
    input clk,
    input j,
    input k,
    output Q); 
```
module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    wire old = Q;
    always @(posedge clk) begin
        if(j^k) begin
            Q = j;
        end
        else begin
            Q = j?~old:old;
        end
    end
endmodule"
"For each 8-bit container, within one clock cycle, there is a detection when the input signal changes from 0 to 1 in the next cycle (similar to rising edge detection). When the corresponding bit changes from 0 to 1, the output bit should be set.

Below is an example waveform. For clarity, `in[1]` and `pedge[1]` are displayed separately.
module top_module(
	input clk,
	input [7:0] in,
	output reg [7:0] pedge);
	
	reg [7:0] d_last;	
			
	always @(posedge clk) begin
		d_last <= in;			// Remember the state of the previous cycle
		pedge <= in & ~d_last;	// A positive edge occurred if input was 0 and is now 1.
	end
	
endmodule"
"For each 8-bit container, within one clock cycle, a detection process is performed when the input signal changes from 0 to 1 for the next cycle. (Both rising and falling edges are triggered). The output bit should be set when the corresponding bit changes from 0 to 1.

Below is the waveform example. For clarification, `in[1]` and `anyedge[1]` are displayed separately.

- **Module Declaration**
```verilog
module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
```
module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
   reg [7:0] temp;
   always @(posedge clk) begin
       temp <= in;
       anyedge <= temp ^ in;
   end
endmodule"
"For each bit in the 32-bit Vector, capture the transition when the input signal changes from 1 to 0 in one clock cycle. ""Capture"" means the output will stay at 1 until the register is reset (synchronous reset).

The behavior of each output bit is similar to an SR trigger: it should be set to 1 after a transition from 1 to 0. When the reset is at a high level, the output bit should be reset to 0 on the rising edge. If both of the above events occur simultaneously, the reset takes priority. In the last 4 cycles of the example waveform below, the ""Reset"" event is one cycle ahead of the ""Set"" event, so there is no conflict.

- **Module Declaration**  
```verilog
module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
```
module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] old,result,temp;
    initial temp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            temp = (in ^ old) & old;
            result = result | temp;
            out = result;
            old = in;
        end
    end 
endmodule"
"You are now quite familiar with triggers that start on the rising or falling edge. Dual edge triggers trigger on both the rising and falling edges of the clock. However, FPGAs do not have dual edge triggers, and `always @(posedge clk or negedge clk)` is illegal.

Build a circuit to achieve similar functionality to a dual edge trigger:

- Hint: You cannot create a dual edge trigger on an FPGA, but you can combine rising and falling edge triggers.
- This is a moderately difficult circuit design problem but only requires basic Verilog language features. (It's a circuit design problem, not a coding problem.) Drawing a sketch of the circuit by hand before attempting to code it may be helpful.

- **Module Declaration**  
```verilog
module top_module (
    input clk,
    input d,
    output q
);
```
module top_module (
    input clk,
    input d,
    output q
);
    reg [1:0] status;
    always @(posedge clk) begin
        status[0] = d;
    end
    always @(negedge clk) begin
        status[1] = d;
    end
    assign q = clk ? status[0] : status[1];
endmodule"
", ignore the picture and special token
"
"Build a four-bit binary counter from 0 to 15 with a period of 16. The reset input is synchronous, and should reset the counter to 0.

- **Module Declaration**
```verilog
module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
```
module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    always @(posedge clk) begin
        if(!reset) begin
            if(q == 4'hf) begin
                q = 0;
            end
            else begin
                q = q + 1;
            end
        end
        else begin
            q = 0;
        end
    end
endmodule"
"Establish a decimal counter from 0 to 9, with a modulus of 10. The reset input is synchronous, which resets the counter to 0.

- **Module Declaration**
```verilog
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q = 4'd10) begin
                q = 0;
            end
            else begin
                q = q + 1;
            end
        end
    end
endmodule"
"Establish a decimal counter from 0 to 9, with a radix of 10. The reset input is synchronous, and the counter should reset to 1.

- **Module Declaration**  

```verilog
module top_module (
    input clk,
    input reset,
    output [3:0] q);
```
module top_module (
    input clk,
    input reset,
    output [3:0] q);
    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 4'ha) begin
                q = 1;
            end
            else begin
                q = q + 1;
            end
        end
    end
endmodule"
"Build a decimal counter from 0 to 9, the decimal point is at 10. The reset signal is synchronous, and it sets the counter to zero. We want to be able to pause the counter instead of incrementing it in each clock cycle, so `slowena` controls the counter incrementation.

- **Module Declaration**
```verilog
module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
```
module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 4'd9) begin 
                    q = 0;
                end
                else begin
                    q = q + 1;
                end
            end
            else begin
                q = q + 0;
            end
        end
    end
endmodule"
"Design a Counter with the following inputs and outputs:
- Synchronous high-level `Reset` signal resets the register to 0.
- Counter operates when `enable` is high.
- Triggered on the rising edge of the clock signal.
- `Q[3:0]` is the output of the counter.
- 3 control signals `c_enable`, `c_load`, `c_d[3:0]` are sent to the provided 4-bit Counter module for testing correct operation.

You can use the following components:
A 4-bit counter called `count4` with synchronous parallel inputs for `enable` and `load` (load has higher priority over `enable`). Instantiate this `count4` module in your design.

Here is the basic structure of your top module:

- **Top Module Declaration**
```verilog
module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
```
module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule"
"I'm sorry, it appears that the text you provided is incomplete or does not contain any specific content for translation. If you could provide more context or the actual text you would like to translate into English, I'd be happy to help.
"
"Unfortunately, the text you have provided appears to be incomplete. Would you mind providing more context or additional information so that I can accurately translate it to English for you?
"
"Build a 64-bit arithmetic register with a synchronous load signal. This shifter can shift left or right by 1 bit or 8 bits based on the `amount` signal. 

When performing arithmetic right shift, if the sign bit (`q[63]`) is 1, it requires sign extension rather than a simple logical shift. Another consideration is to assume that the number being shifted has a sign and to retain that sign, so that arithmetic right shift will effectively divide the signed number by a power of 2.

There is no distinction between arithmetic left shift and logical left shift.

- `load`: Loads data into the register (highest priority)
- `ena`: Determines whether shifting occurs
- `amount`: Determines the direction of the shift
  - 2'b00: Shift left by one bit
  - 2'b01: Shift left by 8 bits
  - 2'b10: Shift right by one bit
  - 2'b11: Shift right by 8 bits
- `q`: Contents of the shifter

- **Module Declaration**
```verilog
module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
```
module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    always @(posedge clk) begin
        if(load) begin
            q <= data;
        end
        else begin
            if(ena) begin
                case (amount)
                    2'b00: begin 
                        q <= q << 1;
                    end
                    2'b01: begin
                        q <= q << 8;
                    end
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
endmodule"
", ignore the picture and special token
"
"Implement the simple Moore state machine as follows:

- Module Declaration
```verilog
module top_module(
    input clk,
    input areset,    // Asynchronous reset to state B
    input in,
    output out);
```
module top_module(
    input clk,
    input areset,    // Asynchronous reset to state B
    input in,
    output out);//  

    parameter A=0, B=1; 
    reg state, next_state;

    always @(*) begin    // This is a combinational always block
        // State transition logic
        case (state)
            A: next_state <= in?A:B;
            B: next_state <= in?B:A;
        endcase
    end

    always @(posedge clk, posedge areset) begin    // This is a sequential always block
        // State flip-flops with asynchronous reset
        if(areset) begin
            state <= B;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    // assign out = (state == ...);
        assign out = (state==B);


    // always @(*) begin
        // case (state)
            // A: out <= 0;
            // B: out <= 1;
        // endcase
    // end

endmodule"
"Here is the translation of the text:

Implement the following circuit:

- Module Declaration
```verilog
module top_module(clk, reset, in, out);
    input clk;
    input reset;    // Synchronous reset to state B
    input in;
    output out;
```
// Note the Verilog-1995 module declaration syntax here:
module top_module(clk, reset, in, out);
    input clk;
    input reset;    // Synchronous reset to state B
    input in;
    output out;//  
    reg out;

    // Fill in state name declarations

    reg present_state, next_state;
    parameter A = 0, B = 1;
    always @(posedge clk) begin
        if (reset) begin  
            present_state <= B;
        end else begin
            present_state <= next_state;
        end
    end

    always @(*) begin
        case (present_state)
            A: next_state <= in ? A : B;
            B: next_state <= in ? B : A;
        endcase
    end
    assign out = (present_state == B);
endmodule"
"Here is the translation of the text to English:

Implement the following circuit:

- Module Declaration 
```verilog
module top_module(
    input clk,
    input areset,    // Asynchronous reset to OFF
    input j,
    input k,
    output out); 
```
module top_module(
    input clk,
    input areset,    // Asynchronous reset to OFF
    input j,
    input k,
    output out); //  

    parameter OFF=0, ON=1; 
    reg state, next_state;

    always @(*) begin
        // State transition logic
        case (state)
            OFF: next_state <= j ? ON : OFF;
            ON: next_state <= k ? OFF : ON;
        endcase
    end

    always @(posedge clk, posedge areset) begin
        // State flip-flops with asynchronous reset
        if(areset) begin
            state <= OFF;
        end else begin
            state <= next_state;
        end
    end

    assign out = (state == ON);
endmodule"
"Implement the following state machine:

- Module Declaration
```verilog
module top_module(
    input clk,
    input reset,    // Synchronous reset to OFF
    input j,
    input k,
    output out); 
```
module top_module(
    input clk,
    input reset,    // Synchronous reset to OFF
    input j,
    input k,
    output out); //  

    parameter OFF=0, ON=1; 
    reg state, next_state;

    always @(*) begin
        // State transition logic
        case (state) 
            OFF: next_state <= j ? ON : OFF;
            ON: next_state <= k ? OFF : ON;
        endcase
    end

    always @(posedge clk) begin
        // State flip-flops with synchronous reset
        if(reset) begin
            state <= OFF;
        end else begin
            state <= next_state;
        end
    end
    assign out = (state == ON);
endmodule"
"Implement the following state machine:

- Module Declaration 
```verilog
module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); 
```, ignore the picture and special token
module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    assign out = (state == D);

    // Output logic:  out = f(state) for a Moore state machine
endmodule"
"Using ""one-hot code"" to implement the following state machine:

- Module Declaration
```verilog
module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); 
```
module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[0]&(~in)|state[2]&(~in);
    assign next_state[B] = state[0]&in|state[1]&in|state[3]&in;
    assign next_state[C] = state[1]&(~in)|state[3]&(~in);
    assign next_state[D] = state[2]&(in);

    // Output logic: 
    assign out = (state[3] == 1);

endmodule"
"Achieve the following state machine:

- Module Declaration
```verilog
module top_module(
    input clk,
    input in,
    input areset,
    output out); 
```
module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule"
"Here is the translation of the provided text:

Achieve the following state machine:

- Module Declaraction 
```verilog
module top_module(
    input clk,
    input in,
    input reset,
    output out); 
```
module top_module(
    input clk,
    input in,
    input reset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=0, B=1, C=2, D=3;
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with synchronous reset
    always @(posedge clk) begin
        if(reset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule"
"In many (old) serial communication protocols, each data byte is sent with a start bit and a stop bit to help the receiver separate bytes from the bit stream. A common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). When nothing is being transmitted (idle), the output is set to 1. Design a finite state machine that, given a bit stream, will identify when a byte is correctly received. It needs to recognize the start bit, wait for all 8 data bits, and then verify that the stop bit is correct. If the stop bit is not received within the expected time, the FSM must wait until it receives the stop bit before attempting to receive the next byte.
module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    reg [3:0] i;
    parameter RECV=0, DONE=1, READY=3, ERROR=4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            READY: next_state <= in ? READY : RECV;
            RECV: begin
                if((i==8)&in) begin
                    next_state <= DONE;
                end else if((i==8)&(~in)) begin
                    next_state <= ERROR;
                end else begin
                    next_state <= RECV;
                end
            end
            DONE: next_state <= in ? READY : RECV;
            ERROR: next_state <= in ? READY : ERROR;
        endcase
    end

    always @(posedge clk) begin
        if(reset) begin
            state <= READY;
            i <= 0;
        end else begin
            if((state == RECV)&&(i!=8)) begin
                i <= i + 1;
            end else if(state == ERROR) begin
                i <= 0;
            end else if(state == DONE) begin
                i <= 0;
            end
            state <= next_state;
        end
    end
    assign done = (state == DONE);    
endmodule"
"Based on the previous topic, output the received data:

- Module Declaration
```verilog
module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
```
module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); 
    reg [3:0] i;
    parameter RECV=0, DONE=1, READY=3, ERROR=4;
    reg [2:0] state, next_state;
    reg [7:0] data;

    always @(*) begin
        case (state)
            READY: next_state <= in ? READY : RECV;
            RECV: begin
                if((i==8)&in) begin
                    next_state <= DONE;
                end else if((i==8)&(~in)) begin
                    next_state <= ERROR;
                end else begin
                    next_state <= RECV;
                    data[i] <= in;
                end
            end
            DONE: begin
                next_state <= in ? READY : RECV;
                out_byte <= data;
            end
            ERROR: next_state <= in ? READY : ERROR;
        endcase
    end

    always @(posedge clk) begin
        if(reset) begin
            state <= READY;
            i <= 0;
        end else begin
            if((state == RECV)&&(i!=8)) begin
                i <= i + 1;
            end else if(state == ERROR) begin
                i <= 0;
            end else if(state == DONE) begin
                i <= 0;
            end
            state <= next_state;
        end
    end
    assign done = (state == DONE);
endmodule"
"The translation of the text is as follows:

""In the two-dimensional world of lemmings, lemmings can be in one of two states: walking left or walking right. If they encounter an obstacle, they will change direction. Specifically, if a lemming bumps into the left side, it will walk to the right. If it collides with the right side, it will walk to the left. If it collides on both sides simultaneously, it will still change direction. Implement a Moore state machine with two states, two inputs, and one output to simulate this behavior.""
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    output walk_left,
    output walk_right); //  

    parameter LEFT=0, RIGHT=1;
    reg state, next_state;

    always @(*) begin
        // State transition logic
        case (state)
            LEFT: next_state <= bump_left ? RIGHT : LEFT;
            RIGHT: next_state <= bump_right ? LEFT : RIGHT;
        endcase
    end

    always @(posedge clk, posedge areset) begin
        // State flip-flops with asynchronous reset
        if(areset) begin
            state <= LEFT;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign walk_left = (state == LEFT);
    assign walk_right = (state == RIGHT);

endmodule"
"Besides walking to the left and right, if the ground disappears, the lemming will fall and scream ""aaah!"".

When ground equals 0, in addition to walking left and right and changing direction, the lemming will also fall and say ""aaah!"". When the ground reappears (ground equals 1), the lemming will resume walking in the same direction as before falling. Being bumped while falling does not affect the walking direction, being hit in the same cycle as the ground disappearing (but not yet falling), or when the ground reappears while falling also does not affect the walking direction.

Establish a finite state machine to simulate this behavior.

- Module Declaration
```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    input ground,
    output walk_left,
    output walk_right,
    output aaah ); 
```
module top_module(
        input clk,
        input areset,
        input bump_left,
        input bump_right,
        input ground,
        output walk_left,
        output walk_right,
        output aaah
);

        parameter LEFT = 2'd0, LEFT_GROUND = 2'd1, RIGHT = 2'd2, RIGHT_GROUND = 2'd3;

        reg [1:0] curr_dir, next_dir;

        always @(posedge clk or posedge areset) begin
                // Freshly brainwashed Lemmings walk left.
                if (areset) begin
                        curr_dir <= LEFT;
                end
                else begin
                        curr_dir <= next_dir;
                end
        end

        always @(*) begin
                case (curr_dir)
                        LEFT: begin
                                if (ground) begin
                                        next_dir = bump_left ? RIGHT : LEFT;
                                end
                                else begin
                                        next_dir = LEFT_GROUND;
                                end
                        end
                        RIGHT: begin
                                if (ground) begin
                                        next_dir = bump_right ? LEFT : RIGHT;
                                end
                                else begin
                                        next_dir = RIGHT_GROUND;
                                end
                        end
                        LEFT_GROUND: begin
                                if (ground) begin
                                        next_dir = LEFT;
                                end
                                else begin
                                        next_dir = LEFT_GROUND;
                                end
                        end
                        RIGHT_GROUND: begin
                                if (ground) begin
                                        next_dir = RIGHT;
                                end
                                else begin
                                        next_dir = RIGHT_GROUND;
                                end
                        end
                endcase
        end

        assign walk_left = curr_dir == LEFT;
        assign walk_right = curr_dir == RIGHT;
        assign aaah = (curr_dir == LEFT_GROUND) || (curr_dir == RIGHT_GROUND);

endmodule"
"除了行走和摔倒之外,有时还可以告诉旅鼠做一些有用的事情,比如挖洞（当dig=1时开始挖洞）。如果一只旅鼠正在地面上行走（ground=1），它可以继续挖掘直到到达另一边（ground=0）。在那一点上，由于没有地面，它会掉下来（aaah!），然后在它再次落地后继续沿着它原来的方向行走。和坠落一样，在挖掘时被撞击没有效果，在坠落或没有地面时被告知挖掘是被忽略的。

换言之，一个行尸走肉的旅鼠可能会摔倒、dig或改变方向。如果满足这些条件中的一个以上，则fall的优先级高于dig，dig的优先级高于切换方向。

扩展有限状态机来模拟这种行为。

- Module Declaration
```verilog
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    input ground,
    input dig,
    output walk_left,
    output walk_right,
    output aaah,
    output digging ); 
```
module top_module(
    input clk,
    input areset,    // Freshly brainwashed Lemmings walk left.
    input bump_left,
    input bump_right,
    input ground,
    input dig,
    output walk_left,
    output walk_right,
    output aaah,
    output digging );

    reg [2:0] state, next_state;
    parameter LEFT=0, RIGHT=1, LEFT_GROUND=3, RIGHT_GROUND=4, DIG_LEFT=5, DIG_RIGHT=6;
    always @(*) begin
        case (state)
            LEFT: begin
                if(ground) begin
                    if(dig) begin
                        next_state <= DIG_LEFT;
                    end else begin
                        next_state <= bump_left ? RIGHT : LEFT;
                    end
                end else begin
                    next_state <= LEFT_GROUND;
                end
            end
            RIGHT: begin
                if(ground) begin
                    if(dig) begin
                        next_state <= DIG_RIGHT; 
                    end else begin
                        next_state <= bump_right ? LEFT : RIGHT;
                    end
                end else begin
                    next_state <= RIGHT_GROUND;
                end
            end
            LEFT_GROUND: begin
                if(ground) begin
                    next_state <= LEFT;
                end else begin
                    next_state <= LEFT_GROUND;
                end
            end
            RIGHT_GROUND: begin
                if(ground) begin
                    next_state <= RIGHT;
                end else begin
                    next_state <= RIGHT_GROUND;
                end
            end
            DIG_LEFT: begin
                if(ground) begin
                    next_state <= DIG_LEFT;
                end else begin
                    next_state <= LEFT_GROUND;
                end
            end
            DIG_RIGHT: begin
                if(ground) begin
                    next_state <= DIG_RIGHT;
                end else begin
                    next_state <= RIGHT_GROUND;
                end
            end
        endcase
    end

            always @(posedge clk or posedge areset) begin
                if( areset) begin
                    state <= LEFT;
                end else begin
                    state <= next_state;
                end
            end
            
            assign walk_left = (state == LEFT);
            assign walk_right = (state == RIGHT);
            assign aaah = (state == RIGHT_GROUND)||(state == LEFT_GROUND);
            assign digging = (state == DIG_LEFT)||(state == DIG_RIGHT);
endmodule"

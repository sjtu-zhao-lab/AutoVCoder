Chunk Content
"Verilog HDL is a hardware description language that can be used to model a digital system  at many levels of abstraction ranging from the algorithmic level to the gate level to the switch  level. The complexity of the digital system being modeled could vary from that of a simple  gate to a complete electronic digital system, or anything in between. The digital system can be  described hierarchically and timing can be explicitly modeled within the same description.    1.1 Typical Design Flow"
"The design flow shown in Figure 1.1 is typically used by designers who use HDLs. In  any design, specifications are written first. Specifications describe abstractly the functionality,  interface, and overall architecture of the digital circuit to be designed. At this point, the  architects do not need to think about how they will implement this circuit. A behavioral  description is then created to analyze the design in terms of functionality, performance,  compliance to standards, and other high-level issues.  Behavioral descriptions are often written  with HDLs"
"Logic synthesis tools convert the RTL description to a gate-level netlist. A gatelevel netlist  is a description of the circuit in terms of gates and connections between them. Logic synthesis  tools ensure that the gate-level netlist meets timing, area, and power specifications. The gatelevel netlist is input to an Automatic Place and Route tool, which creates a layout. The layout  is verified and then fabricated on a chip.    Figure 1.2 Design Methodologies"
"Verilog HDL has two groups of data types a) Net type : A net type represents a  physical connection between structural elements. Its value is determined from the value of  its drivers such as a continuous assignment or a gate output. If no driver is connected to a  net, the net defaults to a value of z. b)Variable type: A variable type represents an abstract  data storage element. It is assigned values only within an always statement or an initial  statement, and its value is saved from one assignment to the next. A variable type has a  default value of x."
"Integers are declared by the keyword integer. Although it is possible to use reg as a  general-purpose variable, it is more convenient to declare an integer variable for purposes  such as counting. The default width for an integer is the host-machine word size, which is  implementationspecific but is at least 32 bits. Registers declared as data type reg store  values as unsigned quantities, whereas integers store values as signed quantities."
Time: Verilog simulation is done with respect to simulation time. A special time register  data type is used in Verilog to store simulation time. A time variable is declared with the  keyword time. The width for time register data types is implementation specific but is at least 64 bits. The system function $time is invoked to get the current simulation time.
"Behavioral modeling is the highest level of abstraction in the Verilog HDL. The other  modeling techniques are relatively detailed. They require some knowledge of how hardware or  hardware signals work. The abstraction in this modeling is as simple as writing the logic in C  language. This is a very powerful abstraction technique. All that a designer need is the  algorithm of the design, which is the basic information for any design. Most of the behavioral  modeling is done using two important constructs: initial and always. All the other behavioral  statements appear only inside these two structured procedure constructs."
"The right-hand side of a procedural assignment can be any expression that evaluates to a  value. However, part-selects on the right-hand side must have constant indices. The lefthand  side indicates the variable that receives the assignment from the right-hand side. The left-hand  side of a procedural assignment can take one of the following forms   − register, integer, real, or time variable   − An assignment to the name reference of one of these data types. bit-select of a register,  integer, real, or time variable   − An assignment to a single bit that leaves the other bits untouched. part-select of a  register, integer, real, or time variable   − A part-select of two or more contiguous bits that leaves the rest of the bits untouched."
"For the part-select form, only constant expressions are legal. memory element − A single word  of a memory. Note that bit-selects and part-selects are illegal on memory element references.  concatenation of any of the above   − A concatenation of any of the previous four forms can be specified, which effectively partitions the result of the right-hand side expression and assigns the partition parts, in order, to  the various parts of the concatenation."
Nonblocking (RTL) Assignments: The non-blocking procedural assignment allows you to  schedule assignments without blocking the procedural flow. You can use the non-blocking  procedural statement whenever you want to make several register assignments within the same  time step without regard to order or dependance upon each other.  <lvalue> <= <timing_control> <expression>
"Where lvalue is a data type that is valid for a procedural assignment statement, <= is the  non-blocking assignment operator, and timing control is the optional intra-assignment timing  control. The timing control delay can be either a delay control or an event control (for example,  @(posedge clk)). The expression is the right-hand side value the simulator assigns to the lefthand side. The non-blocking assignment operator is the same operator the simulator uses for the  less-than-orequal relational operator. The simulator interprets the <= operator to be a relational  operator when you use it in an expression, and interprets the <= operator to be an assignment  operator when you use it in a non-blocking procedural assignment construct. How the simulator  evaluates non-blocking procedural assignments When the simulator encounters a non-blocking  procedural assignment, the simulator evaluates and executes the non-blocking procedural  assignment in two steps as follows –"
"The simulator evaluates the right-hand side and schedules the assignment of the new  value to take place at a time specified by a procedural timing control. At the end of the time  step, in which the given delay has expired or the appropriate event has taken place, the  simulator executes the assignment by assigning the value to the left-hand side."
"The case expressions are evaluated and compared in the exact order in which they are  given. During the linear search, if one of the case item expressions matches the expression in  parentheses, then the statement associated with that case item is executed. If all comparisons  fail, and the default item is given, then the default item statement is executed. If the default  statement is not given, and all of the comparisons fail, then none of the case item statements is  executed."
"Looping Statements: There are four types of looping statements. They provide a means  of controlling the execution of a statement zero, one, or more times. forever continuously  executes a statement. repeat executes a statement a fixed number of times. while executes a  statement until an expression becomes false. If the expression starts out false, the statement is  not executed at all. for controls execution of its associated statement(s) by a three-step process,  as follows   − Executes an assignment normally used to initialize a variable that controls the number  of loops executed Evaluates an expression  if the result is zero, the for loop exits, and if it is not zero, the for loop executes its  associated statement(s) and then performs step 3 Executes an assignment normally used to  modify the value of the loopcontrol variable, then repeats step 2."
"In the first module instantiation, HA is the name of the module, h1 is the instance name  and ports are associated by position, that is, P is connected to module (HA) port A, Q is  connected to module port B, S1 to S and C1 to module port C. In the second instantiation, the  port association is by name, that is, the connections between the module (HA) ports and the port  expressions are specified explicitly."
"SystemVerilog is a standard set of extensions to the IEEE 13642005 Verilog Standard  (commonly referred to as “Verilog-2005”). The SystemVerilog extensions to the Verilog HDL  that are described in this book are targeted at design and writing synthesizable models. These  extensions integrate many of the features of the SUPERLOG and C languages. SystemVerilog  also contains many extensions for the verification of large designs, integrating features from the"
"Accellera, the IEEE-SA organization decided not to immediately add the SystemVerilog  extensions to work already in progress for extending Verilog 1364. Instead, it was decided to  keep the SystemVerilog extensions as a separate document. To ensure that the reference manual  for the base Verilog language and the reference manual for the SystemVerilog extensions to"
"The following list highlights some of the more significant enhancements SystemVerilog adds  to the Verilog HDL for the design and verification of hardware: This list is not intended to be all  inclusive of every enhancement to Verilog that is in SystemVerilog. This list just highlights a  few key features that aid in writing synthesizable hardware models.   Interfaces to encapsulate communication and protocol checking within a design   C like data types, such as int    User-defined types, using typedef    Enumerated types    Type casting    Structures and unions    Packages for definitions shared by multiple design blocks    External compilation-unit scope declarations    ++, --, += and other assignment operators    Explicit procedural blocks    Priority and unique decision modifiers    Programming statement enhancements    Pass by reference to tasks, functions and  keywords. The objects declared within a module are  local to the module. For modeling purposes, these objects should be referenced within the  module in which they are declared. Verilog also allows hierarchical references to these objects  from other modules for verification purposes, but these cross-module references do not represent hardware behavior, and are not synthesizable. Verilog also allows local variables to be defined in  named blocks (formed with begin...end or fork...join), tasks and functions. These declarations are  still defined within a module, however, and, for synthesis purposes, only accessible within the  module. Verilog does not have a place to make global declarations, such as global functions."
"A declaration that is used in multiple design blocks must be declared in each block. This not  only requires redundant declarations, but it can also lead to errors if a declaration, such as a  function, is changed in one design block, but not in another design block that is supposed to have  the same function. Many designers use include files and other coding tricks to work around this  shortcoming, but that, too, can lead to coding errors and design maintenance problems."
"Packages can contain parameter, localparam and const constant declarations. The  parameter and localparam constants are Verilog constructs. A const constant is a SystemVerilog  constant. In Verilog, a parameter constant can be redefined for each instance of a module,  whereas a localparam cannot be directly redefined. In a package, however, a parameter constant  cannot be redefined, since it is not part of a module instance. In a package, parameter and  localparam are synonymous."
Modules and interfaces can reference the definitions and declarations in a package four  ways:   • Direct reference using a scope resolution operator   • Import specific package items into the module or interface   • Wildcard import package items into the module or interface   • Import package items into the $unit declaration space
"When a module references a task or function that is defined in a package, synthesis will  duplicate the task or function functionality and treat it as if it had been defined within the  module. To be synthesizable, tasks and functions defined in a package must be declared as  automatic, and cannot contain static variables. This is because storage for an automatic task  or function is effectively allocated each time it is called. Thus, each module that references  an automatic task or function in a package sees a unique copy of the task or function storage  that is not shared by any other module. This ensures that the simulation behavior of the presynthesis reference to the package task or function will be the same as post-synthesis  behavior, where the functionality of the task or function has been implemented within one or  more modules.   For similar reasons, synthesis does not support variables declarations in packages. In  simulation, a package variable will be shared by all modules that import the variable. One  module can write to the variable, and another module will see the new value. This type of  inter-module communication without passing values through module ports is not  synthesizable.  2.5 $unit compilation-unit declarations"
SystemVerilog adds a concept called a compilation unit to Verilog. A compilation unit is  all source files that are compiled at the same time. Compilation units provide a means for  software tools to separately compile sub-blocks of an overall design. A sub-block might  comprise a single module or multiple modules. The modules might be contained in a single  file or in multiple files. A sub-block of a design might also contain interface blocks and  testbench program blocks.
"A declaration in the compilation-unit scope is not the same as a global declaration. A true  global declaration, such as a global variable or function, would be shared by all modules that  make up a design, regardless of whether or not source files are compiled separately or at the  same time."
"SystemVerilog’s compilation-scope only exists for source files that are compiled at the  same time. Each time source files are compiled, a compilation-unit scope is created that is unique  to just that compilation. For example, if module CPU and module controller both reference an  externally declared variable called reset, then two possible scenarios exist:  • If the two modules are compiled at the same time, there will be a single compilationunit scope. The externally declared reset variable will be common to both modules.   • If each module were compiled separately, then there would be two compilation-unit  scopes, possibly with two different reset variables."
"There is an important consideration when using external declarations. Verilog supports  implicit type declarations, where, in specific contexts, an undeclared identifier is assumed to  be a net type (typically a wire type). Verilog requires the type of identifiers to be explicitly  declared before the identifier is referenced when the context will not infer an implicit type, or  when a type other than the default net type is desired."
"The synthesizable constructs that can be declared within the compilationunit  scope (external to all module and interface definitions) are:   • typedef user-defined type definitions   • Automatic functions   • Automatic tasks   • parameter and localparam constants   • Package imports    While not a recommended style, user-defined types defined in the compilation-unit scope  are synthesizable. A better style is to place the definitions of user-defined types in named  packages. Using packages reduces the risk of spaghetti code and file order dependencies."
"When a module references a task or function that is defined in the compilation-unit scope,  synthesis will duplicate the task or function code and treat it as if it had been defined within the  module. To be synthesizable, tasks and functions defined in the compilation-unit scope must be  declared as automatic, and cannot contain static variables. This is because storage for an  automatic task or function is effectively allocated each time it is called. Thus, each module that  references an automatic task or function in the compilation-unit scope sees a unique copy of the  task or function storage that is not shared by any other module. This ensures that the simulation  behavior of the presynthesis reference to the compilation-unit scope task or function will be the  same as post-synthesis behavior, where the functionality of the task or function has been  implemented within the module."
"A parameter constant defined within the compilation-unit scope cannot be redefined,  since it is not part of a module instance. Synthesis treats constants declared in the compilationunit scope as literal values. Declaring parameters in the $unit space is not a good modeling style,  as the constants will not be visible to modules that are compiled separately from the file that  contains the constant declarations.  2.6 Declarations in unnamed statement blocks"
"Verilog allows local variables to be declared in named begin...end or fork...join blocks. A  common usage of local variable declarations is to declare a temporary variable for controlling a  loop. The local variable prevents the inadvertent access to a variable at the module level of the  same name, but with a different usage. The following code fragment has declarations for two  variables, both named i. The for loop in the named begin block will use the local variable i that  is declared in that named block, and not touch the variable named i declared at the module level."
"SystemVerilog. The Verilog language has a similar situation. User-defined primitives (UDPs)  can have a variable declared internally, but the Verilog language does not require that an  instance name be assigned to primitive instances. This also creates a variable in an unnamed  scope. Software tools will infer an instance name in this situation, in order to allow the variable  within the UDP to be referenced in the tool’s debug utilities. Software tools may also assign an  inferred name to an unnamed block, in order to allow the tool’s waveform display or debug  utilities to reference the local variables in that unnamed block. The SystemVerilog standard  neither requires nor prohibits a tool inferring a scope name for unnamed blocks, just as the  Verilog standard neither requires nor prohibits the inference of instance names for unnamed  primitive instances.  2.7 SystemVerilog Literal Values and Built-in Data Types"
"System Verilog Data Types:  Verilog does not clearly distinguish between signal  types, and the value set the signals can store or transfer. In Verilog, all nets and  variables use 4-state values, so a clear distinction is not necessary. To provide more  flexibility in variable and net types and the values that these types can store or transfer,  the SystemVerilog standard defines that signals in a design have both a type and a data  type."
"Verilog language. The term “reg” would seem to imply a hardware “register”, built  with some form of sequential logic flip-flops. In actuality, there is no correlation  whatsoever between using a reg variable and the hardware that will be inferred. It is the  context in which the reg variable is used that determines if the hardware represented is  combinational logic or sequential logic. SystemVerilog uses the more intuitive logic  keyword to represent a general purpose, hardware-centric data type."
"Because the keyword logic does not convey a false implication of the type of hardware  represented, logic is a more intuitive keyword choice for describing hardware when 4-state logic  is required. In the subsequent examples in this book, the logic type is used in place of the Verilog  reg type (except when the example illustrates pure Verilog code, with no SystemVerilog  enhancements)."
"SystemVerilog adds a cast operator to the Verilog language. This operator can be used to  cast a value from one type to another, similar to the C language. SystemVerilog’s cast operator  goes beyond C, however, in that a vector can be cast to a different size, and signed values can be  cast to unsigned or vice versa. To be compatible with the existing Verilog language, the syntax  of SystemVerilog’s cast operator is different than C’s. <type>’(<expression>) — casts a value to  any type, including user-defined types."
"The static cast operation is a compile-time cast. The expression to be cast will always be  converted during run time, without any checking that the expression to be cast falls within the  legal range of the type to which the value is cast. In the following example, a static cast is used to  increment the value of an enumerated variable by 1. The static cast operator does not check that  the result of state + 1 is a legal value for the next_state enumerated type. Assigning an out of  range value to next_state using a static cast will not result in a compile-time or run-time error."
"The $cast system function takes two arguments, a destination variable and a source  variable.      $cast attempts to assign the source expression to the destination variable. If the  assignment is invalid, a run-time error is reported, and the destination variable is left  unchanged. Some examples that would result in an invalid cast are:   • Casting a real to an int, when the value of the real number is too large to be represented  as an int (as in the example, above).   • Casting a value to an enumerated type, when the value does not exist in the legal set of  values in the enumerated type list  2.10 User-Defined and Enumerated Types"
"The Verilog language does not provide a mechanism for the user to extend the language  net and variable types. While the existing Verilog types are useful for RTL and gate-level  modeling, they do not provide C-like variable types that could be used at higher levels of  abstraction. SystemVerilog adds a number of new types for modeling at the system and  architectural level. In addition, SystemVerilog adds the ability for the user to define new net and  variable types."
"Local typedef definitions: User-defined types can be defined locally, in a package, or  externally, in the compilation-unit scope. When a user-defined type will only be used within a  specific part of the design, the typedef definition can be made within the module or interface  representing that portion of the design. Interfaces are presented in Chapter 10. In the code  snippet that follows, a user-defined type called nibble is declared, which is used for variable  declarations within a module called alu. Since the nibble type is defined locally, only the alu  module can see the definition. Other modules or interfaces that make up the overall design are  not affected by the local definition, and can use the same nibble identifier for other purposes  without being affected by the local typedef definition in module alu."
"Shared typedef definitions:  When a user-defined type is to be used in many different  models, the typedef definition can be declared in a package. These definitions can then be  referenced directly, or imported into each module, interface or program block that uses the userdefined types.  A typedef definition can also be declared externally, in the compilationunit scope."
"Enumerated types provide a means to declare an abstract variable that can have a specific  list of valid values. Each value is identified with a user-defined name, or label. In the following  example, variable RGB can have the values of red, green and blue:  enum {red,green,blue} RGB;  The Verilog language does not have enumerated types. To create pseudo labels for data  values, it is necessary to define a parameter constant to represent each value, and assign a value  to that constant. Alternatively, Verilog’s ‘define text substitution macro can be used to define a  set of macro names with specific values for each name. The following example shows a simple  state machine sequence modeled using Verilog parameter constants and ‘define macro names:"
"The variables that use the constant values—State and NextState in the preceding  example—must be declared as standard Verilog variable types. This means a software tool  cannot limit the valid values of those signals to just the values of the constants. There is nothing  that would limit State or NextState in the example above from having a value of 3, or a value  with one or more bits set to X or Z. Therefore, the model itself must add some limit checking on  the values. At a minimum, a synthesis “full case” pragma would be required to specify to  synthesis tools that the state variable only uses the values of the constants that are listed in the  case items. The use of synthesis pragmas, however, would not affect simulation, which could  result in mismatches between simulation behavior and the structural design created by synthesis."
"SystemVerilog also adds to Verilog the ability to reference an entire unpacked array, or a  slice of multiple elements within an unpacked array. A slice is one or more contiguously  numbered elements within one dimension of an array. These enhancements make it possible to  copy the contents of an entire array, or a specific dimension of an array into another array."
"SystemVerilog defines how the elements of a packed array are stored. The entire array  must be stored as contiguous bits, which is the same as a vector. Each dimension of a packed  array is a sub field within the vector. In the packed array declaration above, there is an array of 4  8-bit sub-arrays."
"In Verilog, a task or function exits when the execution flow reaches the end, which is  denoted by endtask or endfunction. In order to exit before the end a task or function is reached  using Verilog, conditional statements such as if...else must be used to force the execution flow  to jump to the end of the task or function. A task can also be forced to jump to its end using the  disable keyword, but this will affect all currently running invocations of a re-entrant task. The  following example requires extra coding to prevent executing the function if the input to the  function is less than or equal to 1."
"Verilog requires that tasks and functions contain at least one statement (which can be an  empty begin...end statement group). SystemVerilog allows tasks and functions to be completely  empty, with no statements or statement groups at all. An empty function will return the current  value of the implicit variable that represents the name of the function. An empty task or function  is a place holder for partially completed code. In a top-down design flow, creating an empty task  or function can serve as documentation in a model for the place where more detailed  functionality will be filled in later in the design flow."
"SystemVerilog extends the Verilog language with a powerful interface construct. Interfaces  offer a new paradigm for modeling abstraction. The use of interfaces can simplify the task of  modeling and verifying large, complex designs. This chapter contains a number of small  examples, each one showing specific features of interfaces. These examples have been purposely  kept relatively small and simple, in order to focus on specific features of interfaces.   3.1  Interface concepts:"
"The Verilog language connects modules together through module ports. This is a detailed  method of representing the connections between blocks of a design that maps directly to the  physical connections that will be in the actual hardware. For large designs, however, using  module ports to connect blocks of a design together can become tedious and redundant."
"Consider the following example that connects five blocks of a design together using a  rudimentary bus architecture called main_bus, plus some additional connections between some  of the design blocks. Figure shows the block diagram for this simple design, and example lists  the Verilog source code for the module declarations involved."
"Verilog’s module ports provide a simple and intuitive way of describing the  interconnections between the blocks of a design. In large, complex designs, however, Verilog’s  module ports have several shortcomings. Some of these are:   • Declarations must be duplicated in multiple modules.   • Communication protocols must be duplicated in several modules.   • There is a risk of mismatched declarations in different modules.  • A change in the design specification can require modifications in multiple modules."
"One disadvantage of using Verilog’s module ports to connect major blocks of a design  together is readily apparent in the example code above. The signals that make up main_bus in the  preceding example must be declared in each module that uses the bus, as well as in the top-level  netlist that connects the design together. In this simple example, there are only a handful of  signals in main_bus, so the redundant declarations are mostly just an inconvenience. In a large,  complex design, however, this redundancy becomes much more than an inconvenience. A large  design could have dozens of modules connected to the same bus, with dozens of duplicated  declarations in each module. If the ports of one module should inadvertently be declared  differently than the rest of the design, a functional error can occur that may be difficult to find."
"The replicated port declarations also mean that, should the specification of the bus change  during the design process, or in a next generation of the design, then each and every module that  shares the bus must be changed. All netlists used to connect the modules using the bus must also  be changed. This wide spread effect of a change is counter to good coding styles. One goal of  coding is to structure the code in such a way that a small change in one place should not require  changing other areas of the code. A weakness in the Verilog language is that a change to the  ports in one module will usually require changes in other modules."
"SystemVerilog adds a powerful new port type to Verilog, called an interface. An interface  allows a number of signals to be grouped together and represented as a single port. The  declarations of the signals that make up the interface are contained in a single location. Each  module that uses these signals then has a single port of the interface type, instead of many ports  with the discrete signals. Example shows how SystemVerilog’s interfaces can reduce the  amount of code required to model the simple design shown in Figure. By encapsulating the  signals that make up main_bus as an interface, the redundant declarations for these signals  within each module are eliminated."
"The top-level module and all modules that make up these blocks do not repetitively declare these  common signals. Instead, these modules simply use the interface as the connection between  them. Encapsulating common signals into a single location eliminates the redundant declarations  of Verilog modules. Indeed, in the preceding example, since clock and resetN are also common  to all modules, these signals could have also been brought into the interface.  3.4 SystemVerilog interface contents"
"SystemVerilog interfaces are far more than just a bundle of wires. Interfaces can  encapsulate the full details of the communication between the blocks of a design. Using  interfaces:   • The discrete signal and ports for communication can be defined in one location, the  interface.   • Communication protocols can be defined in the interface.   • Protocol checking and other verification routines can be built directly into the interface."
"With Verilog, the communication details must be duplicated in each module that shares a  bus or other communication architecture. SystemVerilog allows all the information about a  communication architecture and the usage of the architecture to be defined in a single, common  location. An interface can contain type declarations, tasks, functions, procedural blocks,  program blocks, and assertions. SystemVerilog interfaces also allow multiple views of the  interface to be defined. For example, for each module connected to the interface, the data_bus  signal can be defined to be an input, output or bidirectional port.  3.5 Differences between modules and interfaces"
"Second, an interface can be used as a module port, which is what allows interfaces to represent  communication channels between modules. It is illegal to use a module in a port list. Third, an  interface can contain modports, which allow each module connected to the interface to see the  interface differently.  3.6 Interface declarations"
"An interface can have ports, just as a module does. This allows signals that are external to the  interface, such as a clock or reset line, to be brought into the interface and become part of the  bundle of signals represented by the interface. Interfaces can also contain declarations of any"
"Example 10-3 shows a definition for an interface called main_bus, with three external signals  coming into the interface: clock, resetN and test_mode. These external signals can now be  connected to each module through the interface, without having to explicitly connect the signals  to each module. Notice in this example how the instance of interface main_bus has the clock,  resetN and test_mode signals connected to it, using the same syntax as connecting signals to an  instance of a module."
An explicitly named interface port can only be connected to an interface of the same  name. An error will occur if any other interface definition is connected to the port. Explicitly  named interface ports ensure that a wrong interface can never be inadvertently connected to the  port. Explicitly naming the interface type that can be connected to the port also serves to  document directly within the port declaration exactly how the port is intended to be used.  3.8 Instantiating and connecting interfaces
"An instance of an interface is connected to a port of a module instance using a port  connection, just as a discrete net would be connected to a port of a module instance. This  requires that both the interface and the modules to which it is connected be instantiated. The  syntax for an interface instance is the same as for a module instance. If the definition of the  interface has ports, then signals can be connected to the interface instance, using either the port  order connection style or the named port connection style, just as with a module instance."
"A module input, output or inout port can be left unconnected on a module instance. This  is not the case for an interface port. A port that is declared as an interface, whether generic or  explicit, must be connected to an interface instance or another interface port. An error will occur  if an interface port is left unconnected. On a module instance, a port that has been declared as an  interface type must be connected to an interface instance, or another interface port that is higher  up in the hierarchy. If a port declaration has an explicitly named interface type, then it must be  connected to an interface instance of the identical type. If a port declaration has a generic  interface type, then it can be connected to an interface instance of any type.  3.9 Interface modports"
"Interfaces provide a practical and straightforward way to simplify connections between  modules. However, each module connected to an interface may need to see a slightly different  view of the connections within the interface. For example, to a slave on a bus, an  interrupt_request signal might be an output from the slave, whereas to a processor on the same  bus, interrupt_request would be an input."
"SystemVerilog interfaces provide a means to define different views of the interface signals  that each module sees on its interface port. The definition is made within the interface, using the  modport keyword. Modport is an abbreviation for module port. A modport definition describes  the module ports that are represented by the interface. An interface can have any number of  modport definitions, each describing how one or more other modules view the signals within the  interface."
"Examples of two modport declarations are:      The modport definitions do not contain vector sizes or types. This information is defined as  part of the signal type declarations in the interface. The modport declaration only defines  whether the connecting module sees a signal as an input, output, bidirectional inout, or ref port.  3.10 Using tasks and functions in interfaces:"
"Interfaces can encapsulate the full details of the communication protocol between  modules. For instance, the main_bus protocol in the previous example includes handshaking  signals between the master processor and the slave processor. In regular Verilog, the master  processor module would need to contain the procedural code to assert and de-assert its  handshake signals at the appropriate time, and to monitor the slave handshake inputs."
"SystemVerilog allows tasks and functions to be declared within an interface. These tasks  and functions are referred to as interface methods. A task or function that is defined within an  interface is written using the same syntax as if it had been within a module, and can contain the  same types of statements as within a module. These interface methods can operate on any signals  within the interface. Values can be passed in to interface methods from outside the interface as  input arguments. Values can be written back from interface methods as output arguments or  function returns."
"If the interface is connected via a modport, the method must be specified using the import  keyword. The import definition is specified within the interface, as part of a modport  definition. Modports specify interface information from the perspective of the module. Hence,  an import declaration within a modport indicates that the module is importing the task or  function."
"The second style of an import declaration is to specify a full prototype of the task or  function arguments. This style requires that the keyword task or function follow the import  keyword. It also requires that the task or function name be followed by a set of parentheses,  which contain the formal arguments of the task or funciton. The basic syntax of this style of  import declarations is:"
"A full prototype can serve to document the arguments of the task or function directly as  part of the modport declaration. This additional code documentation can be convenient if the  actual task or function is defined in a package, and therefore the definition is not in the package  source code for easy visual reference.  3.11 Exporting tasks and functions"
Exporting tasks or functions into an interface is not synthesizable. This modeling style  should be reserved for abstract models that are not intended to be synthesized. An export  declaration in an interface modport does not require a full prototype of the task or function  arguments. Only the task or function name needs to be listed in the modport declaration.
"If an exported task or function has default values for any of its formal arguments, then  each import declaration of the task or function must have a complete prototype of the  task/function arguments. A full prototype for the import declaration is also required if the task  or function call uses named argument passing instead of passing by position.  The code fragments in example 10-10 show a function called check that is declared in  module CPU. The function is exported from the CPU through the master modport of the  chip_bus interface. The same function is imported into any modules that use the slave modport  of the interface. To any module connected to the slave modport, the check function appears to  be part of the interface, just like any other function imported from an interface. Modules using  the slave modport do not need to know the actual location of the check function definition."
Exporting a task or function to the entire interface: The export declaration allows a module to  export a task or function to an interface through a specific modport of the interface. A task or  function can also be exported to an interface without using a modport. This is done by declaring  an extern prototype of the task or function within the interface.
"Restrictions on exporting tasks and functions: SystemVerilog places a restriction on exporting  functions through interfaces. It is illegal to export the same function name from two different  modules, or two instances of the same module, into the same interface. For example, module A  and module B cannot both export a function called check into the same interface."
"SystemVerilog places a restriction on exporting tasks through interfaces. It is illegal to  export the same task name from two different modules, or two instances of the same module,  into the same interface, unless an extern forkjoin declaration is used. The multiple export of a  task corresponds to a multiple response to a broadcast. Tasks can execute concurrently, each  taking a different amount of time to execute statements, and each call returning different values  through its outputs. The concurrent response of modules A and B containing a call to a task  called task1 is conceptually modeled by"
"Because an interface should not contain the hierarchical names of the modules to which it  is connected, the task is declared as extern forkjoin, which infers the behavior of the fork...join  block above. If the task contains outputs, it is the last instance of the task to finish that  determines the final output value."
"This construct can be useful for abstract, non-synthesizable transaction level models of  busses that have slaves, where each slave determines its own response to broadcast signals. The  extern forkjoin  can also be used for configuration purposes, such as counting the number of  modules connected to an interface. Each module would export the same task, name which  increments a counter in the interface.  3.12 System Verilog Event Scheduling:"
"Preponed region:  The values of variables that are used in concurrent assertions are  sampled in the Preponed region. (Evaluation is done at observed region). Preponed region is  executed only once in each time slot, immediately after advancing simulation time.  state of a net or variable in the system description being simulated is  considered an update event. When an update event is executed, all the processes that are  sensitive to those events are considered for evaluation known as an evaluation event. Examples of processes include, initial, always, always_comb, always_latch, and always_ff procedural  blocks, continuous assignments, asynchronous tasks, and procedural assignment statements. A  single time slot is divided into multiple regions where events can be sc heduled. This event  scheduling supports obtaining clear and predictable interactions that provide for the ordering of  particular types of execution. This allows properties and checkers to sample data when the  design under test is in a stable state. Propert y expressions can be safely evaluated, and  testbenches can react to both properties and checkers with zero delay, all in a predictable  manner. This same mechanism also allows for non -zero delays in the design, clock propagation,  e code to be mixed freely and consistently with cycle"
"The values of variables that are used in concurrent assertions are  sampled in the Preponed region. (Evaluation is done at observed region). Preponed region is  executed only once in each time slot, immediately after advancing simulation time.  state of a net or variable in the system description being simulated is  considered an update event. When an update event is executed, all the processes that are  sensitive to those events are considered for evaluation known as an evaluation event. Examples   of processes include, initial, always, always_comb, always_latch, and always_ff procedural  blocks, continuous assignments, asynchronous tasks, and procedural assignment statements. A  heduled. This event  scheduling supports obtaining clear and predictable interactions that provide for the ordering of  particular types of execution. This allows properties and checkers to sample data when the  y expressions can be safely evaluated, and  testbenches can react to both properties and checkers with zero delay, all in a predictable  zero delays in the design, clock propagation,  e code to be mixed freely and consistently with cycle -accurate"
"The values of variables that are used in concurrent assertions are  sampled in the Preponed region. (Evaluation is done at observed region). Preponed region is  executed only once in each time slot, immediately after advancing simulation time.  Pre-active region: The Pre-active region is specifically for a PLI callback control point  that allows for user code to read and write values and create events before events in the Active  region are evaluated"
Active region:  The Active region holds current events being evaluated and can be  processed in any order.    Execute all module blocking assignments.    Evaluate the Right-Hand-Side (RHS) of all nonblocking assignments and  schedule updates into the NBA region.    Execute all module continuous assignments    Evaluate inputs and update outputs of Verilog primitives.    Execute the $display and $finish commands
"Observed region:  The principal function of this region is to evaluate the concurrent  assertions using the values sampled in the Preponed region. A criterion behind this decision is  that the property evaluations must only occur once in any clock triggering time slot. During the  property evaluation, the pass/fail code shall be scheduled in the Reactive region of the current  time slot."
"Reactive region : The code specified in the program block, and pass/fail code from property  expressions, are scheduled in the Reactive region. The principal function of this region is to  evaluate and execute all current program activity in any order   Execute all program blocking assignments.    Execute the pass/fail code from concurrent assertions.    Evaluate the Right-Hand-Side (RHS) of all program nonblocking assignments and  schedule   Execute all program continuous assignments    Execute the $exit and implicit $exit commands"
"Using only Verilog-style module ports, without interfaces, a typical design and  verification paradigm is to develop and test each module of a design, independent of other  modules in the design. After each module is independently verified, the modules are connected  together to test the communication between modules. If there is a problem with the  communication protocols, it may be necessary to make design changes to multiple modules."
"As designs grow larger, it becomes more difficult to create a complete set of stimuli needed  to check their functionality. You can write a directed test case to check a certain set of features,  but you cannot write enough directed test cases when the number of features keeps doubling on  each project. Worse yet, the interactions between all these features are the source for the most  devious bugs and are the least likely to be caught by going through a laundry list of features."
"The solution is to create test cases automatically using constrained-random tests (CRT). A  directed test finds the bugs you think are there, but a CRT finds bugs you never thought about,  by using random stimulus. You restrict the test scenarios to those that are both valid and of  interest by using constraints. Creating a CRT environment takes more work than creating one for  directed tests. A simple directed test just applies stimulus, and then you manually check the  result. These results are captured as a golden log file and compared with future simulations to see  whether the test passes or fails."
"A CRT environment needs not only to create the stimulus but also to predict the result,  using a reference model, transfer function, or other techniques. However, once this environment  is in place, you can run hundreds of tests without having to hand-check the results, thereby  improving your productivity. This trade-off of test-authoring time (your work) for CPU time  (machine work) is what makes CRT so valuable.    4.1 Randomize"
"When you think of randomizing the stimulus to a design, the first thing you may think of  are the data fields. These are the easiest to create – just call $random. The problem is that this  approach has a very low payback in terms of bugs found: you only find data-path bugs, perhaps  with bit-level mistakes. The test is still inherently directed. The challenging bugs are in the  control logic. As a result, you need to randomize all decision points in your DUT. Wherever  control paths diverge, randomization increases the probability that you’ll take a different path in  each test case."
"However, many directed tests, optimized for the fastest simulation, use the shortest latency,  except for that one test that only tries various delays. Your testbench should always use random,  legal delays during every test to try to find that (hopefully) one combination that exposes a  design bug. Below the cycle level, some designs are sensitive to clock jitter. By sliding the clock  edges back and forth by small amounts, you can make sure your design is not overly sensitive to  small changes in the clock cycle. The clock generator should be in a module outside the  testbench so that it creates events in the Active region along with other design events. However,  the generator should have parameters such as frequency and offset that can be set by the  testbench during the configuration phase. (Note that you are looking for functional errors, not  timing errors. Your testbench should not try to violate setup and hold requirements. These are  better validated using timing analysis tools.)  4.2 Randomization in SystemVerilog"
"This class has four random variables. The first three use the rand modifier, so that every  time you randomize the class, the variables are assigned a value. Think of rolling dice: each roll  could be a new value or repeat the current one. The kind variable is randc, which means random  cyclic, so that the random solver does not repeat a random value until every possible value has  been assigned. Think of dealing cards from a deck: you deal out every card in the deck in  random order, then shuffle the deck, and deal out the cards in a different order. Note that the  cyclic pattern is for a single variable."
"A randc array with eight elements has eight different patterns. A constraint is just a set of  relational expressions that must be true for the chosen value of the variables. In this example, the  src variable must be greater than 10 and less than 15. Note that the constraint expression is  grouped using curly braces: {}. This is because this code is declarative, not procedural, which  uses begin...end."
"The randomize() function returns 0 if a problem is found with the constraints. The  procedural assertion is used to check the result. This example uses a $fatal to stop simulation, but  the rest of the book leaves out this extra code. You need to find the tool-specific switches to  force the assertion to terminate simulation. This book uses assert to test the result from  randomize(), but you may want to test the result, call your special routine that prints any useful  information and then gracefully shut down the simulation.   You should not randomize an object in the class constructor. Your test may need to turn  constraints on or off, change weights, or even add new constraints before randomization. The  constructor is for initializing the object’s variables, and if you called randomize() at this early  stage, you might end up throwing away the results."
"Unless the variable happens to fall in the range of 13:19, randomize() fails. While you can use a  constraint to check that a nonrandom variable has a valid value, use an assert or if-statement  instead. It is much easier to debug your procedural checker code than read through an error  message from the random solver."
"The dist operator allows you to create weighted distributions so that some values are  chosen more often than others. The dist operator takes a list of values and weights, separated by  the := or the :/ operator. The values and weights can be constants or variables. The values can be  a single value or a range such as [lo:hi]. The weights are not percentages and do not have to add  up to 100. The := operator specifies that the weight is the same for every specified value in the  range, whereas the :/ operator specifies that the weight is to be equally divided between all the  values."
"Normally, all constraint expressions are active in a block. For example, a bus supports  byte, word, and longword reads, but only longword writes. SystemVerilog supports two  implication operators, -> and if-else. When you are choosing from a list of expressions, such as  an enumerated type, the implication operator, ->, lets you create a case-like block. The  parentheses around the expression are not required, but do make the code easier to read."
"A class can contain multiple constraint blocks. One might make sure you have a valid  transaction, but you might need to disable this when testing the DUT’s error handling. Or you  might want to have a separate constraint for each test. Perhaps one constraint would restrict the  data length to create small transactions (great for testing congestion), whereas another would  make long transactions. At run-time, you can use the built-in constraint_mode() routine to turn  constraints on and off. You can control a single constraint with  handle.constraint.constraint_mode(). To control all constraints in an object, use  handle.constraint_mode(), as shown in Sample.        4.5 Valid Constraints"
"As you write more tests, you can end up with many constraints. They can interact with  each other in unexpected ways, and the extra code to enable and disable them adds to the test  complexity. Additionally, constantly adding and editing constraints to a class could cause  problems in a team environment. Many tests only randomize objects at one place in the code."
"A common mistake is to surround your in-line constraints with parenthesis instead of  curly braces {}. Just remember that constraint blocks use curly braces, and so your in-line  constraint must use them too. Braces are for declarative code.  4.7 Randomizing Individual Variables   Suppose you want to randomize a few variables inside a class. You can call random ize()  with the subset of variables. Only those variables passed in the argument list will be randomized;  the rest will be treated as state variables and not randomized. All constraints remain in effect. In"
"This trick of only randomizing a subset of the variables is not commonly used in real  testbenches as you are restricting the randomness of your stimulus. You want your testbench to  explore the full range of legal values, not just a few corners.      4.8 Pseudorandom Number Generators   Verilog uses a simple PRNG that you could access with the $random function. The  generator has an internal state that you can set by providing a seed to $random. All IEEE-1364compliant Verilog simulators use the same algorithm to calculate values. Sample  shows a simple"
"As designs become more complex, the only effective way to verify them thoroughly is  with constrained-random testing (CRT). This approach elevates you above the tedium of writing  individual directed tests, one for each feature in the design. However, if your testbench is taking  a random walk through the space of all design states."
"Whether you are using random or directed stimulus, you can gauge progress using  coverage. Functional coverage is a measure of which design features have been exercised by the  tests. Start with the design specification and create a verification plan with a detailed list of what  to test and how. For example, if your design connects to a bus, your tests need to exercise all the  possible interactions between the design and bus, including relevant design states, delays, and  error modes."
"Implicit coverage is implied by a test – when the “register move” directed test passes, you  have hopefully covered all register transactions. With CRT, you are freed from hand crafting  every line of input stimulus, but now you need to write code that tracks the effectiveness of the  test with respect to the verification plan. You are still more productive, as you are working at a  higher level of abstraction. You have moved from tweaking individual bits to describing the  interesting design states. Reaching for 100% functional coverage forces you to think more about  what you want to observe and how you can direct the design into those states."
"Gathering Coverage Data : You can run the same random testbench over and over,  simply by changing the random seed, to generate new stimulus. Each individual simulation  generates a database of functional coverage information, the trail of footprints from the random  walk. You can then merge all this information together to measure your overall progress using  functional coverage as shown in Figure 5.2."
"You then analyze the coverage data to decide how to modify your tests. If the coverage  levels are steadily growing, you may just need to run existing tests with new random seeds, or  even just run longer tests. If the coverage growth has started to slow, you can add additional  constraints to generate more “interesting” stimuli. When you reach a plateau, some parts of the  design are not being exercised, and so you need to create more tests."
"Lastly, when your functional coverage values near 100%, check the bug rate. If bugs are  still being found, you may not be measuring true coverage for some areas of your design. Don’t  be in too big of a rush to reach 100% coverage, which just shows that you looked for bugs in all  the usual places. While you are trying to verify your design, take many random walks through  the stimulus space; this can create many unanticipated combinations."
"The easiest way to measure verification progress is with code coverage. Here you are  measuring how many lines of code have been executed (line coverage), which paths through the  code and expressions have been executed (path coverage), which singlebit variables have had the  values 0 or 1 (toggle coverage), and which states and transitions in a state machine have been  visited (FSM coverage). You don’t have to write any extra HDL code. The tool instruments your  design automatically by analyzing the source code and adding hidden code to gather statistics. You then run all your tests, and the code coverage tool creates a database. Many simulators  include a code coverage tool. A postprocessing tool converts the database into a readable form."
"The end result is a measure of how much your tests exercise the design code. Note that  you are primarily concerned with analyzing the design code, not the testbench. Untested design  code could conceal a hardware bug, or may be just redundant code. Code coverage measures  how thoroughly your tests exercised the “implementation” of the design specification, and not  the verification plan. Just because your tests have reached 100% code coverage, your job is not  done."
"The goal of verification is to ensure that a design behaves correctly in its real  environment, be that an MP3 player, network router, or cell phone. The design specification  details how the device should operate, whereas the verification plan lists how that functionality is  to be stimulated, verified, and measured. When you gather measurements on what functions were  covered, you are performing “design” coverage."
"You should keep track of how many bugs you found each week, over the life of a project. At the  start, you may find many bugs through inspection as you create the testbench. As you read the  design spec, you may find inconsistencies, which hopefully are fixed before the RTL is written."
"Once the testbench is up and running, a torrent of bugs is found as you check each module in the  system. The bug rate drops, hopefully to zero, as the design nears tape-out. However, you are not  yet done. Every time the rate sags, it is time to find different ways to create corner cases."
"If you need to check a more complex protocol, such as determining whether a packet  successfully went through a router, procedural code is often better suited for the job. There is a  large overlap between sequences that are coded procedurally or using SVA. The most familiar  assertions look for errors such as two signals that should be mutually exclusive or a request that  was never followed by a grant. These error checks should stop the simulation as soon as they  detect a problem. Assertions can also check arbitration algorithms, FIFOs, and other hardware."
"Some assertions might look for interesting signal values or design states, such as a  successful bus transaction. These are coded with the cover property statement. You can measure  how often these assertions are triggered during a test by using assertion coverage. A cover  property observes sequences of signals, whereas a cover group samples data values and  transactions during the simulation. These two constructs overlap in that a cover group can trigger  when a sequence completes. Additionally, a sequence can collect information that can be used by  a cover group.      5.3 Cover Group"
"A cover group is similar to a class – you define it once and then instantiate it one or more  times. It contains cover points, options, formal arguments, and an optional trigger. A cover group  encompasses one or more data points, all of which are sampled at the same time."
"A cover group can be defined in a class or at the program or module level. It can sample  any visible variable such as program/module variables, signals from an interface, or any signal in  the design (using a hierarchical reference). A cover group inside a class can sample variables in  that class, as well as data values from embedded classes."
"A cover group can be defined in a program, module, or class. In all cases, you must  explicitly instantiate it to start sampling. If the cover group is defined in a class, you do not make  a separate name when you instance it; you just use the original cover group name."
"Some sampled values not only should be ignored but also should cause an error if they  are seen. This is best done in the testbench’s monitor code, but can also be done by labeling a bin  with illegal_bins. Use illegal_bins to catch states that were missed by the test’s error checking."
"If your testbench instantiates a coverage group multiple times, by default SystemVerilog  groups together all the coverage data from all the instances. However, if you have several  generators, each creating very different streams of transactions, you will need to see separate  reports. For example, one generator may be creating long transactions while another makes short  ones. The cover group in example can be instantiated in each separate generator. It keeps track of  coverage for each instance, and has a unique comment string with the hierarchical path to the  cover group instance."
"You can add a comment into coverage reports to make them easier to analyze. A comment  could be as simple as the section number from the verification plan to tags used by a report  parser to automatically extract relevant information from the sea of data. If you have a cover  group that is only instantiated once, use the type option as shown in below example."
"You can query the level of functional coverage on the fly during simulation. This allows  you to check whether you have reached your coverage goals, and possibly to control a random  test. At the global level, you can get the total coverage of all cover groups with $get_coverage,  which returns a real number between 0 and 100. This system task looks across all cover groups."
"You can narrow down your measurements with the get_coverage() and get_inst_coverage()  methods. The first function works with both cover group names and instances to give coverage  across all instances of a cover group, for example, CoverGroup::get_coverage() or  cgInst.get_coverage(). The second function returns coverage for a specific cover group instance,  for example cgInst.get_inst_coverage()."
"Hopefully, another seed or test will increase the coverage. While it would be nice to have a test  that can perform some sophisticated actions based on functional coverage results, it is very hard  to write this sort of test. Each test + random seed pair may uncover new functionality, but it may  take many runs to reach a goal. If a test finds that it has not reached 100% coverage, what should  it do? Run for more cycles? How many more? Should it change the stimulus being generated?"
"Otherwise, how can you reproduce a design bug if the stimulus depends on multiple  random seeds? You can query the functional coverage statistics if you want to create your own  coverage database. Verification teams have built their own SQL databases that are fed functional  coverage data from simulation. This setup allows them greater control over the data, but requires  a lot of work outside of creating tests. Some formal verification tools can extract the state of a  design and then create input stimulus to reach all possible states."
"The Verilog hardware description language (HDL) provides the ability to describe digital and analog systems. This a bility spans the range from descriptions that express conceptual and arc hitectural design to detailed descriptions of implementations in gates and transistors. Verilog was developed originally at Gateway Design Automation Corporation during the mid-eighties. Tools to verify de signs expressed in Verilog were implemented at the same time and marketed. Now V erilog is an open standard of IEEE with the number 1364. Ve rilog HDL is now used universally for digital designs in ASIC, FPGA, microprocessor, DSP and many other kinds of design-centers and is supported by most of the EDA companies. The research and  education that is conducted in many universities is also using"
"Verilog HDL was originally developed and specified with the  intent of use with a simulator. Semantics of the language had not been fully d escribed until now. In this book, each feature of the language is d escribed using semantic introduction, syntax and examples. Chapter 4 leads to the full semantics of the language by providing definitions of terms, and  explaining data structures and a lgorithms."
"The book is written with th e approach that Verilog is not  only a simulation or synthesis  language, or a formal method of  describing design, but a complete language addressing all of these aspects. This book covers many aspects of Verilog HDL that are essential parts of any design process. It has the view of original development, and also encompasses changes and additions in subsequent revisions. The book starts with a tutorial introduction in chapter 1, then explains the data types of Verilog HDL in chapter 2. Today´s object-oriented world knows that the language-constructs and data-types are  equally important parts of a programming language."
"HDL, to those who want to learn additional facets, and  to those who would like a reference book during the development of a hardware design or software tool with Verilog HDL. I wish for you to design and implement some interesting designs of ASICs, FPGAs, microprocessors, caches, memories, boards, systems and/or tools like simulators, synthesizers, timing analyzers, formal verifiers with Verilog HDL, and to have a lot of fun doing so. -Vivek SagdeoACKNOWLEDGEMENTS"
"Corman provided the editorial review and my experience of working with him in the past on simulation and HDLs has been  valuable. Satish Soman provided feedback from the design perspective. UC Berkeley extension provided the teaching environment for me that has added the academic dimension to this book. Dr Richard  Tsina, Joan Siau and Roxanne Giovanetti from UCB deserve mention for their support. Students of the class “Digital Design of Verilog"
"The complexity of hardware design has grown exponentially in the last decade. The exponential growth is fueled by new advances in design technology as well as the advances in fabrication technology. The usage of hardware de scription language to model, simulate, synthesize, analyze, and test the design has been a cornerstone of this rapid development.  Verilog is the first hardware description language that was designed to be the language of choice in this domain. It is designed to  enable descriptions of complex and large designs in a precise and succinct manner. It can facilitate desc riptions of advances in  architectures of de sign such as pipelining, cache management, branch predictions. A smooth top-down design flow is possible with"
"The always block execute s as a loop with ‘@’ symbol indicating a wait on the event described in the expression that follows; in this case the ‘posedge clock’ or rising edge of clock. Another name used for such a loop is ‘process’. In a synchronous system, several  processes that execute based on clock-edges and resets can describe the synchronous behavior fully."
"In Example 1-8, the factorial module generates the factorial of  a number algorithmically. This design module instantiated in a test module and the two modules communicate via the ports n and fact. The module factorial contains an 'always' block that executes based on an event on n. The ‘for’ loop computes the value of the factorial using the loop variable i and the limiting value n. The test module contains an initial block that generates the stimulus for the factorial."
"Memory and Cache. The module System instantiates all three blocks and connects the signals to the modules, thereby creating the network. The data, add ress buses on the processor side are procData and procAddr and on the memory side are memData and memAddr. The cache block connects the two with its mapping  function for address and data on either side. This is modeled in the module cache upto one level of hierarchy. Full details of the subsequent levels are described in Example 11-5."
"In the Example 1-10, a cache system is modeled whereby the  state machine is mapped into a case statement inside an always block.  The IDLE state is when neither read nor write operation is in progress. READ, READ_MISS, and READ_CACHE complete the read operation for this cache. The states of WRITE, WRITE_MISS,"
This model begins with a set of “`de fine” statements that defines text-substitution macros for the  Verilog preprocessor. This helps in separating out constants in one place that can then be varied if desired. Notice that these are done outside the module and will be applicable throughout the file for all modules in it.  The module cache has a port-interface and certain reg and memory  declarations are done in the beginning.
"Verilog description  simulation (step 3) to verify that the implementation is correct. 5. The synthesis tools can be used at behavioral and at the RTL level. The RTL level is synthesized using techniques that are commonly known as logic synthesis. In this book, the major components of this flow will be discussed. The various representations in Verilog like behavioral, RTL and structural occur at different places in this design cycle and will be discussed fully. Simulation aspects will be  discussed for each of those and as a whole as well with the semantic model adding to the depth of this understanding. Synthesis with"
"In this exa mple, we define a non-terminal ‘comment’. The non-terminal name being defined is included  in the angle brackets. The definition begins with the nonterminal ‘c omment’ followed by ‘::=’ or the ‘is de fined as’ sy mbol. On the right hand side of the ‘::=’ symbol, two alternative definitions ‘short-comment and longcomment are stated. The  alternatives are separated by the ‘||=’ symbol. The short_comment is defined to begin with the characters ‘//’ followed by  comment_text and ends with the END_OF_LINE character. The long_comment consists of a comment_text enclosed within ‘/*’ and ‘*/’. The comment_text in turn is any sequence of ASCII characters. This is indicated by the repetition symbol ‘*’ preceded by the lexical token ASCII_CHARACTER. The lexical tokens typically consists of a single character, also known as literal, like ‘A’ or ‘0’ or special non-printable characters like the END_OF_LINE’ character. These are defined in the Appendix A along with the complete syntax definition of  entire Verilog HDL. In the following chapters, we define syntax using the notation defined here for each construct in the language, along with the semantics and usage with examples."
"Verilog supports only predefined data types. These include bits, bit-vectors, memories, integers, reals, events, and strength types. These define the domain of description in Verilog. Verilog deals mainly in the domain of bits and bytes while describing the circuits. The real type is useful for delays and time and is also useful in higher le vel modeling such as stochastic analysis and digital signal processing algorithms. The hardware  types in clude net and reg types. This, in general, can be seen as wires and registers. The nets are further declared to be of different types like tri-stated or non-tri-stated and whether the resolution of multiple connections results in anding, oring or uses prior value. The details of these can be seen in the following sections. 2.2 Value Systems"
"Different data types in Verilog are declared by data declaration statement. These statements occur in module definitions before usage and some of these can be declared within named sequential blocks. In addition to the value-types that may distinguish different types of data, the hardware characteristics of wires versus registers also are distinguished as net versus reg declarations in Verilog. The term driving is used in hardware descriptions to describe how a value is assigned to a date element. Nets and regs are  two main types of data elements in Verilog. Nets are continuously driven from continuous assignments or from structural elements such as module ports, gates, transistors or user defined primitives. Regs are driven strictly from behavioral blocks. Nets are typically implemented as wires in hardware and regs may either be wires, or temporaries or  flip-flops (registers)."
"The net is a set of data types in a Verilog description that represents the physical wires in a circuit. A net connects gate-level instantiations, module instantiations and continuous assignments. The Verilog language allows you to read a value from a net from within behavioral descriptions, but you cannot assign a value to a net within the behavioral descriptions. (An always block is a specific type of begin...end block). A net does not store its value. It must be driven in one of two ways:"
"The tri (three-state) data type is a specific type of wire where the resolution of multiple drivers is done using the rules of tri-state bus. All variables that drive the  tri must have a value of Z (high-impedance), excep t one. This single variable determines the value of the tri."
"You must explicitly declare the direction (whether input, output, or bidirectional) of each port that appears in the port list of a port definition. Three kinds of ports are defined in Verilog—input, output, inout. The ports must be either nets or regs. The only place where a reg can occur is output port. Constants and expressions are allowed in port declarations. input"
"All input ports of a module are decl ared with an input statement. An input is a type of wire and is governed by the syntax of wire. You can use a range spec ification to declare an input that is a vector of signals, as for input b in the following example."
"All output ports of a module are decl ared with an output statement. Unless otherwise defined by a reg, wand, wor, or tri declaration, an output is a type of wire and is governed by the syntax of wire. An output statement can appear in any order in the description, but you must declare it before you use it. You can use a range specification to declare an output that is a vector of signals. If you use a regDATA TYPES IN VERILOG 29declaration for an output, the reg must have the same range as the vector of signals."
Only 1and 2-dimensional arrays are supported in Verilog. One-dimensional arrays are called bit-vectors and may be nets or regs. The 2-dimensional aggregates are called memories and are reg kind. You can define an optional range for all the data types presented in this chapter. The range provides a means for creating a bit-vector.
"Registers are aggregates of data. Data transfer between registers is known as RTL transfer and the event-driven model as basis for these transfers. The  event-driven model here is crucial to these descriptions. In Verilog, the mechanism to model these is called continuous assignments. The LHS gets a new value when anything on RHS changes. This will be the main driver in  (logic) synthesis, especially for d atapath. (Control Logic comes from FSM descriptions that will be discussed later.)"
"However, due to the event driven nature of these and the fact that these are interdependent, will create an order like in the hardware that is being modeled. As the RTL descriptions are in between stru ctural and behavioral, these work in between the other two. In these, we drive the left-hand side just like in ports that are input ports, the rules for ports that can be driven apply here. Thus, we will only use types that are physically realizable or can physically be driven on a c ontinuous basis."
"In Verilog, one is  allowed to use concatenations of nets as a vector net with no name (like in a synthesizer with property on the net, to keep it post-synthesis). This is useful at times, but it is better to create another net and assign the concatenations all other nets to this net. This helps in debugging and better readability of the code."
"In RTL descriptions, power of expressions is available to you in place of a network of several gates, which are hard to program  with for achieving actualization of an algorithm or a machine in hardware. Boolean Algebra is  also now applicable for optimizations and reorganizations. The additional modeling capabilities here include: delay specifications and strength specifications. See the examples below and syntax as well for details."
"Operators identify the op eration to be performed on their operands to produce a new value. Most operators are either unary operators that apply to only one operand, or44 Chapter 3 binary operators that apply to two  operands. Two exceptions are conditional operators, which take three operands, and concatenation operators, which take any number of operands. Verilog provides a rich set of operators as described in the next few pages."
Operator Description { } concatenation + add subtract * multiply / divide % modulus > greater than >= greater than or equal to < less than <= less than or equal to = equal to != not equal to ! logical NOT && logical AND |  |   logical OR == logical equality != logical inequality bit-wise NOT & bit-wise AND |        bit-wise OR ^        bit-wise XOR ^~   ~ ^    b it-wise XNOR & reduction AND~ABSTRACTION LEVELS  IN VERILOG 45 | reduction OR ~&              reduction NAND ~| reduction NOR ^       reduction XOR ~^      reduction XNOR « left shift »                   right shift ? :            conditional or if operator
"If or Conditional operators (? :) evaluate an expression and return a value that is based on the truth of the expression. Example 3-14 shows how to use conditional operators. If the expression (op == ADD) evaluates to true, the value a+b is assigned to result; otherwise, the value a-b is assigned to re sult."
"Variables that represent both wires and registers are allowed in an expression. If the variable is a multi-bit vector and you use only the name of the variable, the entire vector is used in the expression. Bit-selects and part-selects allow you to select single or multiple bits, respectively, from a vector. These are described in the next two sections."
Verilog allows you to call one function from inside an expression and use the return value from the called function as an operand. Functions in Verilog return a value consisting of one or more bits. The syntax of a function call is the function name followed by a comma-separated list of function inputs enclosed in  parentheses.
"A constant-valued exp ression is an expression  whose operands are either constants or parameters. The e xpression (op == ADD) ? a+b : a-b is not a constant-valued expression, since the value depends on the variable op. If the  value of op is 1, b is added to a; oth erwise, b is subtracted from a. // all expressions are constant-valued, // except in the assign statement."
"A body of a module has everything else in  the language, i.e., all other constructs in Verilog discussed throughout this book. A module has data declaration of type parameters. Parameters are a way of defining generic units that can be configured in some dimensions at instance time or at redefinition. Verilog parameters allow you to customize each instantiation of a module. By  setting different values for the parameter when you instantiate the module, you can cause different logic to be constructed. Back-annotating delays is the most common application of  parameters."
"However, the semantics  definition of  a language does not have a formal notation developed and usable in the realm of computer science. Thus, to  help understand the commonly understood semantics of a program in a language, some abstract models are used. For Verilog HDL, thi s model for simulation has been defined to som e extent in the original definition and then by IEEE 1364. Here a model is provided based on the original ideas that we had while  designing and implementing the language."
"First, let us run this by single ste pping through our simulator. We will also set $monitor on all signals in the circuit. In some ways, the single stepping is stepping through the sequence of evaluations. $monitor enables us  to capture  all value changes. Thus, with these two traces, we can see some series of evaluations and value-changes that makes the simulation  run for a given  Verilog model. Capturing this in a log file and visiting this later also gives us the insight into what is happening in the simulation  cycles that lead to the  whole simulation. Here we list an ideal log file w hile running on  your favorite simulator will typically produce a subset of this information. The log file on a sample simulator is also shown for comparison. 4.4 Log of a Typical Simulator"
"Evaluate, Schedule, and U pdate Activities. Simulation starts at time 0 when, the model performs evaluations of all initial and always blocks. The evaluation of a block continues this until it suspends (or schedules itself) for a later time. During the course of this evaluations, value changes on reg variables are effected and their fanouts are evaluated or are  scheduled for evaluations. For example, change in i1 in the beh_block due to assignment statement evaluation results in valuation of a gate a1. This may or may not result in f urther value changes to be scheduled. 4.7Internal Data Structure Representation"
"Internally, during simulation, a Verilog HDL model is represented by a set of signals, a set of ev aluation blocks and their inter-connections. This can be called the network data structure. In the above diagram, the rectangles represent the evaluation blocks and the ellipses represent the signals. The names of these  are given inside and these co rrespond to the names in the design. Coupled with this is the event queue data structure that now enables us to see throughout this event driven simulation cycle in Verilog HDL. 4.8Update and Evaluate Events"
"Update Values. This is reflected in two types of events in the event queue (also known as scheduler)—Update Event and Evaluate Events. In a model known as 2 pass model, the types of events are held in separate lists and are processed in two passes—the first pass for update and second for evaluate.SEMANTIC MODEL FOR VERILOG HDL 91"
Create a network representation of Verilog description. Set current time to 0. Schedule evaluation events on all behavioral blocks for current time and update events for all UDP outputs with initial state. } while ((events in schedule( and (no $finish)) { if (no events in  schedule at  current time) advance time to next event time in the schedule while (events at current time) { fetch next event in the schedule process event (either evaluation or update) remove this event from schedule } }
"If an event already  exists on this signal then if the value on the existing event same as new event, if yes, check the time on the existing event. if earlier than new event then done; else reschedule for the new time, then done else deschedule the existing event and  insert the new event else insert event at the appropriate time in the schedule. } else if (evaluate block is of type monitor) { insert event at the end  of the current simulation time. } }"
"Hardware consists of different design units that always run concurrently. For example, in a computer, CPU, memory,  peripheral boards like the IO controllers (floppy disk controller), hard disk controller are  always running in parallel. The states of some units may imply waits but they will be providing certain outputs as a function of inputs and current state,  independent of  other units. A hardware description language must model this behavior correctly. In the above algorithm, we can clearly see that all the always blocks and the initial blocks in the behavioral description of the Verilog model are executed concurrently. Similarly, the gates, module instances, UDPs and the RTL assignments are continuously providing the outputs as a function of inp uts. In an event-driven model, this translates into creating an evaluation event on the evaluation blocks whenever one of  the inputs changes."
"This is the next level of abstraction after RTL. This allows modeling algorithmic style descriptions. Naturally, we need the ability to capture the algorithms like in a programming language. This is provided with ""C""-like statements—assignments, ifelse, case, for (loop), begin-end blocks, functions and procedures (tasks). In an HDL, as seen in the structural and RTL descriptions, the flow of  control is multiple."
"Verilog is essentially a Concurrent Programming Language. This implies that we need a mechanism to synchronize the algorithmic descriptions together with the structural and RTL descriptions. This is provided by 'initial' and 'always' blocks that enclose all a lgorithmic descriptions. W ithin each of these blocks, timing controls or synchronization primitives are  provided in terms of delays, event controls, fork-join statements, and wait statements."
"These allow transfer of values from an expression into a non-net 1value. All algorithmic descriptions can be thought of as temporary computations whose results can then be put onto physical entities like nets via RTL or gate descriptions that are closer to physical reality. Thus, the original intent of behavioral level HDL is to allow expressing your ideas into a precise form whose results can be easily transferred to the RTL and structural level for ease of development. This will allow stepwise refinement of your model from a higher level description into gates. All non-net c onstructs (reg, integers, reals, time and any aggregate of these ) are abstract and there are different ways to actualize these into hardware. Synthesis has some role to play here, but in  reality, a very small subset of the behavioral level is synthesized by logic synthesis and some larger subset by behavioral synthesis."
"Thus, use blocking assignments fo r temporary computations within a delta cycle forSyntax103 BEHAVIORAL MODELING those regs that are not d irectly transformed to hardware registers. This (nonblocking) type of assignment is a better model for most real registers when modeling synchronous systems. However, by following certain consistent conventions throughout Verilog model, one can use the blocking assignments which are more efficient for simulation and which are easier to understand."
"These are useful for modeling instructions in a microprocessor wh ereby parallelism or pipelines begin after some sequential operations. For example, fetching of operands from memory is  typically serial, but processing may be done in a parallel fashion. Resets and interrupts are also handled in p arallel to the instruction execution. // All variables her e are globally decl ared task add4; begin @posedge(clk) fetch(op1); @posedge(clk) fetch(op2); @posedge(clk) fetch(op3); @posedge(clk) fetch(op4); fork @posedge(clk) sum1  = op1 +  op2; @posedge(clk) sum2 = op3 + op4; join @posedge(clk) sum = sum1 + sum2; end"
"User-Defined Primitives are commonly known as UDPs. In a udp, spaces and cases do not matter. In general,  conflicting entries, where two different descriptons of the same input set has different outputs, will be detected and reported. Exception to this is the mixed descriptions of edge-sensitive and level-sensitive sequential nature."
"One of the sources of power of exp ressing design in Verilog comes from the ability to mix the three  design styles freely in a module and across modules. This is useful for flexible design methodology, and also  for system level modeling. This is also good for performing the following functions all within the realm of Verilog."
"In the following system, we are using as asic which was deve loped previously using structural level design method. We also have a microprocessor developed at behavioral level that can handle the instruction set. The memory read and write cycles are RTL level models. A parity generator at switch level is used."
"In the following  example, we  have a gate-level model of adder mixed wit h a small behavioral section to generate a special output that tells us whether the adder resulted in zero as sum. Thus, a special adder is created effortlessly. This part  of the design can be implemented in terms of gates at a later stage."
"In the example of flip-flop in Chapter 1, the reset was modeled behaviorally while the rest of the flip-flop was made of gates. This is an example of a design that is a special design with the reset being connected to the system reset for all such flipflops and not available fo r connections within the design. Thus, mixing of this behavioral abstraction allows us to make special situations available locally and the get the design going qui ckly."
The following table shows the format specifiers. %h hexadecimal %b binary %o octal %d decimal %c ascii character %v net strength %m module name (full hierarchical) %s string %t current time format %e real number in exponent form %d real number in decimal form %g display real in the 2 formats but shortest width
Verilog provides a set of tasks to save the value-changes in a file that are accessed by a waveform viewer to display the results in the form of a waveform display. These files are called value change  dump files (VCD). The tasks that relate to these are $dumpfile and  $dumpvars. These files are ASCII files and can be used by other postprocessing tools such as tester interface tools as well.
The key compiler directives are: ` include   --- include another file here `define    --- define a macro[symbol] `undef  --- undefine a symbol `ifdef --- These three are  conditional compilation `else directives `endif `default_nettype --- defin e a default net type for the entire design `timescale --- Define the timescale to be used for the subsequent part of design `resetall --- reset al l directives back to original default values168 Chapter 9 `celldefine --These d efine a cell name used by `endcelldefine certain PLI routines
"Some of these covered in Cha pter 9 deal with tasks to perform: display to the output ($display) monitor the value-changes as textual  output($monitor) send the display and monitor results to files ($fdisplay, $fmonitor etc.) stop or end the simulation in interactive mode $stop or $finish generate data for waveform display $dumpvars"
"Most simulators will provide a browser that allows traversal of a design from top to bottom, and then in each part of the design get a list of signals  defined there. These signals can then be selected for displaying values at command line or in the waveform window or for use with other tool within the tool-set. 10.5 Code Coverage"
"The i8085a module describes the instruction cycles for various instructions. Thus, any program in the assembly language (converted to hex or binary) can be run on this model, and various registers and nets can be observed with this. The ram loads these programs an d connects with CPU to make this happen. A monitor and keyboard are connected via the serial interface providin g additional input-output into the system."
"Synthesis converts Verilog HDL models of hardware down to gate-level implementations automatically and maps these into target technology. Synthesis also optimizes the design for a given set of constraints related to area and speed. The synthesis techniques and tools are c ommonly classified int o logic and behavioral synthesis. These techniques apply to HDL descriptions at the logic level and at the behavioral level, respectively. Synthesis allows ma pping of same HDL description into multiple target technologies without any change in the design. 12.2 Design Flow with Synthesis"
"The synthesis tools can be used at behavioral and at the RTL level. The RTL level is  synthesized using techniques that are commonly known as logic synthesis. In thisbook, the major components of thisflow will be  discussed. The various representations in Verilog like behavioral, RTL and structural occur at different places in this design cycle and will be discussed fully. Simulation aspects will be discussed for each of those and as a whole as well with the semantic model adding to the depth of this understanding. Synthesis with"
"Structurally, one can directly instantiate registers into a Verilo g description, selecting from any element in an ASIC library. Clocking schemes can be arbitrarily complex. You can c hoose between a flip-flop and a latch-based architecture. This forms the structural style of describing states. In  this method, the Verilog description is specific to  a given technology because you choose structural elements from that technology library. However, you can isolate the portion of your design with directly instantiated registers as a separate component (module), then c onnect it to the rest of the design. The description is more difficult to write."
"The preceding paragraph’s description of combinational and sequential logic descriptions leads to a set of constructs in Verilog that can be synthesized or a logic synthesis subset. This is de scribed in the remaining sec tions of this chapter and in the next chapter which focuses on special elements like registers, latches, 3-states and multiplexor descriptions."
"Such constructs do not describe the core functionality of the de sign. On the other hand, there are constructs that describe functionality. An example of this will be using arbitrary events based model like that of a microprocessor when instructions are modeled. Such constructs are flagged  as errors during analysis for synthesis. A complete formal description of this classification is provided in Appendix B. 13.2 Structural Descriptions – Modules"
"The macromodule construct makes simulation more efficient by merging the macromodule definition with the definition of the calling (parent) module. However, the synthesizer treats the macromodule construct as a module construct. Whether you use module or mac romodule, the synthesis pro cess, the hierarchy it creates, and its end result are the same. Example 3-2 shows how to use  the macromodule construct."
"Verilog allows you to assign drive strength for each continuous assignment statement. Synthesizer accepts drive strength, but it does not affect the  synthesis of the circuit. Thus, when using drive strength in your Verilog source, this can be a factor. Assignments ar e done bit-wise, with the low bit on the right side assigned to the low bit on the left side. If the number of bits on the right side is greater than the number on the left side, the high-order bits on the right side are discarded. If the number of bits on the left side is greater than the number on the right side, operands on the right side are zero-extended"
"Connection lists for instantiations of a gate-level model use positional notation. In the connection lists for and, nand, or, nor, xor, and xnor gates, the first terminal connects to the output of the gate, and the remaining terminals c onnect to the inputs of the gate. You can build arbitrarily wide logic gates with as many inputs as you want."
"These are optimized during synthesis and their values are computed at compile-time and no corresponding hardware is generated for these. Thus, it is beneficial to add as many constant  valued expressions as possible. Usage of parameters and constants rather than reg types will help in such situations. Constants are also propagated to see if the next level of expressions also is a constant valued expressions indirectly specified as such."
"This may cause simulation to disagree with synthesis. For an alternate method of handling comparisons to X or Z, one can direct the synthesizer to not synthesize this but translate this by hand. Directives like the // synthesis  translate_off directive // synthesis translate_on directives exist for this operation. Inserting these directives might cause simulation to disagree with synthesis. 13.10 Behavioral Modeling for Synthesis"
"To describe combinational logic, you write a sequence of statements an d operators to generate the outputs you want. For example, suppose the + operator is not supported, and you want to create a combinational adder where the bit-by-bit structure is determined by the functional description.. The easiest way to describe this circuit is as a cascade of full adders, as in Example below. The exa mple has four full adders, with each adder following the one before. From this d escription,"
"The synthesizable Verilog language allows you to assign a value to a reg variable only within a function or an always block. In the Verilog  simulator, reg  variables can hold state information. A reg can hold its value across separate calls to a function. In some cases, Synthesizer emulates this behavior by inserting flow-through latches. In other cases, this behavior is emulated w ithout a latch."
"Synthesizer automatically determines whether a case st atement is full or parallel. A case statement is called full case if all possible branches are specified. If you do not specify all  possible branches, but you know that one or more branches can never occur, you can use a directive // Synthesis_full_case. To avoid creating latches, assign a value to all variables or use the  “default” statement that automatically assigns the value specified in that statement to all unstated cases."
"Synthesizer cannot statically determine that branches are  parallel, it synthesizes hardware that includes a priority enc oder. Thus, it is a good idea to specify the case options as constant expressions that are mutually exclusive. If Synthesizer can determine that no cases overlap (parallel case), a multiplexor is synthesized, since a priority encoder is not necessary. You can also declare a case statement as parallel case with the //synthesis_parallel_case directive (see appendix C)."
"The for loop repeatedly executes a single statement or block of statements. The repetitions are performed over a range dete rmined by the range expressions assigned to an index. Two range expressions are used in each for loop: low_range and high_range. Note that in the syntax lines that follow, high_range is greater than or equal to low_range.  Synthesizer recognizes both incrementing and decrementing loops. The statement to be duplicated is surrounded by begin and end statements."
"Synthesizer supports while loops, if you insert an @ (posedge clock) or @ (negedge clock) expression in every path through the loop. Example below shows an unsupported while loop that has no event-expression. This follows with the policy of feedback going via states, that is the only storage must be into states. always while (in1 < in2) out = in1 +  in3;"
"An always block can imply latches or flip-flops, or it can specify purely combinational logic. An always block can  contain logic triggered in response to a change in a level or the rising or falling edge of a signal. The syntax of an always block is: always @ ( event-expression [or event-expression*]) begin ... statements ... end"
"The event-expression declares the triggers, or timing controls. The word or groups several triggers. The Verilog language specifies that if triggers in the eventexpression occur, the block is  executed. Only one trigger in a group of triggers needs to occur for the block  to be executed. However, synthesizer ignores the eventexpression unless it is a synchronous trigger that infers a register. In the next chapter, we discuss the details of this issue. A simple example of an always block with triggers is: always @ (in1 or in2 or in3 or in4) begin out = in1 & in2 | ~in3 ^ in4 end"
"For a synchronous  always block, Synthesizer does not require all variables to be listed. An always  block is  triggered by  any of the following types of eventexpressions: 1. Event expression entailing change in the value of a reg or a net: always @ ( identifier ) begin ... statements ... end"
"An always block can be misinterpreted if you do not list all signals entering an always block in the event specification prior to  the evaluation. As expected, synthesizer builds a 4-input gate-logic for th e description in the example below. always @ (in1 or in2 or in3) begin out = in1 & in2 | ~in3 ^ in4 end"
"Because variables can hold state over time in simulation, synthesizer needs to duplicate this condition in hardware. It does this by inserting a D-type flow-through latch. The latch allows a variable to hold its value (state) until that value is280 Chapter 14 reassigned. A variable must hold its state when  its previous value may change, because of a condition in an  if statement. When the condition is true, the value is reassigned. Since the condition might be false, the variable must be able to hold its state. Therefore, a latch is created to hold th e previous value of the variable. For example:"
"To avoid cre ating latches in combinational logic, the unintended feedback created by “no change” in value during recomputation in a case of if-then-else statement should be avoided. Assign a value to all options in a case or use the “default” statement that automatically assigns value to all unstated cases. The code in"
"Variables declared within a function do not hold their values over time because every time a function is called, its varia bles are  reinitialized. Therefore, synthesizers do not infer latches for these variables. In  Example 14-3, no latches are inferred. This is another reason to use functions for combinational logic function my_func; input data, gate; reg state; begin if (gate) begin state = data; end my_func = state; end endfunction"
"A variable that is assigned a value in this always block is s ynthesized as a D-type edge-triggered flip-flop. The flip-flop is clocked on the rising (or falling) edge of the signal (clock) following the posedge (or nege dge) keyword. Wit h simple flip-flops (with no asynchronous set or reset), the block's event-expression may contain only one posedge (or negedge) statement, as shown  in Example 14-4. always @ (posedge clock) begin out = data; end"
These conditions also require corresponding posedge and negedge entries in the event-expression at the beginning of the always block. The last else clause has no condition to test. The clocked event is assumed. The flip-flop is clocked on the rising (falling) edge of  the signal following the posedge (negedge) keyword in the eventexpression at the  beginning of the always block.
"During synthesis of sequential devices, a particular design will follow a set of rules for the registers used in that design. Synthesizers can assist the designer in  checking the design rules governing  these devices. Several of these rules apply to the set-reset signals and their relationship to each other and other signals. Typically while specifying the conditions under which a register is set or reset, synchronous and asynchronous behavior of these is maintained throughout a design or portion of the design. This can be checked by the synthesizer by the following ways."
"Another aid provided in synthesizing registers consists of se tting the  precedence of set and reset signals. Normally, designers know that these two signals have the same priority. However, in a Verilog HDL model of th ese, a priority encoder can be easily generated since one has to specify one of these  signals before the other."
"Not using these may cause priority-encoded implementations to occur because the if...else construct in the HDL  description specifies  prioritization. The one_hot andSPECIAL CONSIDERATIONS IN SYNTHESIZING VERILOG 285 one_cold directives tell Synthesizer that only one of the objects in the list  is active at one time. To define active high signals, use one_hot. To define active low, use one_cold. Each directive has two objects specified."
"The one_hot dindicator takes one argument of a double-quoted list of objects separated by  commas. This directive indicates that the group  of signals (set and reset) are one_hot, i.e., no more than one signal is active high (has a Logic 1 value) at any one time. Users  are responsible to make sure that the group of signals is really one_hot. Synthesizer does not produce any logic to check this assertion. The syntax of one_hot is: // Synthesis one_hot ""object_name,..."""
"Resource sharing is a common term for synthesis techniques that applies to the assignment of same operation (for example, +) from different statements to a common library cell. Library cells are the resources—they are equivalent to built hardware units. Resource sharing or sharing of  these units of hardware amongst different operations or statements in Verilog is an excellent optimization method."
"Without resource sharing, each Verilog operation is built with separate circuitry. For example, every + with  non-computable operands  causes a new adder to be built. This repetition of hardware increases the area of  a design. In contrast, with  resource sharing, several Verilog + operations can be implemented with a single adder, which reduces the amount  of hardware needed. Also, different operations such as + and can be assigned to a single adder/subtracter to further reduce area or number of gates in an implementation of a Verilog model."
"Operations can be shared only if they lie in the same always block. When units are in different blocks, their control is independent and thus, all the environment (or peripheral circuits) is not reproducible and thus is not a sharable resource. Shared resources must be exact matches in terms of  not only their functionality but all their connections."
Example 14-18 shows several possible sharings. always @(xl or yl or zl or w1 or c onditiona) begin case(conditiona) ‘b0:al=xl+yl; ‘ b l : al =zl+wl; end always @(x2 or y2 or z2 or w2 or c onditionb) begin case (conditionb) ‘b0 : z2 = a2 + b2; ‘bl :z2 =  c2 + d2; end
"When the a+b addition is shared with  the temp_2+f addition on an adder called rl, and the d+e addition is shared with the temp_l+c addition on an adder called r2, a feedback loop results. The variable temp_l connects the output of rl to the input of r2. the variable temp_2 connects the output of r2 to the input of rl, and a feedback loop is created."
"Resource sharing reduces the number of resources in your design, which reduces resource area. The area of a shared resource is a function of the types of operations that are shared on the  resource, and their bit-widths. The shared resource is made large enough to ha ndle the largest of the bit-widths and powerful enough to perform all the operations. Resource sharing usually adds multiplexers to a design to channel values from different sources into a common resource input. In some cases, resource sharing reduces the number of multiplexers in a design."
"Verilog allows double specification of del ays in a module. This can occur if the specify blocks and the functional blocks both contain delay specifications for the same paths. In other words, both path delays as well as distributed delays can be present on the same part of the design at the same time. In such case, distributed delays take effect as the events on the nets or regs take place -and the path de lays are induced into the design when the output end of the path changes. When mixed, slower values take precedence -that means path delays will be effective if those values are larger than the delays inside the module. 15.8 Multi-Driver Nets"
"This ability to extend the la nguage by way of adding keywords is achieved through user-defined tasks and functions. For example, one can take his or her favorite waveform-processing package, and link it in place of $gr_waves. This can then be named $gr_waves_new() and invoked either in interactive debugging session or in simulation at a certain point in test-bench part of the Verilog system being built."
"You may be currently using a system that displays output in  certain format and you are switching to Verilog. Then, a C task that imitates current output will enable smooth tra nsition. Whenever a value changes, this will print out the VERILOG values in a format similar to existing format. This way all diagnostics that happens post-simulation can be preserved mostly as is."
"Verilog simulator to facilitate the development of system t asks and functions which are part of the Verilog HDL. This was a good software practice to develop different parts of the simulator itself. For  example, the tasks of $display, $monitor, or $gr_waves are written and linked to the Verilog Simulation Engine using the same"
"PLI allows one to define $xxx t asks and $yyy functions that associate with ""C"" functions written by you. These tasks can then be invoked from Verilog model just like system tasks and functions. In fact, most system functions and tasks in Verilog are written in ""C"" using the conventions of programming language interface."
This is the lowest level of modeling provided in Verilog. It also allows the greatest levels of details in terms of the circuit-implementation at the digital level. There are three main methods or levels in Verilog that describe transistors: 1. The first level includes unidirectional transistor models. At this level Verilog
"HDL provide nmos, pmos and cmos primitives. These have the switching behavior of the transistors including z values. The tables for these primitives have been discussed in Chapter 6. 2. At the next level,  bidirectional transistors represent the transistors in real life as these do not have directionality. The primitives provided in this class of transistors includes: tran, tranif0, tranif1 rtran, rtranif0, rtranif1."
"Standard Delay Format (SDF) is a file spec ification that assures consistent, accurate, and up-to-date data for timing. The EDA tools can use data created by other tools as input to their own processes via SDF. Sharing data in this way, layout tools can use design constraints identified during timing analysis, and  simulation tools can use the post-layout delay data. The EDA  tools create, read (to update their design),  and write to SDF  files."
"SDF contains constructs for the description of computed timing data for backannotation and th e specification of timing constraints for forward annotation. There is no restriction on using both sets of constructs in the same file, although these are typically different functions and are present in different files as such. Indeed, some design synthesis tools (such as floorplanning) may need access to computed timing data as well as the timing constraints they are intended to meet. In Figure 1-3, the step in which gate-level netlist with back annotated de lays is generated after layout."
"A delay calculator tool is responsible for generating the delays in the SDF file. It will examine the specific design for which it has been instructed to  calculate timing data. The delay calculator must locate, within the design, each region for which a timing model exists and calculate values for the parameters of that timing model."
The SDF file is brought into the analysis tool through SDF annotator. The annotator matches data in the SDF file with the design description and the timing models. Each module in the design identified in the SDF file must be located and its timing model found. Data in the SDF file for thismodule must be applied to the appropriate parameters of  the timing model.
"An annotator may be a part of the tool whereby using access routines or VPI routines it will  traverse the compiled Verilog design and match the SDF representation with the design and then generate delays and timing checks as a part of last phase of design compilation. Alternatively, the annotator may operate independently of the analysis tool and convert the data in the SDF file into a format suitable for the tool to read directly. The naming of design objects must be identical in the SDF file and design description. During annotation, inconsistencies between the SDF file and the design description are  considered errors."
"In addition to the back-annotation of timing data for analysis, SDF supports the forward-annotation of  timing constraints and timing checks to design synthesis tools. (Here, we use the term ""synthesis"" in its broad sense of construction, thus including not only logic synthesis, but floorplanning,  layout and routing.) Timing constraints are ""requirements"" for the design's overall timing properties, often modified and broken down by previous steps in the design process."
"For example, the initial requirement might be  that the primary clock should run at 50MHz. A static timing analysis of the design might identify the critical paths and the available ""slack"" time on these paths and pas s constraints for these paths to the floorplanning, layout and routing (physical synthesis) tools so that the final design is not degraded beyond the requirement. Alternatively, if after layout and routing, the requirement cannot be met, constraints for the problem paths might be constructed and passed back to a logic synthesis tool so that it can ""try again"" and leave more slack for physical synthesis."
"Constraints may also be originated by an analysis tool alone. Consider a synchronous system in which the clock distribution system is to be synthesized. ASTANDARD DELAY FORMAT 323 static timing analysis may be able to determine the maximum permissible skew over the distribution network  and provide this as a constraint to clock synthesis. In turn, this tool may break down the skew constraint into individual path constraints and forward this to  physical synthesis."
"Note: The term ""timing constraint"" is also in use to describe what in SDF are called timing checks. When viewed as statements of the form ""this condition must be met or the circuit won't work"", they are indeed the same. Perhaps the only distinction is that timing checks are applied to an analysis tool, which is only in a position to check to see if they are met and indicate a violation if they are not,  whereas constraints are applied to a synthesis tool, which may adapt its operation to  ensure that the specified condition is met."
"ASIC library has its timing properties described at its boundary, i.e. with direct reference only to the ports of the cell. The timing model is frequently distinct from the functional part of the model and has the appearance of a ""shell"", intercepting transitions entering and leaving the  functional model and applying appropriate delays to output transitions. The SDF IOPATH construct is intended to apply delay data to input-to output path delays across cells described in this way. The COND construct allows any path delay to be made conditional, that is, its value applies only when the specified condition is true. This allows for state-dependency of path delays where the path appears more than once in the timing model with conditions to identify the circuit state when it applies."
"The primitives provided by analysis tools such as simulators an d timing analyzers usually have simple timing capabilities built into them, such as the ability to delay an output signal tra nsition. The delay properties of the cell are constructed by the careful arrangement of modeling primitives and their delays. The SDF DEVICE construct is intended to apply delay data to modeling  primitives in distributed delay models."
"SDF supports the specification of how  short pulses  propagate to the output of a cell described using a pin-to-pin delay model. A limit can be established for the shortest pulse that will  affect the output and a larger limit can be esta blished for the shortest pulse that will appear with its true logical value, rather than appearing as a ""glitch"" to the unknown state. The SDF PATHPULSE construct allows these limits to be specified as time values. The SDF PATHPULSEPERCENT construct allows these limits to be specified as percentages of the path delay."
"SDF supports setup, hold, recovery, removal, maximum skew, minimum pulse width, minimum period and  no-change timing checks. Library models can specify timing324 Chapter 18 checks with respect to both external ports and internal  signals. Negative values are permitted on timing checks where this is meaningful, although analysis tools that cannot use negative values may  substitute a value of zero. The SDF COND construct allows conditional timing checks to be specified."
"The SDF PORT construct allows interconnect delays to be specified as equivalent delays occurring at cell input ports. This results in no loss of generality for wires/nets that have only one driver. However, for  nets with more than one driver, it will not be possible to represent the exact delay over each driving-output-to-driven-input path using this c onstruct. Note that for timing checks to operate correctly when interconnect is modeled in this way, the timing models must be constructed to  apply the delay to the signal at input ports before they arrive at the timing checks."
"The header section of an SDF file contains  information that relates to the file as a whole. Except for the SDF version, entries are optional, so that, in fact, it is possible to omit most of the header section. The syntax defines a strict order for header entries and those that are present must follow this order."
"A cell entry identifies a particular ""region"" or ""scope"" within a design and contains timing data to be applied there. For example, a cell entry might identify an unique occurrence of an ASIC physical primitive, such as a 2input NAND gate, in the design and provide values for its timing properties, such as the input-to-output path delays. As well as identifying such design-specific regions, cell entries can identify( TEMPERATURE RNUMBER)STANDARD DELAY FORMAT 329 all occurrences of a particular ASIC library physical primitive, such as a certain type of gate or flip-flop. Data is applied to all such library-specific regions in the design."
"This identifies the region or scope of the design for which the cell entry contains timing data. The name by which this region is known in the design must be consistent with the CELLTYPE entry for the  cell. If the annotator locates the region330 Chapter 18 and finds that its name does not match the CELLTYPE entry, it  should indicate an error."
"The first form of the cell instance entry identifies an unique occurrence in the design of the region named in the cell type entry. If, for example, the cell is a physical primitive from an ASIC library, then a single occurrence of that cell on the chip will be identified. To do this, the cell instance entry Cell Entry provides a complete path through the design hierarchy to the cell or region of interest."
"The timing data in the timing specifications of this cell entry apply only to the identified region of the design. If you do not specify PATH, i.e. you leave it blank, the default is the region (hierarchical level) in the design at which the annotator is instructed to apply the SDF file (see ""The Annotator"" page 3 in chapter  2). This can be useful for gathering all interconnect information into a top-level cell entry."
"Any number of deltype entries may appear in a del_spec entry. Each deltype will be a PATHPULSE or PATHPULSEPERCENT entry, specifying how pulses will propagate across paths in this cell, or ABSOLUTE or INCREMENT delay definition entries, containing delay values to be applied to the region identified by the cell."
"If input_output_path is omitted, then the data supplied refers to all  input  to-output paths in the region identified by the cell entry. The annotator must locate all paths that are able to model narrow-pulse propagation in the applicable timing model and apply the supplied data. The first value, in time units, is the pulse rejection limit."
"The second value, in time units, is the X limit. This limit defines the minimum pulse width necessary to drive the output of the specified path to a known state; a narrower pulse causes the output to enter the unknown (X) state or is  rejected (if smaller than the pulse rejection limit). Note that the X limit must be greater than the pulse rejection limit to carry any significance."
"When narrow pulses arrive at an output due to changes at different inputs (rather than two changes at the same input, as in the above example), the two paths from the inputs to the output may have different limits. The assumption made in SDF is that the analysis tool will use the data for the path that terminated the pulse to control the pulse's appearance at the output."
"Note that if the analysis tool is able to model narrow-pulse propagation with different limits for each output transition, the tool can pre-compute the  limit values from the percentages and path delay values. The annotator, however, cannot do this as new values for path delays may be supplied after the PATHPULSEPERCENT entry is processed. 18.7 Delay Definitions"
"RNUMBER or rtriple are empty (see ""Data Values"" on page 4-7). The meaning of this is the same as missing numbers in an rtriple: no data is supplied and values should not be changed by the annotator. Such null delvals act as  ""placeholders"" to allow you to  specify delvals further down the l ist."
"When a single rvalue is used, it specifies the delay value. When two rvalues in parentheses are used, the  first rvalue specifies the delay, as if a single rvalue were given. The second specifies both the pulse rejection limit, or  ""r-limit"", associated with this delay, and the X-limit, or ""e-limit"". When three rvalues are used,  the first336 Chapter 18 specifies the delay,  the second specifies the pulse rejection limit, or ""r-limit"", and the third specifies the X-limit, or ""e-limit"". This allows pulse control data to be associated in a uniform way with all types of delays in SDR Note that since any rvalue can be an empty pair of parentheses, each type of delay data can be annotated or omitted as the need arises. Each rvalue is either a single RNUMBER or an rtriple, containing three RNUMBERs separated by colons,  in parentheses."
"Each number in the triple is an alternative value for the data and is typically selected from the triple by the annotator or analysis tool on an instruction from the user. The prevailing use of the three numbers is to represent minimum, typical and maximum values computed at three process/operating conditions for the entire design. Any one or any two (but not all three) of the numbers in a triple may be omitted if the separating colons are left in place. This indicates that no value has been computed for that data, and the annotator should not make any changes if that number is selected from the triple. For absolute delays, this is not the same as entering a value of 0.0."
"If the timing model includes conditions (state dependency) for the path delay between the two specified ports, the specified delval is  still applied. If the model includes more than one delay path, each distinguished by it s conditions, then the data applies to all of them. This has the same effect as specifying all paths (using the"
"QSTRING is an optional symbolic name that can stand in for the e xpression itself for annotators that operate by matc hing named placeholders in the model to SDF constructs. See ""Condition Labels"",  below, for a full explanation. conditional_port_expr is the description of the state dependency of the path delay."
"TRUE. port_instance and delval_list have  exactly the same meaning as in IOPATH entries without the COND keyword as desc ribed above, except that the a nnotator must locate a path delay with a condition matching the one specified and apply the data only to that. Other path delays from the same input port to the same output port but with different conditions in the timing model will not receive the data."
"Annotators may operate by mapping constructs in the SDF file into symbolic names, locating  placeholders with those names in the models and applying values from the SDF file to the variables associated with those placeholders. (An  example of this is the annotator for VITAL models in a VHDL simulator.) To ease the problem of mapping a conditional_port_expr construct (or  the timing_check_condition construct in timing checks, later) into symbolic names, these can optionally be preceded by a QSTRING."
"QSTRING? conditional_port_expr ( IOPATH port_spec port_instance ( RETAIN delval_list )* delval_list) ) ( CONDELSE ( IOPATH port_spec port_jnstance ( RETAIN delval_list )* delval_list)) port_spec is an input or a bidirectional port and can have an edge identifier. port-instance is an output or a bidirectional port. It cannot have an edge identifier. Delay data for the different transitions at the path output port are conveyed by supplying an ordered list of values as described above in ""Specifying Delay"
"Although INTERCONNECT entries are the most general way in which interconnect delays can be exp ressed, some analysis tools may not be able to model independent delay values ove r each driver-to-driven path on a net with more than one driver. Such tools may map INTERCONNECT entries into equivalent input port delays (such as would directly arise from PORT entries), sometimes losing information in the process. Even tools which can model independent delays over each path may do so less efficiently than input port delays. Writers of SDF files should bear this in mind when choosing whether to use PORT entries or"
"The DEVICE entry represents the delay of all paths through a cell to the specified output port. This construct is intended primarily for use with distributed timing models where the cell to which it is applied is a modeling primitive. If it is used at a higher level in the hierarchy, then the effect is to apply the delay data to all input-tooutput paths across the cell that terminate at the specified port."
"Syntax (DEVICE port_instance? delval_list) port_instance is optional and, if present, specifies the output port to which the delay data is to be applied. If a cell has more than one output, you can therefore include several DEVICE entries in a single CELL entry, each indicating the desired output port using port_instance, and  attach different delay data to each output. If port_instance is omitted, all paths to all output ports of the region identified in the cell entry receive the same delay data. delval-list is the delay data. The number of triples in delval-list must correspond to the capabilities of the modeling primitives of the target analysis tool. For example,"
SDF file demonstrates the annotation of delays to the a-to-y and b-to-y paths through the top NAND gate. The first of these de fines the input-to-output path delay from sb to q of the RS latch; the second contributes to the rb to q delay. The delay on bufa also contributes to th e sb-to-qb delay.
"WIDTH, PERIOD or NOCHANGE timing check entry, containing timing check limit values for this cell entry. Timing check entries specify limits in the way in which a s ignal can change or two signals can change in relation to each other for reliable circuit operation. EDA analysis tools use this information in di fferent ways:"
SETUPHOLD port_tchk port_tchk rvalue rvalue ) ||= ( SETUPHOLD port_spec port_spec rvalue rvalue scond? ccond?) ||= ( RECOVERY port_tchk port_tchk value ) ||= ( REMOVAL port_tchk port_tchk value ) ||= ( RECREM port_tchk  port_tchk rvalue rvalue ) ||= ( RECREM port_spec port_spec rvalue rvalue scond? cc ond?) ||= ( SKEW port_tchk port_tchk rvalue ) ||=342 Chapter 18 ( WIDTH port_tchk value ) ||= ( PERIOD port_tchk value ) ||= ( NOCHANGE port_tchk port_tchk rvalue rvalue )
"The COND keyword allows the specification of conditional timing checks. Its use is rather different from the specification of conditional input-output path delays described in ""Conditional Path Delays"" on page 19 in that the condition is associated with the specification of a port rather than the entry as a whole."
"Syntax port_tchk::= port_spec ||= (COND QSTRING? timing_check_condition  port_spec) timing_check_condition is the description of the state dependency of the timing check. The perceptive r eader will notice that this expression evaluates to a logical signal, rather than a boolean. The intent is that the analysis tool should  treat a logical zero as FALSE and any other logical value (1, X or Z) as TRUE and that a particular conditional timing check in the timing model is used only if the con dition is TRUE."
The annotator must locate in the timing model a timing check with conditions matching those specified. Other timing checks of the same kind but with different conditions from the SDF entry will not receive the data. SDF timing check entries with no conditions match any timing check in the model of the same kind and between the ports specified in the SDF entry.
"For the setup phase of  a setuphold timing check, th e ""stamp"" condition  applies to the data port and the ""check"" condition to the clock or gate port. For the hold phase, the ""stamp""  condition applies to the clock or gate port and the ""check"" condition to the data port."
"This is because there is no way to specify that the condition should only apply to signal clk for SETUP checks, and only to signal d for HOLD checks. The SCOND and CCOND fields provide this capability. By de finition, the CCOND field defines a condition for the check event (the 2nd event): (SETUPHOLD d clk (5) (7) (CCOND enb))"
"Each rvalue or value may be a single value (RNUMBER or NUMBER, respectively) or three values separated by colons, (an rtriple or triple) representing three sets of data for minimum, typical and maximum delay conditions. However, the use of single RNUMBER/NUMBERs and rtr iple/ triples should not be mixed in the same SDF file."
"Each number in the triple is an alternative value for  the data and is typically selected from the triple by the annotator or analysis tool on an instruction from the user. The prevailing use of the three numbers is to represent minimum, typical and maximum values computed at three process/operating conditions for the entire design. Any one or any two (but not all three) of the numbers in a triple may be omitted if the separating c olons are left in place. This indicates that no value has been computed344 Chapter 18 for that data, and the annotator should not make any changes if that number is selected from the triple."
"Setup and hold timing checks are used to define a time interval during which a ""data"" signal must remain stable in order for a transition of a ""clock"" or ""gate"" signal to store the data successfully in a storage device (flip-flop or latch). The setup time limit defines the part of  the interval before the clock transition; the hold time limit defines the part of the interval after the clock trans ition. Any change to the data signal within this interval results in a timing violation. To shift the interval with respect to the clock transition, either the setup time or the hold time can be negative; however, their sum must always be greater than zero."
"The first port_tchk or port_spec identifies the data port. The second port_tchk or port_spec identifies the clock port. As with all port_tchks, the COND construct can be used in the first form of the setuphold timing check to specify conditions associated with the ports. The first rvalue is the setup time and the second rvalue is the hold time. Either can be negative, however their sum must be greater than zero."
"This SDF entry will match setup and hold timing ch ecks in the model that are conditional on ~reset at the time the din port changes. At this time in the analysis tool, -reset must evaluate to TRUE, i.e., the reset signal must be in the zero, X or Z states, for the checks  to be performed."
"The RECOVERY entry specifies limit values for recovery timing checks. A recovery timing check is a limit of the time between the release of an asynchronous control signal from the active state and the next active clock edge, for example between clearbar and the c lock for a flip-flop. If the active edge of the clock occurs too soon after the release of the clearbar, the state of the flip-flop will become uncertain—it could be the value set by the clearbar, or it could be the value clocked into the flip-346 Chapter 18 flop from the data input. In other respects, a recovery check is similar to a setup check."
"The second port_tchk refers to the clock (flip-flops) or gate (latches). This will also normally have an edge identifier to indicate the active edge of the clock or the closing edge of the gate. value is the recovery limit value and must not be negative. It is the time it takes a device to recover after an extraordinary operation, such as set or reset, so that it can reliably return to normal operation, such as clocking in of new data."
"The REMOVAL entry  specifies limit values for removal timing checks. A removal timing check is a limit of the time between an active clock edge and the release of an asynchronous control signal from the active  state, for  example between the clock and the clearbar for  a flip-flop. If the rel ease of the clearbar occurs too soon after the active edge of the clock, the state of the flip-flop will become uncertain—it could be the value set by the clearbar, or it could be the value clocked into the flip-flop from the data input. In other respects, a removal check is similar to a hold check."
"The first port_tchk refers to the asynchronous c ontrol signal and will normally have an edge identifier a ssociated with it to indicate which transition corresponds to the release from the  active state. The second por t_tchk refers to the clock (flip-flops) or gate (latches). This will also normally have an edge identifier to indicate the active edge of the clock or the closing edge of the gate. value is the removal limit value and must not be negative. It is the time for which an  extraordinary  operation, such as set or reset, must persist to insure that a device will ignore any normal operation, such as clocking in of new data."
"Syntax ( WIDTH port_tchk value ) port_tchk refers to the port at which the minimum pulse width timing check is applied. If it includes an edge specification, then the data will apply to the w idth check for the phase  of the signal beginning with this edge (see example below). If port_tchk does not include an edge specification, then the data applies to both high and low phases of the signal. value is the minimum pulse width limit and cannot be negative."
"If it includes an edge specification, then the data will apply to the  period check between consecutive edges of this direction (see example below). If por t_tchk does not include an edge specification, then the data applies both to period checks  between consecutive rising edges and between consecutive falling edges if they are present in the timing model. value is the minimum pe riod limit and cannot be negative.STANDARD DELAY FORMAT 349"
"The NOCHANGE entry  specifies limit values for a nochange timing check. The nochange timing check is a signal check relative to the width of a control pulse. A ""setup"" period is established  before the start of the control pulse and a ""hold"" period after the pulse. The signal checked against the control signal must remain stable during the setup period, the entire width of the pulse and the hold period. A typical use of a nochange timing check is to model the timing of memory devices, when address lines must remain stable during a write pulse with margins both before and after."
Syntax te_spec ::= (TIMINGENV te_def+ ) te_def ||= cns_def // constraint ::= tenv_def // timing environment cns_def ::= ( PATHCONSTRAINT name? port_instance  port_instance+ rvalue rvalue ) ||= ( PERIODCONSTRAINT port_instance value exception? ) ||= ( SUM constraint_path constraint_path+ rvalue rvalue? ) ||= ( DIFF constraint_path constraint_path value value? ) ||= ( SKEWCONSTRAINT port_spec value )
"Constraint entries provide information about the timing properties that a design is required to have in order to meet certain design ob jectives. A tool that is synthesizing some aspect of the design (logic synthesis, layout, etc.) will adapt its strategy to try to ensure that the constraints are met and issue warning messages in the event that they cannot be met."
"The PATHCONSTRAINT entry represents delay constraints for paths. Path constraints are the critical paths in a design identified during timing analysis. Layout tools can use these constraints to di rect the  physical design. The constraint specifies the maximum allowable delay for a path, which is typically identified by two ports, one at each end of the path. You can also specify intermediate ports to uniquely identify the path."
"Syntax ( PATHCONSTRAINT name? port_instance  port_instance+rvalue rvalue ) name ::= ( NAME QSTRING ) name is optiona l and allows a symbolic name to be associated with the path. This name should be used by the tool to identify the path to the user when information about the path (problems, failures, etc.) is to be provided. The name is assumed to be more c onvenient for this purpose than the list of port instances.STANDARD DELAY FORMAT 351"
The first port_instance is the start of the path. The last port_instance is the end of the path. You can specify intermediate points along the path by using additional port_instances in this entry. The first rvalue is the maximum rise delay between the start and end points of the path. The second rvalue is the ma ximum fall delay between the start and end points of the path.
The PERIODCONSTRAINT construct allows a path constraint value to be specified for groups of paths in a synchronous circuit. All paths in the group will be from the common clock input of some flip-flops to the data inputs of the flip-flops that share the common clock. This can be used to derive the frequency at  which a circuit must operate as a constraint on how long  signals can take after a clock edge to reach the register data inputs.
"Syntax ( PERIODCONSTRAINT port_instance  value  exception?) exception ::= ( EXCEPTION cell_instance+ ) port_instance identifies the common clock signal which is the start of all constrained paths. Whereas the start of a PATHCONSTRAINT entry is normally an input port, port_instance here is normally the output port of the device that drives the clock of the flip-flops. Only flip-flops directly connected to this output are in constrained paths. Paths that pass through other buffers before reaching a flip-flop clock are also considered in the group constrained by this entry."
"Period Constraint value is the maximum allowable delay for each path in the group. Included in this delay is the clock-to-output delay of the flip-flop driven from port_instance, the setup time of the flip flop that ends the path, and the delay through any combinational logic before arrival at the data input of a flip-flop. Not included is the difference in the timing of the clock of that flip-flop that ends the path from the clock that starts the path. These two times will cause the value supplied in a"
"Each constraint_path specifies a path to be included in the sum. You must specify at least two paths,  but can specify more.In each constraint_path the first port_instance is the beginning of the path and the second port_instance is the end of the path. rvalue is  the constraint va lue. The total (sum) of the individual delays associated with each constraint_path must be less than rvalue. If two  rvalues are supplied, the first applies to the rising transition at the end of the path and the second to the falling."
"The DIFF entry represents a constraint on the difference in the delay over two paths in a design. Syntax (DIFF constraint_path constraint_path value value?) constraint_path specifies a path between two ports. You must specify exactly two paths. In each constraint_path the first port_instance is the be ginning of the path and the second port_instance is the end of the path. value is the constraint value and must be a positive number or zero. The absolute value of the  difference of the individual delays in the two circuit paths must be less than value. If two values are supplied, the first applies to the rising transition at the end of the path and the second to the falling."
The SKEWCONSTRAINT entry represents a constraint on the spread of delays from a common driver to all driven inputs. Only the driving output port can be spec ified in this construct. All inputs connected to this output are implied e nd-points for constrained paths. Only paths over interconnect can be constrained  as these implied paths ca nnot pass through any ac tive devices.
"Syntax ( SKEWCONSTRAINT port_spec value ) port_spec refers to the port driving the net. value is the constraint value and must be a positive number or zero (although zero c lock skew might be a hard constraint for a layout tool to meet!). The delays from the output specified by port_spec to all inputs that it drives may not differ from each other by more than value. This does not place a constraint on the ac tual value of the delays, just their ""spread""."
"In this example, a b uffer cell of cell type buf is used to drive some clock inputs in a circuit. It is buried in  the design hierarchy by being instantiated as bufb in a user block called clockbufs, which in turn is part of the block top. In the excerpt from an"
Timing environment entries provide information about the timing environment in which the circuit will operate. This can be used by analysis tools to determine whether or not a design will operate correctly given the back-annotation  timing data given elsewhere in the file. It can also be used to compute constraints to be forwardannotated to subsequent stages in the design synthesis process.
"Syntax ( ARRIVAL port_edge? port_instance rvalue rvalue rvalue rvalue ) bufa clockbufs port_edge identifies a port and signal edge that form the time reference for the arrival time specification. The port must be an input port. The port_edge  is required if the primary input signal is a fan-out from a sequential element, in which case, port_edge is usually referred to an active edge of a clock signal. Otherwise, the port_edge can be  omitted. All ARRIVAL constructs that do not have the port_edge refer to the  same implicit time  reference point. This reference time should be treated as the time 0 of all WAVEFORM constructs. Note that, to fully specify a timing environment, a WAVEFORM statement is required for each clock signal. port_instance specifies the port at which the arrival time is to be defined. It must be an input or bidirectional port that is a primary (external) input of the top-level module."
"Four rvalues carry the arrival-time data in this order: earliest rising, latest rising, earliest falling and latest falling arrival times. All values are relative to the time reference, either by a port_edge, or by the implicit  reference point. The earliest arrival times must be less than the latest arrival times for the same transition."
"Syntax (DEPARTURE port_edge? port_instance rvalue rvalue rvalue rvalue )STANDARD DELAY  FORMAT 355 port_edge identifies a port and signal edge that form the time reference for the departure time specification. The port must be an input port. The port_edge is required if the primary output is a fanout from a sequential element, in which case, port_edge is usually referred to an active edge of a clock signal. Otherwise, the port_edge can be omitted. All DEPARTURE constructs that do not have the port_edge refer to the same implicit time reference point.  This reference time should be treated as the time 0 of all WAVEFORM constructs. Note that, to fully specify a timing environment, a WAVEFORM statement is re quired for each clock signal. port_instance specifies the port at which the departure time is to be defined. It must be an output or bidirectional port that is a primary (external) output of the top-level module. Four rvalues carry the departure-time data in thisorder: earliest rising, latest rising, earliest falling and late st falling departure times. All values are relative to the time reference, either by  a port_edge, or by the implicit reference point. The earliest departure times must be less than the latest departure times for the same transition."
The SLACK construct is used to specify  the available slack or margin in  a delay path. This is a comparison of the calculated delay over a path to the delay constraints imposed upon that path. Positive slack indicates that the constraints are met with room to spare.  Negative slack indicates a failure to construct the circuit according to the constraints. A layout or logic synthesis tool can use slack information to make trade-offs in cell placement and routing or re-synthesis of parts of the circuit. The objective should be to eliminate negative slack and achieve an even distribution of positive slack.
The SLACK construct is used to  specify the available slack or margin in a delay path. This is a comparison of the calculated delay over a path to the delay constraints imposed upon that path. Positive slack indicates that the constraints are met with room to spare.  Negative slack indicates a failure to construct the  circuit according to the constraints. A layout or logic synthesis tool can use slack information to make trade-offs in cel l placement and routing or re-synthesis of parts of the circuit. The objective should be  to eliminate negative slack and achieve an even distribution of positive slack.
"Four rvalues carry the slack/margin data. In order, they are the rising setup slack, the falling setup slack, the rising hold slack and the falling hold slack. ""Rising"" and ""falling"" indicate the direction of transitions at the specified port_instance to which data applies. The setup slack is the additional delay that could be tolerated in all paths ending at this  port without causing design constraints to be violated. Similarly, the hold slack is the reduction of the delay that could be tolerated in all these paths."
"If rtriples are used in these rvalues, then each number belongs to the data set for that position in the triple. Since the prevailing use of these data sets is to carry data for minimum, typical and maximum delays, setup slack rtriples will have the unusual property of decreasing in value from left to right."
"The WAVEFORM construct allows the specification of a periodic waveform that will be applied to a circuit during its intended operation. Typically, this will be used to define a clock signal. Tools can use this information in  analyzing the circuit for timing behavior and to compute constraints for logic synthesis an d layout."
"It must be an input or bidirectional port. If the port is not a primary input of the circuit, i.e., if it is driven by the output  of some other circuit element in the scope of358 Chapter 18 the analysis, the n the signal driven in the circuit should be ignored and the specified waveform should replace it in the analysis. The hierarchical path to this port is relative to the scope or design region identified by the cell entry."
"NUMBER specifies the period of the waveform. The waveform described repeats indefinitely at this interval. edge_list describes a single period of the waveform. It consists of a list of edge pairs, which can be e ither a posedge entry followed by a negedge entry or a negedge entry followed by a posedge entry. Thus, the total number of edges in the list will be even and edges will alternate between posedge and negedge. In addition to the direction of the transition, each edge gives the time at w hich the transition takes place relative to the start of each period. Offsets must increase monotonically throughout the edge_list and must not exceed the period. If one RNUMBER is supplied, then this precisely defines the transition offset. If two RNUMBERs are supplied, the n they define an  uncertainty region in which the transition will take place. The first RNUMBER gives the beginning of the uncertainty region and the second RNUMBER gives its end. Tools using this construct with two RNUMBERs should assume that a single transition of the specified direction occurs somewhere in the uncertainty region, but should make no assumptions about exactly where. Tools unable to model this edge uncertainty should issue a warning message and use the mean of the two RNUMBERs to locate the trans ition."
"The delay model provides a guideline for using SDF in ASIC application tools. All constructs in SDF should be  directly applicable to the delay model. ASIC timing is divided into forward annotation and back annotation. Although SDF supports bothSTANDARD DELAY FORMAT 361 timing concepts, this section concentrates on ASIC timing back-annotation model. A future release of SDF will provide an abstract model for forward annotation."
"DCL (Delay Calculation Language) is a new standard in the area of timing descriptions and is useful for deep submicron designs where interconnect delay descriptions are involved. The information on this is available from CFI. Originally developed at IBM where the deep submicron technology was implemented first, this is now accepted as CFI standard."
"For interconnect effects of distributed RLC characteristics need to be modeled to characterize the transient function of each driven point on a net. Characterization of delay must consider state and switching dependencies between the controlling input to a gate and the other inputs. Signal slew rates, and degradation, or attenuation, as a result of crosstalk have become factors to be coped with in the delay characterization process."
"However, this requires an additional software component called the model manager which mus t work together with all the tools—thus  making it a framework like or centralized interface as opposed to one -to-one like in the PLI. Similar  interfaces have been proposed in the past [see the CFI web site for intertool  communication  standard accepted in early nineties—but have not really taken root. However, the IP and core methodology may rely on this new interface and attempts are being made in this direction.19 VERILOG-A AND"
Verilog-MS allow Verilog HDL to be  used for describing electrical  circuit behaviorally like the digital system. The digital behavior is described behaviorally under the initial and always blocks. A new analog block is added to Verilog HDL for circuit behavior. Differential equations following Kirchoff’s laws are described in the analog block using the symbol <+ for ‘=’ commonly used in Mathematics.
"In this exa mple, analog to  digital converters will be interfaced  at the first port of instance mdi and digital to  analog converters will be placed at the second and third ports of mai. This will be  done implicitly by the c ompiler and the simulator. Explicit conversions of  signals from analog to digital and vice versa will be supported in this language definition.20 SIMULATION SPEEDUP"
"The simulation of a system can be a time-consuming part of  a project. Optimizations to simulation algorithms can be performed on certain subsets of the HDL. One such technique commonly used is known as cycle-based simulation. As seen in the synthesis subset, the  models written must follow a subset that describes a synchronous system using the model of a Sagdeo machine. [Figure 12-2]. In such cases, the activity in the simulator is only present on clock-edges. There are no other types waits involved or synchronizations or delays. Thus, one can lump all clockbased activity in one block of execution and perform an ac celerated simulation by removing the  events altogether. Thus, a network dat a structure similar to one in"
"Figure 4-1 is created during compilation and one only has to perform evaluations based on this data structure. On each clock edge, stimulus changes are captured in a predetermined fashion and then applied to the circuit under simulation. On each net or reg change arising  from this stimulus change, propagation takes place according to the compiled data structure as per connectivity of different nodes and evaluation blocks without creation of any events."
"In general, event creation and processing takes up 90% of the simulation cpu time. With this method, when the input description is at RTL level and follows the basic synthesis subset model, one  can achieve simulation speedup of an order of magnitude. However, the stimulus is still being generated at the higher level and the simulator must have the capacity to handle both kind so simulations together and interface the two algorithms correctly without losing the speedup achieved in the"
"An interpretive simulator compiles the  Verilog code into int ernal data structure that may be then used for step-by step simulation which can be debugged directly at the source level. This kind of simulation is ideally suited during module by module development of a design. As the design gets larger and the simulation initialization and test-sequence takes longer CPU times, one can optimize  the simulation by compiling down the debugged modules into either binary code via C code translation and compilation or directly generating native code. The step of producing C code and then compiling this takes longer compilation times at the benefit of faster runtime."
"Direct generation of native code typically helps in speeded compilation and may even have some small advantage in simulation. However, C compilers have several optimizing cod generation algorithms which may benefit the run-time and the native code generator must match the quality of optimized code—especially when pipelining and other such pro cessor dependent code-optimizations are involved. 20.4 Parallel Processors and Multi-Threaded Simulators"
"The parallel processing mac hines can speed up certain applications upto the number of processors and at times, more if the caches are local to each processor and the simulations get the advantages of this configuration. For multi-processing applications, a simulator must be rewritten with creation of threads such that all the processors get the computations in simulation done in parallel(generally with a shared memory). Some of the best results can be obtained again for code that has large number of processing done at the same time. The RTL code that is based on a single event in a cycle based simulation may not be  vectorized so  well although benefits in evaluating blocks in parallel may be seen. Events tend to be more naturally threaded and simulations with large number of events at the same time can run with speedups upto n times. Large gate-level or switch-level simulations can also run well in parallel in an algorithm whereby each thread creates its own events in a thread-based event queue. While running for the R1000 processor simulations on"
"The typical simulations of a large design tends to run on certain parts of the design for certain item and then move onto other parts when the boundaries across higher level blocks get triggered. In such cases, the caches can hold the data on which the simulations run for longer time providing  simulation speedup. Thus, managing the application of stimulus and locality of reference are good techniques of managing your simulation runs. The random pattern application really may test th e circuit well but will not have the locality of reference that a well-developed systemic test-suite could provide."
"Virtual memories typically tend to be too slow for simulations as the activity rate I every high, that is, this is a CPU and memory-access intensive application. Thus, providing real memory greater than the simulator would need for running the system is a must for simulation runs to complete in reasonable times. The needs of memory vary for different tools and should be looked at while evaluating the tool that will be used for a design project. 20.6 Distributed Simulations Over a Network of Workstations"
"Communicating over a distributed network for events could be slow and thus partitioning of design must be done such that very few pieces of data are  exchanged amongst a distributed system. All the tests must go through similar initialization of the circuit and then apply  individual tests when test-data is  partitioned. Tools are available to manage the distributed runs of a system which can schedule the runs, do the initial distribution of data, help in synchronization and in finally gathering the result together. 20.7 C Code Versus HDL Code"
"For hardware-software codesign, the full-detailed synthesizable HDL models of the system could be slow in terms of number of cycles needed for software to be run on the hardware to be built ahead of the time to speedup the final system delivery. In such cases, C code is widely used to model th e high-level processor, cache and other system models. However, the modeling in Verilog using higher levels of abstractions is a viable and preferred alternative. As seen in the cache design examples of chapter 11, the behavioral models run order of magnitude faster than the RTL models as the details of synchronization are absent in these models. This level of abstraction can be further raised and cycle-based simulations can still be used to get performance comparable to C models and accuracy and model-development far better. The core or374 Chapter 20"
"Reading large set of patterns and writing large set of data can be quite timeconsuming especially in a networked file system. Files must be locally present on a workstation in a distributed system for the speed issues. On a single workstation, reading and writing must be minimized especially within an event loop. This can be achieved by reading large chunks of data in a cached manner and similarly for writing, local caching must be  done. The output dumpfiles in the format that Verilog provides could be long and several compression techniques are available either to be implemented as user-defined tasks or via tools such as  Veritools waveform processor.A FORMAL SYNTAX"
"This is fixed for some bugs from the orginal specification. A.1 Source Text source_text ::= {description} description ::=  module_keyword ::= modul e | macromodule list_of_ports ::=( port {,port }) port ::= [port_expression] | .port_identifier ([port_expression]) port_expression ::= port_reference | { port_reference ,port_reference } port_reference ::=port_identifier | port_identifier[ consta nt_expression ] | port_identifier [ msb_constant_expression :lsb_constant_expression ] module_item ::= module_item_declaration | gate_instantiation | udp_instantiation | module_instantiation | parameter_override | continuous_assign | specify_block | initial_statement | always_statement module_item_declaration ::= parameter_declaration | input_declaration | output_declaration | inout_declaration | net_declaration376 Appendix A| reg_declaration | time_declaration | realtime_declaration | integer_declaration | real_declaration | event_declaration | task_declaration | function_declaration"
"A.2 Declarations parameter_declaration ::= parameter  list_of_param_assignments; list_of_param_assignments ::=param_assignment {,param_assignment} param_assignment ::=identifier = constant_expression input_declaration ::= input  [range] list_of_port_identifiers ; output_declaration ::= output  [range] list_of_ port_  identifiers; inout_declaration ::= inout  [range] list_of_ port_  identifiers; net_declaration ::=  net_type [expandrange] [delay] list_of_net_ identifiers; | trireg  [charge_strength] [expandrange] [delay] list_of_ net_ identifiers; | NET_TYPE [drive_strength ] [expandrange] [delay] list_of_net_decl_assignments; list_of_net_ identifiers ::= net_ identifier , { net_ identifier } net_type ::=:  wire | tri | tri1 | supply0 | wand | triand | tri0 | supply1 | wor | trior | trireg expandrange ::= range | scalared  range | vectored  range reg_declaration ::= reg [range] list_of_register_ identifiers; list_of_ register_ identifiers ::= register _ identifier, {register _ identifier} time_declaration ::= time  list_of_register_ identifiers; integer_declaration ::= integer  list_of_register _ identifiers; real_declaration ::= real list_of_  real_identifiers;FORMAL SYNTAX DEFINITION FOR VERILOG HDL 377list_of_ real_identifiers ::= real_ identifier , { real_ identifier } event_declaration ::= event  event_identifier{  event_identifier} ; task _declaration ::= task  task_identifier; {task_item_declaration} statement_or_null endtask task_item_declaration ::= block_item_declaration | input_declaration | output_declaration | inout_declaration function_declaration ::= function  [range_or_type]  function_identifier; function_item_declaration statement endfunction function_item_declaration ::= block_item_declaration | input_declaration range_or_type ::= range | integer | function_identifier ::= identifier block_item_declaration ::= parameter_declaration | reg_declaration | time_declaration | integer_declaration | real_declaration | realtime_declaration | event_ declaration continuous_assign ::= assign  [drive_strength] [delay]  list_of_assignments ; | net_type [drive_strength] [expandrange] [delay] list_of_assignments ; parameter_override ::=defparam  list_of_param_assignments ;378 Appendix Alist_of_register_variables ::=register_identifier { , register_identifier } register_variable ::= register_identifier | memory_identifier [ constant_expression : constant_expression ]  register_identifier ::= memory–identifier ::= event_identifier charge_strength ::=( small) | (medium) | (large) drive_strength ::= (strength0 , strength1) | (strength1, strength0) strength0 is one of  the following keywords: supply0 strong0 pull0 weak0  highz0 strength1 is one of  the following keywords: supply1 strong1  pull1 weak1 highz1 range ::= [ msb_constant_expression : lsb_constant_expression ] list_of_net_decl_assignments ::= net_decl_assignment{  ,net_decl_assignment} net_decl_assignment ::=net_identifier = expression"
"A.3 Primitive Instances gate_instantiation ::=n_input_gatetype [drive_strength] [delay2] n_input_gate_instance {, n_input_gate_instance}; | n_output_gatetype[drive_strength] [delay2] n_output_gate_instance { , n_output_gate_instance}; | n_enable_gatetype [drive_strength] [delay3] enable_gate_instance { ,enable_gate_instance}; | mos_switchtype [delay3] mos_switch_instance{ , mos_switch _instance}; | pass_switchtype [delay3] pass_switch_instance{ , pass_switch_instance} ; | pass_en_switchtype [delay3] pass_en_switch_instance{, pass_en_switch _instance} ; | cmos_switchtype [delay3] cmos_switch_instance{, cmos_switch _instance}; | pullup  [pullup_strength] pull-gate_instance{ , pull_gate_instance} ; | pulldown  [pulldown_strength] pull-gate_instance{ , pull_gate _instance} ;FORMAL SYNTAX DEFINITION FOR VERILOG HDL 379n_input_gate_instance ::=  [name_of_ gate_instance] (output_terminal, input_terminal{, input_terminal}); n_output_gate_instance ::=  [name_of_ gate_instance] (output_terminal, {,output_terminal }, input_terminal, input_terminal}); enable_gate_instance ::= [name_of_ gate_instance] (output_terminal, input_terminal{, input_terminal, enable_terminal}); mos_switch_instance ::= [name_of_ gate_instance] (output_terminal, input_terminal, enable_terminal}); pass_switch_instance ::=  [name_of_ gate_instance] (inout_terminal, inout_terminal, enable_terminal}); pass_enable_switch_instance ::=  [name_of_ gate_instance] (inout_terminal, inout_terminal, enable_terminal); cmos_ switch_ instance ::= [name_of_ gate_instance] (output_terminal, input_terminal,ncontrol_terminal, pcontrol_terminal); pull_ gate_ instance ::=  [name_of_ gate_instance] (output_terminal) name_of_ gate_instance ::= gate_instance_identifier[range] pullup_strength ::= (strength0, strength1) | (strength1,  strength0) | (strength0) input_terminal ::= scalar_expression enable_terminal ::=  scalar_expression ncontrol_terminal ::  = scalar_expression pcontrol_terminal ::  = scalar_expression output_terminal ::= terminal_identifier | terminal_identifier[constant_expression] inout_terminal ::= scalar_expression n_input_gatetype ::= and | nand | or | nor | xor | xnor n_output_gatetype::=buf | not enable_gatetype ::= bufif0 | bufif1 | notif0 | notif1 mos_switch_type ::=nmos | rnmos | pmos | rpmos cmos_switch_type ::=  cmos | rcmos pass_switch_type ::=tran | rtran pass_switch_type ::=tranif0 | rtranif0 | tranif1  | rtranif1 delay3 ::=  #delay_value | #( delay_value [,delay_value [,delay_value]]) delay2 ::= #delay_value | #( delay_value [,delay_value]) delay_value ::= unsigned_number | parameter_identifier | (mintypmax_expression [,mintypmax_expression] [,mintypmax_expression])"
"A.5 UDP Declaration and Instantiation udp_declaration ::= primitive  udp_identifier (udp_port_list); udp_port_declaration {udp_port_declaration} udp_body endprimitive udp_port_list ::=  output_port_identifier, input_port_identifier {,  input_port_identifier } udp_port_declaration ::= output_declaration | reg_declaration | input_declaration udp_body ::= combination_body | sequential_body combination_body ::=  table  combinational_entry { combinational_entry }  endtable sequential_body ::=  [UDP_initial_statement]  table  sequential_entry { sequential_entry } endtable"
"A.6 Behavioral Statements initial_statement ::= initial  statement always_ statement ::= always  statement statement_or_null ::= statement |; statement ::=blocking_assignment; | non-blocking_assignment; | procedural_continuous_assignment | procedural_timing_control_assignment | conditional_statement | case_statement | loop_statement | wait_statement | disable_statement | event_trigger | seq_block | par_block | task_enable | system_task_enable procedural_timing_control_assignment :  := delay_or_event_control statement_or_null procedural_continuous_assignment::= assign  reg_assignment | deassign  reg_1value force  reg_assignment release  reg_1value release  net_lvalue conditional_statement ::= if (expression) statement_or_null |if (expression) stateme nt_or_null  else statement_or_null case_statement::= case (expression) case_item {case_item}  endcase | casez  (expression) case _item {case_item}  endcase | casex  (expression) case_item {case_item } endcase loop_statement::= forever  statement | repeat  (expression) statement383| while  (expression) statement | for (assignment; expression ; assignment) statement wait_statement::= wait (expression ) stateme nt_or_null event_trigger ::= -> event_identifier; blocking_assignment ::= reg_lvalue = [delay_or_event_control] expression ; non-blocking_assignment ::= lvalue = expression | lvalue = delay_or_event_control expression ; delay_or_event_control ::= delay_control | event_control | repeat  (expression) eve nt_control case_item ::=expression{ ,expression) : statement_or_null | default: statement_or_null seq_block ::= begin{  statement}  end | begin  : block_identifier{ block_item_declaration}{ statement}  end par_block ::= fork{  statement} join | fork  : block_identifier{ block_item_decl aration}{ sta tement}  block_identifier { statement} join block_declaration ::= parameter_declaration | reg_declaration | integer_declaration | real_declaration | time_declaration | event_declaration task_enable ::=task_identifier | task_identifier (expression{ ,exp ression}); system_task_enable ::= system_task_name; | system_task_name( expression{ ,expression}); system_task_name384 Appendix A::= $system_identifier (Note: the $ may not  be followed by a space.)"
"Any expression, including constants and lists. Its width must be one bit or equal to the destination's width. If the destination is a list, the data source must be as wide as the sum of the bits of the members. edge_identifier ::= posedge | negedge sdpd ::=if(conditional_expression)path_description=path_delay_value; sdpd_conditional_expresssion ::=expressionB INARY_OPERATOR expression |UNARY_OPERATOR expressionFORMAL SYNTAX DEFINITION FOR VERILOG HDL 389A.8 Expressions net_lvalue ::= net_dentifier | net_identifier [ expression ] | net_identifier [constant_expression : constant_expression ] | net_concatenation reg_lvalue ::= reg_identifier |reg_identifier[expression] | reg_identifier[msb_constant_expression: lsb_constant_expression] | reg_concatenation constant_expression ::= constant_primary | unary_operator  constant_primary | constant_expression binary_operator constant_expression | constant_expression ? constant_expression : constant_expression | string constant_primary ::= number | parameter_identifier |constant_concatenation |constant_multiple_ concatena tion constant_mintypmax_expression ::= constant_expression | constant_expression : constant_expression : constant_expression unary_operator ::= + | | ! | ~ | | ~& | | | ~ | | ^ | ~^ | ^ ~ mintypmax_expression ::= expression | expression : expression : expression expression ::= primary | unary_operator primary | expression binary_operator expression | expression question_mark expression : expression | string binary_operator ::="
"An identifier is any sequence of letters, digits, dollar signs ($), and underscore (_) symbol, except that the first must be a letter or the underscore; the first character may not be a digit or $. Upper and lower case letters are considered to be different. Identifiers may be up to 1024 characters long. Some Verilog-based  tools do not recognize {identifier}characters beyond the 1024th as a significant part of the identifier. Escaped identifiers start with the backslash character (\) and may include any printable ASCII character. An escaped identifier ends with white space. The leading backslash character is not considered to be part of{ the} identifier. }delay ::=# number392 Appendix A| # identifier |  #  (mintypmax_expression  [,mintypmax_expression] [,mintypmax_expression]) delay_control ::=# number | # identifier | #  ( mintypmax_expression ) event_control ::= @ identifier | @ (event_expression) event_expression ::= expression | posedge scalar_event_expression | negedge scalar_event_expression | event_expression or event_expression scalar_event_expression"
"BNF Syntax source_text ::= {syn_description} syn_description ::= syn_396 Appendix B module_keyword ::= module | macromodule name_of_module ::= IDENTIFIER list_of_ports ::=( port {,port}) |( ) port ::= [port_expression] | .port_identifier ( [port_expression] ) port_expression ::= port_reference | { port_reference {, port_reference} } port_reference ::=port_identifier | port_identifier [ expression ] |port_identifier [ expression : expression] syn_module_item ::= parameter_declaration | input_declaration | output_declaration| inout_declaration| net_declaration | reg_declaration | integer_declaration | syn_gate_instantiation | module_instantiation | continuous_assign | function_declaration | syn_always_statement function_declaration ::= function  [range]function_identifier; {function_item_declaration} syn_statement endfunction function_item_declaration ::= parameter_declaration | input_declaration | reg_declaration | integer_declarationVERILOG SUBSET FOR LOGIC SYNTHESIS 397 syn_always_statement ::= always @ ( identifier or identifier ) | always @ ( posedge identifier ) | always @ ( negedge identifier ) | always @ ( egde or edge or ... ) edge ::= posedge identifier | negedge identifier parameter_declaration ::= parameter [range] list_of_assignments ; input_declaration ::= input [range] list_of_variables ; output_declaration ::= output [range] list_of_variables ; inout_declaration ::= inout [range] list_of_variables; syn_net_declaration ::= syn_NET_TYPE [charge_strength] [expandrange] [delay] list_of_variables; | NET_TYPE [drive_strength] [expandrange] [delay] list_of_assignments; syn_NET_TYPE ::=wire | wor | wand |tri expandrange ::= range | scalared  range reg_declaration ::= reg [range] list_of_register_variables ; integer_declaration ::= integer list_of_integer_variables; continuous_assign ::= assign [drive_strength] [delay] list_of_assignments;|vectored range398 Appendix B list_of_variables ::=variable_identifier {,variable} list_of_register_variables ::= register_variable {, register_variable) register_variable ::= IDENTIFIER list_of_integer_variables ::= integer_variable {, integer_variable} integer_variable ::= IDENTIFIER charge_strength ::= ( small ) | ( medium ) | ( large ) drive_strength ::=( STRENGTH0, STRENGTH1 ) | ( STRENGHT1  , STRENGTH0 )"
"An identifier is any sequence of letters, digits, and the underscore character (_), where the first character is a letter or underscore. Uppercase and lowercase  letters are treated as different characters. Identifiers can be any size and all characters are significant. Escaped identifiers start with the backslash character (\) and end with a space. The leading backslash character (\) is not part of the identifier. Use escaped identifiers to inc lude any printable"
Hierarchical names within a  endprimitive endtable endtask event for force forever fork function highz0 highz1 if initial inout input integer join large medium module nand negedge nmos nor not notif0 notif1 or output pa rameter pmos posedge primitive pulldown pullup pull0 pull1 rcmos reg release repeat rnmos rpmos rtran rtranif0 rtranif1 scalared smallVERILOG SUBSET FOR LOGIC SYNTHESIS 405 strong0 strong1  supply0 supply1 supply1 table task time tran tranif0 tranif1 tri triand trior trireg tri0 tri1 vectored wait wand weak0 weak1 while wire wor xnor xorC PROGRAMMING
"Header File veriuser.h /***************************************************************************** * veriuser.h * * IEEE 1364 1995 Verilog HDL Programming Language Interface (PLI). * * This file contains the constant definitions, structure definitions, and * routine declarations used by the Verilog PLI procedural interface TF * task/function  routines. * * The file should be included with all C routines that use the PLI TF * routines."
"Header File – verisuer.h int node_lhs_element; int node_rhs_element; int *node_handle; } s_tfnodeinfo, *p_tfnodeinfo; /*-----------data structure of vector values --------/ -*/ typedef struct t_vecval { int avalbits; int bvalbits; } s_vecval, *p_vecval; /*-------------data structure of scalar net strength values ----- --*/ typedef struct t_strengthval { int strength0; int strengthl; } s_strengthval,*p_strengthval; /*---*/ /*routine definitions -------*/ /*--___ ____ _ ___ */ /* -*/ #if defined(__STDC__) || defined(__cplusplus) #ifndef PROTO_PARAMS #define PROTO_PARAMS(params) params #define DEFINED_PROTO_PARAMS #endif #ifndef EXTERN #define EXTERN #define DEF INED_EXTERN #endif #else #ifndef PROTO_PARAMS #define PROTO_PARAMS(params) (/* nothing */) #define DEFINED_PROTO_PARAMS #endif#ifndef EXTERN #define EXTERN extern411412 Appendix C #define DEFINED_EXTERN #endif #endif /* STDC */ /**** Following is a list of routines provided to the user for interacting with the simulator using the io tasks and functions */ /** Explanation for each routine is pr ovided prior to its prototype **/ /* Following are the input-output routines */ /* The following will display a value to multi-channel d escriptor */"
"Header File – acc_user.h typedef int (*consumer_fun ction)(); /* /*-structure definitions*/ /*--*/ /*-------------data structure used with acc_set_value()-------*/ typedef struct t_acc_time { int type; int low, high; double real; } s_acc_time, *p_acc_time; /* -------------data structure used with acc_set_value()-*/ typedef struct t_setval_delay { s_acc_time time; int model; } s_setval_delay, *p_setval_delay; /* data structure of vector values-*/ typedef struct t_acc_vecval { int aval; int bval; } s_acc_vecval,  *p_acc_vecval; typedef struct t_setval_value { int format; union { char *str; int scalar; int integer; double real; p_acc_vecval vector; } value; } s_setval_value, *p_setval_value, s_acc_value, *p_acc_value; /*----------------------structure for  VCL strengths --------------*/ typedef struct t_strengths {426 Appendix D unsigned char  logic_value; unsigned char stre ngth1; unsigned char strength2; } s_strengths, *p_strengths; /* ---------structure passed to callback routine for VCL -------------*/ typedef struct t_vc_record { int vc_reason; int vc_hightime; int vc_lowtime; char *user_data; union { unsigned char logic_value; double real_value; handle vector_handle; s_strengths strengths_s; } out_value; } s_vc_record, *p_vc_record; /* -----------structure used with acc_fetch_location() routine -----------*/ typedef struct t_location { int line_no; char *filename; } s_location, *p_location; /* --structure used with acc_fetch_timescale_info() routine --------*/ typedef struct t_timescale_info { short unit; short precision; } s_timescale_info, *p_timescale_info; /*--*/ /*----------------------routine declara tions------ --------------*/ /* --*/ #if defined(_STDC_) || defined( _cplusplus) #ifndef PR020_PARAMS #define  PROTO_PARAMS(params)  params #define DEFINED_PROTO_PARAMS #endifPROGRAMMING LANGUAGE INTERFACE (PLI)"
"Header File – vpi_user.h file extern vpi_register_cb(); extern vpi_remove_cb(); extern vpi_get_cb_info(); /**************************************************************/ /*** obtain a logic or strength value of an object ***/ p_vpi_value vpi_get_value(vpiHandle object); vpi_put_value(vpiHandle object, p_vpi_value value); /************* write delays or  timing limits to an object *******/ vpi_put_delays(); /********** obtain a handle to an object with one to many relationship and then iterate ***/ vpiHandle vpi_iterate(vpiObjectType otype, vpiHandle object); vpiHandle vpi_scan (vpiHandle object); /******* miscellaneous vpi routines **************************/ /*** find the current simulation time or the scheduled time for future events **/ vpi_get_time(); /******* write to stdout and the current log file ******/ vpi_printf(); /********** open a file  for writing ***************/ vpi_mcd_open(); /********* close one or more files **************/ vpi_mcd_printf(); /************* retrieve the name of the open file *****/ vpi_mcd_name(); /************* retrieve data about product invocation options ***/ vpi_get_vlog_info(); /********** see if two handles refer to the same object ******/ vpi_compare_objects(); vpi_chk_error();444 Appendix E /**** obtain error status and error information about the previous calls to a VPI routine ****/ vpi_free_object(); /*** Get the values of objects of types integer or boolean **/ int vpi_get(); /************ get the values of objects of  string type ****/ char *vpi_get_str(); #endif /* STDC */ /* utility routines */"
"DEFINITION OF SDF delay_file ::= ( DELAYFILE sdf_header cell {, cell} ) sdf_header ::= sdf_version [design_name][date] [vendor] [program_name] [program_version] [hierarchy_divider] [voltage] [process] [temperature] [time_scale] sdf_version ::= ( SDFVERSION QSTRING) design_name ::= ( DESIGN QSTRING ) date ::= ( DATE QSTRING ) vendor ::= ( VENDOR QSTRING ) program_name ::= ( PROGRAM QSTRING ) program_version ::= ( VERSION QSTRING ) hierarchy_divider ::= ( DIVIDER HCHAR )"
HCHAR ::= .// a period character | / // a slash character voltage ::= ( VOLTAGE rtriple ) | ( VOLTAGE RNUMBER ) process ::= ( PROCESS QSTRING ) temperature ::= ( TEMPERATURE rtriple ) | ( TEMPERATURE RNUMBER ) time_scale ::= ( TIMESCALE TSVALUE )cell ::= ( CELL celltype cell_instance {timing_spec} ) celltype ::= ( CELLTYPE QSTRING ) cell_instance ::= ( INSTANCE [PATH] ) | ( INSTANCE WILDCARD )
"WILDCARD ::= * // the asterisk character timing_spec ::= del_spec | tc_sp del_defec | te_spec del_spec ::= ( DELAY deltype {, deltype}) tc_spec ::= ( TIMINGCHECK tchk_def {, tchk_def} ) te_spec ::= ( TIMINGENV te_def {, te_def} ) deltype ::= ( PATHPULSE [input_output_path] value [value]) | ( PATHPULSEPERCENT [input_output_path] value [value] ) | ( ABSOLUTE deLdef {,del_def}) | ( INCREMENT del_def {, del_def} ) input_output_path ::= {port_instance}del_def ::= ( IOPATH port_spec port_instance ( RETAIN { delval_list}) |(COND [QSTRING] conditional_port_expr(IOPATH port_spec port_instance( RETAIN { delvaljist})) |( CONDELSE (IOPATH port_spec portjnstance (RETAIN {delvaljist})) | (PORT port_instance delvaljist) | (INTERCONNECT port_instance portjnstance delvaljist) | (DEVICE [port_instance] delvaljist) tchk_def ::= (SETUP port_tchk por t_tchk value) | (HOLD port_tchk port_tchk value) I (SETUPHOLD port_tchk port_tchk rvalue rvalue ) | (SETUPHOLD port_spec port_spec rvalue [rvalue scond] [ccond]) | (RECOVERY port_tchk port_tchk value) | (REMOVAL port_tchk port_tchk value) | (RECREM port_tchk port_tchk rvalue rvalue) | (RECREM port_spec port_spec rvalue rvalue [scond] [ccond]) | (SKEW port_tchk port_tchk rvalue) I (WIDTH port_tchk value) | (PERIOD port_tchk value) I (NOCHANGE port_tchk port_tchk rvalue rvalue) port_tchk ::= port_spec I (COND [QSTRING] timing_check_condition port_spec) scond ::= (SCOND [QSTRING] timing_check_condition) ccond ::= (CCOND [QSTRING] timing_check_condition) name ::= (NAME [QSTRING])446 Appendix Fexception::= ( EXCEPTION cell_instance {, cell_instance} ) te_def ::= cns_def | tenv_def cns_def::= ( PATHCONSTRAINT [name] port_instance {,port_instance} rvalue rvalue) | ( PERIODCONSTRAINT port_instance value [exception] ) | ( SUM constraint_path constraint_path {, constraint_path} rvalue [rvalue] ) | ( DIFF constraint_path constraint_path value [value] ) | ( SKEWCONSTRAINT port_spec value) tenv_def ::= ( ARRIVAL [port_edge] port_instance rvalue rvalue rvalue rvalue ) | ( DEPARTURE [port_edge] port_instance rvalue rvalue rvalue rvalue ) | ( SLACK port_instance rvalue rvalue rvalue rvalue [NUMBER] ) | ( WAVEFORM port_instance NUMBER edge_list ) constraint_path ::= ( port_instance port_instance ) port_spec ::= port_instance | port_edge port_edge ::= ( EDGE_IDENTIFIER port_instance )"
"NUMBER), rvalue and rtriple are essentially the same as value and triple. delval ::= rvalue | ( r value rvalue ) | ( rvalue rvalue rvalue ) delval_list ::= delval | delval delval | delval delval delval | delval delval delval delval [[delval] delval] | delval delval delval delval delval delval delval [[delval] delval] [delval] [delval] [delval] conditional_port_expr ::= simple_expression | ( conditional_port_expr )| UNARY_OPERATOR ( conditional_port_expr ) | conditional_port_expr BINARY_OPERATOR conditional_port_expr simple_expression ::= ( simple_expression ) | UNARY_OPERATOR ( simple_expression ) | port | UNARY_OPERATOR port | SCALAR_CONSTANT | UNARY_OPERATOR SCALAR_CONSTANT | simple_expression"
BINARY_OPERATOR ::= + // arithmetic sum | // arithmetic difference | * // arithmetic product | / // arithmetic quotient | % // modulus | == // logical equality | != //  logical inequality | === // case equality | !== // case inequality | && // logical AND | || // logical OR | < // relational | <= // relational | > // relational | >= // relational | & // bit-wise binary AND | | // bit-wise binary inclusive OR | ^ // bit-wise binary exclusive OR | ^~ // bit-wise binary equivalence | ~^ // bit-wise binary equivalence (alternative) | >>// right shift | << // left shift
User-defined primitives – instancesMixed edge and level sensitive sequential UDP – SR flip-flop with clearLevel sensitive sequential UDP – a latchA combinational user–defined primitive: An adder part – carry computationA user-defined primitive definitionBuilt-in gate s modelingA behavioral pro cessor modelForce-release statements – debugging the flip-flop modelAassign – deassign – a flip-flop model with quasi-continuous assignmentsTask disabling – reset modeling for a microprocessorTask declaration and usage – a shift registerFunction call – creating a multiplexor module with function muxFunction definition – a muxModeling instructions with pipeline – fork-join usageModeling instructions with parallelismModeling instructions with no parallelismFork-join statements – modeling asynchronous reset and instruction loop co ncurrency in microprocessorsEvent triggering and event based synchronizationMulti-event eventEvent declarationsEvent declarations and usageWait statement – synchronizing two processesSequential blocks – begin-end  usageLoops – forever statement usageLoops – repeat statement usageLoops – while statement  usageLoops – for statement usageCase statement with unknowns and tri-statesCasex statement with unknowns and tri-statesCase statement with unknowns and tri-statesCase statement – a multiplexor model454 Appendix F
"Written for both experienced and new users, this book gives you broad coverage of Verilog HDL. The book stresses the practical design and verification perspective  ofVerilog rather than emphasizing only the language aspects. The informationpresented  is fully compliant with the IEEE 1364-2001 Verilog HDL standard.   • Describes state-of-the-art verification methodologies   • Provides full coverage of gate, dataflow (RTL), behavioral and switch modeling   • Introduces you to the Programming Language Interface (PLI)  • Describes logic synthesis methodologies   • Explains timing and delay simulation   • Discusses user-defined primitives   • Offers many practical modeling tips"
"BSD system, licensed from the University of California. Third-party software, including  font technology in this product, is protected by copyright and licensed from Sun's Suppliers.      RESTRICTED RIGHTS LEGEND: Use, duplicati on, or disclosure by the government is  subject to restrictions as set forth in subparagraph (c)(1)(ii) of the Rights in Technical"
"The product described in this manual may be protected by one or more U.S. patents, foreign patents, or pending applications.      TRADEMARKS      Sun, Sun Microsystems, the Sun logo, and Solaris are trademarks or registered  trademarks of Sun Microsystems, Inc. in the United States and may be protected as  trademarks in other countries. UNIX is a re gistered trademark in the United States and  other countries, exclusively licensed through X/Open Company, Ltd. OPEN LOOK is a  registered trademark of Novell, Inc. PostScript and Display PostScript are trademarks of"
"VirSim is a trademark of Simulation Technologies, Inc. Signalscan is a trademark of Design Acceleration, Inc. All other product, service, or company names mentioned herein  are claimed as trademarks and trade names by their respective companies.              4All SPARC trademarks, including the SCD Compliant Logo, are trademarks or registered  trademarks of SPARC International, Inc. in the United States and may be protected as  trademarks in other countries. SPARC center, SPARCcluster, SPARCompiler,"
"UltraSPARC are licensed exclusively to Sun Microsystems, Inc. Products bearing SPARC trademarks are based upon an architecture developed by Sun Microsystems, Inc.     The OPEN LOOK  and Sun  Graphical User Interfaces were developed by Sun Microsystems, Inc. for its users and licensees. Sun acknowledges the pioneering efforts  of Xerox in researching and developing the concept of visual or graphical user interfaces  for the computer industry. Sun holds a non-exclusive license from Xerox to the Xerox Graphical User Interface, which license also covers Sun's licensees who implement"
"About the Author     Samir Palnitkar is currently the President of Jambo Systems, Inc., a leading ASIC design  and verification services company which specializes in high-end designs for  microprocessor, networking, and communications applications. Mr. Palnitkar is a serial entrepreneur. He was the founder of Integrated Intellectual Property, Inc., an ASIC company that was acquired by Lattice Semiconductor, Inc. Later he founded Obongo,"
"Mr. Palnitkar is a recognized authority on Verilog HDL, modeling, verification, logic  synthesis, and EDA-based methodologies in digital design. He has worked extensively with design and verification on various su ccessful microprocessor, ASIC, and system  projects. He was the lead developer of the Verilog framework for the shared memory,  cache coherent, multiprocessor architecture, popularly known as the UltraSPARCTM Port Architecture, defined for Sun's next generation UltraSPARC-based desktop systems."
"Mr. Palnitkar is the author of three US patents, one for a novel method to analyze finite state machines, a second for work on cycle-based simulation technology and a  third(pending approval) for a unique e-commerce tool. He has also published several  technical papers. In his spare time, Mr. Palnitkar likes to play cricket, read books, and travel the world.                                 7"
"Foreword     From a modest beginning in early 1984 at Gateway Design Automation, the Verilog  hardware description language has become an industry standard as a result of extensive  use in the design of integrated circuit chips and digital systems. Verilog came into being as a proprietary language supported by a simulation environment that was the first to support mixed-level design representations co mprising switches, gates, RTL, and higher  levels of abstractions of digital circuits. The simulation environment provided a powerful  and uniform method to express digital designs as  well as tests that were meant to verify  such designs."
"Preface     During my earliest experience with Verilog HDL, I was looking for a book that could  give me a ""jump start"" on using Verilog HDL. I wanted to learn basic digital design  paradigms and the necessary Verilog HDL constructs that would help me build small digital circuits, using Verilog and run simula tions. After I had gained some experience  with building basic Verilog models, I wanted to  learn to use Verilog HDL to build larger  designs. At that time, I was searching for a book that broadly discussed advanced"
"Verilog-based digital design concepts and real digital design methodologies. Finally, when I had gained enough experience with digital design and verification of real IC  chips, though manuals of Veril og-based products were available, from time to time, I felt  the need for a Verilog HDL book that would act as a handy reference. A desire to fill this need led to the publication of the first edition of this book."
"The book presents a logical progression of Verilog HDL-based topics. It starts with the  basics, such as HDLbased design methodologies, and then gradually builds on the basics  to eventually reach advanced topics, such as PLI or logic synthesis. Thus, the book is  useful to Verilog users with varying levels of expertise as explained below.     • Students in logic design  courses at universities     • Part 1  of this book is ideal for a foundat ion semester course in Verilog HDLbased logic design. Students are exposed to hierarchical modeling concepts, basic"
"Verilog constructs and modeling techniques, and the necessary knowledge to  write small models and run simulations.     • New Verilog users in the industry     • Companies are moving to Verilog HDLbased design. Part 1  of this book is a  perfect jump start for designers who want to orient their skills toward HDL-based  design.     • Users with basic Verilog knowledge who need to understand advanced concepts     • Part 2  of this book discusses advanced concepts, such as UDPs, timing  simulation, PLI, and logic synthesis, which are necessary for graduation from  small Verilog models to larger designs.     • Verilog experts     • All Verilog topics are covered, from the basics modeling constructs to advanced  topics like PLIs, logic synthesis, and advanced verification techniques. For"
"Acknowledgments     The first edition of this book was written with the help of a great many people who  contributed their energies to this project. Fo llowing were the primary contributors to my  creation: John Sanguinetti, Stuart Sutherland, Clifford Cummings, Robert Emberley, Ashutosh Mauskar, Jack McKeown, Dr. Ar un Somani, Dr. Michael Ciletti, Larry Ke,"
"Sanghani, Kiran Buch, Anshuman Saha, Bill Fuchs, Babu Chilukuri, Ramana Kalapatapu, Karin Ellison and Rachel Borden. I would like to start by thanking all those  people once again.   For this second edition, I give special thanks to the following people who helped me with  the review process and provided valuable feedback:"
"Computer-Aided Design (CAD) tools refers to back-end tools that perform functions  related to place and route, and layout of the chip . The term Computer-Aided Engineering (CAE) tools refers to tools that are used for front-end processes such HDL simulation,  logic synthesis, and timing analysis. Designers used the terms CAD and CAE  interchangeably. Today, the term Electronic Design Automation is used for both CAD and CAE. For the sake of simplicity, in this book, we will refer to all design tools as EDA  tools.      With the advent of VLSI (Very Large Scale Integration) technology, designers could  design single chips with more than 100,000 transistors. Because of the complexity of  these circuits, it was not possible to verify these circuits on a breadboard. Computer-aided techniques became critical for verification and design of VLSI digital circuits."
"For a long time, programming languages such as FORTRAN, Pascal, and C were being used to describe computer programs that were sequential in nature. Similarly, in the  digital design field, designers felt the need for a standard language to describe digital  circuits. Thus, Hardware Description Langua ges (HDLs) came into existence. HDLs  allowed the designers to model the concurrency of processes found in hardware elements."
"Even though HDLs were popular for logic verification, designers had to manually  translate the HDL-based design into a schematic circuit with interconnections between gates. The advent of logic synthesis in the late 1980s changed the design methodology  radically. Digital circuits could be described at a register transfer level (RTL) by use of an HDL. Thus, the designer had to specify how the data flows between registers and how  the design processes the data. The details  of gates and their interconnections to  implement the circuit were automatically extracted by logic synthesis tools from the RTL  description."
"Thus, logic synthesis pushed the HDLs into the forefront of digital design. Designers no  longer had to manually place gates to build digital circuits. They could describe complex circuits at an abstract level in terms of functionality and data flow by designing those  circuits in HDLs. Logic synthesis tools would implement the specified functionality in  terms of gates and gate interconnections."
"A behavioral description is then created to analyze the design in terms of functionality,  performance, compliance to standards, and other high-level issues. Behavioral descriptions are often written with HDLs. [2]     [2] New EDA tools have emerged to simulate behavioral descriptions of circuits. These tools combine the powerful concepts from HDLs and object oriented languages such as"
"Logic synthesis tools ensure that the gate-level netlist meets timing, area, and power  specifications. The gate-level netlist is inpu t to an Automatic Place and Route tool, which  creates a layout. The layout is verified and then fabricated on a chip.      Thus, most digital design activity is c oncentrated on manually optimizing the RTL  description of the circuit. Af ter the RTL description is frozen, EDA tools are available to  assist the designer in further processes. Designing at the RTL level has shrunk the design cycle times from years to a few months. It is also possible to do many design iterations in  a short period of time."
"Logic synthesis tools can automatically convert the design to any fabrication  technology. If a new technology emerges, designers do not need to redesign their  circuit. They simply input the RTL desc ription to the logic synthesis tool and  create a new gate-level netlist, using the new fabrication technology. The logic  synthesis tool will optimize the circuit in area and timing for the new technology.   • By describing designs in HDLs, functional verification of the design can be done  early in the design cycle. Since designers work at the RTL level, they can  optimize and modify the RTL description until it meets the desired functionality."
"Most design bugs are eliminated at this po int. This cuts down design cycle time  significantly because the probability of hitting a functional bug at a later time in the gate-level netlist or physical layout is minimized.     • Designing with HDLs is analogous to computer programming. A textual  description with comments is an easier way to develop and debug circuits. This  also provides a concise representation of the design, compared to gate-level  schematics. Gate-level schematics are al most incomprehensible for very complex  designs.    HDL-based design is here to stay. With rapidly increasing complexities of digital circuits  and increasingly sophisticated EDA tools, HDLs are now the dominant method for large  digital designs. No digital circuit designer can afford to ignore HDL-based design.   [3] New tools and languages focused on verification have emerged in the past few years."
Verilog HDL has evolved as a standard hardware description language. Verilog HDL  offers many useful features    • Verilog HDL is a general-purpose hardware description language that is easy to  learn and easy to use. It is similar in syntax to the C programming language. Designers with C programming experience will find it easy to learn Verilog HDL.   • Verilog HDL allows different levels of abstraction to be mixed in the same model.
"Thus, a designer can define a hardware model in terms of switches, gates, RTL, or  behavioral code. Also, a designer needs to learn only one language for stimulus  and hierarchical design.     • Most popular logic synthesis tools support Verilog HDL. This makes it the  language of choice for designers.     • All fabrication vendors provide Verilog HDL libraries for postlogic synthesis  simulation. Thus, designing a chip in Verilog HDL allows the widest choice of vendors.     • The Programming Language Interface (PLI) is a powerful feature that allows the  user to write custom C code to interact with  the internal data structures of Verilog."
"The speed and complexity of digital circuits have increased rapidly. Designers have  responded by designing at higher levels of abstraction. Designers have to think only in terms of functionality. EDA tools take care of the implementation details. With designer  assistance, EDA tools have become sophisticated enough to achieve a close-to-optimum  implementation."
"The most popular trend currently is to design in HDL at an RTL level, because logic synthesis tools can create gate-level netlists from RTL level design. Behavioral synthesis  allowed engineers to design directly in terms of algorithms and the behavior of the  circuit, and then use EDA tools to do the translation and optimization in each phase of the design. However, behavioral synthesis did not gain widespread acceptance. Today, RTL  design continues to be very popular. Verilog HDL is also being constantly enhanced to  meet the needs of new verification methodologies."
"Formal verification and assertion checking techniques have emerged. Formal verification applies formal mathematical techniques to verify the correctness of Verilog HDL  descriptions and to establish equivalency be tween RTL and gate-level netlists. However,  the need to describe a design in Verilog HD L will not go away. Assertion checkers allow  checking to be embedded in the RTL code. This is a convenient way to do checking in the most important parts of a design.      New verification languages have also gained rapid acceptance. These languages combine  the parallelism and hardware constructs from HDLs with the object oriented nature of"
"For very high-speed and timing-critical circuits like microprocessors, the gate-level netlist provided by logic synthesis tools is not optimal. In such cases, designers often mix  gate-level description directly into the RTL description to achieve optimum results. This  practice is opposite to the high-level design paradigm, yet it is frequently used for high-speed designs because designers need to squeeze the last bit of timing out of circuits, and"
"EDA tools sometimes prove to be insufficient to achieve the desired results.                  25Another technique that is used for system-level design is a mixed bottom-up  methodology where the designers use either existing Verilog HDL modules, basic  building blocks, or vendor-supplied core blocks to quickly bring up their system simulation. This is done to reduce development costs and compress design schedules. For  example, consider a system that has a CPU, graphics chip, I/O chip, and a system bus."
"The CPU designers would build the next-generation CPU themselves at an RTL level, but they would use behavioral models for the graphics chip and the I/O chip and would buy a  vendor-supplied model for the system bus. Thus, the system-level simulation for the CPU  could be up and running very quickly and long before the RTL descriptions for the graphics chip and the I/O chip are completed.                                                                          26Chapter 2. Hierarchical Modeling"
"Concepts      Before we discuss the details of the Verilog language, we must first understand basic  hierarchical modeling concepts in digital de sign. The designer must use a ""good"" design  methodology to do efficient Verilog HDL-based design. In this chapter, we discuss typical design methodologies and illustrate how these concepts are translated to Verilog. A digital simulation is made up of various components. We talk about the components  and their interconnections."
"There are two basic types of digital design methodologies: a top-down design  methodology and a bottom-up design methodology. In a top-down design methodology, we define the top-level block and identify the sub-blocks necessary to build the top-level  block. We further subdivide the sub-blocks until we come to leaf cells, which are the  cells that cannot further be divided. Figure 2-1  shows the top-down design process."
"Typically, a combination of top-down and bottom-up flows is used. Design architects define the specifications of the top-level block. Logic designers decide how the design  should be structured by breaking up the functi onality into blocks and sub-blocks. At the  same time, circuit designers are designing optimized circuits for leaf-level cells. They build higher-level cells by using these leaf cells. The flow meets at an intermediate point  where the switch-level circuit designers have created a library of leaf cells by using          28switches, and the logic level designers have designed from top-down until all modules are  defined in terms of leaf cells."
"Specifically, the T-flipflop could be defined as a       Verilog is both a behavioral and a structural language. Internals of each module can be  defined at four levels of abstraction, depending on the needs of the design. The module behaves identically with the external environm ent irrespective of the level of abstraction  at which the module is described. The internals of the module are hidden from the environment. Thus, the level of abstraction to describe a module can be changed without  any change in the environment. These levels will be studied in detail in separate chapters  later in the book. The levels are defined below.                31• Behavioral or algorithmic level     • This is the highest level of abstraction provided by Verilog HDL. A module can  be implemented in terms of the desired design algorithm without concern for the hardware implementation details. Designing at this level is very similar to C  programming.     • Dataflow level     • At this level, the module is designed by specifying the data flow. The designer is  aware of how data flows between hardware registers and how the data is  processed in the design.     • Gate level     • The module is implemented in terms of logic gates and interconnections between  these gates. Design at this level is similar to describing a design in terms of a  gate-level logic diagram.     • Switch level     • This is the lowest level of abstraction provided by Verilog. A module can be  implemented in terms of switches, storage nodes, and the interconnections  between them. Design at this level requires knowledge of switch-level  implementation details."
"Verilog allows the designer to mix and match all four levels of abstractions in a design. In the digital design community, the term regist er transfer level (RTL)  is frequently used  for a Verilog description that uses a combination of behavioral and dataflow constructs  and is acceptable to logic synthesis tools."
"The second style of applying stimulus is to instantiate both the stimulus and design blocks in a top-level dummy module. The stimulus block interacts with the design block only through the interface. This style of applying stimulus is shown in Figure 2-7 . The  stimulus module drives the signals d_clk and d_reset, which are connected to the signals  clk and reset in the design block. It also checks and displays signal c_q, which is connected to the signal q in the design block. The function of top-level block is simply to  instantiate the design and stimulus blocks."
"In this chapter we discussed the following concepts.      • Two kinds of design methodologies are used for digital design: top-down and  bottom-up. A combination of these two methodologies is used in today's digital designs. As designs become very complex, it is important to follow these  structured approaches to manage the design process.     • Modules are the basic building blocks in Verilog. Modules are used in a design by  instantiation. An instance of a module has a unique identity and is different from other instances of the same module. Each instance has an independent copy of the  internals of the module. It is importan t to understand the difference between  modules and instances.     • There are two distinct components in a simulation: a design block and a stimulus  block. A stimulus block is used to test the design block. The stimulus block is  usually the top-level block. There are two different styles of applying stimulus to a design block.     • The example of the ripple carry counter explains the step-by-step process of  building all the blocks required in a simulation."
"In this chapter, we discuss the basic cons tructs and conventions in Verilog. These  conventions and constructs are used throughout the later chapters. These conventions  provide the necessary framework for Verilog HDL. Data types in Verilog model actual  data storage and switch elements in hardware very closely. This chapter may seem dry, but understanding these concepts is a necessary foundation for the successive chapters."
"Learning Objectives      • Understand lexical conventions for operators, comments, whitespace, numbers,  strings, and identifiers.     • Define the logic value set and data types such as nets, registers, vectors, numbers,  simulation time, arrays, para meters, memories, and strings.     • Identify useful system tasks for displaying and monitoring information, and for  stopping and finishing the simulation.     • Learn basic compiler directives to define macros and include files.                3.1 Lexical Conventions"
"A question mark ""?"" is the Verilog HDL alternat ive for z in the context of numbers. The ?  is used to enhance readability in the casex and casez statements discussed in Chapter 7 ,  where the high impedance value is a don't care condition. (Note that ? has a different  meaning in the context of user-defined primitives, which are discussed in Chapter 12 ,"
"If two signals of unequal strengths are driven on a wire, the stronger signal prevails. For  example, if two signals of strength strong1 and weak0 contend, the result is resolved as a strong1. If two signals of equal strengths are driven on a wire, the result is unknown. If  two signals of strength strong1 and strong0 conflict, the result is an x. Strength levels are  particularly useful for accurate modeling of signal contention, MOS devices, dynamic MOS, and other low-level devi ces. Only trireg nets can have storage strengths large,  medium, and small. Detailed information about strength modeling is provided in"
"Nets are declared primarily with the keyword wire. Nets are one-bit values by default  unless they are declared explicitly as vectors. The terms wire and net are often used  interchangeably. The default value of a net is z (except the trireg net, which defaults to x ). Nets get the output value of their drivers. If a net has no driver, it gets the value z.     wire a; // Declare net a for the above circuit  wire b,c; // Declare two wires b,c for the above circuit  wire d = 1'b0; // Net d is fixed to logic value 0 at declaration.      Note that net is not a keyword but represents a class of data types such as wire, wand,  wor, tri, triand, trior, trireg , etc. The wire declaration is used most frequently. Other net  declarations are discussed in Appendix A , Strength Modeling and Advanced Net"
"Registers represent data storage elements. Re gisters retain value until another value is  placed onto them. Do not confuse the term re gisters in Verilog with hardware registers  built from edge-triggered flipflops in real ci rcuits. In Verilog, the term register merely          47means a variable that can hold a value. Unlike a net, a register does not need a driver."
"Integers are declared by the keyword integer. Although it is possible to use reg as a  general-purpose variable, it is more convenient to declare an integer variable for purposes  such as counting. The default width for an integer is the host-machine word size, which is  implementation-specific but is at least 32 bits. Registers declared as data type reg store values as unsigned quantities, whereas integers store values as signed quantities.     integer counter; // general purpose variable used as a counter.  initial     counter = -1; // A negative one is stored in the counter"
Verilog simulation is done with respect to si mulation time. A special time register data  type is used in Verilog to store simulation time. A time variable is declared with the  keyword time. The width for time register data types is implementation-specific but is at  least 64 bits.The system function $time is invoked to get the current simulation time.     time save_sim_time; // Define a time variable save_sim_time  initial      save_sim_time = $time; // Save the current simulation time          50
"Verilog provides standard system tasks for certain routine operations. All system tasks  appear in the form $<keyword>. Operations such as displaying on the screen, monitoring values of nets, stopping, and finishing are done by system tasks. We will discuss only the  most useful system tasks. Other tasks are listed in Verilog manuals provided by your  simulator vendor or in the IEEE Standard Verilog Hardware Description Language specification."
"Displaying information       $display is the main system task for disp laying values of variables or strings or  expressions. This is one of the most useful tasks in Verilog.      Usage: $display(p1, p2, p3,....., pn);      p1, p2, p3,..., pn can be quoted strings or variables or expressions. The format of $display  is very similar to printf in C. A $display inserts a newline at the end of the string by  default. A $display without any arguments produces a newline."
"The parameters p1, p2, ... , pn can be variable s, signal names, or quoted strings. A format  similar to the $display task is used in the $monitor task. $monitor continuously monitors the values of the variables or signals specified in the parameter list and displays all  parameters in the list whenever the value of any one variable or signal changes. Unlike  $display, $monitor needs to be invoked only once."
The $stop task puts the simulation in an in teractive mode. The designer can then debug  the design from the interactive mode. The $sto p task is used whenever the designer wants  to suspend the simulation and examine the values of signals in the design.      The $finish task terminates the simulation.
"The `include directive allows you to include en tire contents of a Verilog source file in  another Verilog file during compilation. This works similarly to the #include in the C  programming language. This directive is typi cally used to include header files, which  typically contain global or commonly used definitions (see Example 3-8 )."
"To understand the components of a  statement  endmodule   // Module name and port list // Stimulus module module Top;   // Declarations of wire, reg, and other variables          64wire q, qbar;  reg set, reset;   // Instantiate lower-level  statement  end statement but does not contain port list, port declarations,  and data flow (assign) statements.     • Thus, all parts except  are optional and can  be mixed and matched as per design needs.                4.2 Ports"
"Notice that in the above figure, the module Top is a top-level module. The module fulladd4 is instantiated below Top. The module fulladd4 takes input on ports a, b, and  c_in and produces an output on ports sum and c_out. Thus, module fulladd4 performs an  addition for its environment. The module Top is a top-level module in the simulation and does not need to pass signals to or receive signals from the environment. Thus, it does not  have a list of ports. The module names and po rt lists for both module declarations in"
"One can visualize a port as consisting of two units, one unit that is internal to the module  and another that is external to the module. The internal and external units are connected. There are rules governing port connections when modules are instantiated within other  modules. The Verilog simulator complains if  any port connection rules are violated."
"Verilog allows ports to remain unconnected. For example, certain output ports might be simply for debugging, and you might not be interested in connecting them to the external  signals. You can let a port remain unconnected by instantiating a module as shown  below.    fulladd4 fa0(SUM, , A, B, C_IN); // Output port c_out is unconnected"
"We described earlier how Verilog supports a hierarchical design methodology. Every  module instance, signal, or variable is defined with an identifier. A particular identifier has a unique place in the design hierarchy. Hierarchical name referencing allows us to  denote every identifier in the design hierarchy with a unique name. A hierarchical name  is a list of identifiers separated by dots (""."") for each level of hierarchy. Thus, any identifier can be addressed from any place in  the design by simply specifying the  complete hierarchical na me of that identifier."
"In the earlier chapters, we laid the foundations of Verilog design by discussing design methodologies, basic conventions and constructs, modules and port interfaces. In this  chapter, we get into modeling actual hardware circuits in Verilog.     We discussed the four levels of abstraction used to describe hardware. In this chapter, we  discuss a design at a low level of abstraction?gate level. Most digital design is now done  at gate level or higher levels of abstraction. At gate level, the circuit is described in terms  of gates (e.g., and, nand). Hardware design at this level is intuitive for a user with a basic  knowledge of digital logic design because it is possible to see a one-to-one  correspondence between the logic circuit diagra m and the Verilog description. Hence, in  this book, we chose to start with gate-level modeling and move to higher levels of  abstraction in the succeeding chapters.      Actually, the lowest level of abstraction is switch(transistor-) level modeling. However,  with designs getting very comp lex, very few hardware designe rs work at switch level."
And/or gates have one scalar output and multi ple scalar inputs. The first terminal in the  list of gate terminals is an output and the other terminals are inputs. The output of a gate is evaluated as soon as one of the inputs changes. The and/or gates available in Verilog  are shown below.     and     or       xor  nand    nor      xnor      The corresponding logic symbols for these gates are shown in Figure 5-1 . We consider  gates with two inputs. The output terminal is denoted by out. Input terminals are denoted  by i1 and i2.
Buf/not gates have one scalar input and one or more scalar outputs. The last terminal in  the port list is connected to the input. Other terminals are connected to the outputs. We will discuss gates that have one input and one output.      Two basic buf/not gate primitives are provided in Verilog.    buf         not
They can also be used to implement boolean functions. We will assume for this example that signals s1 and s0 do not get the value x or z. The I/O diagram and the truth table for  the multiplexer are shown in Figure 5-4 . The I/O diagram will be useful in setting up the  port list for the multiplexer.
"Example 5-6 Stimulus for Multiplexer     // Define the stimulus module (no ports)  module stimulus;   // Declare variables to be connected // to inputs reg IN0, IN1, IN2, IN3;          84reg S1, S0;   // Declare output wire  wire OUTPUT;   // Instantiate the multiplexer mux4_to_1 mymux(OUTPUT, IN0, IN1, IN2, IN3, S1, S0);   // Stimulate the inputs  // Define the stimulus       The output of the simulation is shown below. Each combination of the select signals is  tested."
"The turn-off delay is associated with a gate  output transition to the high impedance value  (z) from another value.               89If the value changes to x, the minimu m of the three delays is considered.      Three types of delay specifications are allowed. If only one delay is specified, this value  is used for all transitions. If two delays are sp ecified, they refer to the rise and fall delay  values. The turn-off delay is the minimum of the two delays. If all three delays are specified, they refer to rise, fall, and turn-off delay values. If no delays are specified, the  default value is zero. Examples of delay specification are shown in Example 5-10 ."
"For each type of delay?rise, fall, and turn-off?three values, min, typ, and max, can be specified. Any one value can be chosen at the start of the simulation. Min/typ/max values  are used to model devices whose delays vary within a minimum and maximum range  because of the IC fabrication process variations."
"Min, typ, or max values can be chosen at Verilog run time. Method of choosing a  min/typ/max value may vary for different simulators or operating systems. (For Verilog-XL , the values are chosen by specifying options +maxdelays, +typdelays, and  +mindelays at run time. If no option is speci fied, the typical delay value is the default)."
"In this chapter, we discussed how to model gate-level logic in Verilog. We also discussed  different aspects of gate-level design.      • The basic types of gates are and, or, xor, buf, and not. Each gate has a logic  symbol, truth table, and a correspondin g Verilog primitive. Primitives are  instantiated like modules except that they are predefined in Verilog. The output of a gate is evaluated as soon as one of its inputs changes.     • Arrays of built-in primitive instances and user-defined modules can be defined in"
"Each step of the design process was explained.     • Three types of delays are associated with gates: rise, fall, and turn-off. Verilog  allows specification of one, two, or three delays for each gate. Values of rise, fall,  and turn-off delays are computed by Ver ilog, based on the one, two, or three  delays specified.     • For each type of delay, a minimum, typical, and maximum value can be specified."
"Construct an xor module in Verilog that realizes the logic function, z = xy' + x'y. Inputs are x and y, and z is the output. Write a stimulus module that  exercises all four combinations of x and y inputs.  3: The 1-bit full adder described in the chapter can be expressed in a sum of  products form.    sum = a.b.c_in + a'.b.c_in' + a'.b'.c_in + a.b'.c_in'    c_out = a.b + b.c_in + a.c_in"
"Also, gate-level modeling is very intuitive to a designer with a basic knowledge of digital  logic design. However, in complex designs the number of gates is very large. Thus, designers can design more effectively if they concentrate on implementing the function at a level of abstraction higher than gate level. Dataflow modeling provides a powerful way  to implement a design. Verilog allows a circuit to be designed in terms of the data flow  between registers and how a design processes data rather than instantiation of individual gates. Later in this chapter, the benefits of dataflow modeling will become more apparent.     With gate densities on chips increasing rapidly, dataflow modeling has assumed great  importance. No longer can companies devote engineering resources to handcrafting entire  designs with gates. Currently, automated tools are used to create a gate-level circuit from a dataflow design description. This process is called logic synthesis. Dataflow modeling  has become a popular design approach as logic synthesis tools have become  sophisticated. This approach allows the designer to concentrate on optimizing the circuit in terms of data flow. For maximum flexibility in the design process, designers typically  use a Verilog description style that combines the concepts of gate-level, data flow, and  behavioral design. In the digital design community, the term RTL (Register Transfer Level) design is commonly used for a combination of dataflow modeling and behavioral  modeling."
"A continuous assignment is the most basic statement in dataflow modeling, used to drive  a value onto a net. This assignment replaces gates in the description of the circuit and describes the circuit at a higher level of abstraction. The assignment statement starts with  the keyword assign. The syntax of an assign statement is as follows.     continuous_assign ::= assign [ drive_strength ] [ delay3 ]                        list_of_net_assignments ;  list_of_net_assignments ::= net_assignment { , net_assignment }  net_assignment ::= net_lvalue = expression"
Registers or nets can be scalars or vectors.     4. Delay values can be specified for assignment s in terms of time units. Delay values  are used to control the time when a net is assigned the evaluated value. This  feature is similar to specifying delays for gates. It is very useful in modeling  timing behavior in real circuits.
"Instead of declaring a net and then writing a continuous assignment on the net, Verilog provides a shortcut by which a continuous assignment can be placed on a net when it is  declared. There can be only one implicit declaration assignment per net because a net is  declared only once."
"A delay can be specified on a net when it is declared without putting a continuous assignment on the net. If a delay is specified on a net out, then any value change applied  to the net out is delayed accord ingly. Net declaration delays can also be used in gate-level  modeling.     //Net Delays  wire # 10 out; assign out = in1 & in2;   //The above statement has the same effect as the following. wire out;  assign #10 out = in1 & in2;"
"Verilog provides many different operator types. Operators can be arithmetic, logical,  relational, equality, bitwise, reduction, shift, concatenation, or conditional. Some of these  operators are similar to the operators used in the C programming language. Each operator  type is denoted by a symbol. Table 6-1  shows the complete listing of operator symbols  classified by category."
"Relational operators are greater-than (>), lessthan (<), greater-than-or-equal-to (>=), and  less-than-or-equal-to (<=). If  relational operators are used in an expression, the  expression returns a logical value of 1 if the expression is true and 0 if the expression is  false. If there are any unknown or z bits in the operands, the expression takes a value x."
"Usage: condition_expr ? true_expr : false_expr ;    The condition expression (condition_expr) is first evaluated. If the result is true (logical  1), then the true_expr is evaluated. If the result  is false (logical 0), then the false_expr is  evaluated. If the result is x (ambiguous), th en both true_expr and false_expr are evaluated  and their results are compared, bit by bit, to re turn for each bit position an x if the bits are  different and the value of the bits if they are the same.     The action of a conditional operator is simila r to a multiplexer. Alternately, it can be  compared to the if-else expression."
"In ripple carry adders, the carry must propagate through the gate levels before the sum is available at the output terminals. An nbit ripple carry adder will have 2n gate levels. The  propagation time can be a limiting factor on the speed of the circuit. One of the most  popular methods to reduce delay is to use a carry lookahead mechanism. Logic equations for implementing the carry lookahead mechanism can be found in any logic design book.     The propagation delay is reduced to four gate levels, irrespective of the number of bits in  the adder. The Verilog description for a carry lookahead adder is shown in Example 6-5 ."
"A continuous assignment is always active and the assignment expression is evaluated as soon as one of the right-hand-side variables changes. The left-hand  side of a continuous assignment must be a net. Any logic function can be realized with continuous assignments.     • Delay values control the time between the change in a right-hand-side variable  and when the new value is assigned to the left-hand side. Delays on a net can be  defined in the assign statement, implicit continuous assignment, or net declaration.     • Assignment statements contain expressions, operators, and operands.     • The operator types are arithmetic, logical, relational, equality, bitwise, reduction,  shift, concatenation, replication, and conditional. Unary operators require one  operand, binary operators require two operands, and ternary require three operands. The concatenation operator can take any number of operands.     • The conditional operator behaves like a mu ltiplexer in hardware or like the ifthen-else statement in programming languages.     • Dataflow description of a circuit is more concise than a gate-level description."
"The magnitude can be compared by comparing the numbers bit by bit, starting with the most significant bit. If any bit mismatches, the number with bit 0 is the          124lower number. To realize this functionality in logic equations, let us define an  intermediate variable. Notice that the function below is an xnor function.     x(i) = A(i).B(i) + A(i)'.B(i)'"
"Design a 4-bit synchronous counter. Circuit diagrams for the synchronous counter and the JK flipflop are given below.  The clear signal is active low. Data  gets latched on the positive edge of clock,  and the output of the flipflop appears  on the negative edge of clock. Counting is disabled when count_enable signal is low. Write the dataflow description for the synchronous counter. Write a  stimulus file that exercises clear and count_enable. Display the output count"
"With the increasing complexity of digital design, it has become vitally important to make wise design decisions early in a project. Designers need to be able to evaluate the tradeoffs of various architectures and algorithms before they decide on the optimum  architecture and algorithm to implement in ha rdware. Thus, architectural evaluation takes  place at an algorithmic level where the designers do not necessarily think in terms of logic gates or data flow but in terms of the algorithm they wish to implement in  hardware. They are more concerned about the behavior of the algorithm and its  performance. Only after the high-level architecture and algorithm are finalized, do designers start focusing on building the digital circuit to implement the algorithm.      Verilog provides designers the ability to describe design functionality in an algorithmic  manner. In other words, the designer describes the behavior of the circuit. Thus,  behavioral modeling represents the circuit at a very high level of abstraction. Design at this level resembles C programming more th an it resembles digital circuit design."
"All statements inside an initial statement constitu te an initial block. An initial block starts  at time 0, executes exactly once during a simulation, and then does not execute again. If there are multiple initial blocks, each block starts to execute concurrently at time 0. Each  block finishes execution independently of other blocks. Multiple behavioral statements  must be grouped, typically using the keywords begin and end. If there is only one behavioral statement, grouping is not necessary. This is similar to the begin-end blocks in"
"The initial blocks are typically used for init ialization, monitoring, waveforms and other  processes that must be executed only once during the entire simulation run. The  following subsections discussion how to initialize values using alternate shorthand  syntax. The use of such shorthand syntax has the same effect as an initial block combined with a variable declaration."
"Blocking assignment statements are executed in the order they are specified in a sequential block. A blocking assignment will not block execution of statements that  follow in a parallel block. Both parallel and sequential blocks are discussed in Section  7.7, Sequential and Parallel Blocks. The = operator is used to specify blocking  assignments."
"Having described the behavior of nonblocking assignments, it is important to understand  why they are used in digital design. They are used as a method to model several          134concurrent data transfers that take place after a common event. Consider the following  example where three concurrent data transfers take place at the positive edge of clock.     always @(posedge clock)  begin      reg1 <= #1 in1;     reg2 <= @(negedge clock) in2 ^ in3;      reg3 <= #1 reg1; //The old value of reg1 end"
Example 7-9 Implementing Nonblocking As signments using Blocking Assignments     //Emulate the behavior of nonblocking assignments by  //using temporary variables and blocking assignments always @(posedge clock)  begin     //Read operation     //store values of right-hand-side expressions in temporary variables     temp_a = a;     temp_b = b;      //Write operation      //Assign values of temporary variables to left-hand-side variables      a = temp_b;      b = temp_a; end
"Intra-assignment delay control      Instead of specifying delay control to the left of the assignment, it is possible to assign a  delay to the right of the assignment operator. Such delay specification alters the flow of  activity in a different manner. Example 7-11  shows the contrast between intra-assignment  delays and regular delays."
Note the difference between intra-assignment  delays and regular delays. Regular delays  defer the execution of the entire assignment. Intra-assignment delays compute the righthand-side expression at the current time and defer the assignment of the computed value to the left-hand-side variable. Intra-assignment delays are like using regular delays with a  temporary variable to store the current value of a right-hand-side expression.
"Zero delay control      Procedural statements in different always-initial blocks may be evaluated at the same simulation time. The order of execution of these statements in different always-initial  blocks is nondeterministic. Zero delay control is a method to ensure that a statement is  executed last, after all other statements in that simulation time are executed. This is used to eliminate race conditions. However, if there are multiple zero delay statements, the  order between them is nondeterministic. Example 7-12  illustrates zero delay control."
"An event is the change in the value on a register or a net. Events can be utilized to trigger  execution of a statement or a block of statements. There are four types of event-based          139timing control: regular event control, named event control, event OR control, and levelsensitive timing control."
Named event control      Verilog provides the capability to declare an event and then trigger and recognize the occurrence of that event (see Example 7-14 ). The event does not hold any data. A named  event is declared by the keyword event. An event is triggered by the symbol ->. The  triggering of the event is recognized by the symbol @.
"When the number of input variables to a combination logic block are very large,  sensitivity lists can become very cumbersome to  write. Moreover, if an input variable is          141missed from the sensitivity list, the block will not behave like a combinational logic  block. To solve this problem, Verilog HDL contains two special symbols: @* and @(*)."
"Event control discussed earlier waited for the change of a signal value or the triggering of an event. The symbol @ provided edge-sens itive control. Verilog also allows levelsensitive timing control, that is, the ability to wait for a certain condition to be true before  a statement or a block of statements is executed. The keyword wait is used for level-sensitive constructs.     always      wait (count_enable) #20 count = count + 1;"
"The keyword repeat is used for this loop. The repeat construct executes the loop a fixed number of times. A repeat construct cannot be used to loop on a general logical  expression. A while loop is used for that purpose. A repeat construct must contain a number, which can be a constant, a variable or a signal value. However, if the number is  a variable or signal value, it is evaluated only when the loop starts and not during the loop  execution."
"The keyword forever is used to express this loop. The loop does not contain any expression and executes forever until the $f inish task is encountered. The loop is  equivalent to a while loop with an expression  that always evaluates to true, e.g., while  (1). A forever loop can be exited by use of the disable statement."
"A forever loop is typically used in conjunction with timing control constructs. If timing  control constructs are not used, the Verilog simulator would execute this statement infinitely without advancing simulation time and the rest of the design would never be  executed. Example 7-25  explains the use of the forever statement."
"Parallel blocks, specified by keywords fork and join, provide interesting simulation features. Parallel blocks have the following characteristics:     • Statements in a parallel block are executed concurrently.     • Ordering of statements is controlled by the delay or event control assigned to each  statement.     • If delay or event control is specified, it is relative to the time the block was  entered."
"Blocks can be given names.     • Local variables can be declared for the named block.     • Named blocks are a part of the design hierarchy. Variables in a named block can  be accessed by using hierarchical name referencing.     • Named blocks can be disabled, i.e., their execution can be stopped."
"Example 7-29 Named Blocks     //Named blocks  module top;    initial begin: block1 //sequential block named block1  integer i; //integer i is static and local to block1             // can be accessed by hierarchical name, top.block1.i  ...  ... end    initial  fork: block2 //parallel block named block2  reg i; // register i is static and local to block2                 // can be accessed by hierarchical name, top.block2.i  ...  ...  join"
"Disabling named blocks      The keyword disable provides a way to terminate the execution of a named block. disable can be used to get out of loop s, handle error conditions, or c ontrol execution of pieces of  code, based on a control signal. Disabling a block causes the execution control to be  passed to the statement immediately succeeding the block. For C programmers, this is very similar to the break statement used to exit a loop. The difference is that a break          155statement can break the current loop only, whereas the keyword disable allows disabling  of any named block in the design."
"Generated variable declarations and instantia tions can be multiply instantiated into a  design. Generated instances have unique identifier names and can be referenced  hierarchically. To support interconnection between structural elements and/or procedural  blocks, generate statements permit the following Verilog data types to be declared within the generate scope:     • net, reg     • integer, real, time, realtime     • event"
"Generated data types have unique identifier names and can be referenced hierarchically.                157Parameter redefinition using ordered or name d assignment or a defparam statement can  be declared with the generate scope. However, a defparam statement within a generate  scope is allowed to modify the value of a parameter only in the same generate scope or within the hierarchy instantiated within the generate scope.      Task and function declarations are permitted within the generate scope but not within a  generate loop. Generated tasks and functions have unique identifier names and can be  referenced hierarchically."
"A generate conditional is like an if-else-if generate construct that permits the following Verilog constructs to be conditionally instantiated into another module based on an  expression that is deterministic at the time the design is elaborated:     • Modules     • User defined primitives, Gate primitives     • Continuous assignments     • initial and always blocks"
"A generate case permits the following Verilog constructs to be conditionally instantiated  into another module based on a select-one-ofmany case construct that is deterministic at  the time the design is elaborated:     • Modules     • User defined primitives, Gate primitives     • Continuous assignments     • initial and always blocks       Example 7-34  shows the implementation of an N-bit adder using a generate case block."
"The following specifications must be considered:    • The traffic signal for the main highway gets highest priority because cars are  continuously present on the main highway. Thus, the main highway signal remains green by default.     • Occasionally, cars from the country road arrive at the traffic signal. The traffic  signal for the country road must turn green only long enough to let the cars on the  country road go.     • As soon as there are no cars on the country road, the country road traffic signal  turns yellow and then red and the traffic signal on the main highway turns green  again.     • There is a sensor to detect cars waiting on the country road. The sensor sends a  signal X as input to the controller. X = 1 if there are cars on the country road; otherwise, X= 0.     • There are delays on transitions from S1 to S2, from S2 to S3, and from S4 to S0."
We discussed digital circuit design with behavioral Verilog constructs.     • A behavioral description expresses a digital circuit in terms of the algorithms it  implements. A behavioral description does not necessarily include the hardware  implementation details. Behavioral modeling is used in the initial stages of a  design process to evaluate various design-related trade-offs. Behavioral modeling  is similar to C programming in many ways.     • Structured procedures initial and always form the basis of behavioral modeling.
A designer is frequently required to implement the same functionality at many places in a behavioral design. This means that the commonly used parts should be abstracted into  routines and the r outines must be invoked instead of repeating the code. Most  programming languages provide procedures or subroutines to accomplish this. Verilog provides tasks and functions to break up large behavioral designs into smaller pieces. Tasks and functions allow the designer to abstract Verilog code that is used at many  places in the design.
"Functions must have at least one input argument. They can have more than one input. Tasks may have zero or more arguments of  type input, output, or inout.  unctions always return a single value. They cannot have output or inout  arguments. Tasks do not return with a value, but can  pass multiple values through output and  inout arguments.   Both tasks and functions must be defined in a module and are local to the module. Tasks  are used for common Verilog code that contains delays, timing, event constructs, or multiple output arguments. Functions are used when common Verilog code is purely  combinational, executes in zero simulation time, and provides exactly one output."
"I/O declarations use keywords input, output, or inout, based on the type of argument  declared. Input and inout arguments are passed into the task. Input arguments are processed in the task statements. Output and inout argument values are passed back to the  variables in the task invocation statement wh en the task is completed. Tasks can invoke  other tasks or functions."
"In the above task, the input values passed to the task are A and B. Hence, when the task is  entered, a = A and b = B. The three output values are computed after a delay. This delay is specified by the parameter delay, which is 10 units for this example. When the task is  completed, the output values are passed back to the calling output arguments. Therefore,"
"Tasks are normally static in nature. All declared items are statically allocated and they are  shared across all uses of the task executing concurrently. Therefore, if a task is called concurrently from two places in the code, th ese task calls will oper ate on the same task  variables. It is highly likely that the results of such an operation will be incorrect."
"To avoid this problem, a keyword automatic is added in front of the task keyword to  make the tasks re-entrant. Such tasks are called automatic tasks. All items declared inside automatic tasks are allocated dynamically for ea ch invocation. Each task call operates in  an independent space. Thus, the task calls operate on independent copies of the task  variables. This results in correct operation.  It is recommended that automatic tasks be  used if there is a chance that a task might be called concurrently from two locations in the code.      Example 8-5  shows how an automatic task is defined and used."
"Example 8-6 Syntax for Functions     function_declaration ::=              function [ automatic ] [ signed ] [ range_or_type ]             function_identifier ;              function_item_declaration { function_item_declaration }              function_statement              endfunction             | function [ automatic ] [ signed ] [ range_or_type ]             function_identifier (function_port_list ) ;              block_item_declaration { block_item_declaration }              function_statement              endfunction  function_item_declaration ::=           block_item_declaration          | tf_input_declaration ;  function_port_list ::= { attribute_instance } tf_input_declaration {,                         { attribute_instance } tf_input_declaration }  range_or_type ::= range | integer | real | realtime | time"
"There are some peculiarities of functions. When a function is declared, a register with name function_identifer is decl ared implicitly inside Verilog. The output of a function is  passed back by setting the value of the re gister function_identifer appropriately. The  function is invoked by specifying function name and input arguments. At the end of function execution, the return value is placed where the function was invoked. The  optional range_or_type specifies the width of the internal register. If no range or type is          183specified, the default bit width is 1. Functions are very similar to FUNCTION in"
"We studied procedural assignments in Section 7.2 , Procedural Assignments. Procedural  assignments assign a value to a register. The value stays in the register until another  procedural assignment puts another value in that register. Procedural continuous  assignments behave differently. They are procedural statements which allow values of  expressions to be driven continuously onto registers or nets for limited periods of time. Procedural continuous assignments override existing assignments to a register or net."
"If multiple parameters are defined in the module,  during module instantiation, they can be  overridden by specifying the new values in the same order as the parameter declarations in the module. If an overriding value is no t specified, the default parameter declaration  values are taken. Alternately, one can override specific values by naming the parameters          196and the corresponding values. This is called parameter value assignment by name."
"A portion of Verilog might be suitable for one environment but not for another. The  designer does not wish to create two versions of Verilog design for the two environments. Instead, the designer can specify that the particular portion of the code be compiled only  if a certain flag is set. This is called conditional compilation."
"Verilog. We discuss system tasks [1] for file output, displaying hierarchy, strobing,  random number generation, memory initialization, and value change dump.    [1] Other system tasks such as $signed and $unsigned used for sign conversion are not discussed in this book. For details, please refer to the ""IEEE Standard Verilog Hardware"
"Opening a file      A file can be opened with the system task $fopen.      Usage: $fopen(""<name_of_file>""); [2]     [2] The ""IEEE Standard Verilog Hardware Description Language"" document provides additional capabilities for $fopen . The $fopen syntax mentioned in this book is adequate  for most purposes. However, if you need additi onal capabilities, please refer to the ""IEEE"
"Note that these tasks are similar in syntax to regular system tasks $display, $monitor, etc., but they provide the additional capability of writing to files.    [4] The ""IEEE Standard Verilog Hardware Description Language"" document provides many additional capabilities for file output. Th e file output system tasks mentioned in this book are adequate for most digital designers. However, if you need additional capabilities  for file output, please refer to the IEEE Standard Verilog Hardware Description"
"Systems tasks for reading files are also provided by the IEEE Standard Verilog Hardware Description Language. These system tasks include $fgetc, $ungetc, $fgetc, $fscanf,  $sscanf, $fread, $ftell, $fseek, $rewind, and $fflush. However, most digital designers do  not need these capabiliti es frequently. Therefore, they ar e not covered in this book. If you  need to use the file reading capabilities, please refer to the ""IEEE Standard Verilog"
"Strobing is done with the system task keyword $strobe. This task is very similar to the $display task except for a slight difference. If many other statements are executed in the  same time unit as the $display task, the order in which the statements and the $display  task are executed is nondeterministic. If $strobe  is used, it is always executed after all  other assignment statements in the same time unit have executed. Thus, $strobe provides  a synchronization mechanism to ensure that data is displayed only after all other  assignment statements, which change the data in that time step, have executed. See Example 9-11 ."
"The $dumpfile and $dumpvars tasks are normally specified at the beginning of the simulation. The $dumpon, $dumpoff, and $dumpall control the dump process during the  simulation. [5]     [5] Please refer to ""IEEE Standard Veril og Hardware Description Language"" document  for details on additional tasks such as $dumpports, $dumpportsoff, $dumpportson, $dumpportsall, $dumpportslimit, and $dumpportsflush.      Postprocessing tools with graphical displays are commercially available and are now an important part of the simulation and debug process. For large simulation runs, it is very  difficult for the designer to analyze the output from $display or $monitor statements. It is  more intuitive to analyze results from gra phical waveforms. Form ats other than VCD  have also emerged, but VCD still remain s the popular dump format for Verilog  simulators."
"In this chapter, we discussed the following aspects of Verilog:    • Procedural continuous assignments can be used to override the assignments on  registers and nets. assign and deassign can override assignments on registers.  force and release can override assignments on registers and nets. assign and  deassign are used in the actual design. force and release are used for debugging.     • Parameters defined in a module can be overridden with the defparam statement or  by passing a new value during module instantiation. During module instantiation, parameter values can be assigned by ordered list or by name. It is recommended  to use parameter assignment by name.     • Compilation of parts of the design can be made conditional by using the 'ifdef,  'ifndef, 'elsif, 'else, and 'endif directives. Compilation flags are defined at compile  time by using the `define statement.   •     • Execution is made conditional in Verilog simulators by means of the  $test$plusargs system task. The execution flags are defined at run time by  +<flag_name>.     • Up to 30 files can be opened for writing in Verilog. Each file is assigned a bit in  the multichannel descriptor. The multichannel descriptor concept can be used to  write to multiple files. The IEEE St andard Verilog Hard ware Description"
Language document describes more advanced ways of doing file I/O.     • Hierarchy can be displayed with the %m option in any display statement.     • Strobing is a way to display values at a certain time or event after all other  statements in that time unit have executed.     • Random numbers can be generated with th e system task $random. They are used  for random test vector generation. $random task can generate both positive and  negative numbers.     • Memory can be initialized from a data file. The data file contains addresses and  data. Addresses can also be specified in memory initialization tasks.    Value Change Dump is a popular format used by many designers for debugging with  postprocessing tools. Verilog allows all or selected module variables to be dumped to the
"However, blocks in real hardware have delays associated with the logic elements and paths in them. Therefore, we must also check whether the circuit meets the timing  requirements, given the delay specifications for the blocks. Checking timing requirements  has become increasingly important as circuits have become smaller and faster. One of the ways to check timing is to do a timing simulation that accounts for the delays associated with the block during the simulation.      Techniques other than timing simulation to verify timing have also emerged in design  automation industry. The most popular technique  is static timing verification. Designers  first do a pure functional verification and then verify timing separately with a static timing verification tool. The main advantage of static verification is that it can verify  timing in orders of magnitude more quickly than timing simulation. Static timing  verification is a separate field of study and is not discussed in this book."
"Distributed delays can be modeled by assigning delay values to individual gates or by  using delay values in individual assign statements. When inputs of any gate change, the output of the gate changes after the delay value specified. Example 10-1  shows how  distributed delays are specified in gates and dataflow description."
"In a parallel connection, each bit in source field connects to its corresponding bit in the  destination field. If the source and the destination fields are vectors, they must have the  same number of bits; otherwise, there is a mismatch. Thus, a parallel connection specifies  delays from each bit in source  to each bit in destination."
"Full connection      A full connection is specified by the symbol *> and is used as shown below.      Usage: ( <source_field> *> <des tination_field>) = <delay_value>;      In a full connection, each bit in the source field connects to every bit in the destination  field. If the source and the destination are vectors, then they need not have the same  number of bits. A full connection describes the delay between each bit of the source and every bit in the destination, as illustrated in Figure 10-5 ."
"Note that specify parameters are used only inside their own specify block. They are not general-purpose parameters that are declared by the keyword parameter. Specify  parameters are provided for convenience in assigning delays. It is recommended that all  pin-to-pin delay values be expressed in terms of specify parameters instead of hardcoded numbers. Thus, if timing specifications of the circuit change, the user has to change only  the values of specify parameters."
"Pin-to-pin timing can also be expressed in more detail by specifying rise, fall, and turnoff delay values (see Example 10-8 ). One, two, three, six, or twelve delay values can be  specified for any path. Four, five, seven, eight, nine, ten, or eleven delay value  specification is illegal. The order in which delays are specified must be strictly followed."
"Verilog uses the pessimistic method to compute delays for transitions to the x state. The pessimistic approach dictates that if x tran sition delays are not explicitly specified,     • Transitions from x to a known state should take the maximum possible time     • Transition from a known state to x should take the minimum possible time"
"Delay back-annotation is an important and vast topic in timing simulation. An entire boo k could be devoted to that subject. However, in this section, we introduce the designer to  the concept of back-annotation of delays in a simulation. Detailed coverage of this topic  is outside the scope of this book. For de tails, refer to the IEEE Standard Verilog"
"Distributed delays are more accurate than lumped delays but difficult to model for  large designs. Lumped delays are relatively simpler to model.     • Path delays, also known as pin-to-pin delays, specify delays from input or inout  pins to output or inout pins. Path delays  provide the most accuracy for modeling  delays within a module.     • Specify blocks are the basic blocks for expressing path delay information. In  modules, specify blocks appear separately from initial or always blocks.     • Parallel connection and full connection ar e two methods to describe path delays.     • Parameters can be defined inside the specify blocks by specparam statements.     • Path delays can be conditional or dependent on the values of signals in the circuit."
"In Part 1  of this book, we explained digital design and simulation at a higher level of  abstraction such as gates, data flow, and behavior. However, in rare cases designers will  choose to design the leaf-level modules, using transistors. Verilog provides the ability to  design at a MOS-transistor level. Design at th is level is becoming rare with the increasing  complexity of circuits (millions of transistor s) and with the availability of sophisticated"
"CAD tools. Verilog HDL currently provides only digital design capability with logic  values 0 1, x, z, and the drive strengths associated with them. There is no analog  capability. Thus, in Verilog HDL, transistors are also known switches that either conduct or are open. In this chapter, we discuss the basic principles of switch-level modeling. For  most designers, it is adequate to know only  the basics. Detailed information on signal  strengths and advanced net definitions is provided in Appendix A , Strength Modeling and"
"Since switches are Verilog primitives, like logic gates, the name of the instance is  optional. Therefore, it is acceptable to instantiate a switch without assigning an instance  name.    nmos (out, data, control); //instantiate an nmos switch; no instance  name  pmos (out, data, control); //instantiate a pmos switch; no instance name          239"
"Strength Modeling and Advanced Net Defini tions, for strength levels in Verilog.     • Resistive devices have a high source-to-drain impedance. Regular switches have a  low source-to-drain impedance.     • Resistive switches reduce signal strengths when signals pass through them. The  changes are shown below. Regular switches retain strength levels of signals from input to output. The exception is that if the input is of strength supply, the output  is of strong strength. Table 11-2  shows the strength reduction due to resistive  switches."
"We discussed the following aspects of Verilog in this chapter:     • Switch-level modeling is at a very low level of design abstraction. Designers use  switch modeling in rare cases when they need to customize a leaf cell. Verilog  design at this level is becoming less popular with increasing complexity of  circuits.     • MOS, CMOS, bidirectional switches, and supply1 and supply0 sources can be  used to design any switch-level circuit. CMOS switches are a combination of"
"The state table is the most important part of the UDP definition. The best way to explain  a state table is to take the example of an and gate modeled as a UDP. Instead of using the and gate provided by Verilog, let us define our own and gate primitive and call it  udp_and."
"Compare parts of udp_and defined above with the parts discussed in Figure 12-1 . The  missing parts are that the output is not declared as reg and the initial statement is absent. Note that these missing parts are used only for sequential UDPs, which are discussed  later in the chapter."
"It is important to note that the state table becomes large very quickly as the number of inputs increases. Memory requirements to simu late UDPs increase exponentially with the  number of inputs to the UDP. However, UDPs offer a convenient feature to implement an  arbitrary function whose truth table is known, without extracting actual logic and by using logic gates to implement the circuit.      The stimulus shown in Example 12-6  is applied to test the multiplexer."
"Sequential UDPs have the following differences:    • The output of a sequential UDP is always declared as a reg.     • An initial statement can be used to  initialize output of sequential UDPs.     • The format of a state table entry is slightly different.     • <input1> <input2> ..... <inputN> : <current_state> :  <next_state>;     • There are three sections in a state table entry: inputs, current state, and next state."
The three sections are separated by a colon (:) symbol.     • The input specification of state table entr ies can be in terms of input levels or  edge transitions.     • The current state is the current value of the output register.     • The next state is computed based on inputs and the current state. The next state  becomes the new value of the output register.     • All possible combinations of inputs must be specified to avoid unknown output  values.
"When designing a functional block, it is important to decide whether to model it as a  module or as a user-defined primitive. Here are some guidelines used to make that decision.    • UDPs model functionality only. They do not model timing or process technology  (such as CMOS, TTL, ECL). The primary purpose of a UDP is to define in a  simple and concise form the functional portion of a block. A module is always used to model a complete block that has timing and process technology.     • A block can modeled as a UDP only if it has exactly one output terminal. If the  block to be designed has more than one output, it has to be modeled as a module.     • The limit on the maximum number of inputs of a UDP is specific to the Verilog  simulator being used. However, Verilog simulators are required to allow a minimum of 9 inputs for sequential UDPs and 10 for combinational UDPs.     • A UDP is typically implemented as a lookup table in memory. As the number of  inputs increases, the number of table entries grows exponentially. Thus, the  memory requirement for a UDP grows exponentially in relation to the number of inputs. It is not advisable to design a block with a large number of inputs as a"
"UDP.     • UDPs are not always the appropriate method to design a block. Sometimes it is  easier to design blocks as a module. For example, it is not advisable to design an  8-to-1 multiplexer as a UDP because of the large number of table entries. Instead,  the data flow or behavioral representation would be much simpler. It is important  to consider complexity trade-offs to de cide whether to use UDP to represent a  block.       There are also some guidelines for writing the UDP state table.     • The UDP state table should be specified as  completely as poss ible. All possible  input combinations for which the output is known should be covered. If a certain  combination of inputs is not specifie d, the default output value for that  combination will be x. This feature is used frequently in commercial libraries to  reduce the number of table entries.     • Shorthand symbols should be used to combine table entries wherever possible."
We discussed the following aspects of Verilog in this chapter:     • User-defined primitives (UDP) are used to define custom Verilog primitives by  the use of lookup tables. UDPs offer a convenient way to design certain functional  blocks.     • UDPs can have only one output terminal. UDPs are defined at the same level as  modules. UDPs are instantiated exactly like gate primitives. A state table is the  most important component of UDP specification.     • UDPs can be combinational or sequential. Sequential UDPs can be edgeor levelsensitive.     • Combinational UDPs are used to describe combinational circuits where the output  is purely a logical combination of the inputs.     • Sequential UDPs are used to define blocks with timing controls. Blocks such as  latches or flipflops can be described with sequential UDPs. Sequential UDPs are  modeled like state machines. There is a present state and a next state. The next  state is also the output of the UDP. Edge and level-sensitive descriptions can be  mixed.     • Shorthand symbols are provided to make UDP state table entries more concise.
"List of Keywords, System Tasks, and Compiler Directives. However, designers frequently need to cu stomize the capability of the Verilog language by defining their own  system tasks and functions. To do this, the de signers need to interact with the internal  representation of the design and the simulation environment in the Verilog simulator. The"
"There are three generations of the Verilog PLI.    1. Task/Function (tf_) routines make up the first generation PLI. These routines are  primarily used for operations involving user-defined task/function arguments,  utility functions, callback mechanism,  and writing data to output devices.     2. Access (acc_) routines make up the second-generation PLI. These routines are  provide object-oriented access directly into a Verilog HDL structural description."
"Figure 13-1. PLI Interface                   277A designer describes the design and stimulus by using standard Verilog constructs and  system tasks. In addition, use r-defined system tasks can also  be invoked in the design and  stimulus. The design and stimulus are compiled and converted to an internal design representation. The internal design represen tation is typically in the Verilog simulator  proprietary format and is incomprehensible to the designer. The intern al representation is  then used to run the actual simulation and produce output."
"Each of the user-defined system tasks is linked to a user-defined C routine. The C routines are described by means of a standard library of PLI interface routines, which can access the internal design repr esentation, and the standard C routines available with the C  compiler. The standard PLI library is provided with the Verilog simulator. A list of PLI  library routines is provided in Appendix B , List of PLI Routines. The PLI interface  allows the user to do the following:     • Read internal data structures     • Modify internal data structures     • Access simulation environment"
"PLI provides a powerful capability to extend the Verilog language by allowing users to define their own utilities to access the inte rnal design representation. PLI has various  applications.     • PLI can be used to define additional system tasks and functions. Typical examples  are monitoring tasks, stimulus tasks, debugging tasks, and complex operations  that cannot be implemented with  standard Verilog constructs.     • Application software like translators a nd delay calculators can be written with"
"To understand the process, let us consider the example of a simple system task  $hello_verilog. When invoked, the task simply prints out a message ""Hello Verilog World"". First, the C routine that implements the task must be defined with PLI library  routines. The C routine hello_verilog in the file hello_verilog.c is shown below.     #include ""veriuser.h"" /*include the file provided in release dir */   int hello_verilog()  {     io_printf(""Hello Verilog World\n""); }"
"We discussed a simple example to illustrate how a user-defined system task is named,  implemented in terms of a user-defined C rout ine, linked into the simulator, and invoked  in the Verilog code. More complex PLI task s discussed in the following sections will  follow the same process. Figure 13-2  summarizes the general process of adding and  invoking a user-defined system task."
"Before we understand how to use PLI library routines, it is first necessary to describe  how a design is viewed internally  in the simulator. Each module is viewed as a collection  of object types. Object types are elements defined in Verilog, such as:     • Module instances, module ports, module pin-to-pin paths, and intermodule paths     • Top-level modules     • Primitive instances, primitive terminals     • Nets, registers, parameters, specparams     • Integer, time, and real variables     • Timing checks     • Named events"
"We will discuss only reading of information from the design. Information about  modifying internal design representation can be found in the Programming Language Interface (PLI) Manual. However, reading of information is adequate for most practical  purposes.    Access routines can read information about objects in the design. Objects can be one of  the following types:     • Module instances, module ports, module pin-to-pin paths, and intermodule paths     • Top-level modules     • Primitive instances, primitive terminals     • Nets, registers, parameters, specparams     • Integer, time, and real variables     • Timing checks     • Named events"
"C routine must call acc_close().     • If access routines are being used in a file, the header file acc_user.h must also be  included. All access routine data types an d constants are predefined in the file  acc_user.h.     • #include ""acc_user.h""       • Access routines use the concept of a handle to access an object. Handles are  predefined data types that point to specific objects in the design. Any information  about the object can be obtained once the obj ect handle is obtain ed. This is similar  to the concept of file handles for accessing files in C programs. An object handle identifier is declared with the keyword handle.      handle top_handle;          286"
We discuss six types of access routines.     • Handle routines. They return handles to objects in the design. The name of handle  routines always starts with the prefix acc_handle_.     • Next routines. They return the handle to the next object in the set of a given object  type in a design. Next routines always start with the prefix acc_next_ and accept reference objects as arguments.     • Value Change Link (VCL) routines. They allow the user system task to add and  delete objects from the list of objects th at are monitored for value changes. VCL  routines always begin with the prefix acc_vcl_ and do not return a value.     • Fetch routines. They can extract a variety of information about objects.
"Information such as full hierarchical path name, relative name, and other  attributes can be obtained. Fetch routines always start with the prefix acc_fetch_.     • Utility access routines. They perform miscellaneous operations related to access  routines. For example, acc_initialize() and acc_close() are utility routines.     • Modify routines. They can modify internal data structures. We do not discuss  them in this book. Refer to the IEEE Standard Verilog Hardware Description"
We will discuss two examples that illustrate the use of access routines. The first example is a user-defined system task to find names of all ports in a module and count the number  of ports. The second example is a user-defined system task that monitors the changes in  values of nets.
"Let us write a user-defined system task $get_ports to find complete hierarchical names of input, output, and inout ports in a module and to count the number of input, output, and          287inout ports. The user-defined system task will be invoked  in Verilog as  $get_ports(""<hierarchical_module_name>""). The user-defined C routine get_ports, which  implements the task $get_ports, is described in file get_ports.c. The file get_ports.c is shown in Example 13-3 ."
"Some observations about utility routines are listed below.     • Utility routines always start with the prefix tf_.     • If utility routines are being used in a file , the header file veriuser.h must be  included. All utility routine data types and constants are predefined in veriuser.h.      #include ""veriuser.h""                  292Types of utility routines      Utility routines are available for the following purposes:     • Get information about the Verilog system task invocation     • Get argument list information     • Get values of arguments     • Pass back new values of argu ments to calling system task     • Monitor changes in values of arguments     • Get information about simulation time and scheduled events   •     • Perform housekeeping tasks, such as sa ving work areas, and storing pointers to  tasks    • Do long arithmetic     • Display messages     • Halt, terminate, save, and restore simulation"
"In this chapter, we descri bed the Programming Language Interface (PLI) for Verilog. The  following aspects were discussed:     • PLI Interface provides a set of C interface routines to read, write, and extract  information about the internal data struct ures of the design. Designers can write  their own system tasks to do various useful functions.     • PLI Interface can be used for monitors, debuggers, translators, delay calculators,  automatic stimulus generators, dump file generators, and other useful utilities.     • A user-defined system task is implemented with a corresponding user-defined C  routine. The C routine uses PLI library calls.     • The process of informing the simulator that a new user-defined system task is  attached to a corresponding user C routine is called linking. Different simulators handle the linking process differently.     • User-defined system tasks are invoked lik e standard Verilog system tasks, e.g.,  $hello_verilog(); . The corresponding user C routine hello_verilog is executed  whenever the task is invoked.     • A design is represented internally in a Verilog simulator as a big data structure  with sets for objects. PLI library routines allow access to the internal data  structures.     • Access (acc) routines and utility (tf) routines are two types of PLI library routines.   • Utility routines represent the first genera tion of Verilog PLI.  Utility routines are  used to pass data back and forth across the boundary of user C routines and the  original Verilog design. Utility routines start with the prefix tf_. Utility routines do not interact with object handles.     • Access routines represent the second generation of Verilog PLI. Access routines  can read and write information about a particular object from/to the design."
Access routines start with the prefix acc_. Access routines are used primarily across the boundary of user C routines and internal data representation. Access  routines interact with object handles.     • Value change link (VCL) is a special ca tegory of access routines that allow  monitoring of objects in a design. A consumer routine is executed whenever the monitored object value changes.     • Verilog Procedural Interface (VPI) rout ines represent the third generation of          297Verilog PLI. VPI routines provide a superset of the functionality of acc_ and tf_  routines. VPI routines are not covered in this book.
"Advances in logic synthesis have pushed HDLs into the forefront of digital design  technology. Logic synthesis tools have cut design cycle times significantly. Designers can design at a high level of abstraction and thus reduce design time. In this chapter, we discuss logic synthesis with Verilog HDL. Synopsys synthesis products were used for the  examples in this chapter, and results for individual examples may vary with synthesis  tools. However, the concepts discussed in this  chapter are general enough to be applied to  any logic synthesis tool. [1]  This chapter is intended to give the reader a basic  understanding of the mechanics and issues involved in logic synthesis. It is not intended  to be comprehensive material on logic synthesis. Detailed knowledge of logic synthesis can be obtained from reference manuals, logi c synthesis books, and by attending training  classes.    [1] Many EDA vendors now offer logic synthesis tools. Please see the reference documentation provided with your logic synthe sis tool for details on how to synthesize"
"Simply speaking, logic synthesis is the process of converting a high-level description of  the design into an optimized gate-level representation, given a standard cell library and  certain design constraints. A standard cell library can have simple cells, such as basic logic gates like and, or, and nor, or macro cells, such as adders, muxes, and special flipflops. A standard cell library is also known as the technology library. It is discussed in  detail later in this chapter."
"Logic synthesis always existed even in the days of schematic gate-level design, but it was  always done inside the designer's mind. The designer would first understand the architectural description. Then he would consider design constraints such as timing, area,  testability, and power. The designer would pa rtition the design into high-level blocks,  draw them on a piece of paper or a computer terminal, and describe the functionality of the circuit. This was the high-level description. Finally, each block would be  implemented on a hand-drawn schematic, using the cells available in the standard cell  library. The last step was the most complex process in the design flow and required several time-consuming design iterations before an optimized gate-level representation  that met all design constraints was obtained. Thus, the designer's mind was used as the  logic synthesis tool, as illustrated in Figure 14-1 ."
"Logic synthesis has revolutionized the digital design industry by significantly improving  productivity and by reducing design cycle time. Before the days of automated logic synthesis, when designs were converted to gates manually, the design process had the  following limitations:     • For large designs, manual conversion was prone to human error. A small gate  missed somewhere could mean redesign of entire blocks.     • The designer could never be sure that the design constraints were going to be met  until the gate-level implementation was completed and tested.     • A significant portion of the design cycle was dominated by the time taken to  convert a high-level design into gates.     • If the gate-level design did not meet requirements, the turnaround time for  redesign of blocks was very high.     • What-if scenarios were hard to verify. For example, the designer designed a block  in gates that could run at a cycle time of 20 ns. If the designer wanted to find out whether the circuit could be optimized to run faster at 15 ns, the entire block had  to be redesigned. Thus, redesign was needed to verify what-if scenarios.     • Each designer would implement design  blocks differently. There was little  consistency in design styles. For large designs, this could mean that smaller  blocks were optimized, but the overall design was not optimal.     • If a bug was found in the final, gate-level design, this would sometimes require  redesign of thousands of gates.     • Timing, area, and power dissipation in library cells are fabrication-technology  specific. Thus if the company changed th e IC fabrication vendor after the gatelevel design was complete, this would mean redesign of the entire circuit and a possible change in design methodology.     • Design reuse was not possible. Designs we re technology-specific, hard to port,  and very difficult to reuse."
"Logic synthesis will convert a high-level design to a gate-level netlist and ensure that all constraints have been met. If not, the designer goes back, modifies the  high-level design and repeats the process until a gate-level netlist that satisfies timing, area, and power constraints is obtained.     • Conversion from high-level design to gates is fast. With this improvement, design  cycle times are shortened considerably. What took months before can now be  done in hours or days.     • Turnaround time for redesign of blocks is shorter because changes are required  only at the register-transfer level; then, the design is simply resynthesized to  obtain the gate-level netlist.   •     • What-if scenarios are easy to verify. The high-level description does not change."
"For the purpose of logic synthesis, designs ar e currently written in an HDL at a register  transfer level (RTL). The term RTL is used for an HDL description style that utilizes a combination of data flow and behavioral constructs. Logic synthesis tools take the  register transfer-level HDL description and c onvert it to an optimized  gate-level netlist."
"Not all constructs can be used when writing a description for a logic synthesis tool. In  general, any construct that is used to define a cycle-by-cycle RTL description is  acceptable to the logic synthesis tool. A list of  constructs that are typically accepted by  logic synthesis tools is given in Table 14-1 . The capabilities of individual logic synthesis  tools may vary. The constructs that are typically acceptable to logic synthesis tools are  also shown."
"Type Keyword or Description Notes  ports input, inout, output    parameters parameter    module  definition module    signals and  variables wire, reg, tri Vectors are allowed  instantiation module instances,  primitive gate instances E.g., mymux m1(out, i0, i1, s); E.g., nand  (out, a, b);  functions and tasks function, task Timing constructs ignored  procedural always, if, then, else, case,  casex, casez initial is not supported          306procedural  blocks begin, end, named blocks,  disable Disabling of named blocks allowed  data flow assign Delay information is ignored  loops for, while, forever, while and forever loops must contain  @(posedge clk) or @(negedge clk)   Remember that we are providing a cycle-by-cycle RTL description of the circuit. Hence,  there are restrictions on the way these constructs are used for the logic synthesis tool. For  example, the while and forever loops must be broken by a @ (posedge clock) or @ (negedge clock) statement to enforce cycle-by-cycle behavior and to prevent combinational feedback. Another restriction is that logic synthesis ignores all timing  delays specified by #<delay> construct. Therefore, preand post-synthesis Verilog  simulation results may not match. The designer must use a description style that eliminates these mismatches. Also, the init ial construct is not supported by logic  synthesis tools. Instead, the designer must us e a reset mechanism to initialize the signals  in the circuit."
Arithmetic *     /    +        % multiply     divide    add     subtract    modulus          307 +      unary plus     unary minus   Logical !    &&     || logical negation    logical and     logical or   Relational >    <     >=    <= greater than    less than     greater than or equal    less than or equal   Equality ==     != equality     inequality   Bit-wise ~     &    |     ^   ^~ or ~^ bitwise negation     bitwise and    bitwise or     bitwise ex-or   bitwise ex-nor
The assign statement      The assign construct is the most fundamental construct used to describe combinational  logic at an RTL level. Given below is a logi c expression that uses the assign statement.     assign out = (a & b) | c;     This will frequently translate to th e following gate-level representation:
"Let us discuss each component of the flow in detail.                  313RTL description      The designer describes the design at a high level by using RTL constructs. The designer  spends time in functional verification to ensure that the RTL description functions  correctly. After the functionality is verified, the RTL description is input to the logic  synthesis tool."
"Technology mapping and optimization      Until this step, the design description is inde pendent of a specific target technology. In  this step, the synthesis tool takes the internal representation and implements the  representation in gates, using the cells provided in the technology library. In other words, the design is mapped to the desired target technology.      Suppose you want to get your IC chip fabricated at ABC Inc. ABC Inc. has 0.65 micron"
"CMOS technology, which it calls abc_100 technology. Then, abc_100 becomes the target  technology. You must therefore implement your internal design representation in gates, using the cells provided in abc_100 technology library. This is called technology          314mapping. Also, the implementation should satisf y such design constraints as timing, area,  and power. Some local optimizations are done to achieve the best results for the target  technology. This is called technology  optimization or technology-dependent  optimization."
"The technology library contains library cells provided by ABC Inc. The term standard cell library used earlier in the chapter and the term technology library are identical and are used interchangeably.      To build a technology library, ABC Inc. decides the range of functionality to provide in  its library cells. As discussed earlier, library cells can be basic logic gates or macro cells  such as adders, ALUs, multiplexers, and specia l flip-flops. The library  cells are the basic  building blocks that ABC Inc. will use for IC fabrication. Physical layout of library cells  is done first. Then, the area of each cell is computed from the cell layout. Next, modeling  techniques are used to estimate the timing an d power characteristics of each library cell."
"This process is called cell characterization.      Finally, each cell is described in a format th at is understood by the synthesis tool. The  cell description contains information about the following:     • Functionality of the cell     • Area of the cell layout     • Timing information about the cell     • Power information about the cell"
"A collection of these cells is called the technology library. The synthesis tool uses these cells to implement the design. The quality of re sults from synthesis tools will typically be  dominated by the cells available in the technology library. If the choice of cells in the  technology library is limited, the synthesis tool cannot do much in terms of optimization  for timing, area, and power."
"Let us discuss synthesis of a 4-bit magnitude comparator to understand each step in the  synthesis flow. Steps of the synthesis flow such as translation, logic optimization, and technology mapping are not visible to us as designers. Therefore, we will concentrate on  the components that are visible to the designer, such as the RTL description, technology  library, design constraints, and the fina l, optimized, gate-level description."
"If the designer decides to use another technology, say, xyz_100 from XYZ Inc., because  it is a better technology, the RTL description and design constraints do not change. Only the technology library changes. Thus, to map to a new technology, a logic synthesis tool  simply reads the unchanged RTL description, unchanged design constraints, and new  technology library and creates a new, optimized, gate-level netlist."
"The style of the Verilog description greatly affects the final design. For logic synthesis, it  is important to consider actual hardware im plementation issues. The RTL specification  should be as close to the desired structure as possible without sacrificing the benefits of a  high level of abstraction. There is a trade-off between level of design abstraction and  control over the structure of the logic synthesi s output. Designing at a very high level of  abstraction can cause logic with undesirable structure to be generated by the synthesis  tool. Designing at a very low level (e.g., hand instantiation of each cell) causes the  designer to lose the benefits of high-level design and technology independence. Also, a ""good"" style will vary among logic synthesi s tools. However, many principles are  common across logic synthesis tools. Listed below are some guidelines that the designer  should consider while designing at the RTL level."
Use parentheses to optimize logic structure      The designer can control the final structure of logic by using parentheses to group logic. Using parentheses also improves read ability of the Verilog description.     //translates to 3 adders in series  out = a + b + c + d;    //translates to 2 adders in parallel with one final adder to sum  results out = (a + b) + (c + d) ;
"Multiply, divide, and modulo operators are very  expensive to implement in terms of logic  and area. However, these arithmetic operators can be used to implement the desired functionality concisely and in a technology-independent manner. On the other hand,  designing custom blocks to do multiplication , division, or modulo operation can take a  longer time, and the RTL description becomes more technology-dependent."
"Be careful with multiple assignments to the same variable      Multiple assignments to the sa me variable can cause undesired logic to be generated. The  previous assignment might be ignored, and only the last assignment would be used.     //two assignments to the same variable  always @(posedge clk)         if(load1) q <= a1;    always @(posedge clk)        if(load2) q <= a2;      The synthesis tool infers two flipflops with the outputs anded together to produce the q  output. The designer needs to be careful about such situations."
"In this chapter, we discussed the following aspects of logic synthesis with Verilog HDL:     • Logic synthesis is the process of converting a high-level description of the design  into an optimized, gate-level representation, using the cells in the technology library.     • Computer-aided logic synthesis tools have greatly reduced the design cycle time  and have improved productivity. They allow designers to write technologyindependent, high-level descriptions and produce technology-dependent,  optimized, gate-level netlists. Both combinational and sequential RTL  descriptions can be synthesized.     • Logic synthesis tools accept high-level descriptions at the register transfer level  (RTL). Thus, not all Verilog constructs are acceptable to a logic synthesis tool."
"We discussed the acceptable Verilog constructs and operators and their          339interpretation in terms of digital circuit elements.     • A logic synthesis tool accepts an RTL description, design constraints, and  technology library and produces an optimized gate-level netlist. Translation, logic  optimization, and technology mapping are the internal processes in a logic synthesis tool and are normally invisible to the user.     • Functional verification of the optimized gate-level netlist is done by applying the  same stimulus to the RTL description and the gate-level netlist and comparing the  output. Timing is verified with timing simulation or static timing verification.     • Proper Verilog coding techniques must be used to write efficient RTL  descriptions, and various design trade-offs must be evaluated. Guidelines for  writing efficient RTL descriptions were discussed.     • Design partitioning is an important technique used to break the design into  smaller blocks. Smaller blocks reduce the complexity of optimization for the logic  synthesis tool.     • Accurate specification of design constraints is an important part of logic  synthesis."
"Verilog HDL was traditionally used both as a simulation modeling language and as a  hardware description language. Verilog HDL was heavily used in verification and simulation for testbenches, test environments, simulation models, and architectural models. This approach worked  well for smaller designs an d simpler test environments.      As the average gate count for designs began to approa ch or exceed one million,  verification soon became the main bottleneck in  the design process. Design teams started  spending 50-70% of their time in verifyin g designs rather than creating new ones."
"To address these needs, a variety of verification methodologies and tools has emerged over the past few years. The latest additio n to verification methodology is assertionbased  verification. However, Verilog HDL remains the focal point in the design process. These  new developments enhance the productivity of verifying Verilog HDL-based designs. This chapter gives the reader a basic understanding of these verification concepts that  complement Verilog HDL."
"Functional test environments are needed to apply these test vectors. There are  many tools available for generating and apply test vectors. These tools also allow the efficient creation of test environments.     3. The DUT is then simulated using traditi onal software simulators. (The DUT is  normally created by logic designers. Ve rification engineers simulate the DUT.)     4. The output is then analyzed and checked against the expected results. This can be  done manually using waveform viewers and debugging tools. Alternately,  analysis can be automated by the test environment checking the output of the"
"DUT or by parsing the log files using a language like PERL. In addition, coverage results are analyzed to ensure that the tests have exercised the design thoroughly and that the verification goals are met. If the output matches the expected results  and the coverage goals are met, then the verification is complete.     5. Optionally, additional steps can be taken to decrease the risk of a future design respin. These steps include Hardware Ac celeration, Hardware Emulation and"
"This stage includes design exploration by the architects. The initial model typically does  not capture exact design behavior, except to th e extent required for the initial design  decisions. For example, a fundamental algorithm like an MPEG decoder might be  implemented, but the processor to memory bandwidth is not specified. The architect tries  out several different variations of the model and make some fundamental decisions about the system. These decisions may include number of processors, algorithms implemented  in hardware, memory architecture, and so on. These trade-offs will affect the eventual  implementation of the target design."
"Architectural models are often written using C and C++. Though C++ has the advantage of object oriented constructs, it does not implement concepts such as parallelism and  timing that were found in HDLs. Thus, creators of architectural models have to  implement these concepts in their models. Th is is very cumbersome, resulting in long  development times for architectural models.          345"
"To solve this problem, architectural modeling languages were invented. These languages  have both the object oriented constructs found in C++ as well as parallelism and timing constructs found in HDLs. Thus, they are well-suited for high-level architectural models.     A likely advancement in the future is the de sign of chips at the architectural modeling  level rather than at the RTL level. High-lev el synthesis tools will convert architectural  models to Verilog RTL design implementations based on the trade-off inputs. These RTL designs can then go through the standard ASIC design and verification flow. Figure 15-2   shows an example of such a flow."
"DUT and its surrounding functional verification environment. In a typical HDL-based  verification environment,  [1] In this chapter, the words ""designer"" and ""verification engineer"" have been used  interchangeably. This is because logic designers perform block level verification and are  often involved in the full chip verification process.    • The testbench consisted of HDL procedures that wrote data to the DUT or read  data from it.     • The tests, which called the testbench procedures in sequence to apply manually  selected input stimuli to the DUT and checked the results, were directed only  towards specific features of the design as described in the functional test plan."
"However, as design sizes exceeded million gates, this approach became less effective because     • The tests became harder and more time consuming to write because of decreasing  controllability of the design.     • Verifying correct behavior became diffi cult due to decreasing observability into  internal design states.     • The tests became difficult to read and maintain.     • There were too many corner cases for the available labor.     • Multiple environments became difficult to create and maintain because they used  little shared code.           347"
"HVLs are powerful because they combine the object oriented approach of C++ with the  parallelism and timing constructs in HDLs and are thus best suited for verification. HVLs also help in the automatic generation of  test stimuli and provide an integrated  environment for functional verification, including input drivers, output drivers, data  checking, protocol checking, and coverage. Thus, HVLs maximize productivity for  creating and maintaining verification environments."
"Hardware accelerators can cut simulation times from a matter of days to a few hours. Therefore, they can greatly shorten the verification timeline. However, they are expensive  and need significant set-up time. Another dr awback is that they usually require long  compilation times, which means that they are most useful only for long regression simulations. As a result, smaller design s still employ software simulation as the  simulation technique of choice.      Appendix E , Verilog Tidbits, contains further information on popular hardware  accelerators."
"Running live systems with the design is an important verification step that reduces the  possibility of bugs and a design re-spin. However, software simulators and hardware          351accelerators cannot be used for this purpose because they are too slow and do not have  the necessary hooks to run a live system. For example, to boot UNIX with a software  simulation of a design may take many year s. Hardware emulation can boot UNIX in a  few hours."
Figure 15-6  shows the setup of a typical emulation system. Emulation is done so that the  software application runs exactly as it would on the real chip in a real circuit. The  software application is oblivious to the fact that it is running on an emulator rather than  the actual chip.
"Toggle coverage does not ensure completeness. It cannot assure that a specific bit  toggle sequence that represents high-level functionality has occurred. Toggle  coverage does not shorten the verification process. It may even prolong the  verification process as engineers try to toggle a bit, which cannot toggle according to the specification. Toggle coverage is very low-level coverage and it is  cumbersome to relate a specific bit to a high-level test plan item.     3. Branch coverage: Branch coverage checks if all possible branches in a control  flow are taken. This coverage metric is necessary but not sufficient."
"Many other verification methodologies have evolved over the past few years to complement the traditional verification flow discussed in the previous section. In this  section and the following sections, we explain some of these new verification  methodologies that use the white box verification approach, i.e., knowledge of the internal structure of the design is needed for verification."
Assertion checking is a form of white box verification. It requires knowledge of internal structures of the design. The main purpose of assertion checkers is to improve  observability.    Assertions are statements about a design's intended behavior. There are two types of  assertions:     • Temporal assertions ? they describe the timing relationship between signals.     • Static assertions ? they describe a property of a signal that is always true or false.
"A well-known white-box approach is formal verification, in which mathematical  techniques are used to prove an assertion or a property of the design. The property to be proven may be related to the chip's overall fu nctional specification, or it may represent  internal design behavior. Detailed knowledge of the behavior of design structures is often  required to specify useful properties that are worth proving. Thus, one can prove the correctness of a design without doing simulations. Another application of formal  verification is to prove that the architectural specifications of a design are sound before  starting with the RTL implementation."
The limitations on formal verification tools are not based on number of lines. They are  based on the complexity of the assertions being proven and the design structure. The  limitation lies in the number of cycles the algorithm can reach from the seed state(Formal  verifications tools often use reset as the seed state).
"During a Verilog simulation, seed states are captured to serve as starting points for formal  methods. Then formal methods start from the seed states and try to prove the assertions completely or describe stimulus sequences that will violate these assertions. The semiformal tool proves properties exhaustively in a limited exploration space starting from  these seed states, thus quickly identifying many corner-cases that would have been detected only by extensive simulation test suites. Figure 15-9  shows the verification flow  with a semi-formal tool."
"After logic synthesis and place and route tools create gate level netlist and physical implementations of the RTL design, it is necessary to check whether these  implementations match the functionality of th e original RTL design. One methodology is  to re-run all the test vectors used for RTL ve rification, with the gate level netlist and the  physical implementation. However, this methodology is extremely time consuming and  tedious.    Equivalence checking solves this problem. Equivalence checking is one application of  formal verification. It ensures that the gate  level or the physical netlist has the same  functionality as the Verilog RTL that was simulated. Equivalence checkers build a logical model of both the RTL and gate level representations of the design and mathematically prove that they are functionally equivalent. Thus, functional verification can focus  entirely on RTL and there is little  need for gate level simulation.    Figure 15-10  shows the equivalence checking flow."
Strength Level Abbreviation  Degree Strength Type  supply1 Su1 strongest 1 driving  strong1 St1 driving  pull1 Pu1 driving  large1 La1 storage  weak1 We1 driving  medium1 e1 storage  small1 Sm1   storage  highz1 HiZ1 weakest1 high impedance highz HiZ0 weakest0 high impedance small0 Sm0 storage  medium0 Me0 storage  weak0 We0 driving  large0 La0 storage  pull0 Pu0 driving  strong0 St0   driving  supply0 Su0 strongest0 driving                       365
"The keywords wire and tri have identical syntax and function. However, separate names are provided to indicate the purpose of the net. Keyword wire denotes nets with single  drivers, and tri is denotes nets that have  multiple drivers. A multiplexer, as defined  below, uses the tri declaration.          The net is driven by b1 and b2 in a complementary manner. When b1 drives a, b2 is  tristated; when b2 drives b, b1 is tristated. Thus, there is no logic contention. If there is  contention on a tri net, it is resolved by usin g strength levels. If there are two signals of  opposite values and same strength, the resulting value of the tri net is x."
Keyword supply1 is used to model a power supply. Keyword supply0 is used to model ground. Nets declared as supply1 or supply0 have constant logic value and a strength  level supply (stronge st strength level).     supply1 vcc;     //all nets connected to vcc are connected to power  supply  supply0 gnd;    //all nets connected to gnd are connected to ground
"Type Name Argument List Description  handle acc_handle_by_name (char *name, handle  scope) Object from name  relative to scope.          371handle acc_handle_condition (handle object) Conditional  expression for  module path or timing check  handle.  handle acc_handle_conn (handle terminal); Get net connected  to a primitive,  module path, or timing check  terminal.  handle acc_handle_datapath (handle modpath); Get the handle to  data path for an  edge-sensitive module path.  handle acc_handle_hiconn (handle port); Get hierarchically  higher net  connection to a  module port.  handle acc_handle_interactive_scope ( ); Get the handle to  the current  simulation  interactive scope.  handle acc_handle_loconn (handle port); Get hierarchically  lower net connection to a  module port.  handle acc_handle_modpath (handle module, char  *src, char *dest); or      (handle module, handle src, handle dest); Get the handle to  module path whose  source and destination are  specified. Module  path can be specified by names  or handles.    handle   acc_handle_notifier   (handle tchk);"
"Get notifier register  associated with a particular timing  check.          372handle acc_handle_object (char *name); Get the handle for  any object, given  its full or relative hierarchical path  name.  handle acc_handle_parent (handle object); Get the handle for  own primitive or  containing module or an object.  handle acc_handle_path (handle outport, handle  inport); Get the handle to  path from output  port of a module to  input port of another module.  handle acc_handle_pathin (handle modpath); Get the handle for  first net connected  to the input of a  module path.  handle acc_handle_pathout (handle modpath); Get the handle for  first net connected  to the output of a  module path.  handle acc_handle_port (handle module, int  port#); Get the handle for  module port. Port# is the position from  the left in the  module definition (starting with 0).  handle acc_handle_scope (handle object); Get the handle to  the scope  containing an  object.  handle acc_handle_simulated_net (handle  collapsed_net_handle); Get the handle to  the net associated with a collapsed  net.  handle acc_handle_tchk (handle module, int  tchk_type, char  *netname1, int edge1, ........); Get the handle for a  specified timing  check of a module or cell.          373handle acc_handle_tchkarg1 (handle tchk); Get net connected  to the first  argument of a timing check.  handle acc_handle_tchkarg2 (handle tchk); Get net connected  to the second  argument of a  timing check.  handle acc_handle_terminal (handle primitive, int  terminal#); Get the handle for a  primitive terminal. Terminal# is the  position in the  argument list.  handle acc_handle_tfarg (int arg#); Get the handle to  argument arg# of calling system task  or function that  invokes the PLI routine.  handle acc_handle_tfinst ( ); Get the handle to  the current user  defined system task or function."
Next routines return the handle to the next object in the linked list of a given object type in a design. Next routines always start with the prefix acc_next_ and accept reference  objects as arguments. Reference objects are shown with a prefix current_. See Table B-2 .   Table B-2. Next Routines
"Type Name Argument List Description  handle acc_next (int obj_type_array[],  handle module, handle  current_object); Get next object of a  certain type within a  scope. Object types such  as accNet or accRegister are defined in  obj_type_array.          374handle acc_next_bit (handle vector, handle  current_bit); Get next bit in a vector  port or array.  handle acc_next_cell (handle module, handle  current_cell); Get next cell instance in  a module. Cells are  defined in a library.  handle acc_next_cell_load (handle net, handle  current_cell_load); Get next cell load on a  net.  handle acc_next_child (handle module, handle  current_child); Get next module instance  appearing in this module  handle acc_next_driver (handle net, handle  current_driver_terminal); Get next primitive  terminal driver that  drives the net.  handle acc_next_hiconn (handle port, handle  current_net); Get next higher net  connection.  handle acc_next_input (handle path_or_tchk,  handle current_terminal); Get next input terminal  of a specified module  path or timing check.  handle acc_next_load (handle net, handle  current_load); Get next primitive  terminal driven by a net  independent of hierarchy. handle acc_next_loconn (handle port, handle  current_net); Get next lower net  connection to a module  port.  handle acc_next_modpath (handle module, handle  path); Get next path within a  module.  handle acc_next_net (handle module, handle  current_net); Get the next net in a  module.  handle acc_next output (handle path, handle  current_terminal); Get next output terminal  of a module path or data  path.  handle acc_next_parameter (handle module, handle  current_parameter); Get next parameter in a  module.  handle acc_next_port (handle module, handle  current_port); Get the next port in a  module port list.  handle acc_next_portout (handle module, handle  current_port); Get next output or inout  port of a module.  handle acc_next_primitive (handle module, handle  current_primitive); Get next primitive in a  module.          375handle acc_next_scope (handle scope, handle  current_scope); Get next hierarchy scope  within a certain scope.  handle acc_next_specparam (handle module, handle  current_specparam); Get next specparam  declared in a module.  handle acc_next_tchk (handle module, handle  current_tchk); Get next timing check in  a module.  handle acc_next_terminal (handle primitive, handle  current_terminal); Get next terminal of a  primitive.  handle acc_next_topmod (handle current_topmod); Get next top level  module in the design."
"Type Name Argument List Description  void acc_vcl_add (handle object, int  (*consumer_routine) (), char  *user_data, int VCL_flags); Tell the Verilog simulator to  call the consumer routine with  value change information  whenever the value of an object changes.  void acc_vcl_delete (handle object, int  (*consumer_routine) (), char  *user_data, int VCL_flags); Tell the Verilog simulator to  stop calling the consumer  routine when the value of an object changes."
"Type Name Argument List Description  int acc_fetch_argc ( ); Get the number of  invocation command-line  arguments.  char ** acc_fetch_argv ( ); Get the array of  invocation command-line  arguments.  double acc_fetch_attribute (handle object, char  *attribute, double  default); Get the attribute of a  parameter or specparam.  char * acc_fetch_defname (handle object); Get the defining name of  a module or a primitive  instance.  int acc_fetch_delay_mode (handle module); Get delay mode of a  module instance.  bool acc_fetch_delays (handle object, double  *rise, double *fall, double *turnoff);      (handle object, double  *d1, *d2, *d3, *d4 *d5,  *d6); Get typical delay values  for primitives, module  paths, timing checks, or module input ports.  int acc_fetch_direction (handle object); Get the direction of a port  or terminal, i.e., input, output, or inout.  int acc_fetch_edge (handle  path_or_tchk_term); Get the edge specifier  type of a path input or  output terminal or a timing check input  terminal.  char * acc_fetch_fullname (handle object); Get the full hierarchical  name of any name object  or module path.  int acc_fetch_fulltype (handle object); Get the type of the object."
"Return a predefined integer constant that tells  type.          377int acc_fetch_index (handle  port_or_terminal); Get the index for a port  or terminal for gate,  switch, UDP instance, module, etc. Zero  returned for the first  terminal.  void acc_fetch_location (p_location loc_p,  handle object); Get the location of an  object in a Verilog source file. p_location is a  predefined data structure  that has file name and line number in the file.  char * acc_fetch_name (handle object); Get instance of object or  module path within a  module.  int acc_fetch_paramtype  (handle parameter); Get the data type of  parameter, integer, string,  real, etc.  double acc_fetch_paramval (handle parameter); Get value of parameter or  specparam. Must cast  return values to integer,  string, or double.  int acc_fetch_polarity (handle path); Get polarity of a path.  int acc_fetch_precision ( ); Get the simulation time  precision.  bool acc_fetch_pulsere (handle path, double  *r1, double *e1,double *r2, double *e2.........) Get pulse control values  for module paths based  on reject values and e_values for transitions.  int acc_fetch_range (handle vector, int  *msb, int *lsb); Get the most significant  bit and least significant  bit range values of a vector.  int acc_fetch_size (handle object); Get number of bits in a  net, register, or port.  double acc_fetch_tfarg (int arg#); Get value of system task  or function argument  indexed by arg#.          378int acc_fetch_tfarg_int (int arg#); Get integer value of  system task or function  argument indexed by arg#.  char * acc_fetch_tfarg_str (int arg#); Get string value of  system task or function  argument indexed by  arg#.  void acc_fetch_timescale_info(handle object,  p_timescale_info  timescale_p); Get the time scale  information for an object. p_timescale_info is a  pointer to a predefined  time scale data structure.  int acc_fetch_type (handle object); Get the type of object."
"Return a predefined integer constant such as  accIntegerVar,  accModule, etc.  char * acc_fetch_type_str (handle object); Get the type of object in  string format. Return a  string of type  accIntegerVar, accParameter, etc.  char * acc_fetch_value (handle object, char  *format); Get the logic or strength  value of a net, register, or  variable in the specified  format."
"Return an array of handles.  bool acc_compare_handles (handle object1,  handle object2); Return true if both handles  refer to the same object.  void acc_configure (int config_param,  char *config_value); Set parameters that control  the operation of various  access routines.  int acc_count (handle  *next_routine,  handle ref_object); Count the number of  objects in a reference  object such as a module."
"The objects are counted by successive calls to the acc_next routine  void acc_free (handle  *object_handles); Free memory allocated by  acc_collect for storing  object handles.  void acc_initialize ( ); Reset all access routine  configuration parameters. Call when entering a userdefined PLI routine.  bool acc_object_in_typelist (handle object, int  object_types[]); Match the object type or  property against an array of  listed types or properties.  bool acc_object_of_type (handle object, int  object_type); Match the object type or  property against a specific type or property.  int acc_product_type ( ); Get the type of software  product being used.  char * acc_product_version ( ); Get the version of software  product being used.  int acc_release_object (handle object); Deallocate memory  associated with an input or  output terminal path.  void acc_reset_buffer ( ); Reset the string buffer.  handle acc_set_interactive_scope ( ); Set the interactive scope of  a software implementation.          380void acc_set_scope (handle module, char  *module_name); Set the scope for searching  for objects in a design  hierarchy.  char * acc_version ( ); Get the version of access  routines being used."
"Type Name Argument List Description  void acc_append_delays (handle object,  double rise, double fall, double z); or      (handle object, double d1, ..., double  d6); or      (handle object,  double limit); or      (handle object double delay[]); Add delays to existing delay  values for primitives, module  paths, timing checks, or module  input ports. Can specify rise/fall/turn-off or 6 delay or  timing check or min:typ:max  format.  bool acc_append_pulsere (handle path, double  r1, ...., double r12,  double e1, ..., double  e12); Add to the existing pulse control  values of a module path.          381void acc_replace_delays (handle object,  double rise, double  fall, double z); or      (handle object, double d1, ..., double  d6); or      (handle object,  double limit); or      (handle object double delay[]); Replace delay values for  primitives, module paths, timing  checks, or module input ports."
"Can specify rise/fall/turn-off or 6 delay or timing check or  min:typ:max format.  bool acc_replace_pulsere (handle path, double  r1, ...., double r12,  double e1, ..., double  e12); Set pulse control values of a  module path as a percentage of  path delays.  void acc_set_pulsere (handle path, double  reject, double e); Set pulse control percentages for  a module path.  void acc_set_value (handle object,  p_setval_value value_P,  p_setval_delay  delay_P); Set value for a register or a  sequential UDP.                                            382"
Utility (tf_) routines are used to pass data in both directions across the Verilog/user C  routine boundary. All the tf_ routines assume that operations are being performed on current instances. Each tf_ routine has a tf_i counterpart in which the instance pointer  where the operations take place has to be passed as an additional argument at the end of  the argument list. See Table B-7  through B-16 .
List Description  char * tf_getinstance ( ); Get the pointer to the current instance of the  simulation task or function that called the  user's PLI application program.  char * tf_mipname ( ); Get the Verilog hierarchical path name of the  simulation module containing the call to the  user's PI application program.  char * tf_ispname ( ) Get the Verilog hierarchical path name of the  scope containing the call to the user's PLI  application program.
"Type Name Argument List Description  int tf_nump ( ); Get the number of  parameters in the argument  list.  int tf_typep (int param_index#); Get the type of a particular  parameter in the argument  list.          383int tf_sizep (int param_index#); Get the length of a parameter  in bits.  t_tfexprinfo * tf_expinfo (int param_index#, struct  t_tfexprinfo *exprinfo_p); Get information about a  parameter expression.  t_tfexprinfo * tf_nodeinfo (int param_index#, struct  t_tfexprinfo *exprinfo_p); Get information about a node  value parameter."
"Type Name Argument List Description  int tf_getp (int param_index#); Get the value of parameter in  integer form.  double tf_getrealp (int param_index#); Get the value of a parameter in  double-precision floating-point  form.  int tf_getlongp (int *aof_highvalue, int  para_index#); Get parameter value in long 64bit integer form.  char * tf_strgetp (int param_index#, char  format_character); Get parameter value as a  formatted character string.  char * tf_getcstringp (int param_index#); Get parameter value as a C  character string.  void tf_evaluatep (int param_index#); Evaluate a parameter expression  and get the result."
"Type Name Argument List Description  void tf_putp (int param_index#, int  value); Pass back an integer value to  the calling task or function.          384void tf_putrealp (int param_index#, double  value; Pass back a double-precision  floating-point value to the  calling task or function.  void tf_putlongp (int param_index#, int  lowvalue, int highvalue); Pass back a double-precision  64-bit integer value to the calling task or function.  void tf_propagatep (int param_index#); Propagate a node parameter  value.  int tf_strdelputp (int param_index#, int  bitlength, char format_char, int delay, int delaytype, char *value_p); Pass back a value and  schedule an event on the  parameter. The value is expressed as a formatted  character string, and the  delay, as an integer value.  int tf_strrealdelputp (int param_index#, int  bitlength, char format_char, int delay, double delaytype,  char *value_p); Pass back a string value with  an attached real delay.  int tf_strlongdelputp (int param_index#, int  bitlength, char format_char,  int lowdelay,int highdelay, int delaytype, char  *value_p); Pass back a string value with  an attached long delay."
Type Name Argument List Description  void tf_asynchon ( ); Enable a user PLI routine to be called  whenever a parameter changes value.  void tf_asynchoff ( ); Disable asynchronous calling.  void tf_synchronize ( ); Synchronize parameter value changes  to the end of the current simulation time  slot.  void tf_rosynchronize ( ); Synchronize parameter value changes  and suppress new event generation  during current simulation time slot.          385  int   tf_getpchange   (int  param_index#);
"Type Name Argument List Description  void tf_add_long (int *aof_low1, int  *aof_high1, int low2, int high2); Add two 64-bit long  values.  void tf_subtract_long (int *aof_low1, int  *aof_high1, int low2, int  high2); Subtract one long value  from another.  void tf_multiply_long (int *aof_low1, int  *aof_high1, int low2, int high2); Multiply two long  values.  void tf_divide_long (int *aof_low1, int  *aof_high1, int low2, int  high2); Divide one long value by  another.  int tf_compare_long (int low1, int high1, int low2,  int high2); Compare two long  values.  char * tf_longtime_tostr (int lowtime, int hightime); Convert a long value to a  character string.  void tf_real_to_long (double real, int *aof_low, int  *aof_high); Convert a real number to  a 64-bit integer.  void tf_long_to_real (int low, int high, double  *aof_real); Convert a long integer to  a real number."
"Type Name Argument List Description  void io_printf (char *format,  arg1,......); Write messages to the standard  output and log file.  void io_mcdprintf (char *format,  arg1,......); Write messages to multiple-channel  descriptor files.          388void tf_error (char *format,  arg1,......); Print error message.  void tf_warning (char *format,  arg1,......); Print warning message.  void tf_message (int level, char facility,  char code, char  *message, arg1, ....); Print error and warning messages,  using the Verilog simulator's  standard error handling facility.  void tf_text (char *format, arg1,  .....); Store error message information in  a buffer. Displayed when  tf_message is called."
"Type Name Argument List Description  void tf_dostop ( ); Halt the simulation and put the  system in interactive mode.  void tf_dofinish ( ); Te rminate the simulation.  char * mc_scanplus_args (char *startarg); Get command line plus (+)  options entered by the user in interactive mode.  void tf_write_save (char *blockptr, int  blocklength); Write PLI application data to a  save file.  int tf_read_restart (char *blockptr, int  block_length); Get a block of data from a  previously written save file.  void tf_read_restore (char *blockptr, int  blocklength); Retrieve data from a save file.  void tf_dumpflush ( ); Dump parameter value changes  to a system dump file.  char * tf_dumpfilename ( ); Get name of system dump file.                      389B.3.10 Housekeeping Tasks"
Type Name Argument List Description  void tf_setworkarea (char  *workarea); Save a pointer to the work area of a PLI  application task/function instance.  char * tf_getworkarea ( ); Retrieve pointer to a work area.  void tf_setroutine (char (*routine)  () ); Store pointer to a PLI application  task/function.  char * tf_getroutine ( ); Retrieve pointer to a PLI application  task/function.  void tf_settflist (char *tflist); Store pointer to a PLI application  task/function instance.  char * tf_gettflist ( ); Retrieve pointer to a PLI application  task/function instance.                                                         390
The list is sorted in alphabetical order.      always ifnone rnmos  and incdir rpmos assign include rtran automatic initial rtranif0  begin inout rtranif1  buf input scalared  bufif0 instance showcancelled bufif1 integer signed  case join small  casex large specify casez liblist specparam cell library strong0  cmos localparam strong1  config macromodule supply0 deassign medium supply1 default module table defparam nand task  design negedge time  disable nmos tran edge nor tranif0 else noshowcancelled tranif1          392end not tri  endcase notif0 tri0  endconfig notif1 tri1  endfunction or triand endgenerate output trior endmodule parameter trireg endprimitive pmos unsigned  endspecify posedge use  endtable primitive vectored endtask pull0 wait event pull1 wand  for pulldown weak0  force pullup weak1 forever pulsestyle_onevent while fork pulsestyle_ondetect wire  function rcmos wor  generate real xnor genvar realtime xor highz0 reg   highz1 release   if repeat
D.1.2 Configuration Source Text    config_declaration ::=        config config_identifier ;       design_statement        {config_rule_statement}        endconfig design_statement ::= design { [library_identifier.]cell_identifier } ;  config_rule_statement ::=        default_clause liblist_clause     | inst_clause liblist_clause      | inst_clause use_clause      | cell_clause liblist_clause     | cell_clause use_clause  default_clause ::= default  inst_clause ::= instance inst_name inst_name ::= topmodule_iden tifier{.instance_identifier}  cell_clause ::= cell [ library_i dentifier.]cell_identifier  liblist_clause ::= liblist [{library_identifier}] use_clause ::= use [library_ident ifier.]cell_identifier[:config]
"D.1.4 Module Parameters and Ports    module_parameter_port_list ::= # ( parameter_declaration { , parameter_declaration } )  list_of_ports ::= ( port { , port } )  list_of_port_declarations ::=       ( port_declaration { , port_declaration } )       |( )  port ::=       [ port_expression ]       |. port_identifier ( [ port_expression ] )  port_expression ::=       port_reference       |{ port_reference { , port_reference } }  port_reference ::=       port_identifier       |port_identifier [ constant_expression ]       |port_identifier [ range_expression ] port_declaration ::=        {attribute_instance} inout_declaration       |{attribute_instance} input_declaration      |{attribute_instance} output_declaration"
D.1.5 Module Items    module_item ::=       module_or_generate_item    | port_declaration ;     | { attribute_instance } generated_instantiation     | { attribute_instance } local_parameter_declaration    | { attribute_instance } parameter_declaration     | { attribute_instance } specify_block     | { attribute_instance } specparam_declaration               397module_or_generate_item ::=       { attribute_instance } module_or_generate_item_declaration     | { attribute_instance } parameter_override    | { attribute_instance } continuous_assign     | { attribute_instance } gate_instantiation     | { attribute_instance } udp_instantiation    | { attribute_instance } module_instantiation     | { attribute_instance } initial_construct     | { attribute_instance } always_construct module_or_generate_item_declaration ::=      net_declaration     | reg_declaration     | integer_declaration    | real_declaration     | time_declaration     | realtime_declaration    | event_declaration     | genvar_declaration     | task_declaration     | function_declaration non_port_module_item ::=       { attribute_instance } generated_instantiation    | { attribute_instance } local_parameter_declaration     | { attribute_instance } module_or_generate_item     | { attribute_instance } parameter_declaration    | { attribute_instance } specify_block     | { attribute_instance } specparam_declaration  parameter_override ::= defparam  list_of_param_assignments ;
Module parameter declarations     local_parameter_declaration ::=       localparam [ signed ] [ range ] list_of_param_assignments ;      | localparam integer list_of_param_assignments ;      | localparam real list_of_param_assignments ;     | localparam realtime list_of_param_assignments ;      | localparam time list_of_param_assignments ;  parameter_declaration ::=          398      parameter [ signed ] [ range ] list_of_param_assignments ;      | parameter integer list_of_param_assignments ;      | parameter real list_of_param_assignments ;     | parameter realtime list_of_param_assignments ;      | parameter time list_of_param_assignments ;  specparam_declaration ::= specparam [ range ] list_of_specparam_assignments ;
Port declarations     inout_declaration ::= inout [ net_type ] [ signed ] [ range ]           list_of_port_identifiers  input_declaration ::= input [ net_type ] [ signed ] [ range ]            list_of_port_identifiers output_declaration ::=        output [ net_type ] [ signed ] [ range ]            list_of_port_identifiers     | output [ reg ] [ signed ] [ range ]            list_of_port_identifiers      | output reg [ signed ] [ range ]            list_of_variable_port_identifiers     | output [ output_variable_type ]            list_of_port_identifiers     | output output_variable_type            list_of_variable_port_identifiers
Type declarations     event_declaration ::= event list_of_event_identifiers ; genvar_declaration ::= genvar  list_of_genvar_identifiers ;  integer_declaration ::= integer list_of_variable_identifiers ;  net_declaration ::=       net_type [ signed ]             [ delay3 ] list_of_net_identifiers ;      | net_type [ drive_strength ] [ signed ]            [ delay3 ] list_of_net_decl_assignments ;      | net_type [ vectored | scalared ] [ signed ]             range [ delay3 ] list_of_net_identifiers ;     | net_type [ drive_strength ] [ vectored | scalared ] [ signed ]             range [ delay3 ] list_of_net_decl_assignments ;      | trireg [ charge_strength ] [ signed ]            [ delay3 ] list_of_net_identifiers ;      | trireg [ drive_strength ] [ signed ]             [ delay3 ] list_of_net_decl_assignments ;     | trireg [ charge_strength ] [ vectored | scalared ] [ signed ]             range [ delay3 ] list_of_net_identifiers ;      | trireg [ drive_strength ] [ vectored | scalared ] [ signed ]            range [ delay3 ] list_of_net_decl_assignments ;          399real_declaration ::= real list_of_real_identifiers ;  realtime_declaration ::= realtime list_of_real_identifiers ;  reg_declaration ::= reg [ signed ] [ range ]            list_of_variable_identifiers ;  time_declaration ::= time list_of_variable_identifiers ;
Net and variable types     net_type ::=        supply0 | supply1     | tri  | triand | trior | tri0 | tri1     | wire | wand | wor  output_variable_type ::= integer | time  real_type ::=       real_identifier [ = constant_expression ]      | real_identifier dimension { dimension }  variable_type ::=       variable_identifier [ = constant_expression ]      | variable_identifier dimension { dimension }
"Strengths     drive_strength ::=       ( strength0 , strength1 )      | ( strength1 , strength0 )      | ( strength0 , highz1 )     | ( strength1 , highz0 )      | ( highz0 , strength1 )      | ( highz1 , strength0 ) strength0 ::= supply0 | strong0 | pull0 | weak0  strength1 ::= supply1 | strong1 | pull1 | weak1 charge_strength ::= ( small ) | ( medium ) | ( large )"
"Delays     delay3 ::= # delay_value | # ( delay_value [ , delay_value [ , delay_value ] ] )  delay2 ::= # delay_value | # ( delay_value [ , delay_value ] )  delay_value ::=       unsigned_number      | parameter_identifier      | specparam_identifier     | mintypmax_expression               400D.2.3 Declaration Lists     list_of_event_identifiers ::= event_identifier [ dimension { dimension }]           { , event_identifier [ dimension { dimension }] }  list_of_genvar_identifiers ::= genvar_identifier { , genvar_identifier }  list_of_net_decl_assignments ::= net_de cl_assignment { , net_decl_assignment }  list_of_net_identifiers ::= net_identifier [ dimension { dimension }]            { , net_identifier [ dimension { dimension }] }  list_of_param_assignments ::= param_ assignment { , param_assignment }  list_of_port_identifiers ::= port _identifier { , port_identifier }  list_of_real_identifiers ::= real_type { , real_type }  list_of_specparam_assignments ::= specparam_assignment { , specparam_assignment } list_of_variable_identifiers ::= variable_type { , variable_type } list_of_variable_port_identifiers ::= port_identifier [ = constant_expression ]                    { , port_identifier [ = constant_expression ] }"
"D.2.4 Declaration Assignments    net_decl_assignment ::= net_identifier = expression param_assignment ::= parameter_identifier = constant_expression  specparam_assignment ::=       specparam_identifier = constant_mintypmax_expression    | pulse_control_specparam  pulse_control_specparam ::=        PATHPULSE$ = ( reject_limit_value [ , error_limit_value ] ) ;    | PATHPULSE$specify_input_terminal_descriptor$specify_output_terminal_descripto r                     = ( reject_limit_value [ , error_limit_value ] ) ; error_limit_value ::= limit_value reject_limit_value ::= limit_value  limit_value ::= constant_mintypmax_expression"
D.3.4 Primitive Gate  and Switch Types     cmos_switchtype ::= cmos | rcmos  enable_gatetype ::= bufif0 | bufif1 | notif0 | notif1 mos_switchtype ::= nmos | pmos | rnmos | rpmos n_input_gatetype ::= and | nand | or | nor | xor | xnor  n_output_gatetype ::= buf | not  pass_en_switchtype ::= tranif0 | tranif1 | rtranif1 | rtranif0 pass_switchtype ::= tran | rtran
"D.4.1 Module Instantiation    module_instantiation ::=      module_identifier [ parameter_value_assignment ]        module_instance { , module_instance } ;  parameter_value_assignment ::= # ( list_of_parameter_assignments )  list_of_parameter_assignments ::=       ordered_parameter_assignment { , ordered_parameter_assignment } |        named_parameter_assignment { , named_parameter_assignment }  ordered_parameter_assignment ::= expression          405named_parameter_assignment ::= . parameter_identifier ( [ expression ] )  module_instance ::= name_of_instance ( [ list_of_port_connections ] )  name_of_instance ::= module_instance_identifier [ range ] list_of_port_connections ::=         ordered_port_connection { , ordered_port_connection }       | named_port_connection { , named_port_connection } ordered_port_connection ::= { attribute_instance } [ expression ]  named_port_connection ::= { attribute_instance } .port_identifier ( [ expression ] )"
"D.4.2 Generated Instantiation    generated_instantiation ::= generate { generate_item } endgenerate generate_item_or_null ::= generate_item | ; generate_item ::=        generate_conditional_statement      | generate_case_statement     | generate_loop_statement      | generate_block      | module_or_generate_item generate_conditional_statement ::=        if ( constant_expression ) generate_item_or_null [ else generate_item_or_null ]  generate_case_statement ::= case ( constant_expression )               genvar_case_item { genvar_case_item } endcase  genvar_case_item ::= constant_expression { , constant_expression } :                generate_item_or_null | default [ : ] generate_item_or_null generate_loop_statement ::= for ( genvar_assignment ; constant_expression ;                genvar_assignment )                begin : generate_block_identifier { generate_item } end genvar_assignment ::= genvar_identifier = constant_expression  generate_block ::= begin [ : generate_block_identifier ] { generate_item } end"
"D.5.2 UDP Ports     udp_port_list ::= output_port_identifier , input_port_identifier { , input_port_identifier } udp_declaration_port_list ::=      udp_output_declaration , udp_input_declaration { , udp_input_declaration } udp_port_declaration ::=        udp_output_declaration ;      | udp_input_declaration ;     | udp_reg_declaration ;  udp_output_declaration ::=        { attribute_instance } output port_identifier     | { attribute_instance } output reg port_identifier [ = constant_expression ] udp_input_declaration ::= { attribute_instance } input list_of_port_identifiers  udp_reg_declaration ::= { attribute_instance } reg variable_identifier"
D.6.2 Procedural Blocks and Assignments    initial_construct ::= initial statement always_construct ::= always statement  blocking_assignment ::= variable_lvalue = [ delay_or_event_control ] expression  nonblocking_assignment ::= variable_lvalue <= [ delay_or_event_control ] expressionprocedural_continuous_assignments ::=        assign variable_assignment      | deassign variable_lvalue     | force variable_assignment      | force net_assignment      | release variable_lvalue     | release net_lvalue  function_blocking_assignment ::= variable_lvalue = expression  function_statement_or_null ::=       function_statement      | { attribute_instance } ;
D.6.3 Parallel and Sequential Blocks    function_seq_block ::= begin [ : block_identifier          { block_item_declaration } ] { function_statement } end  variable_assignment ::= variable_lvalue = expression  par_block ::= fork [ : block_identifier            { block_item_declaration } ] { statement } join  seq_block ::= begin [ : block_identifier           { block_item_declaration } ] { statement } end
D.6.6 Conditional Statements    conditional_statement ::=        if ( expression )              statement_or_null [ else statement_or_null ]     | if_else_if_statement  if_else_if_statement ::=        if ( expression ) statement_or_null       { else if ( expression ) statement_or_null }       [ else statement_or_null ]  function_conditional_statement ::=        if ( expression ) function_statement_or_null           [ else function_statement_or_null ]      | function_if_else_if_statement  function_if_else_if_statement ::=       if ( expression ) function_statement_or_null        { else if ( expression ) function_statement_or_null }        [ else function_statement_or_null ]
"System timing check commands     system_timing_check ::=        $setup_timing_check     | $hold _timing_check          413    | $setuphold_timing_check      | $recovery_timing_check      | $removal_timing_check     | $recrem_timing_check      | $skew_timing_check      | $timeskew_timing_check     | $fullskew_timing_check      | $period_timing_check      | $width_timing_check     | $nochange_timing_check $setup_timing_check ::=        $setup ( data_event , reference_event , timing_check_limit [ , [ notify_reg ] ] ) ;  $hold _timing_check ::=       $hold ( reference_event , data_event  , timing_check_limit [ , [ notify_reg ] ] ) ;  $setuphold_timing_check ::=        $setuphold ( reference_event , data_event , timing_check_limit , timing_check_limit                       [ , [ notify_r eg ] [ , [ stamptime_condition ] [ , [ checktime_condition ]                           [ , [ delayed_reference ] [ , [ delayed_data ] ] ] ] ] ] ) ;  $recovery_timing_check ::=        $recovery ( reference_event , data_event , timing_check_limit [ , [ notify_reg ] ] ) ; $removal_timing_check ::=        $removal ( reference_event , data_event , timing_check_limit [ , [ notify_reg ] ] ) ; $recrem_timing_check ::=        $recrem ( reference_event , data_event , timing_check_limit , timing_check_limit                       [ , [ notify_reg ] [ , [ stamptime_condition ] [ , [ checktime_condition ]                        [ , [ delayed_reference ] [ , [ delayed_data ] ] ] ] ] ] ) ;  $skew_timing_check ::=        $skew ( reference_event , data_event , timing_check_limit [ , [ notify_reg ] ] ) ; $timeskew_timing_check ::=        $timeskew ( reference_event , data_event , timing_check_limit                    [ , [ notify_reg ] [ , [ event_based_flag ] [ , [ remain_active_flag ] ] ] ] ) ; $fullskew_timing_check ::=        $fullskew ( reference_event , data_event , timing_check_limit , timing_check_limit                      [ , [ notify_reg ] [ , [ event_based_flag ] [ , [ remain_active_flag ] ] ] ] ) ; $period_timing_check ::=        $period ( controlled_reference_event , timing_check_limit [ , [ notify_reg ] ] ) ;  $width_timing_check ::=       $width ( controlled_reference_event , timing_check_limit ,                     threshold [ , [ notify_reg ] ] ) ;  $nochange_timing_check ::=       $nochange ( reference_event , data_event , start_edge_offset ,                          end_edge_offset [ , [ notify_reg ] ] ) ;                  414System timing check command arguments     checktime_condition ::= mintypmax_expression controlled_reference_event ::= controlled_timing_check_event  data_event ::= timing_check_event  delayed_data ::=       terminal_identifier      | terminal_identifier [ constant_mintypmax_expression ]  delayed_reference ::=       terminal_identifier     | terminal_identifier [ constant_mintypmax_expression ]  end_edge_offset ::= mintypmax_expression  event_based_flag ::= constant_expression notify_reg ::= variable_identifier  reference_event ::= timing_check_event  remain_active_flag ::= constant_mintypmax_expression stamptime_condition ::= mintypmax_expression  start_edge_offset ::= mintypmax_expression  threshold ::=constant_expression  timing_check_limit ::= expression"
D.8.5 Expression Left-Side Values     net_lvalue ::=       hierarchical_net_identifier      | hierarchical_net_identifier [ constant_expression ] { [ constant_expression ] }      | hierarchical_net_identifier [ constant_expression ] { [ constant_expression ] } [                constant_range_expression ]     | hierarchical_net_identifier [ constant_range_expression ]      | net_concatenation  variable_lvalue ::=       hierarchical_variable_identifier      | hierarchical_variable_identifier [ expression ] { [ expression ] }      | hierarchical_variable_identifier [ expression ] { [ expression ] } [ range_expression ]     | hierarchical_variable_identifier [ range_expression ]      | variable_concatenation
D.8.6 Operators    unary_operator ::=       + | | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~  binary_operator ::=        + | | * | / | % | == | != | === | !== | && | || | **     | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<  unary_module_path_operator ::=        ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~ binary_module_path_operator ::=        == | != | && | || | & | | | ^ | ^~ | ~^
"Prabhu Goel, the inventor of the PODEM test generation algorithm. Verilog HDL was  introduced into the EDA market in 1985 as a simulator product. Verilog HDL was  designed by Phil Moorby, who was later to become the Chief Designer for Verilog-XL  and the first Corporate Fellow at Cadence Design Systems. Gateway Design Automation  grew rapidly with the success of Verilog-XL and was finally acquired by Cadence Design"
"Compile time is usually long for compiled code simulators, but, in general, the execution  speed is faster compared to interpreted simulators. An example of compiled code simulator is Synopsys VCS simulator.      Native compiled code simulators read in th e Verilog HDL design and convert it directly  to binary code for a specific machine platform. The compilation is optimized and tuned  separately for each machine platform. Of course, that means that a native compiled code simulator for a Sun workstation will not run on an HP workstation, and vice versa. Because of fine tuning, native compiled code simulators can yield significant  performance benefits. An example of a native compiled code simulator is Cadence"
"Event-Driven Simulation, Oblivious Simulation     Verilog simulators typically use an event-driv en or an oblivious simulation algorithm. An  event-driven algorithm processes elements in the design only when signals at the inputs  of these elements change. Intelligent scheduling is required to process elements. Oblivious algorithms process all elements in the design, irrespective of changes in  signals. Little or no scheduling is required to process elements.                      425"
"Fault simulation is used to deliberately insert stuck-at or bridging faults in the reference circuit. Then, a test pattern is applied and the outputs of the faulty circuit and the  reference circuit are compared. The fault is said to be detected if the outputs mismatch. A  set of test patterns is developed for testing the circuit."
"This book does not take a “cookie-cutter” approach to learning Verilog, nor is it a completely theoretical book. Instead, it describes some of the formal Verilog syntax and definitions, and shows practical uses. Once we cover most of the constructs of the language, the book examines how style affects the constructs you choose while2 Verilog Quickstart modeling your design. This text is not intended as a complete and exhaustive reference on Verilog. For a comprehensive Verilog reference, I suggest one of the reference manuals from IEEE, Open Verilog International (OVI) or your tool vendor."
"Gateway Design Automation in 1986) introduced a product named  Verilog. It was the first logic simulator to seamlessly incorporate both a higher-level language and gate-level simulation. Before Verilog, there were many gate-level simulators and several higher-level language simulators,  but there was no way to make them work together easily. About the same time, Gateway added the -XL algorithm to its product, creating Verilog-XL. It was the addition of  this algorithm that put Verilog on the map."
"There is another key reason why HDLs were created. The United States Department of Defense (DOD) realized that they had a lot of electronics designed and built for them, and their products had a long life span. In fact, DOD  might use equipment for upwards of twenty years. Over such periods semiconductor technology changed quite a bit. DOD realized they needed a technology-independent way to describe what was in the semiconductors they were receiving. Through a joint effort of the"
"VHDL were developed, the makers of programmable array logic (PAL) chips had created simple languages and tools (such as PALASM) to burn these chips. These languages accepted only simple equations and could create the correct bit pattern to make the  chip reflect the functionality described in the language. Today, synthesisIntroduction 3 tools are much more robust and Verilog or VHDL may be used to  describe many types of chips."
"This book focuses on the first two reasons because when you do these steps correctly, the third—synthesis—is an easily attainable goal. (Chapter 12 covers some synthesis specifics). I believe that if you truly understand Verilog, synthesis is not a problem. Furthermore, I think it is fine if not all your code is immediately synthesizable."
"Which of  these levels do you think Verilog can be used for? The an swer to this question varies, but  Verilog can definitely be used from the system level down to switches. However, Verilog is most commonly used from behavioral through gate levels. This book focuses on this commonly used range of d esign abst raction."
"The IEEE standard for  Verilog is 1364, and the IEEE standard may also be used as a reference. Verilog documentation falls into two categories: Reference manuals and user guides. Reference manuals provide details of a command or construct. User guides show you how to use a tool. This book falls in between: It teaches you the"
"The usenet is great source for information. There is a news group just for Verilog, called  comp.lang.verilog. This news group sometimes has tips on modeling or news about Verilog tools. There is also a  comp.cad.cadence  news group that has news about Verilog-XL and other tools from Cadence Design Systems, Inc. The comp.cad.synthesis news group has  news about synthesis tools for both Verilog and"
"VHDL. As with most news groups there is a lot of banter, complaining, and philosophy mixed in with the occasional good tip. Perhaps the best single piece of information on the usenet regarding Verilog is the Frequently Asked Questions (FAQ) about Ve rilog. This document is updated and posted frequently and lists currently available tools and publications about Verilog.2 INTRODUCTION TO THE VERILOG LANGUAGE"
"What this means is that you are not limited to eight or sixteen characters to name things. You have over a thousand characters to use in the name of an identifier, so use names that make sense to you. Because names can start with a letter or underscore, and can contain letters and digits, you have quite a bit of flexibility."
"Verilog does not have a standard notation for negated or active low signals. In this book, the standard for active low signals will be the  name of the signal followed by _n. We use this notation to indicate active low signals because the notation is compatible with both Verilog and VHDL. (VHDL does not allow either leading or trailing underscores in names.) We make this recommendation to emphasize good habit from the beginning: Try to use naming conventions that will work both in"
Escaped identifiers allow you to use characters other than those noted  above. The primary use of escaped identifiers is with automated tools and with translators that take a design from a format that allows names not legal in Verilog and converts the design and names to Verilog. Escaped identifiers follow these rules:
"In Verilog the expression  carry/borrow  is not an identifier. It is an expression that says divide  carry by  borrow.  If you want to use an identifier that would not normally be legal in Verilog, such as  carry/borrow  or 3sel, you should form an escaped identifier. An escaped identifier is any sequence of printable characters that starts with a backslash (\) and ends with white space, so the identifiers \ 3sel and \carry/borrow  are legal in Verilog.Introduction to the Verilog language 11"
"You just learned that you need to know the base (or radix) and the number of bits used to represent a number. You also need to know the value, so there are three pieces of information needed to form a number: The number of bits, the radix, and the value. Figure 2-1 shows the notation used in Verilog to fully represent a number."
"The letters used for the radix are  b for binary,  d for decimal,  h for hexadecimal, and o for octal. White space is allowed in numbers, so  1 ‘b 1 is legal, but no space is allowed between the apostrophe and the radix mark. The radix  specifiers are not case sensitive."
"Is x a number? How do you set a signal to the value  unknown? x  by itself is an identifier. If we want the value  x we need to make it into a number. To make a Introduction to the  Verilog  language 17 number we need a number of bits, a radix , and a value. Therefore  1’bx  is a number with the value  x."
"One of the easiest ways to model designs in Verilog is with structural modeling, which is simply connecting devices. Even c omplex models can exhibit elements of structural modeling. W hether you are connecting a cache to a processor, or an inverter to an AND gate, you interconnect the models the same way. This chapter shows you how to connect your models. By the end of this chapter, you should be able to model and simulate simple circuits."
"The primitives  and, nand, or, nor, xor, and  xnor  represent simple logic functions with one or more inputs and one output. Buffers, inverters, and  three-state buffers/inverters  are represented  bybuf, not, bufif1, bufif0, notif1,  and notif0.  The pullup and  pulldown primitives hav e a single output and no inputs, and are used to pull up or pull down a net.  MOS-level unidirectional and bidirectional switches are represented by the rema ining primitives."
"The Verilog terminology for a connection or ""pin"" is port. All the built-in primitives (gates) have ports. The pullup and pulldown primitives have only one port. The first port of each of the built-in primitives (gates) is the output. This allows you, for example, to use the same and primitive to represent a 2-input or 4Structural Modeling 21 input AND gate. The only built-in primitives that can have more than one  output port are the  buf and  not primitives, which can have many outputs, with the last terminal being the input."
"Modules can have ports. Two of the modules you have seen thus far (the  phone and hello modules) did not have ports, but the  mux module did. In general, if you are modeling a self-contained system, you will not have ports. But if you are modeling something that needs to be connected to some thing else, you will need ports to  make those connections."
"The word  instance is not a Verilog keyword. Rather, it is the word we use to mean make a copy of,  or use. When you use a built-in primitive, you make an instance or copy of the built-in gate and list its connections. When you make an instance of a built-in gate, you have the option to give it a unique name called an  instance name."
"When the Verilog simulator finishes compiling your  modules, the first thing it reports is which module or modules are “H ighest-level modules.” Highest-level or top modules are modules that no other module has made an instance of. These nonreferenced modules are considered to be at the top of the hierarchy. Usually there is only one top-level module, the  test bench for your circuit. The test bench module is used to  provide inputs or  stimulus to a design. Chapter 18 discusses test benches."
"When you write the Verilog for the adder you will need to decide on names for the three internal wires. You can use any names you prefer, but your wire names must be legal identifiers. Some suggested wire names are  half_carry_ab, for the output of the top AND gate,  half_sum for the output of the first EXCLUSIVE-OR, and half_carry_cin for the output of the second AND gate."
"Next, connect two of your adders to create an  adder2 as shown in Figure 3-8. You will need an extra signal, internal_carry, to connect the carry_out of your low-order adder to the  carry_in of your high-order adder. You will also need instance names for the two adder modules. The s implest instance names to use are  hi and lo."
"Using the structural modeling technique from Chapter 3, you can model many different types of circuits. One of the reasons thatVerilog gained popularity was the ease with which it allowed mixing behavioral modeling techniques with structural modeling. Before Verilog, there  were both  structural modeling and simulation tools, and there were even behavioral languages and tools, but no one tool combined both behavioral and  structural modeling."
"Procedural Ve rilog code is like programming in a computer language—with one large exception:  Procedural Verilog code adds a concept of time. With a programming language, code is started at a particular location, fo r example, at the first line or main function. In Verilog, code starts running in one of two pl aces: at the initial statement and at the  always statement. Do not assume that you can have only these two statements in your code. You can have as many  initial statements and always statements as you want in your simulation or  module. However, if all the code is started at the  initial and  always statements, how can you know the order in which the statements will run? This is where the model of time c omes into effect."
"Verilog interprets the  initial keyword to mean “start here at  time 0.” Do not let the keyword throw you off track. Sometimes people think the  initial keyword is used only for  initialization. The keyword  initial is used not only for initialization, but also as a place for starting c ode. Look at the test bench for the 8-bit adder. It has an initial statement with several statements to apply the stimulus and check th e results from the adder."
"Although there are four possible ways to nest these blocks, two of the combinations are generally impractical. Nesting  begin-end  blocks w ithin begin-end  blocks has no benefit b ecause all the statements are sequential already. When  begin-end  blocks are nested, it is usually for control flow, such as in the adder test module at the end of"
"One of the most important concepts in Verilog modeling is knowing  when a procedural statement will be run. The preceding section introduced most of the key words and symbols used  to control when a procedural statement will be run. A common cause of incorrect model behavior and even of syntax errors is incorrectly specifying, or  omitting, statements that control when your code should be run. If you don't know when your code should be run, perhaps the simulator or synthesis tool will have the same problem."
"As you learn the Verilog language, you will see that Verilog is a flexible language for modeling. There are some special built-in commands for system functions such as printing messages or reading and w riting files. The special commands are called system tasks and they all begin with the “$” symbol. The “$” symbol is also used to indicate system functions. $display andIts Relatives"
"The $display  command has several relatives:  $write, $strobe,  and $ monitor. $write and $strobe  are very similar to $ display , and $monitor  is a special, more powerful command. $write  is similar to  $display:  They both print results when encountered. The only difference between the two is that  $display  automatically puts in a new line at the end of the results, whereas  $write  does not. If you need to print many results on a line and need to use more that a single  $display  statement, use  $write  statements for the first part(s) of the line and then a  $display  for the rest of the line. You could decide never to use $display, and just use $write and put a new line in manually."
"Does Verilog display the old value or the new? If you are using  $display, an alternative is to put more delay before the  $display statement. However, there is a special form of  $display called  $strobe. If you want to print out your results only after all values are finished changing at the cur rent time unit, use $strobe. $strobe waits until just before time is going to advance, then it prints. With  $strobe you always get the  new value."
"If you want to print re sults as they change, use the  $monitor system task. Unlike $display, which prints only once,  $monitor  automatically prints out whenever any of the signals it is printing changes, so you only need to call it once. Only one $monitor  can be active at a time. If you want to change what is being printed, just execute another  $monitor  system task and the new  $monitor becomes the active print-on-change system task."
"Along with se nding output to the screen and log file, Verilog can write up to thirtyone additional files at the same time. File output is accomplished by d eclaring an integer that is used to represent the file and then opening the file. Once the file is opened, output commands s imilar to the ones previously described may be used to write to the file."
"For each of the commands covered so far, there is an f prefixed version of the command for printing data to files. All the file output commands require the  first argument to be the file integer. The other command arguments are just like those for$display.  Table 5-2 lists the screen and file output c ommands."
"The 2001 standard defines  $ferror,  $fflush,  $fgetc,  $fgets,  $fread,  $fscanf,  $fseek, $fsscanf, $ftel, $rewind, $sformat, $swrite, $swriteb, $swriteh, $swriteo and $ungetc,  as new system functions. These functions work on files opened with $fopen, when $fopen is called with a ""mode"" similar to the ANSI C fopen function call. Each of these new functions works similar to the ANSI C functions by the same name. The details  of these functions are not explained in this Quick-Start book. These functions are similar to the ANSI standar d and documentation can be found in your C and Verilog vendors documentation."
"This section lists a few more that are useful to format output. To print a percent character, use %%. The hierarchical name where the  $display command is being executed can be pr inted using %m. The %% and  %m format specifiers do not have a companion argument in the c omma separated value list following the format string."
"Example 5-9 shows how to use  $timeformat , and the results show the differences between  $time  and $realtime . When the time scale allows non integer delays, $timeformat specifies the number of decimal places to print.  $time will have only the integer portion of the time, but  $realtime  contains the fractional time units."
"Nets (sometimes called wires) are the most common data object in Verilog. Nets are used to interconnect modules and primit ives, as discussed in Chapter 3. You used nets in Exercise 2. There are net types representing wired OR, wired AND, sto rage nodes, pullups, and pulldowns. Th e default net type is a plain wire with no special properties."
"The trireg net type is used in switc h-level modeling for storage nodes. The  trireg net has a capacitive size associated with it. Because  trireg is an abstraction of a Data Objects 63 storage node, the capacitors never decay. See appendix A for the interaction between capacitive size and gate drive stre ngth."
"Memories are arrays of registers. A memory declaration is similar to a  reg declaration with the addition of the range of words in the memory. The range of words can be ascending or descending, as with the range of a vector. The range of words does not need to be zeroor one-based; it can start anywhere. It is usually most c onvenient to declare a memory as zero-based with an ascending range."
"It can be difficult to distinguish memory word references from the reference of a bit of a register. There is no direct way to reference a bit of a memory. Therefore, word references in a memory (which look exactly like bit references in a word) can only be distinguished if you know the data type of the referenced  element. Refer to the declaration to determine whether you are referencing a bit or a w ord. Example 6-8 shows selecting bits in  regs and words in memories."
"Verilog uses the time keyword to represent the current simulation time. time  is double the size of an integer (usually 64 bits) and is unsigned. If your model uses a timescale you can use realtime to store the simulation time and time units. You can declare variables of type time or realtime in your models for timing checks, or in any other operations you need to do with time. See Appendix A."
"Parameters are run-time constants that take their  size fro m their value automatically. The default size of a parameter is the size of an integer (32 bits). For backwards compatibility, you can declare parameters with ranges to make them bigger or  smaller than their default size. Parameters are chiefly useful in creating modules with adjustable sizes or  delays. Even though parameters are run-time constants, their values can be updated at compilation time. Each instance of a module with  parameters can have di fferent values for those parameters at run time."
Events were first used in the phone example in Chapter 1. They are usually used in very abstract models. An event does not represent any  real hardware. Events have no value or duration. They are used  to signal that something has occurred to trigger something else to happen. Events cannot be passed through ports.
"The addition of  multi-dimensional arrays adds a much needed syntax to the Verilog language that also enables selecting a bit from a word in a memory. You can access a word of a multi-dimensional array, or a bit of a word, but you can not access a range of words."
"Up to this point, examples of ports have been nets going through ports. As you move towards procedural modeling in Verilog, you may want to have ports that are regs.  It is legal to declare only output ports as registers. It  is a common error to declare  input  or inout  ports as registers."
"The data types  reg, integer, real, and  time can only be assigned values in procedural blocks of code. These assignments are called  procedural assignments. They are similar to variable  assignments in other programming languages. When the statement is executed, the variable on the left-hand side of the assignment receives a new value."
"The destination of  a procedural assignment is never a  wire. The procedural assignment is one of three types of assignments you will learn in Verilog. For now, just remember that the  left-hand side of a procedural assignment is a  reg. The lefthand side can contain an  integer, time, or  real, but these data types can be thought of as abstractions of  regs."
"The intra-assignment delay  is a special form of the proced ural assignment with a delay in the middle. With the delay on the right-hand side of the e qual sign, the right-hand side is evaluated immediately, but the assignment is delayed. The operation of a procedural assignment with an intra-assignment delay is sample the values on the right had side, delay, then assign.Procedural Assignments 75"
"The examples presented up to this point have been a bstract, and have shown the details of the workings of the procedural assignment. The procedural assignment is the main component of procedural modeling, therefore learning best practices will minimize errors. The procedural assignment can be  used to model two types of hardware: Combinatorial logic and sequential logic."
"In Example 7-9, the intra-assignment delay is shown as a text macro. This allows the delay to be zero, one, random, or any other value desi red. The delay should be non-zero, but  much shorter than the clock period. Unfortunately some code checking tools (lint tools) may flag intra-assignment delays for sequential logic as a warning since synthesis tools ignore these delays. These false warnings should always be ignored. The more important warning is when the delays are omitted from sequential logic that is modeled with non-blocking procedural assignments."
"One of the most important reasons for using a delay is matching pre-synthesis and post-synthesis simulations. The clock-to-out delay of  flip-flops is non-zero. With the intra-assignment delay, the clock-to-out delay is modeled. In a pre-synthesis simulation with gated clocks  or generated clocks it is possible that data will be seen on the wrong edge if the delays are  omitted."
"The remainder of the book uses the blocking with no delays for c ombinatorial logic, and the non-blocking with a text macro for an intra-assignment delay for  sequential logic. You should follow this practice as well with all your hardware models. The only violations of this convention you will find are either abstract examples or testbenches.8 OPERATORS"
"Operators in Verilog can be divided into several categories. One way to categorize the operators is by the number of operands they take. For example, the + symbol takes two operands, as in  a + b. When an operator takes two operands, it is called a binary operator. Verilog, like most programming languages, has many binary operators. Verilog also includes unary operators (which take only one operand), and a ternary operator (which takes three operands)."
"Another way to  group the operators is by the size of what they return. Some operators, when operating on vectors, return a vector. But two types of operators return a single-bit value even if they are pa ssed vectors. The operators that return only a single bit are either reduction or  logical operators."
"The bit-wise     &, and ^ operators typically will be used with two operands of the same size, and return a value of the same size. The shift operators can end up creating a larger (left shifts) or smaller (right shifts) re sult. All of the shift operators except  signed shift right >>>  zero fill. The  signed shift right  fills with  whatever the most significant bit of  the right left hand operator was."
"The ternary operator takes three operands and use s the question mark (?) and colon (:) to indicate the operation. A ternary operation is essentially an  if-then-else statement in an expression. The first operand is logically evaluated. If it is true, the second operand is returned. If the first operand is not true, the third operand is returned."
"In Verilog (as  in other languages), only 0 is false. Because Verilog also includes unknown  x and high impedance z as values, a logical value can also be unknown. If the vector contains  x’s orz’s but no 1s, then the logical value of the vector would be unknown. The convert-to-logical implicit conversion is similar to the reduction OR."
"Verilog’s rich set of operators and data objects to use as operands. In this chapter you will learn how to use the operators to model circuits at a higher level of abstraction than merely structural. At the end of this chapter is an exercise based on the operators introduced in Chapter 8, and the high level constructs presented in this chapter."
"The continuous assignment is a quick and easy way to model when the combinatorial logic can be expressed as a simple equation. A simple buffer (for example,  assign a=b ;), a mux using the ternary operator, an  arithmetic function, or a complex set of Boolean operators. These can all be modeled using the continuous assignment."
"The change (or edge) operator is the “@” (“at” sign). The @ operator is best described as “wait for event.” The event that the @ waits for is normally any change on a signal. The  @ can also be used with the  event data type. In addition to @, there are three related keywords for working with edges or events:  posedge  and negedge  for selecting only one edge, and  or for waiting for a change on more than one signal."
"One of the most important concepts in  Verilog modeling is knowing  when a procedural statement will be run. The remaining key words and symbols that indicate when a procedural statement will be run were just introduced. A common cause for incorrect model behavior and even syntax errors is incorrectly specifying, or omitting, an  indication of when your code should be run. If you don't know when your code should be run, perhaps the simulator or  synthesis tool may have the same difficulty."
Also remember that an  always  loop with no delay or event controls is a zero delay loop. A zero delay loop does not allow s imulation time to advance and your simulation can hang. An  always  with only  wait statements or a path to avoid the delay or event controls may potentially be a zero delay loop. This Page Intentionally Left Blank10 PROCEDURAL FLOW CONTROL
"Under what condition does the design “just do it”? Does this happen when  A is not true, and does the indenting make the result appear? The answer is: When  A is true and B is not true. Why? An  else  is always a ssociated with the immediately preceding if that does not have an else associated with it. In Example 10-3, the else is associated with the latest  if, which is the  if(B)."
"Each of the  case  items (possible matches for the expression being compared to) is denoted by a colon and followed by a single statement. If more than one statement needs to be executed for a particular  case item, enclose the statements in a  beginend block or  fork-join  block. When one case item statement has executed. Flow automatically resumes at the  endcase,  this eliminates the need for a  break  statement like C uses. If you want multiple conditions to execute the same statement, you can separate them with commas before the colon. Only the first condition that is true is executed. The keyword  default  can be used to catch any of the conditions not explicitly stated."
"Let’s model a simple loadable counter. This counter has a  load and a  reset, both of which are active on the rising edge of the clock,  reset has priority over  load, and if load is not set, then the counter counts up or down based on the state of the  up signal. This could be  modeled with some  if-else statements, bu t Example 10-6 uses casez."
The only loop that has been used so far in this book is the  always  loop. The  always loop combines a sta rting point for execution with an infinite loop. The rest of the looping constructs do not imply starting pl aces for exec ution. They must be contained in a procedural block of code so they have a starting point.
"The simplest loop is the  forever  loop. The  forever  loop is an infinite loop. The construct initial forever is almost identical in behavior to always. The forever loop contains a single statement. If you want multiple statements in the  forever  loop, use a begin-end  block. Like the  always  statement,  a  forever  loop without delay or event controls would be a zero-delay loop and inhibits simulation time from advancing."
"The repeat  loop is the next simplest of the looping constructs in Verilog. The  repeat loop takes some expression that will evaluate to an integer, and rep eats the loop that many times. The  repeat  loop is similar to the  forever  loop in that it uses a single statement or a  begin-end  block."
"The test bench reads in an external set of vectors to apply and ex pected values to compare against the ALU outputs. These vectors are in a form readable by Verilog and are read from the file  alu_test.vec,  as is specified in the line with the $readmemh  command. It is difficult to read these vectors because their bytes are not neatly aligned. Rather than go to the trouble of deciphering them, it is much easier to add  $display  statements into the test bench or ALU to evaluate what is  happening with the vectors."
Please refer back to Chapter 8 on operators to create the functions for the alu. There are a few tricks in the exp ressions you will need to figure out to pass the test patterns. Each of the expressions is  simple and can be expressed in a single short equation.
"In Verilog, you may use a  task to encapsulate a behavior. A  task is defined in a module and is invoked when its name is called in  procedural code. A  task has access to all the data objects (nets registers, integers, reals, etc.), so it does not need to have inputs and  outputs, though it can have inputs, outputs and inouts. Tasks may take more than zero time to complete; they can have delays,  wait statements, and event controls in them. Tasks can be used to apply stimulus, simulate bus cycles, display contents of  memories, and many other things. Tasks contain a single statement. If you wan t a task to have more than a single statement, use a  begin-end block or a fork-join block."
"The test_alu module in the previous exercise had a  task called  run_test. The run_test task did not have any inputs or ou tputs, but directly accessed and modified the values on the nets and registers in  the module. When the  run_test task executed its procedural assignment into the stimulus registers, the inputs were  applied."
"Local data can be declared in a  task. The only problem with local data in a  task is with multiple invocations of a  task. If a  task is triggered while it is still running (for example, if a  task is triggered from more than one place or a re-entrant  task), this is legal, but there is only one copy of the local data, so the multiple invocations will be sharing data."
Another common use for  tasks  is to have  tasks  in a module that are only used interactively for de bugging. These  tasks can be activated interactively during a debugging session to display critical information or to set up particular values. A task to display the contents of a memory is shown in the parameterized RAM example in Chapter 14.
"When you declare a function, you must also declare the type and size of the return value. If the size of a function is not declared, it defaults to 1 bit. The size of a function is declared like any other range declaration, so the number of bits returned can be from one to one million."
"A function can also be called in a continuous assignment. Whenever any one of the inputs to the function changes, the function is called. This is consistent with the behavior of the continuous assignment because a continuous a ssignment is reevaluated whenever anything on the RHS changes. Example 11-9 provides an example of a mux implemented with a function and a continuous assignment."
"Now that you know about functions and continuous assignments, modify your result from the previous exercise so a function calculates  carry  and aluout.  Assign the values to  aluout  and carry  from the function in a continuous assignment. Use two more continuous assignments; One to calculate  zero and one to calculate  parity."
"So far you have learned how to use the procedural assignment (which is like a typical assignment in  a programming language) and the continuous assignment (which acts like combinatorial logic). The procedural continuous assignment has unique characteristics, and it shares characteristics with each of the other two assignments, but is identical to neither. The procedural continuous assignment overrides the normal behavior of a reg."
To summarize the PCA: It overrides the normal behavior of a reg. Only one PCA can be active on a reg at a time. The last PCA executed is the PCA in effect. The deassign statement stops the effect of the PCA and the next procedural assignment to the reg takes effect normally.
"Because  inout  ports cannot be regs, how is it possible to do high level  modeling with inouts? The key is to have a reg for the output and a continuous assignment to the port. When sampling the input side of the  inout,  put a  z in the reg, and read the port. When driving a value out, place the value in the output reg. Advanced Procedural Modeling 145"
Putting a  z in the output reg is  like turning off the driver on the  port. This model can be simplified by making the continuous assignment control whether or not the reg is connected. Example 12-12 shows how the continuous assignment was changed so the reg can be disconnected from the  inout port.
"Named blocks can  be referenced with the  disable  statement to stop the execution in the block. (The disable statement is introduced in the next section.) To name a block, place a colon and the name for the block directly after the  begin  or fork statement. Example 12-13 shows both named  begin-end  and fork-join blocks with local regs."
"In this module, the three regs are unique regs. The regs each have a unique hierarchical name. The top level  a is just named  a;the other two regs are  b1.a  and b2.a.  The block names can be any legal  Verilog ide ntifier. The block names  b1 and b2 are used  for simplicity."
"The last  always block that checks for  reset handles the asynchronous nature of reset. Thus, the  other blocks do not need to check for  reset through their code. The fetch and  execute blocks check for  reset, and then disable themselves so that they will not continue if  reset is still asserted. It is important that there is a delay or event control between the start of an  always loop and the statement that self-disables the block. If there is no delay or event  control, the  always loop may become a zero-Advanced Procedural Modeling 149 delay infinite loop under the condition that it  self-disables. Zero-delay  always loops stop the progression of simulation time and your simulation freezes or hangs."
"With this statement, we know the simulation will terminate at time 1000. The only problem with this method is that if more stimulus is added, the simulation might terminate before the end of the stimulus. So if you use a separate  initial block like this to end your simulation, be sure to calculate how far you want it to run before it terminates."
"Often the  $finish statement is included at the end of the stimulus (or elsewhere in the test bench) to check for the final test having been a pplied. If the correct conditions to terminate the simulation never occur (for example, if your code includes a zero-delay  always loop), the simulation may never end on its own."
"If the simulation does not terminate on its own by running out of events to process or by encountering a  $finish statement, the only other way to stop Verilog is through user intervention. To manually stop Verilog, press  Control-C (in most systems), or click the  stop or  interrupt button if you are using a graphical use r interface. Once you have interrupted Verilog, you can  issue the  $finish; command manually on a150 Verilog Quickstart command line, or issue the  exit command from a menu of a graphical interface system.13 USER-DEFINED PRIMITIVES"
"Although the aim of this book is to teach high level modeling in Verilog, the book would not be complete without mentioning user-defined primitives (UDPs). A UDP describes a piece of logic with a truth table. UDPs can be  either combinatorial or sequential. As you may  recall, the Verilog primitive set does not include any muxes,"
"UDPs quickly, and UDPs take up only a small amount of memory. For example, a mux is typically modeled with an inverter, two AND g ates, and an OR gate. These four gates can be replaced with a single UDP. Flip-flops, w hich take even more gates to model than a mux, can be replaced by a UDP. The  most common use for"
"The simplest thing you might want to model with a UDP is a mux. If you want to model a mux, is the mux optimistic or pessimistic? If the two inputs are 1, and the select is unknown, is the output 1 or  x? Because it is your UDP, you get  to choose which result you want."
"UDPs always have scalar inputs (1 bit wide). Combinatorial UDPs can have up to ten inputs (you would not want to create a table larger than that anyway). UDPs in original Verilog have only one output. Th e current IEEE 1364 standard provides for multiple-output UDPs, but this is not common yet. Just as with the built-in primitives, the output port must be the first port in the port list."
"UDPs start to look a bit lik e   is replaced by primitive-endprimitive. The other major difference between UDPs and  modules is that instead of the usual module contents, there is only the  table-endtable construct in the body of the UDP. Table 13-1 shows the symbols used so far, and what they mean."
"One of the most common errors in creating UDPs is to omit one or more combinations of inputs, with the result that the output unexpectedly becomes unknown. Verilog produces an error message if two  lines in a UDP describe the same condition with different outputs. Verilog issues a warning if two lines contain the same input and output description. 154 Verilog Quickstart"
"The order of the columns in the table entries is determined by the port list, not by the order that the ports are declared in the input statement(s). Although the commen t just after the  table keyword is not required, it is good modeling practice to labe l the columns of the table. As you can see from the examples, each line of the table contains the set of inputs, followed by a colon, then the output, and ends with a semicolon. White space is not required in the table so the code in Example 13-3 is legal but difficult to read."
"The sequential UDP differs slightly from th e combinatorial UDP. First, the output is declared as a  reg to alert Verilog that this is a sequential UDP, not a combinatorial one. Next, notice that the table has an extra column, separated by colons. This field represents the current state of the output. The final column is the next output. There are also a few new symbols used in the table, as listed in Table 13-2."
"Any transition on any of the input signals may be used. A UDP may be edgesensitive to a clock, but  level-sensitive to set and reset signals. In a sequential UDP, each row of the table may only contain one transition. There is no way to specify edges on two signals at the same time."
A sequential UDP may have its  output initialized by adding an  initial statement to the UDP. The  initial statement in a UDP may only set the output of the UDP to a constant. The procedural assignment setting the register to a constant is the only statement allowed in an  initial  block in a UDP.User-Defined Primitives 157
"You can design a generic adder and decide how many bits you need later. You can use the same parameterized adder as a 5-bit adder in one place and as a 64-bit adder elsewhere. Parameters are often used to describe the word size of a module, the number of words in a memory, or even delays.  Delays are more  commonly set up with a  specify block that can be annotated with actual delays from an SDF file."
"When you instantiate a parameterized module, you can use the  defparam  statement to override the default value of parameters in the module. parameters are used as constants. The only legal way to change the value of a constant is with the  defparam  statement,  parameters and  defparam  statements are evaluated only during compilation.  parameters  cannot be changed during simulation time. The values are set at compile time.  parameters  are by default 32bit values. It is  not common, but the size of a parameter may be changed by specifying a range in the same way  wire and  register  ranges are declared.162 Verilog Quickstart"
"A parameter that is not passed will have its default value. If a parameter value is an equation such as  W in Example 14-4, the value is recalculated if any of the values in the equation are passed. It is possible to bypass the equation by passing a value to a calculated parameter.This Page Intentionally Left Blank15 STATE MACHINES"
"Moore machines is in how outputs are generated. In a Moore machine, the  outputs are a function of the current state. This implies that the outputs from the Moore machine are synchronous to the state changes. In a Mealy  machine, the outputs are a function of both the state and the inputs."
"Because the output section can be modeled as either sensitive only to changes on state or also sensitive to changes on inputs, you can use this to model both Mealy and Moore machines. This style is the most modular; it may take a few more lines of Verilog code, though it may be the easiest to maintain."
"This style is more compact than the first, and may even be more efficient because the next-state logic is only evaluated on clock edges, rather than whenever an input changes. If your state machine has many inputs that change frequently, this may be a better style to use than the first. This style has the output as a separate section so you can use this style to model both Mealy and Moore machines."
"The third style leaves the state register in a separate  always  block, while combining the next-state logic and the output logic. Because the next-state logic and the output logic may be combinatorial, combining them still allows for modeling both Mealy and Moore machines. However, this grouping does not tend to help the readability of your code; styles 1 and 2 are easier to model and maintain."
"To demonstrate all these styles, with Moore and Mealy variations on them, we will use a simple example. This example won’t be the traffic light controller, vending machine, or a completely trivial state machine, but instead an automatic food cooker. This cooker has a supply of food that it can load into its heater when requested. The cooker then unloads the food when the cooking is done."
"Besides  clock, the inputs to this state machine are  start (which starts a load/cook/unload cycle);  temp_ok (a temperature sensor that detects when the heater is done preheating);  done (a signal from a timer or sensor that detects when the cooking cycle is complete); and  quiet (a final input that selects if the cooker should beep when the food is ready)."
"The outputs from the machine are  load (a signal that sends food into the cooker); heat (a signal that turns on the heating ele ment, which has its a built-in temperature control);  unload (a signal that removes the food from the c ooker and presents it to the diner); and  beep (a signal that alerts the diner when the food is done).State Machines 173"
"With all of these styles to choose from, which one is best? Which one will result in the smallest synthesized circuit? These are not easy questions to  answer. Style 2 is both compact and allows for  both Mealy and Moore mac hines, so this is a good allaround style to use. As for synthesized results, state encoding will have a greater effect on ultimate size than any of these varia tions in style.State Machines 179"
"A common sense approach to state encoding might be to assume that the  heat output needs to be on for the states PREHEAT, LOAD, and COOK. So the states could be encoded with one of the bits set for all of those states. This would have the effect of simplifying the output logic. The  heat output is now simplified to  state[2]."
"This state encoding has a bit for each output and extra bits for states that do not have unique outputs. The states PREHEAT and COOK both have the same outputs, so they need to have two different enc odings. The last bit, used for the BEEP output, can be removed for optimization since it is the same as UNLOAD. This method of encoding uses four or five flip-flops, so it yields a larger circuit than do the o ther encoding methods."
"Each of the state machine examples inc luded a  default clause. Those examples used 3 bits for state, but only five states were  used. Thus it may be possible for the state machine to glitch  into one of the three rema ining illegal states. One other reason for 182 Verilog Quickstart including the  default clause is that when simulation starts, the state machine is in an unknown state, and the  default  clause gets it on track with the first clock."
"In all of the previous state machine examples, the three sections of the state machine were obvious (or explicit) in the coding style. The automatic oven design could also be coded as an implicit state machine. This style can be easier to code and maintain in an abstract model. In this style, only the behavior of the state machine is seen. The values of the outputs can also be seen, but the state register and next-state logic are implied."
"There are many ways to model a state machine. How do you know which style to use and how to encode your states? There are a number of different goals you may have for your state machine: Maximum frequency, area, clock-to-output delay, glitch-free outputs, minimal input setup time, minimum simultaneous switching, minimal power, or ease of maintenance. Each of these goals dictates a different style or encoding method."
"For a state machine to have the highest possible frequency, the next-state logic must be as small as possible. In a logic type such as CMOS (where AND gates are fast), one-hot encoding may generate the fastest next-state logic because each state bit is usually set from the outputs of only AND gates. In other state encodings, there tend to be AND/OR networks driving each state bit."
"For minimal clock-to-output delay, a state machine where the outputs come directly from flip-flops is best. The output-equals-state encoding or  registered output style state machines both have outputs that come directly from flip-flops, making either of these styles the best choices for state machines requiring fast clock-to-output times.186 Verilog Quickstart"
"Most circuits are either sequential or combinatorial. The  Verilog constructs can be used to model both combinatorial and sequential circuits, and it is possible to create models in  Verilog that are neither combinatorial or sequential. (However, if a model is neither sequential nor combinatorial it may not be possible to built it in actual hardware.) This chapter  provides modeling rules for both combinatorial as well as sequential circuits."
"If you intend to model combinatorial logic using the  always block, be sure to model all branches in your logic, or you may imply a latch. All if statements must have else clauses. All  case statements must either have a  default clause or all cases specified. Otherwise, a latch will be implied, and you will not have combinatorial logic."
"Example 16-15 is a memory exerciser. It waits for a start signal, then it waits for a clock. It cycles through each location in a memory and performs a write cycle and writes into each location data equal to the complement of the a ddress. The write cycle is a sequence of  events: First there is a time delay, then the data register is set."
"The model then waits for a  clock and provides a pulse on the  write signal. The memory responds with the  ready signal when it is done with the write, so the model waits for the ready signal before continuing. The write sequence continues through all of the memory locations and then all of the location go through a read sequence."
"Most of the sequential behavior in th e memory exerciser models either the read cycle or write cycle. The sequential code for the read and write cycles could be moved into tasks. With the complexity of the read and write cycles removed, the memory exerciser could then be expanded to run other memory test patterns. The new model for the memory exercise is shown in Example 16-16."
"The one-shot in Example 16-17 may work for you, but it has a few potential problems. What happens if the trigger signal is held high? What happens if the trigger signal rises again during the time constant? For this one-shot, the answer to both of those questions is: Nothing happens. This one-shot starts timing at the first positive edge and then ignores the trigger signal until the time constant expires."
"You have already seen a model of a one-shot, which is the simplest of  asynchronous circuits. This next set of examples will go through  the entire design process of a slightly more complex asynchronous system. First, a simple behavioral model of the system will be developed. The behavioral model will use some of the less common behavioral constructs to develop a working model quickly. The working model will then be used to develop a comprehensive test bench. (A following chapter, Chapter 17, will go into more detail about test benches.) The comprehensive test bench will then be used to verify the detailed implementation model of the system. Because this is an asynchronous circuit, we cannot use synthesis tools to help with the implementation.200 Verilog Quickstart"
"The sense input is low whenever a door is open. When everything is secure, the sense input is high. The  disarm input is momentarily low when the system should be disarmed. The  armed output is high when the alarm is armed. The alarm output is high for five minutes after the alarm is armed and the  sense input goes low. The alarm arms itself from the disarmed state when the  sense input is high for five uninterrupted minutes. If the alarm output goes high, after five minutes, it goes low again, and waits five minutes for  sense to go high before rearming."
"This model will have three asynchronous features. The first is the five-minute timer, which itself is asynchronous because it is reset by the  sense signal when the system waits for five minutes of no lows on the  sense input. Secondly, the system is asynchronous because it will go from an armed state to an alarm state instantly when the  sense input goes low. The final asynchronous feature is the  disarm signal, which quiets the al arm output signal and sets the machine into a disarmed state instantly."
"The implementation is now possible because the desired behavior has been modeled and a comprehensive test bench has been developed. Because the  final implementation will be based on some target technology, we will not attempt a final implementation here. What we will do is take a step towards implementation by using a combination of structural and behavioral modeling tec hniques. The timing element, a resistor, a capacitor, and a discharge transistor will be modeled behaviorally. Some SR flip-flops will be modeled structurally, and the “glue logic” that determines the functionality will be modeled with con tinuous assignments. The difficult part of the design will be creating the correct equations for the state204 Verilog Quickstart transitions. Because the state transition logic needs the most tuning to get it right, the continuous  assignments will make modifying it easy. The continuous assignments will map easily into some final technology for final implementation."
The timer (which is  partially analog) has a simple mapping of its  elements into actual components. The voltage comparitors that determine the charge state of the capacitor are modeled as buffers. The resistor-capacitor timing element is modeled as behavioral code. The  set and  reset  signals to each of the flip-flops are active low.
"Continuous assignments are used to m odel the logic that feeds the flip-flops. To make the equations as simple to write as possible, the bit-wise complement op erator is used to invert each of the c ontinuous assignments and make them active low. It is much easier to debug the circuit at this mixed behavioral and structural level than it would be to try  and go directly from the  behavioral model shown in  Example 16-19 to some final implementation."
"Example 16-23 is a simple behavioral description for a Z-detector. If you were modeling a test bench that was going to check when a bus was being driven, the behavioral approach is the best solution. If you wanted to model the library cell that detects the special voltage on an input to put a chip in a special mode, a structural approach might be more a ppropriate."
"Example 16-24 uses the proper ties of the  mos switch primitives in Verilog to  create a structural model for the Z-detector. The two unidirectional  nmos transistors split the signal and feed it both to a  pulldown and  pullup. Rather than using  wire type nets and  pullup and  pulldown primitives, the model can just use the  tril and  tri0 net types. When the input is driven, the same signal will drive both nets. When the input is not driven (Z), the two nets will go to different values, and the difference will be detected by the  xor gate."
If your design requires a multiplier you will find there are many algorithms for multipliers. You must then choose how you want to implement your multiplier and what the trade-offs will be.  There is a dizzying array of ways to build a multiplier. A few examples of multipliers and their trade-offs are presented in this section.
"The final tip in this chapter is the use of progressive re finement, as demonstrated with the alarm examples. First, a behavioral model of the desired system answers this question: “What do you think you are des igning?” Next, you should develop a218 Verilog Quickstart set of tests to exercise the operating functions. This step answers the  question: “Does it work the way you expect it to?” With these two  questions answered, you can be confident about what you are designing, and you have a set of tests to prove that the design works correctly."
"Once you know exactly what you are building and have a set of tests, you can start to work on  more detailed models. Each of the more detailed models can be tested with the original tests to insure correct functionality. Finally, a model of the ultimate implementation can be verified with the original tests."
"Many people are hesitant to start with a behavioral model because they think it may be a waste of time. They may think: “If I am not drawing schematics or writing synthesizable code, I am not working toward my final implementation. So why do it?” The time spent developing and testing a behavioral model pays off as a huge time savings in the design and debugging of the final model. It was much easier to debug the behavioral model of the alarm than to debug the partial implementation."
"When you are working on a larger system with more than one functional block, the payoff of starting with behavior models is even more pronounced. Each block can be modeled rapidly at the behavioral level. The blocks can be tested together as a system. The interactions between functional blocks in a system are often the source of unforeseen behaviors. These unforeseen interactions can be observed and debugged. By debugging the system early in the design cycle, you can avoid redesign later in the design cycle. As you complete more detailed descriptions of each of the functional blocks, you can still test the entire system by using behavioral descriptions for some of the blocks and more detailed  descriptions for others."
"Two obvious questions in the construction of a model are, “Will it  simulate quickly?” and, “Will it synthesize into what I want to  build?” Although simulation performance and synthesis are two considerations for modeling (and the choices you make as you write a model), they are not the only considerations in choosing a modeling style."
"So far in this book, the only forces influencing your models have been “write it fast” or “use this new  construct.” As new constructs were introduced in this book, you were encouraged to use each of them in a model, so the “use this construct” force on modeling style is an artifact of the learning process. The most common force on modeling style is “write it fast.” The old adage “haste makes  waste” still applies today. A hastily written model may appear to have the correct functionality, but it220 Verilog Quickstart may be terribly inefficient for simulation, or it may not be synth esizable. As mentioned in Chapter 1, there are three basic reasons for using a hardware description language: Simulation, documentation, and synthesis. Th erefore, these three are also  forces that act on modeling style."
"These forces may be pulling your modeling style in different directions. It would be naive to think there is only one force on modeling  style, and that there is only one “correct” model for a given circuit. Unfortunately, many people have tried this “one correct model” approach and have not realized tha t they were costing themselves time and productivity."
"Every model starts with the write-it-fast approach, but where does the model go from there? You can hope that the model will be revised, move in the direction of documentation, and become a good reference for the design. Is a model that represents good documentation the final step in the evolution of model? No: You need to use the  correct model for each job."
"Example 17-2 shows how the flip-flop can be modified to wait first for the data to change and then wait for the clock to change. The two flip-flop models behave identically, but the second one may potentially be a thousand times faster. Before you get carried away and change all of your flip-flops, be  aware that this trick has to be applied properly. If your data change at about the same rate as your clock, there may be no advantage to  this modified flip-flop. You should also be aware that most modern simulators automatically optimize your flip-flops, so this model may actually go slower. This example is only meant to show that by taking into consideration the operating conditions of your models, you may be able to improve their simulation performance."
"Simulation has to come first. Simulation answers the important question: “Are you designing the correct system?” To  answer that question the predominant forces on modeling style are “write it fast” and “simulation performance.” Once you have verified that you are designing the correct system, you can make any changes to222 Verilog Quickstart your models that are needed for synthesis. If you start with synthesis as your only consideration, you may never  answer the ques tion, “Are you designing the correct system?”"
"Change the question from “Is it synthesizable?” to “Is it combinatorial or sequential?” If your model is ne ither combinatorial nor sequential, or you can’t determine which one it is, most likely the synthesis tool won’t be able to either, and your model is not synthesizable. If each part of your circuit is either combinatorial or sequential, it should be synthesizable."
"Sequential logic is also synthesizable, but not all sequential logic synthesizes. If you have only one edge of one clock, it is synthesizable. The  one edge refers to the active clock edge. Asynchronous set and reset are synthesizable so it is legal to have three edges in the sens itivity list of the  always statement.."
"A more subtle problem  is the  case  of how  clr_n interacts  with  the clock (clk). This model creates a one-time-unit glitch on the output in some cases when clear is asserted. If clear is not asserted (clr_n =  1), the model waits for the clock, and the output  (q)gets a new value one time unit after the clock. If the model is waiting for the clock, and then clear is asserted, the output does not change until the clock rises, whereupon the output will change to the then current value of the input (d).The always loop will recycle to the top, where it  checks clear and then one unit later the output will go to 0."
"You may have noticed that the  begin-end block is removed. The  begin-end block is not needed because there is only one statement (the  if)in the  always block. Omitting the begin-end block around a single statement is a matter of preference. It is definitely not needed, though some designers may feel it improves readability."
"The negative setup time was corrected in Example 17-4 by using the intraassignment delay. In this case, the model waites for the clock, sampled the input immediately, and then waites one time unit to propagate it to the output. The assignment is also changed from a blocking to a non-blocking assignment to be consistent with the preferred style."
"It is starting to look like using the continuous assignment is the most efficient way to model. However, modeling style is not as simple as that. There are cases in which the continuous  assignment would be very inefficient to use. The continuous assignment is evaluated whenever any of the inputs change: If you have a complex expression with many inputs, a lot of unnecessary calculation may take place."
"Example 17-11 repeats some style errors you have seen before, such as the extra begin-end block. You have seen the merits of removing extra  initial blocks inserted for arbitrary  initialization. This model evaluates the shift at every clock, independently of the inputs changing, and you have seen that error before as well."
"The biggest inefficiency in Example 17-11 is the clock. In large systems, the clock is evaluated more often than anything else. Efficient generation and distribution of the clock can make  a big difference in model performance. It does not make sense that each module in a system reproduces the clock; the clock should be generated externally and passed into the module. If you had a thousand or more instances of a module that generated the clock internally, you would spend most of your time in simulation generating a clock. The statement  internal_clock = ~internal_clock makes this clock generator even more inefficient and time consuming because the computer must calculate the complement."
"Example 17-12 cleans up the barrel shifter in a number of ways. The clock is now passed in rather than regenerated. The port  declarations are in the same order as the ports list. If you look carefully at the past several examples, you will notice that the port declarations are not always in the same order as the port list. There is no requirement in Verilog that the port declaration order match the port list order, but matching the orders improves readability."
"User-defined primitives (UDPs) are fast and efficient in Verilog. To model a flipflop in Ve rilog, you might need to use four or more gates. But the same flip-flop might be modeled with a s ingle user-defined primitive. An AND-OR-INVERT gate might require the use of three Verilog built-in primitives (two  ands and a  nor) but could be modeled with a single UDP. In general, Verilog simulators can evaluate a"
"When designing a library for Verilog, as a general rule you should use a UDP if you can replace three or more gates. The only time you might not want to use a UDP is if there are many inputs. UDPs allow up to ten inputs. However, in  practice, anything more than six inputs is difficult to write."
"The advantage of this style for combinatorial logic is that the combinatorial logic is zero delay independent of the number of stages of logic. Since the  actual depth and delay of the combinatorial logic is be determined by the synthesis tool, the delay in the source Verilog is irrelevant. An  interesting side effect of this strategy is that a logic error resulting in a combinatorial feedback loop will be easy to detect as a zero delay oscillation in simulation."
"The advantage of using the unit delay blocking assignment for sequential logic is two fold. It reduces the possibility of race conditions in simulation, and it makes it232 Verilog Quickstart easier to understand the results  of simulation. Since synthesis ignores the delays, there is no h arm in including them in the simulation."
"If a simulated register has zero clock-to-q delay, it is possible that the data from this register can get to the n ext register before the clock. Although it is possible that the final implementation of a circuit will result in enough delay in the clock signal to mimic this condition of the data arriving at the next stage before the clock, rarely is data faster than the clock. Using a clock to q delay of one will eliminate these races in the verilog code and more closely model the final circuit."
"Debugging a circuit is also simplified when the registers have clock-to-q delay. If you look at a result wave form from a simulation that had zero delay, it is difficult to know if a change that occurs with a clock was seen at that clock or caused by that clock. With a unit delay, it is quite easy to see that a signal changed as a result of the clock, and the value of that signal is seen on the edge of the clock.18  TEST BENCHES   AND TEST MANAGEMENT"
"You might well ask: “If it takes more time and more code to test a model, why is testing being introduced so late in the book?” The answer is that Verilog makes writing your tests easier by using the same techniques for writing tests as you use to write your models. In this chapter, you will us e all the constructs that you have already learned  to test models."
"While you develop the test suite and behavior model for the alarm model in Chapter 16 or for any other complex system, you will undoubtedly find mismatches between the assumptions of behavior in the model and the assumptions of behavior in the test suite. The differences are resolved by  fixing either the model or the test suite, until a single correct set of behaviors is found. The process of enhancing the model234 Verilog Quickstart and enhancing the test bench can be one of the most time-consuming parts of the design cycle."
"Developing a good set of tests can make the difference between a design that behaves properly the first time, and a design that does not perform correctly under some conditions. While you develop your test suites, you can add  $monitor, $display,  and custom checking tasks to check for correct responses."
"The code to apply tests often becomes repetitious. As with any Verilog module, if the same several lines of code are repeated many times, it becomes obvious that a task would be a more effective modeling technique. You may find that you use  tasks more often in creating test benches than in  the course of designing circuits."
"The main purpose of modeling with Verilog is to determine if you are designing and building the correct circuit or system. When you model  a design, you are trying to describe how your circuit should act. When you write tests, you are trying to simulate the environment in which the circuit will function, and to exercise all of the functionality of your circuit. Your tests should try to exercise every possible scenario that the circuit  may encounter."
"Some approaches to testing a new design involve modeling an entire system around it. For example, to test a model for a disk controller, the disk and a computer interacting with the disk controller might be modeled. In a case like this, there mayTest Benches and Test Management 235 be a hundred times more code written to test the circuit than to model the circuit itself."
"The most common types of tests written for a model are called  functional tests because they test the expected functionality. These tests apply the expected inputs and look for  correct responses. During the development of your model, your first tests will exercise what you expect to happen. Functional tests do not necessarily test every possible manufacturing fault, nor do they necessarily test every possible set of inputs."
"During the progress of a design, you should develop a set  of tests with known responses. Each time you make a change to the design, you should rerun the tests and compare the results from the new model to the results from the old model. This rerunning of tests and matching the results to  a known, good set of results is called regression testing. The purpose of  regression testing is to verify that no errors are introduced into the circuit as the design evolves."
"When your design is ready for fabrication, you will need a set of tests that will be run against the design when it is fabricated. The purpose of these tests is different from that of the functional tests. The purpose of the sign-off tests is to detect any manufacturing faults. There are  special simulators (called fault simulators) that can determine if your tests exercise and detect all possible manufacturing faults. It may be possible to  exercise your circuit to catch all possible manufacturing faults with many less vectors than you used for functional testing."
Another concern when writing sign-off tests is the simulator(s) that  your vendor will support for  sign-off. Most ASIC vendors support Verilog-XL as a sign-off simulator. The simulators that vendors support are important because the vendors have verified that these simulators (with their libraries) produce the same results as the circuits  they fabricate. You want th e circuits which a vendor fabricates for you to behave the same as your simulations.236 Verilog Quickstart
"A unit test is a test that tests an individual module, or a small set of modules, that form a functional unit in your design. A  system test is a test that tests a larger group of modules that forms a complete system. A large design  project will have a combination of both system and unit tests."
"Unit tests should be written for every functional unit in a large design. It is much easier to debug a problem using a unit test. However, it might be easier to find a problem using system tests because system tests tend to exercise a circuit more fully, and run the circuit through many more cycles. Therefore, systems tests tend to catch more errors. When a problem is found with a system test, you can write a unit test to reproduce and debug the problem."
"Typically, a large system design is  partitioned into functional units. As you model each unit in Verilog, you should develop unit tests. As units become functional, they can be combined into subsystems, and you can develop subsystem tests. Next, all the modules can be combined into a system, often by  adding further modules to build a complete system (including the operating environment). Systems tests ar e developed and run against the simulated system. The more tests you can run in simulation, the better the chance that the final design will be built without errors."
Test plans do not need to be long or  detail each test. The test plan should at least outline the general tests you plan to write. Without a plan you will likely forget to test something. Please see Chapter 22 regarding code coverage for a correlation between test plans and code coverage.
"Testbenches need to model the timing of the expected circuit. The test bench needs to provide inputs with adequate setup time and hold time. The test module must allow the model enough time to respond. The pre-synthesis model may be able to respond in near zero time, but the final implementation may need significant time to respond."
"Similar to the combinatorial test cycle e xample; If the inputs were applied from one initial or  always block, and the results were being checked in a different  initial or always block, the timing should allow the results to be checked before the stimulus is changed. Please see Chapter 22 for  an additional example."
"The test bench for the 8-bit adder is a self-checking test bench: The test bench automatically checks the results from the adder and reports any errors. The test242 Verilog Quickstart bench for the  alu model is also self-checking. There are many ways to build a selfchecking test bench. The basic idea is to automatically check the response from the circuit and detect any differences from the expected results. Self-checking test benches are the easiest to use as regression tests because, after you run a selfchecking test bench, it is easy to tell if the tests pass or fail."
"How should you generate the correct answers for  a self-checking test bench? In the test b ench for the 8-bit adder, the correct answers were hard-coded into the test bench. This choice of modeling style was based on your presumed level of Ve rilog experience at the time that this test bench was introduced. That test bench could be improved in three ways. First, Verilog could be made to do the math and calculate the expected response. Second, the repeated code for each test could be simplified and put into a  task. A third alternative for self-checking is to compare the  response from two different circ uits, typically a b ehavioral model and a gate-level model."
"Because Ve rilog uses the same language for modeling and stimulus, your stimulus can respond to your circuit. Stimulus can be simply written to apply different inputsTest Benches and Test Management 247 at different times. But what if the circuit is not ready for the input? You may need to rewrite your stimulus to get the correct timing. For example, assume you are designing a bus protocol controller that waits for a request, responds with a grant, and then expects data. You could write the stimulus to simply be time based, and guess how long it will take from the request to the grant, and guess when to a pply the data. Instead, you could write a test that applies the request, then waits for the grant and then applies the data. Using the response-driven method, if the design parameters change and the time between the request and the grant changes, the test does not need to be rewritten."
"Example 18-7 dynamically calculates the nex t time a printer can accept more data, based on the incoming data rate, the size of the buffer, and the print speed. This abstraction represents the model of a printer being able to  accept data. If this printer were being designed by your design group, they could also modify the size of the buffer, the speed of the buffer, and the speed of the print mechanism."
"If your job is to write a test bench to send the message “this is a test message”,  how will you time the sending of the characters to the printer? One approach would be to send them slowly. Perhaps a delay of 100 between them would be  conservative, but248 Verilog Quickstart that may not accomplish the goal of se nding them as fast as the printer can accept them. Another approach might be to guess the timing in this fashion: send the first four characters (the size of the bu ffer) with a delay of 11 (the  buffer write time plus the acknowledge  time). With what timing would the fifth character be sent?"
"In the test module in Exa mple 18-8, the test bench must be modified to send the data at the c orrect rate each time the design team makes a change in the printer design. This means you will have to spend time modifying the timing in the test bench, rather than designing a better printer or testbench."
"In Example 18-9, all the timing is removed from the test bench. Instead, the test bench gets its timing from the device u nder t est. Test benches driven by the circuit’s response can be used to simplify the timing, as shown here, or the test  bench can apply a different set of inputs depending on the output from a circuit."
"There are two system tasks for reading a file into the memory, $readmemh (hexadecimal format) and $readmemb  (binary format). Each of the tasks takes between two and four arguments. The last two arguments are optional and are usually omitted. The first argument is the name of the file to read in, and the second is the name of the memory to be l oaded. You can optionally specify the starting and ending addresses as the third and fourth arguments."
"The file to be read in can  be created with any text editor, or created from Verilog using a  $fdisplay  or $fstrobe  command. The format of the file is simply numbers in hexadecimal format for  $readmemh,  or binary for  $readmemb,  separated by white space. The files may contain comments and the numbers may be uppercase or lowercase. The digits may be separated by underscores for clarity.252 Verilog Quickstart"
"The $readmemh or  $readmemb  task invocations do not need to be in the module that declares a memory array. The name of the memory being loaded may be a hierarchical name; for example, you could load all of your memories from the test bench. You do not need to load the memories at time  0 from an  initial statement; they can be loaded at any time during the simulation. If the file you are trying to load cannot be read, Verilog issues a warning, and simulation continues without the file. Make sure that the files exist or you may be debugging a simulation with incorrect results because you overlooked the warning."
"If you want to check that the correct number of locations is read, you can use the start and end address optional arguments to the  $readmemh or  $readmemb  system tasks. If Verilog does not read the correct number of values from the file, a warning message will be printed. The start and end addresses are also useful to reverse the254 Verilog Quickstart direction of loading if you declared the range of words backwards or wish to load a range backwards."
"You can set values of  registers, load files into memories, or trigger tasks you coded into your modules specifically for debugging—all interactively. If you designed a microprocessor system, the main stimulus is most likely the program loaded into memory, and you may have coded a task to reset the processor. A sequence of tests might be to load a program, reset the processor, let it run, load the next program, and so on. This  sequence of  loading programs may be  repeated for several test programs. You can  write a script of interactive commands to run a set of test cases."
"The advantage of using a command script is you don’t have to code all of your tests into a test bench in advance. As your tests develop or as you debug interactively,Test Benches and Test Management 255 you can begin to build a set of scripts for your test cases, rather than modifying test benches or test vector files."
"Built-in self-test (BIST) is a technique for applying stimulus and collecting responses within a circuit. BIST requires the modeling of a linear feedback shift register (LFSR) to generate input patterns and a multiple-input shift register (MISR) to collect the responses. The LFSR uses a polynomial to generate a known sequence of pseudo-random inputs. The MISR uses another polynomial to generate a unique signature for the tests. The art of using the optimum polynomials is not discussed here, and is the subject of other texts. When the circuit is in test mode, the inputs are switched from their normal function to be connected to the LFSR, and the outputs are connected to the MISR. The LFSR is initialized to a known  value and a fixed number of clocks is applied. At the end of the clocking sequence, the value in the MISR is  compared to the correct signature and the pass/fail status is determined."
"The system tasks  $fdisplay or  $fstrobe are used to write  the values to a file. In which module should you put the tasks to  capture the i nputs and outputs? The easiest place to capture the inputs and outputs of a submodule is in the submodule itself. In the submodule, you can easily see all the inputs and outputs, and you also know when the inputs and outputs are valid. The second easiest place to capture the inputs and outputs is from the module that instantiated the s ubmodule. Once you have decided where to do the capture, you need to know when to capture the values."
"Once the vectors have been captured to a file, you need to create a new test bench that will play the vectors back into the module. The module that plays the vectors back should apply the inputs, allow time for the outputs to settle, and then check the outputs. The test bench for the ALU used in cha pter 6 is an example of a module that plays back captured vectors."
"Once you have captured the vectors, and have created the new test module, it is important to test the vectors and new test module against the  module with which you captured the vectors. You may have captured the vectors at the wrong times or applied them with the wrong timing, so double-check them against the original submodule before using them to test other versions of the submodule."
"The resulting test module and tes t vectors form a unit test for the submodule, and these serve as a quick verification of correct implementation. This test bench is satisfactory as a check-off (or  regression) test. Unfortunately, because the tests embodied in the test vectors may be difficult to understand, it may be difficult for you to isolate the cause of any discrepancies."
"For example, you may have noticed that  $readmemh was used to read the file of test vectors. This is the simplest way to read files of stimulus into Verilog. If you have a large number of signals or a large number of test vectors, you will have to allocate a large amount of memory in Verilog to hold the test vectors. This might not be practical for a large circuit. Verilog has some system tasks that are more efficient in handling the reading and writing of files for test vectors. These routines are $incpattern_write (to write out a file of test vectors);  $incpattern_read (to read in the file and apply the stimulus); and  $compare or  $strobe_compare (for comparing the response from the circuit to the expected values).This Page Intentionally Left Blank19 MODEL ORGANIZATION"
The ` include  can include a full file path name. Standard  practice suggests that `include  should only have the file name and not the path. This allows the files to be more portable and m oved around your system or to a nother system. The verilog simulator allows you to specify a set of directories to search for the included files.
"You may have noticed that the output  count is repeated three times. Once in the port list, a second time when the direction is declared and a third time for the  reg declaration. The input puts are declared twice , and co uld have been declared three times if we had re-declared the inputs as w ires (which they are by default).266 Verilog Quickstart"
"When running simulations for a large system there will be many test cases. This does not always imply tha t there are many testbenches. There many be many more test cases than testbenches. A simple example of many test cases with a single test bench is system with an embedded  processor. The test  bench may be exactly the same, but a different program may be run on the processor. A system regression script may run the simulator again and again with either a different file name passed to the simulator, or with a new program file copied or linked to the file the simulated memory always reads."
"If each test case has a unique directory we can make use of two powerful techniques to simplify creating a set of tests for a c omplex system. Imagine a complex system with many devices on a bus, and one bus master is responsible for initializing the bus, then conducting the tests. The system reset and initialization sequence isModel Organization 267 common, but each test is conducted by a unique set of write and read commands issued on the bus. Each unique test sequence will be in a file called  current_test.v and in its own directory. The test bench has the reset sequence and then includes the current_test.v  file."
"There are many interesting things in this test bench. The event  start_tests is used to signal the test sequence(s) to start once the system is initialized. The system initialization sequence is abstracted via text m acros. A global variable  passed is declared and initialized to true. If a test fails  passed is set to zero. There is  a task done which is called from the current test upon success or failure. The task also runs some a dditional time to allow the system to complete what wa s doing. Often in complex systems, a test may pass or fail, but the next few cycles are interesting."
"This current_test.v does some interesting things. Since it is included in the module but not in a  begin-end  block, it can declare some a dditional data it needs,  i, j, data1, and data2. This test also has two initial blocks that wait for the  start_tests  event before they begin testing. In this example a data equals address test in run by first writing data to two boards in parallel, then reading them back in parallel. The test competes by calling  done on the first failure or when all is complete. Note, it is assumed that the  write and  read tasks (not defined) can read and write two boards at the same time. It is  also assumed that the second board finishes after the first."
"Remember the exact details of this test are not important, the important concept to learn is that the test can be broken between the test bench and the test sequence, and we can have many test sequences run by having a unique  current_test.v in many test case di rectories.Model Organization 269"
"Mismatched port order may also result in any  number of Verilog error or warning messages. If you sw itch the order of two signals that are  of different sizes, you might get a port size mismatch wa rning message. If you connect an output port of an instaniated module to a reg in the current module, you may get an error message about an illegal declaration."
"The best wa y to avoid mismatched ports is to adopt some simple rules for port order. For simple modules with one output (such as a mux), use the same rules as those that apply to  the Verilog built-in primitives: State the output first, then the inputs followed by the control input. For an adder, you might code the design by starting with the most significant output and proceed to the least significant input."
"Look at every procedural assignment. The object on the le ft-hand side of the assignment must be declared as a  reg (or possibly as an  integer, real, or  time ). The error messages for a missing re g declaration points to the procedural assignment. IfCommon Errors 273 you have an error message about the left-hand side of a procedural assignment, chances are you are  missing a reg declaration."
"Missing width declarations can be more difficult to find than missing  reg declarations. It is possible that no error or warning message will be issued for a missing width declaration. It is easy to forget to declare the width of a  port, net, reg, or function. Carefully check each of your modules for the width of each of these."
"All buses (multibit wires or vectors) used within a module must be declared. You might have omitted a net and width declaration, with the result that you see not an error message, but only incorrect behavior. Verilog generates implicit nets for every undeclared wire name that is used in a module or primitive instance. If an implicit net is generated due to a missing declaration, a warning about port size mismatches may be issued. If you declare a net but  omit its width, there may be no error message—merely incorrect results. This is especially true if that net is used only in continuous assignments. If you are expecting to use any multibit nets, carefully check their width declarations."
"LSB). The left index is always the index of the MSB and the right index is the index of the LSB. If the index of the MSB is greater than the index of the LSB, the range is descending. If the index of the MSB is less than the index of the LSB, the range is ascending. Both ascending and descending ranges are legal in Verilog."
"A more subtle error (one that can be more difficult to debug) occurs when you connect something that is declared to be ascending to something that is declared to be descending. The connection could o ccur in a module instance, procedural assignment, or  continuous assignment. Although  connecting objects with  reversed ranges is not an error, such a practice can be confusing. MSBs are always connected to MSBs, so the resulting bit indexes are reversed. The best way to avoid the confusion created by reversed ranges is to adopt a standard of using only ascending or descending ranges for your project."
"In sum, inco rrect declarations can cause misleading error messages or merely incorrect behavior. This section did not list every possible problem, but tried to highlight some of the more common errors of this type. You have to check that the declaration of each object you use matches its use and your expectations. For example, a novice might be unsur e when to declare a  net versus a  reg.  If you are unsure what should be a  net and what should be a  reg, reread the sections of"
"The compiler catches this type of error, but the error message may simply indicate a syntax error. The key  questions to ask are these: When do you want the code to run? and When did you tell Verilog to run it?  You will recall that  initial and  always are the only two starting places for behavioral code in Verilog."
"Most commonly, every  always statement is immediately followed by the  wait for event (@) operator. If you have any  always loops without the  wait for event operator, you may unintentionally introduce a zero-delay always loop. If you do not have an @ but have the wait( ) (level-sensitive delay operator), you may still have a zero-delay loop when the condition for the wait( ) is true.276 Verilog Quickstart"
"An initial block runs only once. If you use an  initial block to model the function of your circuit, the block runs only once. Most models  are supposed  to run more than once. For example, whenever the inputs cha nge. If you start the behavior of your model with only an  initial block, the model will run only once and at time 0. Of course there are exceptions, because there are looping constructs you could put inside the  initial block."
"You should reserve the  initial block for stimulus and initialization. Look at each initial block and ask yourself: When should this code run? If the code should run once, starting at time 0, then it is a valid  initial block. If the code s hould run when the inputs change, you should model with an  always block."
Every wire and reg in Verilog starts out unknown. Any circuit that depends on a known value to get started needs some form of initialization. Make sure that any counter or state machine has a  reset or some way to get into a known state. The simplest case of a missing initialization is a clock generator.
"If a section of code looks confusing, it has a good chance of being wrong. Extra code tends to creep into modules during the initial debugging process. To suppress compiler errors, a novice may add additional code, additional declarations, or may create procedural continuous assignments. A simple bidirectional buffer that could be modeled with only two continuous assignments could grow to have two temporary regs, two  always  blocks,  if statements, and procedural continuous assignments, for a total of ten or more lines of code."
"Regs and  always  blocks are a powerful and versatile way to model almost anything in Verilog. To avoid storing a value unintentionally, you must know when values in regs are  updated. Occasionally a reg  retains an old value when the  value should change. Remember that a reg will hold a value forever until that value is changed. If your intended model is combinatorial, make sure that the code is evaluated whenever any inputs change. For combinatorial logic, each if should have an  else, and all branches of  case statements must be specified or a  default  clause is needed."
"At first glance, the negative  setup merely looks like a  clock-to-q delay. If you look carefully at the code, you will notice that  d is actually sampled one time unit after the clock. This is a negative setup. The  clock-to-q delay can be maintained without the negative setup by using the intra-assignment delay as shown in Example 20-3."
"In Verilog it is possible to perform many operations in zero  time. Even though operations take place in zero time, they still have some order in which they must occur. A net or reg can change values many times during the same time unit. If a model is sampling a net or reg during the same time unit when it changes, does the model see the final value, the previous value, or an intermediate value?"
"In gate-level modeling, regs and c ombinatorial circuits typically have delays, so zero-delay race conditions are eliminated. In behavioral modeling, regs and combinatorial circuits can have zero delay. Thus it is possible that a value may be sampled before it has a chance to change, or a value may be sampled after it changed when in fact the  previous value was desired. It is also possible that a circuitCommon Errors 279 may behave properly with zero-delay races. It is best to avoid zero-delay races because they can cause unpredictable results. The easiest way to avoid zero-delay races it to model regs and/or combinatorial logic with unit delays."
"Verilog code than in a completed chip. In Verilog you can watch the exact sequence of events, look at values buried within the circuit, and even see what is driving a multiply driven signal. It takes technique, strategy, and experience to find errors quickly and correct them. This chapter explains a few basic techniques and provides strategies for when to apply those techniques."
"One thing to remember about debugging is this: The more information you  extract from the simulation, the slower the simulation will go. Printing information to the282 Verilog Quickstart screen, saving values to a file, or sending signals to a waveform all slow down simulation. If you print out every value in your circuit at every simulation time, the simulator will spend all its time writing out values, and you will spend all your time analyzing them. A more efficient approach is to start out by examining a few critical signals and then narrowing the scope of your debugging. Working on a small, focused portion of the circuit at a time has a minimal effect on the simulator and allows you to understand all the values you are examining."
"During functional debugging, you are as likely to find errors in the test bench as you are in the design. Because there can be m ore code in the test bench than in the model, you may actually find more errors in the test bench! Another common place to find errors is in the interconnection between modules. If the original specification was subject to interpretation, the assumptions made in one module may not match the assumptions in a connected module."
"The simplest type of message to print out is a message that indicates where  a block of code is running. You can add a  $display statement inside an  always block to indicate when certain tests are about to start, or to indicate the completion of a test.Debugging a Design 283"
Adding a  $display  statement to an  always block can tell you when that block was triggered. Even a function can have $display statements in it. Knowing what is running gives you some insight into the functionality of the design. Knowing whether or not a critical test or event takes place can greatly narrow down the search for bugs.
"The most common task used to print values is  $monitor, which prints out whenever any of the signals it is monitoring changes. The output from  $monitor can be difficult to interpret if you are looking for the timing between changes. There may be ten lines printed one time unit apart, and then no printouts for a thousand time284 Verilog Quickstart units, depending on the activity of the signals being monitored. Even though you may be printing out the simulation time along with the signals, you may not easily see the timing relationships. In conclusion, use  $monitor  to see a sequence of changes and not timing; use  $display  or $strobe  for periodic pr intouts, or for printouts triggered by interesting sequences of events."
"All output that goes to the screen also goes into a log file. By default, the log file is named  verilog.log.  You can specify a different name for the log file with the l command-line option. There are two  additional  commands,  $nolog and  $log, that that you can use within Verilog to turn logging off, turn it back on, and open a new log file for following results."
"Waveforms are a great tool for visualizing both the values and the timing of circuits. Every Verilog simulator has a waveform tool. All these tools allow you to select signals to be written to the  waveform display. Some allow interactive, marching waveform displays; others are only postprocessors that let you look at waveforms after simulation is c omplete. All wave form displays allow you to measure the  distance between edges of signals. Consult the documentation for the tool set you are using for exact instructions on using a waveform tool."
This technique is limited by how much data you can analyze with a graphical waveform. All the data from a sm all circuit that runs for a short time can be Debugging a Design 285 displayed and analyzed in a waveform. There is usually too much data from  a large simulation for effective graphical viewing and analysis.
"Change Dump. VCD is not a particularly efficient format, but it is recognized by most wave display tools. Example 21-1 shows an initial block you can add to your code  to generate  a full wave database  for you  design;  be sure  to use a  proper  file name and select the hierarchical name for what to dump."
"A common problem when looking at wave files is trying to figure out what data is seen at a clock edge if the data changes at the same time as the clock. If you follow the suggestion for unit delay seque ntial blocks, it will be clear what data is seen at the clock, and what changes are as a result of the clock.286 Verilog Quickstart"
Interactive debugging is the ultimate way of finding problems in a simulation. You can look at any value; see what is driving a wire; change values on wires and regs; set breakpoints; add signals to a waveform display; and so on. The entire simulation becomes an open book for you to look at.
This book has attempted to be simulator-independent. This section provides details on interactive debugging using commands native to Verilog-XL™. Some clone simulators may include some or all of these commands and features by the same name or by using other commands . Companies that primarily use simulators other than Verilog-XL often have some copies of Verilog-XL for debugging use.
There are other ways to put the simulator into interactive mode. It is often desirable to start the simulator in  interactive mode. You can start the simulator in interactive mode by using the  -s command-line option. The  -s stands for “stop at time 0.” It is equivalent to having  initial $stop; in one of your Verilog modules.
"Verilog in the normal fashion, and they hit the interrupt key. The interrupt key can be a button in a graphical user interface, or a keyboard key. The interrupt key is most commonly  Control-c. For the purposes of this section,  Control-c is used as the interrupt key. If your system uses a different key, use that one instead."
"Another way of entering the interactive mode is hitting a breakpoint. Verilog-XL includes a number of specialized breakpoint commands for breaking on edges of signals, on particular  values, or at a particular time. All of these breakpoint commands are similar to encountering a  $stop statement. If you are using the graphical user interface to Verilog-XL, the menu command s for breakpoints use these special commands. Breakpoints are usually set after Verilog is in interactive mode. To enter the interactive mode, start Verilog with the  -s command-line option."
"Verilog does not have a special language for interactiv e debugging. You use the same commands you have  already learned (in behavioral modeling) for interactive debugging. There are a few special keystrokes, and a few commands, that are most useful for interactive debugging that will be introduced in this chapter."
"You have already lea rned that it is important to remember the semicolons in interactive mode, just as in Verilog source files. There are two other equally important keys. The period key has  a special meaning in interactive Verilog; it means “c ontinue.” The comma key means “single step”, or executed as a single statement. Enter the"
"Now that you know the basics of r unning a simulation in interactive mode, you are ready to run a simulation and traverse through the design and observe values. When a simulation is interactive, you can navigate through the design and observe the values anywhere in  the circuit. The commands and examples shown in this section are specific to  Verilog-XL. How ever, other simulators may  support these or similar commands."
"The command  $list decompiles th e module at the current scope. This is the easiest way to see the values of the inputs and outputs. As Verilog-XL decompiles or lists the source code, it adds comments showing the current value of each of the ports in both hexadecimal and decimal. The numbers in the left-hand column are the line numbers from the original source file. Looking at the decomposed source and values of inputs and outputs may provide important clues when debugging a circuit. On large circuits, it may not be effective to use  $list if the modules are large and $list would generate too much output to be readable."
"Another effective command to observe values is  $display. The  $display command can be used to display the value of any signal in any radix. Since  $scope was used to traverse into a particular hierarchy, the hierarchical names of the  displayed signalsDebugging a Design 307 are relative to the current scope. Interactive debug is the most common place of using the alternate forms of  $display."
Just knowing  the value of a signal is not always sufficient to understand the behavior (or misbehavior) or a circuit. Sometimes it is necessary to see what is driving a wire (especially if a wire is  driven by more than one source). The command  $showvars shows all the drivers of a wire.
"Waveforms and graphical user interfaces make it easier for you to traverse hierarchy and observe values. Graphical tools can greatly re duce your debugging time by enhancing visualization of values, simplifying hierarchy traversal, and simplifying the selection of signals to display. The techniques demonstrated by Example 21-7 and its results can be repeated using the graphical tools provided with your simulator."
"Catching an error in simulation can be difficult. If an error occurs early in a simulation, you  might catch it with tracing from the start. If an error occurs after a large amount of  simulation has occurred, it is often more difficult to find and  isolate the problem. Looking through a large amount of trace output to find the problem might take a long time. You could run the simulation without tracing until near the time when you expect the error to occur, and then turn on tracing with  $settrace."
"You have seen how to add a  $stop interactively or in your source code to try and stop when you think an error is going to occur. Often you may find that you want to start over again and look at the simulation at an earlier time. The command  $reset resets simulation time to 0, so you can start again and set earlier breakpoints or try other techniques."
"If you want to have a known point in the simulation to return to and resume simulation from other than time 0, you can create a save-restore file. At any time during simulation you can issue the  $save command and  Verilog-XL creates a snapshot of the  current s imulation. You can return to the saved state of the simulation two ways. The  $restore command reads back in a saved simulation snapshot. The  -r command line option lets you jump back into a previously saved snapshot. The combination of  $save and  -r allows you to save where you are in your debugging process, exit, and then resume your simulation later."
"The $save and  $restore commands help you return to a state of simulation that might otherwise be difficult to reach. If you are debugging a problem that only occurs after sev eral hours of simulation, you can use  $save to save the circuit a few hours into the simulation. As you are de bugging, rather than starting from time 0 each time you are looking for the error, you can restore and save the time it took to get to that state. You can have as many save-restore files as you have disk space."
"In such cases, one of the first things to check is timing. Are both models for the circuit expecting inputs at the same time? Are the inputs being provided at the proper times? Different models often have  different output timing. A behavioral model might have zero or unit delay, but a gate-level m odel may have some longer delay associated with the actual gates. Is the circuit taking longer than expected by the test bench or other connection modules to produce correct outputs, or are you just looking for the outputs too soon?"
"If timing is the only di fference between two simulations, is the timing of both models acceptable? Can yo u modify the test bench to accept both timings? If unknowns constitute the difference, can the circuits and  stimulus be modified to eliminate the unknowns? If the difference is functional, which model is correct?"
"As designs become more complicated, it is important to measure that every branch of each  if and  case statement is executed as part of the simulations. If you find statements that are not executed, you need to write more tests that try to exercise the316 Verilog Quickstart previously non-executed stateme nts. If you cannot write tests that exercise the nonexecuted parts of your code, you may have cases in which it is not possible to execute those statements. The  non-executed statements may  require an impossible set of conditions to be executed. In this case the code may be  dead code and s hould be removed. In other cases, the code may simply be difficult to test."
"Code coverage and fault simulation are both ways to measure how well a design is tested; Code coverage measures if each line of the code is executed, while fault simulation determines if each potential manufacturing fault can be observed. Code coverage is not a replacement for fault s imulation and both may be needed as part of your design flow. 100% code coverage does not ensure 100% fault coverage."
"Testing  a model  with  a FIFO  is complicated: This m odel can be  fully  tested  with  a unit level test bench. The unit level  test bench  can control the rate of the reads and writes, therefore the conditions of  empty and  reading from an empty FIFO can be tested. The condition offull and writing to a full FIFO can also be tested. Example 22-4 shows a simple FIFO model."
"When you run this example, look initially at line coverage. You will see the first counter has 100% line coverage, but that the new style counter never tests load or match. If you look at an expression coverage report, you can see that the (count==ldata) expression is never  true for either counter."
"The bufif0 primitive  has two  inputs, (data  and control)  and one  output. When  the control input is “0” the output passes the same value as the data input, except that an input of “z” produces an output of “x”. When the control input is “1” the output is “z”. The port order of the primitive is  output, input, control."
"The notif1  primitive has two inputs, data and control and one output. When the control input is “1” the output passes the opposite value as the data input, except that an input of “z” produces an output of “x”. When the control input is “0” the output is “z”. The port order of the primitive is  output, input, control."
"The nmos and  rnmos primitives are  abstractions of  unidirectional switches. When the gate input is 1, this input is passed to the output, otherwise the output is high impedance. The difference between the  nmos and  rnmos is the  nmos passes the input to the output with the strength unchanged, but the  rnmos passes the value to the output with a decreased strength. The port order of the primitive is  output, input, gate."
"The pmos and  rpmos primitives are abstractions of unidirectional switches. When the gate input is 0, this input is passed to the output, otherwise the output is high impedance. The  difference between the  pmos and  rpmos is the  pmos passes the input to the output with the strength unchanged, but the  rpmos passes the value to the output with a decreased strength. The port order of the primitive is output, input, gate. 336 Verilog Quickstart"
"The tranif1  and rtranif1  primitives  are bi-directional pass gates. They have three terminals. The first two are the bi-directional data pins, the third is the control input. When the control input is  1, data passes between the two bi-directional data pins. Delay specifications on  these primitives ar e only turn on and turn off delays."
"A primitive may have from zero to nine delay specifications. If a primitive instance has no delay specification the primitive is zero delay. A primitive may have separate delays for both rise (to  1) and fall (to 0 ) time. A primitive that can output high impedance (such as bufif1, bufif0, and the switches) has an optional turn off (to z) delay. The delay to  x is always the least of  the delays specified. If a single delay is specified, it is  used for both rise and fall (and turn off if applicable)."
"The main drawback to using delay units is that if you use them on one  module you must use them on all modules. When you declare  a delay unit and precision, that declaration applies to all following modules. You can  declare the unit and precision for just one module and have that declaration carry forward to all your other modules: Just make sure that the file with the delay unit and precision declaration is the first one compiled. If you compile a module before a ` timescale  directive and a `timescale  directive appears later in the source, Verilog will issue an error message and abort compiling your  files."
"Example A-2 shows two modules with their timescales. With the addition of the time unit and precision, decima l delays are possible. Timescales and decimal delays are usable for both behavioral and gate-level modeling, but most delays in behavioral modeling are unitless. Behavioral modeling tends  to be  more abstract and delays less important than delays in gate-level models."
"As mentioned in cha pter 2, Verilog supports  seven levels of strength. A be havioral statement such as a register or c ontinuous assignment always drives with a strength of strong. By default all gate instances drive with  strength strong, with the exception of the  pullup, pulldown, and resistive  transistors which are pull, or are decreased by one strength level."
"Table A-21 shows the output strength for the switch primitives. The  nmos, pmos, cmos, tran, tranif0,  and tranif1  primitives are considered to be ideal devices since the strength is not reduced through them, except that supply strength is reduced to strong. The rnmos, rpmos, rcmos, rtran, rtranif0, and rtranif1 primitives are considered to be resistive devices since the strength is reduced through them."
"The Verilog  language is a hardware description language that provides a means of specifying a digital system at a wide range of levels of abstraction. The language supports the early conceptual stages of design with its behavioral level of abstraction, and the later implementation stages with its  structural abstractions. The language includes hierarchical constructs, allowing the designer to control a d escription’s complexity."
"It is sometimes difficult to separate th e language from the simulator tool because the dynamic aspects of the language are defined by the way the simulator works. Further, it is difficult to separate it from a synthesis tool because the semantics of the language become limited by what a synthesis tool a llows in its input specification and produces as an  implementation. Where possible, we have  stayed away from simulatorand synthesis-specific details and concentrated on design specification. But, we have included enough information to be able to write working executable models.xvi The Verilog Hardware Description Language"
"The book takes a tutorial approach  to presenting the language. Indeed, we start with a tutorial introduction that presents, via examples, the major features of the language and the prevalent styles of describing systems. We follow this with  a detailed presentation on using the language for synthesizing combinational and sequential systems. We then continue with a more complete discussion of the language constructs."
Our approach is to provide a means of learning by observing the examples and doing exercises. Numerous examples are provided to allow the reader to learn (and relearn!) easily by example. It is  strongly recommended that you try the exercises as early as possible with the aid of a Verilog simulator. The examples shown in the book are available in electronic form on the enclosed CD. Also included on the CD is a simulator. The simulator is limited in the size of description it will handle.
"The majority of the book assumes a knowledge of introductory logic design and software programming. As such, the book is of use to practicing integrated circuit design engineers, and undergraduate and graduate electrical or  computer engineering students. The tutorial introduction is organized in a manner appropriate for use with a course in introductory logic design. A separate appendix, keyed into the tutorial introduction, provides solved exercises thatdiscuss common errors. The book has also been used for courses in introductory and upper level logic and integrated circuit design, computer architecture, and  computer-aided design (CAD). It provides complete coverage of the language for design courses, and how a simulator works for"
"Thus, this section can stand as a short primer on many of the new changes, or as a reference for how to read “old code.” Throughout this  preface, cross references are made to further discussion in the earlier parts of the book. However, not all changes are illustrated in this preface."
"The authors would like to acknowledge  Accellera (http://www.accellera.org), whose role it is to maintain and promote the Verilog standard, and the  many CAD tool developers and system  designers who have contributed to  the continuing development of the Verilog language. In particular, the authors would like to thank Leigh Brady for her help in  reviewing earlier manuscripts."
"Digital systems are highly complex. At their most detailed  level, they may consist of millions of elements, as would be the case if we viewed a system as a collection of logic gates or pass transistors. From a more abstract viewpoint, these elements may be grouped into a handful of  functional components such as cache memories, floating point units, signal processors, or real-time controllers. Hardware description languages have evolved to aid in the design of systems with this large number of elements and wide range of electronic and logical abstractions."
"The creative process of digital  system design begins with a conceptual idea of a logical system to be built, a set of constraints that the  final implementation must meet, and a set of primitive components from which to build the system. Design is an iterative process of either manually proposing or automatically synthesizing alternative solutions and then testing them with respect to the given constraints. The design is typically divided into man y smaller subparts (following the well-known divide-andconquer engineering approach) and each subpart is further divided, until the whole design is specified in terms of known primitive components."
"The language supports the early conceptual stages of  design with its behavioral constructs, and the  later  implementation stages with its structural constructs. During the design process, behavioral and structural constructs may be mixed as the logical struc-2                                                                The Verilog Hardware Description Language ture of portions of the design are designed. The description may be simulated to determine correctness, and some synthesis tools exist for automatic design. Indeed, the Verilog language provides the designer entry into the world of large, complex digital systems design. This first chapter provides a brief tour of the basic features of the"
Example 1.1 A Binary To Seven Segment Display Driver (E Segment Only) four-bit binary input and drives the seven segments needed to display the digits zero through nine and the hexadecimal digits A through F. Only the logic to drive segment E of a display is shown in the example.
"The fifth  line,  and its  continuation onto lines  6 through  10, instantiates  five  NAND gates, each having  a delay  of one  time unit. NAND  gates  are one of the  predefined  logic gate types in the language — the others, including AND,OR, and XOR, are detailed later. This statement specifies  that five gates, called  g1 through  g5, exist in the circuit."
"The “#1” indicates that they each have a delay of one time unit. Finally, the labels in the parentheses indicate the wires and registers to which the gates are connected. The first label in the parentheses is the gate’s output and the others are inputs. The NOT operator (“~”) is used to sp ecify that the complement of a value is  connected to the input. The wire, register, and instance names are included in the schematic drawing to further clarify the correspondence between the logic diagram and its equivalent Verilog description."
"Verilog la nguage. The first is the notion of module  definition versus module  instantiation. Using the module  statement, as shown in the above example, we define a module once specifying all of its inner detail. This module may then be used (instantiated) in the design many times. Each of these instantiations are called instances of the module; they can be separately named and connected differently. Primitive gates, like the"
"The gates are connected by  nets.  Nets are one of the two fundamental data types of the language (registers are the other), and are used to model an electrical connection between structural entities  such as gates. A  wire is one type of net; others include wired -AND, wiredOR, and trireg connections. The different net types are described in more detail in Chapters 6 and 10."
"In this example, NAND  gates were used  to build  thebinaryToESeg  module.  This binaryToESeg  module, if it had input/output ports, could then be used in another module by instantiating it there, and so on. The use of hierarchical descriptions allows us to control the complexity of a design by breaking the design into smaller and more meaningful chunks (i.e. submodules). When ins tantiating the submodules, all we need know about them is their interface; the ir potentially complex implementation details are described elsewhere and t hus do not clutter the current module’s description."
"As a final comment, we should point out that the designation of A , B, C, and D as registers might seem anomalous. One would think that these would be inputs to module  binaryToESeg , and that the value  eSeg  would be an output. These will be4 The Verilog  Hardware Description Language changed to inputs and outputs in a later example. But for now, we will keep the register definitions as they will aid in simulation in the next section."
"The first statement in the initial is a simulation c ommand to monitor (and print) a set of values when any one of the values changes. In this case, the time is printed requests that the current time be printed) and then the quoted string is  printed with the values of A, B, C, and D substituted for the %b (for binary) printing control in the string. Between and the  quoted string are  several extra commas. One is needed to separate and the quoted string; the extras each  introduce an extra space in the printout. When issued, the monitor command prints the  current values in the design, and will automatically print later when at least one of the values in its list changes. (However, it will not print when only changes.) As shown in"
"Indeed, they will all ha ppen at the same “simulated time”, in  this case time 11. However, the simulator can only update them one at a time. All we know about the order of updates is that it will be arbitrary — we cannot assume that one will happen before the other."
"We now can see why A,B,C, and D were defined as registers for the examples of this section.  As the  only “external” inputs to the NAND  gates,  we needed  a means  of setting and holding their value during the simulation.  Since wires do not hold values — they merely transmit values from outputs to inputs — a register was used to hold the input values.Verilog — A Tutorial Introduction 7"
"As a final comment on the simulation of this example, note that simulation times have been described in terms of “time units.” A Verilog description is written with time delays specified as we  have shown above. The  timescale compiler directive is then used to attach units and a precision (for rounding) to these numbers. The examples in the book will not specify the actual time  units."
"This module may now be  instantiated into  other modules. The port list in the module definition establishes a c ontract between the internal  workings of the module and its external usage. That is, there is one output and four inputs to connect to. No other connections within the module (say, wire p1) can be connected outside of this module. Indeed, the internal structure of the module is not known from the outside — it could be implemented with NOR gates. Thus, once defined, the module is a blackbox that we can instantiate and connect into the design many times. But since we don’t have to be bothered  with the internal details of the module each time it is instantiated, we can control the descriptive complexity of the design."
"However, when writing Verilog descriptions, it is often appropriate to organize your description using the  testbench approach. The idea is based on a vague analogy to an engineer’s workbench where you have the system  being designed wired to a test generator that is going to provide inputs at controlled time intervals an d monitor the outputs as they change. In Verilog, a module is defined and, possibly, given the name testBench. Within  this module are two other modules, one representing the system being designed, and the other representing  the test generator  and monitor. These are shown in Figure 1.2."
"Module testBench  instantiates two modules: the design module binaryToESeg and the test module  test_bToESeg.  When modules are instantiated, as shown on lines four and five, they are given names. The fo urth line states that a module of type binaryToESeg is instantiated in this module and given the name d. The fifth line instantiates the test_bToESeg module with name t. Now it is clear what the functionality of the  system is (it’s a binary to seven segment decoder) and what its ports are. Further, it is clear how the system is going to be tested (it’s all in the test module)."
"Wires need to be declared when connecting modules together. Here, wires w1 through w5 , declared on line two of the example, specify the interconnection. We can see that output register A in module test_bToESeg is connected to an output of the module. The ports are specified and connected in order. In module testBench ,A is the second port ( eSeg  is the first) and is connected to wire w2 (the second port in the list of ports), which is also connected to port A on module binaryToESeg. Inside module binaryToESeg , that port is connected to gates g2 and g4. Thus register A drives the inputs of g2 and g4 . Simulating module testBench  will produce the same results as simulating module  binaryToESegSim  in Example 1.2."
"You might think that register A in module test_bToESeg and input net A in module binaryToESeg  are the same because they are named the same. However, in Verilog, each module has its own name space; each A in this example is known only Verilog — A Tutorial Introduction 11 within the module in which it is declared. Thus the two A’s are names of distinct entities. In this example though, wire  w2 connects them making them electrically the same. Thus a change made to register A will propagate across wire w2 to the A inputs of g2 and g4."
"Behavioral models are useful early in the design process. At that point, a designer is more concerned with simulating the system’s intended behavior to  understand its gross performance characteristics with little regard to its final implementation. Later, structural models with accurate detail of the final implementation are substituted and resimulated to demonstrate functional and timing correctness. In terms of the design process, the key point is that it is often useful to describe and  simulate a module using a behavioral description  before deciding on the module’s actual structural  implementation. In this way, the designer can focus on developing the right design (i.e. one that works correctly with the rest of a system and has the intended behavior) before continuing. This behavioral model can then be the starting point for synthesizing several alternate structural implementations of the behavior."
"The example shows a behavioral model of our binary to seven segment display driver. The port declarations are the same as before. We have also declared one register,eSeg. This is the register we will make assignments to within the always statement, and it will also be the output of  the purely combinational circuit. This always statement starts off with an event control “@” statement. Th e statement: @(A, B, C, D) begin … end states that the simulator should suspend execution of this always block until a change occurs on one of the named entities. Thus, the value of each of A,B,C, and D is sampled when this statement executes. The simulator then waits for  a change to o ccur on any of these named inputs. When a change occurs on any one (or more) of these, then execution will continue with the next statement — in this case what is contained in the begin … end block. Verilog — A Tutorial Introduction 13"
"Secondly, the fact that eSeg  is declared as a register might make you think that it is not a combinational circuit.  But, consider the action of this module when only looking at its ports from the outside. You will quickly conclude tha t if there is any change on any of the inputs, the output will be re-evaluated based only on the module inputs."
"Not just any sequence of behavioral statements is appropriate for synthesis of combinational circuits. To use synthesis tools, you need to be very careful with how the description is written. The rules for synthesizing combinational circuits are briefly summarized here but they are covered in far more detail in Chapter 2. To be sure that your synthesized circuit will be combinational:"
"To understand the nee d for this  requirement, consider the  situation where you execute the begin…end loop and don’t assign to the output. In this case, the circuit needs to remember  the previous value. Thus, the output is a function of the current inputs  and the previous output. This is a fundamental characteristic of a sequential circuit, not a combinational one. A synthesized version of such a circuit will have latches to implement the sequential nature of the description. That’s not cool, given thatwe’re trying to design a combinational circuit!"
"Procedural models also can be used to describe finite state machines. Figure 1.4 shows the state transition diagram for a machine with  three states, one input, and one output. The states are encoded by two ftip ftops named and The reset  state is encoded with both ftip ftops being zero. Also shown in the figure is an implementation of the machine using D ftip ftops and gates."
"The second always block specifies the  sequential portion of the finite state machine. We have seen the procedural assignment “=” as it has been used in initial and always statements.  This  always block introduces  the non-blocking  assignment “<=” — an assignment that might best be described as a concurrent assignment — used in initial and al ways statements with edge specifications (i.e., posedge or negedge). For now, just think  of“=” as an  immediate assignment,  and“<=” as a delayed, concurrent assignment; shortly, we’ll explain the differences."
"Assume that a negative edge on reset  occurs. As the begin…end block begins executing,reset  will be zero and thus currentState  will be set to zero. As long as reset remains zero, even a positive edge on clock  will only result in currentState  being set to zero. This is the action of an a synchronous reset signal that overrides the  clock on a ftip ftop."
Now consider the situation where reset  is one and there is a positive edge on clock ; the begin…end loop is executed but this time the else clause is taken. The assignment18 The Verilog Hardware Description Language currentState <=  nextState; loads currentState  with the nextState . These statements model the positive edgetriggered behavior of a two-bit register made up of D-type ftip ftops.
"Non-blocking assignments (“<=”) are the assignment operator of choice when specifying  the edge-sensitive behavior  of a  circuit.  The  “< =” states that  all the transfers in the whole system that are specified to occur on the edge in the sensi-Verilog — A Tutorial Introduction 19 tivity list should occur concurrently. Although descriptions using the  regular “=” will s ynthesize properly, they may not simulate properly. Since both simulation and synthesis  are generally  of importance,  use “<=” in this situation."
"The non-blocking assignment is used to synchronize assignment statements so that they all appear to happen at once — concurrently. The  non-blocking assignment is used with an edge as illustrated in module fsm. When the specified edge occurs, then the new values are loaded concurrently in all assignments thatwere waiting for the signal’s edge. In c ontrast to the re gular assignment (“=”), the right-hand sides of all assignments waiting for the signal’s edge are  evaluated first, and  then the left-hand sides are assigned (updated). Think of this as all of these assignments happening concurrently — at the same time — independent of any blocking assignments anywhere in the description. Indeed, when all of the ftip ftops in a large digital system are clocked from the same clock edge, this is what happens. The non-blocking assignment models this  behavior."
"Consider how the second always block works. The block waits for either a positive edge on clock  or a negative edge on reset . If the negative edge on reset occurs, then both cS0 and cS1 are set to 0. If the positive edge of clock  occurs, the right-hand sides of the two  “<=” assignments  are evaluated.  Then  all of the  assignments  are made  to the registers on the left-hand s ide. Thus &  in” (the ANDof  and in) and | in” (the OR of  and in) are both evaluated, and then the results are assigned to cS1 andcS0respectively."
"When looking at the description, yo u should think of the  two statements20 The Verilog Hardware  Description Language cS1 <= in  & cS0; cS0 <= in | cS1; as occurring at the same time (i.e., concurrently). Think of the right-hand sides as the inputs to two ftip ftops, and that the change in cS1 and cS0 occur when the clock edge occurs. Realize that they occur concurrently. The cS1 on the left-hand side of the first line is not the value cS1 used on the right-hand side of the second line. cS0 and cS1on the right-hand sides are the va lues before the clock edge.  cS0 and cS1 on the lefthand sides are the values after the clock edge. These statements could have been written in either order with the same resulting values for cS0 and cS1 after the clock edge!"
"This example illustrates the functionality being specified with the non-blocking assignment. Across a whole design there may be many always statements in many different modules waiting on the same edge of the same signal. The powerful feature of the non-blocking assignment is that all of these right -hand side expressions will be evaluated before any of the left-hand side registers are updated. Thus, you do not need to worry about which value  of cS1 is  being used  to calculate cS0.  With  the “< =” you know it is  the value before the clock edge."
"We may want to specify the c lock period with real time units. The timescale compiler directive is used to specify the time units of any delay operator (#), and the precision to which time calculations will be rounded. If the com piler directive `timescale 1ns / 100ps was placed before a module d efinition, then all delay operators in that module and any module that followed it would be in units of nanoseconds and any  time  calculations would be internally rounded to the nearest one hundred picoseconds."
"The initial statement in board also runs. We can see that the initialization in m16 Verilog — A Tutorial Introduction 25 runs first, setting ctr to 1. Then the initial in board runs, executing the statement and printing the first line in the figure. (If the had executed before the initialization of ctr, count would have printed as x.)"
"Some of them were de fined structurally using only gate level primitives. And some were defined behaviorally, using al ways blocks. This is a powerful aspect of the language because it a llows us to model parts of a system at a detailed level (i.e., the structural models) and other parts at a less detailed level (the behavioral models). At the start of a design project, most of the system will be at the behavioral level. Then parts will be detailed into structural models. The final simulation could then be with all modules defined at the gate level for accurate timing and functional simulation. Thus the language aids in the complete design process, allowing a design to evolve from behavioral through to structural in evolutionary steps. 26 The Verilog Hardware Description Language"
"The ability to describe a design either in terms of the abstract behavior of the design or in terms of its actual logical structure. The behavioral  description a llows for early design activities to concentrate on functionality. When the behavior is agreed upon, then it becomes the specification for designing possibly several alternate structural implementations, possibly through the us e of synthesis tools."
"This tutorial chapter was meant to give a quick introduction to the language. As such, many details were skimmed over with the goal of giving the reader a feel for the language. The approach was to  present and describe examples that illustrate the main features and uses of the language."
"The goal of the later chapters is to cover the language and its uses in more depth, while still presenting the language with an example-oriented approach. Our goal is not to present the Verilog language just as a formal s yntax specification. But, realizing that the examples we  give cannot illustrate the entire language syntax, we will begin introducing some of the language’s formal syntax specification. This specification will probably not be useful for the first-time reader. However, it will be  invaluable for the28 The Verilog Hardware Description Language reference reader and description writer. The  complete formal syntax specification is in"
"A. The bits will come in to the module low order first. The carry into the loworder bits is assumed to be zero. The inputs are all valid right before the negative edge of the clock. a and b are the two bits to add and sum is the result. If start is 1, then these two bits are the first of the w ord’s bits to add. Just after the negative edge of  the clock, sum will be updated with its new value based on the values of a and b (and the carry from the previous bits) just before the clock edge."
"Has_Fame ,Going_To_Die  and output Has_Satisfaction . Only this time, add another input called, Keeps_on_Trying. In addition to the logic of the old Satisfaction Detector, where any of money, power or fame will indicate satisfaction, the new Satisfaction Detector will also indicate satisfaction if the man keeps on trying, no matter what else (even if he is dying)!"
"Implement the following in structural Verilog. Much publicity was given to the women’s US Soccer team for w inning the title several y ears back — and for one of the player’s removing her jersey  after the big win. Someone collected a lot of opinions and came up with the  following set of rules for when it’s OK to remove one’s jersey on the field a fter a game. We’ll call the output of the rule implementorJersey_Freeway  which is asserted if it’s OK for a player to take off her Jersey after a game. The logic works like this. If a player scored the winning goal (Winning_Goal ) or was the goalie ( Goalie ) and her team won the game (Won), then she can take off her jersey (Jersey_Freeway), but only if she did not become bruised during the game ( Bruised)."
"C. Alas, the rules have now been extended. The circuit must be modified. A player should never remove her jersey unless her team  won the game, except if this is her last game (Retiring) when she always should, unless she is too badly bruised by the game. Design a Verilog module for a new Jersey_Freeway detector, called New_Jersey_Freeway  to implement the design with this additional rule. Don’t re-design from scratch! Re-use your Jersey_Freeway module in the design of your New_Jersey_Freeway detector. The solution must have one module containing another module."
"HW_Design_Survivor  works like this. If a designer’s partner packs a rat in their backpack for those long design sessions (rat is asserted) and forms an alliance with a group of designers who do not use VHDL ( non_VHDL_alliance  is asserted) they will survive. Or if a designer passes both immunity hardware test challenges ( immunity1  and immunity2  are asserted) and does not show up to the final presentation naked ( naked  is most definitely de-asserted), they will also be a hardware de sign survivor. Assume complemented inputs are available."
The Steelers will win their next game ( Win_L ) if hell freezes over ( Hell_L is asserted and Warm_H is de-asserted) or if the other team is locked in their hotel rooms ( Lock_L is asserted) and someone threw away the key ( Key_L is de-asserted). The Steelers will also win if the other team lets them (Trying_L is de-asserted). The Steelers will also win if they are playing a high school team (High_H  is asserted) where all of the good players are on  academic probation (Smart_L  is de-asserted). Simulate your design using only primitive gates -structural Verilog. Clearly justify how your simulation verifies your design!
"It is worth buying hot dogs (Hot_L) on a weekday (Week_H) whenever it is lunchtime (Lunch_L) or after midnight ( Midnight_H), but only if none of your Professors are swimming in the pool (No_Profs_L) and the person behind the counter does not have a tatoo that says “Mother” ( No_Tatoo_H ). Simulate your design using only primitive gates — structural Verilog. Clearly justify how your simulation verifies your design!2Logic Synthesis"
"In this chapter, the use of the language as an input specification for  synthesis is presented. The concern is developing a functionally correct specification whil e allowing a synthesis CAD tool to design the final gate level structure of the system. Care must be taken in writing a description so that it can be used in both simulation and synthesis. 2.1Overview of Synthesis"
"The predominate synthesis technology in use today is logic synthesis. A system is specified at the register-transfer level of design; by using logic synthesis tools, a gate level implementation of the system can be obtained. The synthesis tools are capable of optimizing a design with respect  to various  constraints, including timing and/or area."
"A logic synthesis tool compiles a register-transfer level design using two main phases. The first is a technology independent phase where the design is read in and manipulated without regard to the final implementation technology. In this phase, major simplifications in the combinational logic may be made. The second phase is technology mapping where the design is transformed to match the components in a component library. If there are only  two-input gates in the library, the design is transformed so that each logic function is implementable by a component in the library."
"Karnaugh map had more than five or six variables!) These tools target large combinational design and different technology libraries, providing implementation trade-offs in time and area. Further, they promise functional equivalence of the  initial  specification and its  resulting implementation. Given the complexity of this level of design, these tools improve the productivity of designers in many common design situations."
"The first part of this chapter defines what a  synthesizable description for logic synthesis is. There are behaviors that  we can describe but thatcommon logic synthesis tools will not be able to design. (Or they may design something you’d want your competitor to implement!) Since synthesis technology is still young, and the task  of mapping an arbitrary behavior on to a set of library components is complex, arbitrary behavior specifications are not allowed as inputs to logic synthesis tools. Thus, only a subset of the language may be used for logic synthesis, and the style of writing a description using that subset is restricted. The first part of this chapter describes the subset and restrictions commonly found in logic synthesis specification today. Our discussion of logic synthesis is based on experience using current tools. If you use others, your mileage may vary. Read the synthesis tool manual closely.Logic Synthesis 37 2.2Combinational Logic Using Gates and"
"Essentially, logic synthesis tools read the logic functionality of the  specification and try to optimize the final gate level design with respect to  design constraints and library elements. Even though Example 2.1 specifies a gate level design, a logic synthesis tool is free, and possibly constrained, to implement the functionality using different gate primitives. The  example shows a different, but functionally equivalent, gate level design. Here, the technology library only contained two-input gates; the synthesis tool transformed the design to the implementation on the right of the example. Other designs are possible with alternate  libraries and pe rformance c onstraints."
"The example does not contain delay (#) information, illustrating one of the key differences between writing Verilog descriptions for simulation and synthesis. In simulation, we normally provide detailed timing information to the simulator to help the designer with the task of timing verification. A logic synthesis tool will ignore these timing specifications, using only the functional specification provided in  the description. Because timing specifications are ignored, having them in a description could give rise to differences in simulating a design being input to a logic synthesis tool versus simulating the resulting implementation."
"Using a continuous assign statement,  as shown in Example 2.2, is similar to specifying logic in Boolean algebra, except Verilog has far more operators to use in the specification. The assign statement allows us to describe a combinational logic function without regard to its  actual structural implementation — that is, there are no instantiated gates with wires and  port connections. In  a simulation of the circuit, the result of the logical expression on the right-hand side of the equal sign is evaluated anytime one of its values changes and the result drives the output f."
Continuous assign statements are often used for describing datapath elements. These modules tend to have one-line specifications as c ompared to the logic specifications for next state and output logic in a finite state machine. In Example 2.3 both an adder an d a multiplexor are described wit h continuous assign. The addWithAssign
There are limits on the operators that may be used as well as the ways in which unknowns ( x) are used. An unknown may be used in a synthesizable description but only in certain situations. The  following fragment is not synthesizable because it  compares a value to an unknown. assign y = (a === 1'bx)? c : 1 ;
"An unknown used in this manner is a value in a simulator; it is useful in  determining if the value of ahas become unknown. But we do not build digital hardware to compare with unknowns and thus this  construct is  not synthesizable. However, the following fragment, using an unknown in a non-comparison fashion, is a llowable: assign y = (a == b) ? 1'bx : c ;"
"Example 2.4. It inc ludes an always statement with an event  statement  containing all of the input variables to the combinational function. The example shows a multiplexor described procedurally. In this case, input a selects between passing inputs b orc to output f. Even though f is defined to be a register, a synthesis tool will treat this"
"Considering Example 2.4 further, we note  that the c ombinational output f is assigned in every branch of the always block. A  control path is defined to be a sequence of operations performed when executing an always loop. There may be many different control paths in an always block due to the fact that conditional statements (e.g. case and if) may be used. The output of the combinational function must be assigned in each and every one of the possible control paths. Thus, for every conceivable input change, the  combinational output will be calculated anew; this is a characteristic of combinational logic."
"When using the construct @(*) — or  @* which is equivalent — only the statement’s right-hand side or conditional expression is included. Thus, if several procedural statements are needed to specify the combinational function, a begin-end block must be used to group them into a compound statement. The “@(*) begin-end” will then include the registers and nets from the right-hand sides and conditionals of all of the statements in th e compound statement.42 The Verilog Hardware Description Language"
"Although this relieves the problem of correctly specifying the sensitivity list for combinational f unctions, the rule concerning assigning to the combinational output(s) during any execution of the always block must still be followed. An approach to organizing descriptions so that an assignment is always made is shown in Example 2.6 . This"
"If there exists a control path that does not assign to the output, then the  previous output value needs to be remembered. This is not a characteristic of combinational hardware. Rather it is indicative of a sequential system where the  previous state is remembered in a latch and gated to the output when the inputs specify this control path. A logic synthesis tool will recognize this situation and infer that a latch is needed in the  circuit. Assuming that we are trying to describe  combinational  hardware, we want to insure that this inferred latch is not added  to our design. Assigning to the combinational output  in every control path will insure this."
"Example 2.7. If we follow the control paths in this example, we see that if a is equal to one, then f is assigned the value of b &c. However, if a is equal to zero, then f is not assigned to in the execution of the always block. Thus, there is a control path in which f is not assigned to. In this case a latch is in ferred and the circuit shown on the  right of the example is synthesized. The latch is actually a gated latch — a level-sensitive device"
"Of course, wh en using a case statement it is possible to inc ompletely specify the case. If there are n bits in the case’s controlling expression, then a synthesis tool will know that there are possible control paths through the case. If not all of them are specified, then there will be a control path in whic h the output is not assigned to; a latch  will be inferred. The default case item can be used  to define the remaining unspecified case items. Thus"
"Also shown in the  example is a parallel case a ttribute. A Verilog case statement is allowed to have overlapping case items. In this situation, the statements for the matching items are executed in the order specified. This can result in some complex logic because a priority among the case items is specified. A parallel case is a case statement where there is no overlap among the case items. That is, only one of the case items can be true at any time. If the case is parallel (and full), it can be regarded  as a sum-of-products specification which could be implemented by a multiplexor. Specifying the parallel case attribute enables  this interpretation and generally  simplifies the logic gen erated."
"The use of the ? in this statement specifies that the value of b does not matter in this situation. Thus this case item covers the first column of the Karnough map. Although we could have specified the two case items (2'b00 and 2'b01) and assigned fto be x in both situations, the approach shown is more compact. Since this first case item covers"
"Care should be taken when using don’t cares in a specification  because they give rise to differences between simulation and synthesis. In a simulator, an x is one of the four defined logic values that will be printed when tracing values. However, in the synthesized circuit, the value printed for the same situation will either be 1 or0. Further, comparing to an x  makes sense in a simulation but not in synthesis. To reduce the differences between simulation and synthesis, a synthesizable description does not compare with x orz."
A reading of the above examples might suggest that the only means to specify logic functions is through if and case  statements. The for loop in Verilog may be used to specify combinational logic. The while and forever loops are used for synthesizing sequential systems. The repeat loop is not allowed in any synthesizable specifications.
"Section 5.4.) In this example, each iteration of the loop specifies a different logic element indexed by the loop variable i. Thus, eight xor gates are connected between  the inputs and the outputs. Since this is a specification of c ombinational logic, i does not appear as a register in the final implementation."
"The example  illustrates several points about using for  statements for specifying logic. The for loop is highly structured, clearly specifying the step variable and its limits. It will have an index i that must either start with a low limit and  step up to a high limit, or start with a high limit and step down to a low limit. The comparison for end of loop may be <, >, <=, or >=, and the step size need not be one. The general form shown below illustrates the count down version: for (i = highLimit; i >=  lowLimit; i = i step);"
"Latches are  inferred using the always statement as a basis. Within an always statement, we define a  control path  to be a sequence of operations performed when executing an always loop. There may be many different control paths in an always block due to the fact that conditional statements (e.g. case and if) may be used. To produce a combinational circuit using procedural statements, the output of the combinationalLogic Synthesis 49 function must be assigned in each and every one of the different control paths. Thus, for every conceivable input change, the  combinational output will be calculated anew."
"To infer a latch, two situations must exist in the always statement: at least one control path must exist that does not assign to an output, and the se nsitivity list must not contain any edge-sensitiv e specifications. The first gives rise to the fact that the previous output value needs to be remembered. The second leads to the use of level-sensitive latches (as opposed to edge-sensitive flip flops). The requirement for memory is indicative of a sequential element where  the previous state is remembered in a latch when the  inputs specify this control  path. A logic synthesis tool will recognize this situation and infer that a latch is needed in the circuit. Assuming that we are trying to d escribe a sequential element, leaving the output variable unassigned in at least one path will cause a latch to be inferred."
"Example 2.16 shows a latch with a reset input. Although we have specified output to be a register, that alone does not cause a latch to be inferred. To see how the latch inference arises, note that in the control flow of the always statement, not all of the possible input combinations of g and reset  are specified. The specification says that if there is a change on either g,d or reset , the always loop is executed. If reset is zero, then    is set to zero. If that is not the case, then if g is one, then is set to the d input. However, because there is  no specification for what happens when reset  is one and g is zero, a latch is needed to remember the previous value of This is, in fact, the behavior of a level sensitive latch with reset. The latch  behavior c ould also have been inferred using case or other statements."
"Flip flops are  edge-triggered storage devices. Typically, their behavior is controlled by a positive or negative edge that occurs on a special input, called the clock. When the edge event occurs, the input d is  remembered and gated to the output The y often have set and/or reset inputs that may  change the flip flop state either synchronously or asynchronously with respect to the clock. At no time is the output a combinational function of the input d. These flip flops are not explicitly specified. Rather, they are inferred from the behavior. Since some of their behavior can  be rather complex, there is essentially a template for how to  specify it. Indeed some synthesis tools provide special compiler directives for specifying the  flip flop type."
Example 2.18 shows a synthesizable model of a flip flop. The main characteristic of a flip flop description is that the event expression on the always statement specifies an edge. It is this edge event that infers a flip flop in the final design (as opposed to  a level  sensitive latch).
"As we will see,  an always  block with an edgetriggered event expression will cause flip flops to be inferred for all of the registers assigned to in procedural assignments in the al ways block. (Thus, an always block with an edge-triggered event expression ca nnot be used to define a f ully combinational function.)"
"The means for specifying these signals is very stylized so that the  synthesis tool can determine the behavior of the device to  synthesize. Example 2.19 shows a D flip flop with asynchronous set and reset capabilities. In this example, the reset  signal is asserted low, the set signal is asserted high, and the clock event occurs on the positive edge of clock ."
The always statement must specify the edges for each signal. Even though asynchronous reset and set signals are not edge triggered they must be  specified this way. (They are not edge triggered because q will be held at zero as long as reset  is zero — not just when the negative edge occurs.)
The tests for the set and reset conditions are done first in the always statement using else-if c onstructs. The expressions for set  and reset cannot be indexed; they must be one-bit variables. The tests  for their value must be simple and must be done in the order specified in  the event expression.
"All procedural assignments in an always block must either be blocking or nonblocking assignments. They ca nnot be mixed within an always block. Non-blocking assignments (“<=”) are the a ssignment operator of choice when specifying the edge-sensitive behavior  of a  circuit.  The “<=” states that all the  transfers  in the whole system that are specified to occur on the edge in the sensitivity list should52 The Verilog Hardware Description Language occur concurrently. Although  descriptions using the  regular “=” will synthesize properly, they may not simulate properly. Since  both simulation and synthesis are generally  of importance,  use “<=” for edge sensitive circuits."
Their complex behavior requires that a strict format be used in their specification. We have only covered the basics of their specification. Most synthesis tools provide compiler directives to aid in making sure the  proper library element is selected to implement the specified behavior. Read the synthesis tool manual closely. 2.5Inferring Tri-State Devices
"We have seen how to specify combinational logic and sequential elements to a synthesis tool. In this section we will c ombine these into the specification of a finite state machine. The standard form of a finite state machine is shown in Figure 2.1. The machine has inputs outputs and flip flops holding the current state. The outputs can either be a function solely of the current state, in which case this is  a Moore machine. Or, they can be  a function of the current state and input, in which case this is a Mealy machine. The input to the flip flops is the next state; this is a combinational function of the current state and inputs."
"The first always statement is a description of the combinational output ( out) and next state ( nextState ) functions. The input set for these functions contains the input i and the register currentState . Any change on either of these will cause the always statement to be re-evaluated. The single statement within the al ways is a case state54 The Verilog Hardware Description Language ment indicating the actions to be performed in each state. The controlling expression for the case is the state variable ( currentState ). Thus, depending on wha t state the machine is in, only the specified  actions occur. Note that in each case item, the two combinational functions being computed ( out and nextState ) are assigned to. In addition, a default case item is listed representing the remaining unassigned states. The default sends the machine to state A which is equivalent to a reset. By arbitrary choice, out is set to don’t care in the unassigned states."
"This always statement will result in combinational logic because: the sensitivity list contains all of the input set, there are no edge specifiers in the sensitivity list, and for every control path, both of the combinational outputs have been assigned to. This includes every po ssible case item. Thus,  there will be no inferred latches. Note that a default case  item  was used here instead  of specifying  that this is a full case.  This  allows us to specify the reset state as the next state in case there is an error in operation — for instance, the logic circuit somehow gets into an undefined state. Although we specified that the output in this situation is a don’t care, we could have made a specification here too."
"The second always statement infers the state register with its reset  condition. In this case, reset  is asserted low and will cause the machine to go into state A. If reset  is not asserted, then the normal action of the always will be to load currentState  with the value of nextState , changing the state of the FSM on the positive edge of clock ."
"Notice that currentState  is assigned to in every control path of the always — so why is a flip flop inferred? The reason is that the edge specifications in the event expression cause any register assigned to in the  block to be implemented using flip flops. You cannot specify combinational logic in an always block with edge tr iggers in the sensitivity list. This is why we need two al ways blocks to specify an FSM: one for the state register, and th e other for the combinational logic."
"Example 2.23 using a slightly different calculation. Here a result is produced every clock period in dataOut . In this case, three FSMs are specified; one for each stage of the pipe. At every clock event, each stage  computes a new output ( stageOne , stageTwo , and dataOut ). Since these variables are used on the lefthand side of a procedural statement in an always block with an edge specifier, there are implemented with re gisters. The nonblocking assignment (<=) must be used here so that the  simulation results wil l be correct."
"The name in each box in the figure suggests its functionality. Names with overbars are control signals that are asserted low. Looking at the block labeled register i , we see that its  output (coming from the bottom) is connected back to the input of an adder whose other input is connected to 1. The output of thatadder (coming from the bottom) is connected to the input of register i . Given that the register stores a value and the adder is  a combinational circuit, the input to register i   will always be one greater than the current value of register i . The register also has two control inputs: iLoad andiClear . When one of these inputs is asserted, the specified function will occur at… …Logic Synthesis 59 the next clock edge. If we assert iLoad , then after the next clock edge register i  will load and store its input, incrementing i. Alternately, iClear  will load a zero into register i. The compare modules are also combinational and produce the Boolean result indicated."
"This does not assign b toa with a non-blocking assignment, and then assign a toout with a blocking assignment. Only one assignment is a llowed in a statement. Thus by their position in the statement, we know that the first is an assignment and the second is a less than or equal comparison."
"The adder, compare andcompareLT  modules could have written using the combinational version of the al ways block. As used in these examples, the two forms are equivalent. Typically, the  continuous assign approach is used when a combinational function can be described in a simple  statement. More complex combinational functions, including ones with don’t care specifications, are  typically easier to d escribe with a combinational always statement."
"The state transition diagram is shown in Figure 2.5 along with the specification for the computation. The states marked  “...”represent the computation  before and after the portion of interest to us. Each state “bubble” indicates the FSM outputs that are to be asserted during that state; all others will be unasserted. The arrows indicate the next state; a conditional expression beside an arrow indicates the condition in which that state transition is  taken. The diagram is shown as a Moore machine, where the outputs are a function only of the current state. Finally, the states are  labeled A through Ffor discussion purposes."
"Following through the computation and the state transition diagram, we see that the first action is to clear both the x and i registers in state A. This means that while the machine is in state A, xClear  and iClear  are asserted (low). Note though that the registers i and x will not become zero until after the pos itive clock edge and we’re in the next state ( B). State B then asserts the load  signals for x and i. The datapath in"
"Thus, state B executes both the loop body and the loop update. From state B the system goes to state Cwhere there is no FSM output asserted. However, from state C there are  three possible next states depending on whether we are staying in the loop (going to state B), exiting the loop and going to the then part of the conditional (state"
"It is interesting to note that in this implementation of the system, the exit condition of the for loop is not checked be fore entering the loop. However, given that we just cleared i before entering the loop, it is not n ecessary to  check that is less than or equal to 10. Further, with a different datapath, state Cmight not be  necessary. For instance, the comparisons with i andx could be based on the input value to these registers, thus comparing with the future value. Or the constants with which  the comparisons are made c ould be changed. Of course, these are all at the discretion of the designer. Logic Synthesis 65"
"Internal to the fsmmodule, they are called LTand respectively.  Module fsm also has a reset input and a clock ( ck) input. The module outputs are the control points on the registers (yLoad, yClear, xLoad, xClear, iLoad, iClear). Like our previous fsm examples, there are two always blocks, one for the sequential state change and the other to implement the next state and output combinational logic. Registers are declared for all of the combinational outputs."
"The second always block implements the next state and  output combinational logic. The inputs to this combinational logic are the current state (cState)  and fsm inputs ( LTand The body of the al ways block is organized  around the value of cState . A case statement, essentially a multiway branch, is used to specify what is to happen given each possible value of cState . The value of the expression in parentheses, in this case cState, is compared to the values listed on each line. The line with the matching value is executed."
"The last case item specifies the default situation. This is the statement that is executed if none of the other items match the value of cState. For simulation purposes, you might want to have a statement to print out an error warning thatyou’ve reached an illegal state. The prints a message on the screen during simulation, acting much like a print statement in  a programming language. This one displays the message “Oops, unknown state: %b” with the binary representation of cState substituted for %b.66 The Verilog Hardware Description Language"
"To make this al ways block a combinational synthesizable function, the default is required. Consider  what happens if we didn’t have the default statement and the value ofcState  was something other than one of the five values specified. In this situation, the case statement w ould execute, but none of the specified actions would be executed. And thus, the outputs would not be assigned to.  This breaks the combinational synthesis rule that states that every possible path through the al ways block must assign to every combinational output. Thus, although it is optional  to have the d efault case for debugging a description through simulation, the  default is required for this always block to synthesize to a combinational circuit. Of course a default is not required for synthesis if all known value cases have been specified or cState was assigned a value before the case statement."
"In our description, several always blocks are were waiting for changes to cState, x, andi. These include the fsm’s combinational always block, the adders, and the compare modules. Because of the change to cState , x, and i, these always blocks are now enabled to execute. The  simulator will execute them, in arbitrary order. Indeed, the simulator may execute some of them several times. (Consider the situation where the fsm’s combinational always  block executes first. Then after the c ompare modules execute, it  will have to execute again.)  Eventually, new values will be generated for the outputs of the comparators. Changes in LT and in the fsm module will cause its combinational always block to execute, generating a value for nState. At the next positive clock edge, this value will be loaded into cState and another state will be entered."
"We now begin a more in-depth discussion of the constructs used to model the behavior of digital systems. These have been split into two groups. The first are statements that are, for the most part, similar to those found in  programming languages: if-thenelse, loops, etc. In the next chapter we take up the statements that are oriented toward modeling the concurrent nat ure of digital hardware. 3.1 Process Model"
"The basic essence of a behavioral model is the  process.  A process can be thought of as an independent thread of control, which may be quite  simple, involving only one repeated action, or very complex. It might be implemented as a sequential state machine, as an a synchronous clearing of a register, or as a combinational circuit. The point is that we conceive the behavior of  digital systems as a set of these independent, but communicating, processes. Their actual implementation is left  to the context of the description (what level of abstraction we are  dealing with) and the time and area constraints of the implementation.74 The Verilog Hardware Description Language"
"When modeling a system using the statements in an al ways or initial block, we must be cognizant of the execution model of these statements. The statements are executed in the order specified in the description. Assignments made using the  blocking assignment (“=”) take effect immediately and the value written to the left-hand side of the = is available for use in the next statement. When an  event statement (“@”), a delay statement (“#”), or, as we’ll see later, a wait statement where the expression is"
"FALSE  is executed,  the execution  of the initial  or always  statement  is suspended  until (respectively): the event occurs, the number of time units indicated in the delay has passed, or the wait  statement expression becomes TRUE. At that time, execution of statements in the initial or al ways statement continues."
"Further, even though the  statements in an always or initial block are executed in order, it is possible that statements from other always or initial blocks will be interleaved with them. When an always or initial block is waiting to continue (due to  @, #, or wait), other al ways or initial blocks, gate primitives, an d continuous assign statements can execute. Thus, concurrent/overlapping behavior is modeled."
"At the start of the simulation, all of the initial and al ways statements are allowed to execute until they are suspended due to an event, delay, or wait. At this point, register values set in an initial or al ways may activate a gate input, or time may advance to the next event that will probably allow one or more of the suspended processes to become active again. When there are multiple pro cesses that can execute at any particular time, the order in which they begin executing  is arbitrary. Care must be taken when writing them to insure that register and wire values are assigned in an appropriate order."
"In summary, the  initial and always statements are the basic constructs for describing concurrency. When using  these statements, we should be thinking conceptually of concurrently ac tive processes thatwill interact with each other. Although it is possible to mix the description of  behavior between the al ways and  initial statement, it is more appropriate to describe the behavior of the hardware in the always, and describe initialization for the simulation  in the initial."
"Conditional statements are used in a sequential behavior description to alter the flow of control. The  if statement and its variations are common examples of conditional statements. Example 3.1 is a behavioral model  of a divide module that shows several new features, including two versions of the ifstatement, with and without an else clause."
"Thedivide  module determines the output quotient  from the two inputs, dvInput andddInput , using an iterative subtract and shift algorithm. First, four text macros are defined. The `define compiler directive provides a macro capability by defining a name and gives a constant textual value to it. The name may then be used in the description; on compilation, the text value will be substituted. The  general form is: `define A a lpha"
"The divide starts  by zeroing  the done output  and waiting  for go to be TRUE. These two signals are the handshake signals that allow the divide module to communicate and synchronize with other modules. done indicates when the divide module has completed a division and stored the result in the quotient.  Since at the beginning no quotient  has been  calculated, done is set toFALSE  (or zero).  Then  we wait for the go input  to be one (or TRUE ) signifying  that thedvInput  and ddInput  inputs  are valid."
"The wait statement, waits  for an external  condition  to become  TRUE.  When  it is executed, execution continues if the condition in the parentheses is TRUE . However, if the condition  is FALSE,  the always  block stops  executing  and waits  for the  condition  to become  TRUE.  At that point,  execution  continues  with  the statement  after  the wait."
"This shows the basic form of the if statement. The if is followed by a parenthesized expression;  a zero expression  evaluates  to FALSE  and any  value other than zero evaluates to TRUE.  Comparison with  an unknown  (x) or high  impedance  (z) may  produce  a result  that is either unknown  or high impedance; these  are interpreted  as FALSE.  In this case, we are tes ting the divisor.  If it is not zero, then we follow the normal divide algorithm. The begin-end block following the if statement a llows all of the encompassed statements to be  considered as part of the then statement of the if."
"This statement also illustrates a  bit-select. A bit-select is  used to specify that only one of the bits of a vector are to be used in the operation. A range of bits may also be specified by separating the bit numbers specifying the range with a colon. This is called a  part-select. Also, a starting bit number and a width may be specified. The + shown below indicates the bit  numbers increase from the starting but number; the indicates the bit numbers decrease. More formally, a bitor part-select occurs either as an expression or as part of an expression as shown below: primary hierarchical_identifier [ range_expression ] range_expression expression msb _constant_expression: 1sb_constant_expression base_expression +: width_constant_expession base_expression -:  width_constant_ expession"
"After the initialization to determine the final arithmetic sign, the repeat statement executes the statements in the begin-end block 16 times. Each time, the quotient   and dividend are shifted left one position, as described by the < <operator, and then the divisor  is subtracted from the top part of the dividend.   If the result of this subtract is positive, one is added to the quotient.   However, if the result is negative (the top most bit is a one), the else part of the if conditional statement is executed, adding the divisor back into the top part of the dividend.Behavioral Modeling 79"
"Vector nets and  registers all obey the laws of arithmetic modulo where n is the number of bits in the vector. In effect, the language treats the numbers as unsigned quantities. If any of  these values were printed by a or statement, they would be interpreted and printed as unsigned values. However, that does not stop us from writing descriptions of hardware  that use the two’s complement number representation — the laws of arithmetic modulo still hold. Indeed, the unary minus provided in the language performs the correct operation. In this example, we have declared the  registers dividend, divisor,   and quotient  to be signed. They will print correctly."
"Appendix B.  These include > (greater than), >= (greater than or equal), = = (equal), and != (not equal). In the case where unknown or high impedance values are present, these comparisons may evaluate to a quantity which contains unknown or high impedance  values.  Such  values  are considered  to be  FALSE  by the simulator.  However, the case equality operator (= = =) and inequality operator (!= =) can be used to specify thatindividual unknown or high impedance bits are to take part in the comparison."
"In this example, we have nested ifstatements and a single else. In general,  the language attaches the else to the nearest if statement. In the above situation, if expressionA  and expressionB   are both TRUE , then a is assigned a new value. If expressionABehavioral Modeling 81 is TRUE  and expressionB  is FALSE,  then q is assigned  a new  value.  That  is, the else is paired with the second if."
"The conditional operator ( ?:) can be used in place of the if statement when one of two values is to  be selected for assignment. For instance, the statement  determining the final sign of the quotient   in Example 3.1 could have been written with the same result as quotient = (negDivisor !=  negDividend) ? -quotient: quotient;."
"This operator works as follows: first the conditional expression in the  parentheses is evaluated.  If it is TRUE (or nonzero), then  the value  of the  right-hand side of the  statement  is found  immediately  after  the question  mark.  If it is FALSE , the value  immediately after the colon is used. The result of this statement is that one of the two va lues gets assigned  toquotient. In this case,  if it is TRUE  that the signs  are not  equal, then quotient is loaded with its negative. Otherwise, quotient remains unchanged. As in"
"There is a major distinction between if-then-else and the conditional operator. As an operator, the  conditional operator may appear in an expression that is either part of a procedural or continuous assignment statement.  The if-then-else construct is a statement that may appear only in the  body of an initial or al ways statement, or in a task or function. Thus whereas if-then-else can onl y be used in behavioral modeling, the conditional operator can be used both in behavioral and gate level structural modeling."
"Specifically, the first assignment is executed once at the beginning of the loop. The expression is executed before the body of the loop to determine if we are to stay in the loop. Execution stays in the  loop  while  the expression  isTRUE . The second assignment is executed after the body of the loop and before the  next check for the end of the loop. The statement is the body of the loop. The difference between the for and repeat loop statements is that repeat  is simply a means of specifying a constant number of iterations. The for loop is far more flexible and gives access to the loop update variable for control of the end-of-loop-condition."
"Here, the while statement expression is dependent on the value of inputA  and the while stat ement is null. The  above while statement appears to have the effect of doing nothing until  the value  of inputA isTRUE , at which time  the other statements  are executed. However, since we are waiting for an external value to change, the correct statement to use is the  wait.  For further discussion, see section 4.3 on the wait statement."
If-else-if simply  uses if-then-else statements to specify multiple actions. It is the most general way to write a multi-way decision in that it allows for a variety of different expressions to be  checked in the if conditional expressions. Consider the  description of a simple  computer shown in Example 3.5. The example is reminiscent of the early
"The case expressions are evaluated linearly in the order given in the description. In this case, bits fifteen through thirteen of the instruction register (the  controlling expression )are compared with  each of the seven  case expressions.  Bit widths must match exactly. The first expression to match the controlling expression causes the statement following the colon to be executed. Then execution continues with the statement after the case. The comparison is done using 4-valued logic; thus a 2-bit case condition can evaluate to sixteen different values."
"In the Mark-1 examples above, either case or if-else-if could be used. Stylistically, the case is more compact in this example and makes for easier reading. Further,  since all of the expressions were  compared with one controlling expression, the case is more appropriate. However, there are two major differences between these constructs."
"Functions and t asks allow often-used behavioral sequences to be written once and called when needed. They also allow for a cleaner writing s tyle; instead of long sequences of behavioral statements, the sequences can be broken into more readable pieces, regardless of whether they  are called one or many times. Finally, they allow for92 The Verilog Hardware Description Language data to be hidden from other parts of the design. Indeed, functions and tasks play a key role in making a behavioral description more readable and maintainable."
"A task is defined within a module using the  task and  endtask keywords. This task is named multiply  and is defined to have one inout ( a) and one input ( b). This task is called from within the always statement. The order  of task parameters at the calling site must correspond to the order of definitions within the task. When multiply  is called, acc is copied into task variable a, the value read from memory is copied intob, and the task proceeds. When the task is ready to return, prod  is loaded into a. On return, a is then copied back into acc and execution continues after the task call site."
"Although not illustrated here, a task may include timing  and event  control statements. Twice within Example 3.9 named be gin-end blocks are used, illustrating that within these blocks, new register identifiers may be defined. The scope of these names (ir, mcnd, mpy,  and prod ) is the named begin-end block. The general form of the task declaration is: task_declaration task [ automatic]  task_identifier ; {task_item_declaration} statement_or_null endtask | task [ automatic]  task_identifier (task_port_list) ; {block_item_declaration} statement endtask | task_item_declaration block_item_declaration | tf_output_declaration | tf_input_declaration| inout_declaration94 The Verilog Hardware Description Language"
"Their scope is the task-endtask block. When a task is called, the internal variables96 The Verilog  Hardware Description Language declared as inputs or  inouts receive copies of the values named at the calling site. The task proceeds executing. When it is done, then all of the variables declared as inouts or outputs are copied back to the variables listed at the call site. When copying values to and from the call site, the variables at the call site are lined up left-to-right with order of the input, output, and inout declarations at the  task definition site."
"Thus, the registers used after the second call to the task are the same physical entities as those in  the previous call(s). Th e simulator maintains the thread of control so that the returns from a task called multiple times are handled correctly. Further, a task may be called from separate processes (i.e., always and initial statements) and the task may even be stopped at  an event  control when the task is enabled from another process."
"When a task is declared automatic,   the task is  re-entrant.  That is, there may be calls to it from several concurrent processes. Indeed, since tasks may have timing and event controls, several processes may be waiting in the task. Each call to the task, whether from concurrent processes or from itself, works with its own copies of the internally declared storage. Upon exit  from the task, this storage is released and thus in unavailable to any other scope. Thus inputs, outputs, and other internal variables cannot be assigned values using non-blocking assignments, or traced with statements, for instance. The point is that nonautomatic   tasks have static storage allocation. Automatic   tasks have dynamic storage allocation which only  exists during a particular instance’s execution."
"A Verilog function is similar to a software function. It is called from within an expression and the value it returns will be used in the  expression. The function has one output (the function name) and at least one input. Other identifiers may be declared within the function and their scope will be the function. Unlike a task, a function may not include delay(#) or event control (@), or wait sta tements. Although not illustrated here, a function may be called from within a continuous assignment. Functions may call other functions (including itself) but not other tasks. During the execution of the function, a value must be assigned to the function name; this is the value returned by the function."
"A special case of a function is the constant function. There is no keyword to declare them constant. Rather, their inputs  are constants  or parameterized values that have been previously declared. These functions are useful for calculating bitwidths in declarations as illustrated in Example 3.11 of a parameterized memory for the Markl examples. Here the parameters are Width  and number of words ( NumWords). From the parameter NumWords , the size of the address  port of the memory is calculated using the constant function clog2b ."
"The task and  function examples of the previous  sections have illustrated different organizations of a behavioral model. That is, we can choose to model the behavior in different ways with the same result. When we used the * operator,  we were probably only interested in simulation of the model. There are many ways to implement a multiply in hardware, but early in the design process we were content to let the simulator substitute its method."
"As the design progresses, we want to specify the multiply algorithm that we want our hardware to implement. This we did by using the task and function statements in the above examples. The implication of the description using a task or function is  that this divide algorithm will be part of the final data path and  state machine synthesized to implement the Mark-1 processor. That is, we  enlarged the  behavioral description by specifying the details of the multiply algorithm and thus we would expect the f inal state machine that implements this behavior to have more states. Likewise, the data path may need more components to hold the values and perform the operations."
"Forward referenced. Identifiers for modules, tasks, functions, an d named beginend blocks are allowed to be forward referencing and thus may be used before they have been defined. That is, you can  instantiate a module, enable a task, enable a function, or disable a named block before either of these  entities has been defined."
"For the case of the forward referencing entities (module, task, function, and named begin-end  blocks),  there  is also an upward  scope  defined  by the  module  instantiation hierarchy. From the low end of the hierarchy, forward referenced identifiers in each higher local scope are known within the lowest scope. This path up the module instantiation hierarchy is the  upward scope."
"Consider Example 3.13. The ide ntifiers in the local scope of module top are: top, instance1, y, r, w,  and t. When module b is instantiated within module top, procedural statements in b can enable tasks and functions defined in the local scope of module top and also disable a named block in its local scope. However, taskt in module top has a named block ( c) within its scope. c cannot be disabled from module b because c is not in top’s local scope and thus it is not in b’s upward scope (rather, it is  down a level from it in taskt’s local scope). Further, named block y intop’s local scope can be disabled from module b and it can be disabled from within a task or function defined in module top, or from within named blocks within the task or function."
"Note however, that register r and wire w, although in the upward scope of module b, are not accessible from it; registers and nets are not forward referencing and thus can only be accessed in the local scope. The rule is that forward-referencing identifiers (i.e. module, task, function, and named block identifiers) are resolved a fter the instantiations are known by looking  upward through the module instantiation tree. When the top of the hierarchy is reached (at a module that is not instantiated elsewhere) the search for the identifier is ended. Non-forward referenced registers and nets are resolved immediately in the local scope."
"It is also useful to think of the upward identifier tree as arising from two sources: the module hierarchy, and  procedural statement hierarchy. The module hierarchy tree was described above. The procedural statemen t hierarchy arises from nested named blocks within al ways and initial statements, tasks, and functions. Procedural statement hierarchies are rooted in modules (essentially, they are always and initial state-104 The Verilog Hardware Description Language"
"Hierarchical names are forward referencing — they are not resolved until all modules are instantiated. Hierarchical names consist of a path name which has  identifiers separated by periods (“.”). The first identifier is a forward  referencing identifier found by searching up the procedural and module hierarchy name tree. From where the first identifier is found, each succeeding identifier specifies the named scope w ithin which to continue searching downward. The  last identifier specifies the entity being search for."
"Consider Example 3.13. W ithin module b, register r is not known because register and wire identifiers are not searched for across module instantiations; they are only known in the local scope. However, the hierarchical reference top.r  in module b will access r intop. Similarly, from module b, t.c.q  accesses register q in task t (which, by the way is different  than register q in named block y). Further, block c can be disabled from b through the hierarchical name t.c. Note that these last two did not start with top (although they could have). When searching up the module hie rarchy from b, the next scope up includes forward referencing names top, y,  and t. Any of  these (and actually any forward referencing identifier — modules, tasks, functions, or named blocks) can be used as the root of the hierarchical name. Indeed, when using a hierarchical name to specify a register or wire, the first identifiers in the name must be forward referencing identifiers. The last is the register or wire. When specifying the name, you need not start from the top.top.t.c.q  and t.c.q are, from module b’s perspective, the same."
"Although we can gain access to any named item in the description with this mechanism, it is more appropriate to stay within the local and upward scope rules which enforce better style, readability, and ma intainability. Use hierarchical names sparingly because they violate the stylistic rules of localizing access to elements of the design, rather than allowing any statement in the whole design to access anything."
"The behavioral modeling statements that we have covered so far are very similar to those found in software programming languages. Probably the major difference seen so far is that the Verilog language has separate mechanisms for handling the structural hierarchy and behavioral decomposition. Functions and tasks are provided to a llow for the behavior of a module to be “software engineered.” That is, we can break long and sometimes repetitious descriptions into behavioral subcomponents.  Separately, we can use module definitions to describe the structural hierarchy of the design and to separate concurrently operating behaviors into different modules. The examples of"
"Most of the behavioral modeling statements discussed to this point have been demonstrated using single process examples. These statements are part of the body of an always statement and are repetitively executed in sequential order. They may operate on values that are  inputs or outputs of the module or on the module’s internal registers. In this chapter we present behavioral modeling statements that by  their definition interact with activities external to the enclosing always. For instance, the  wait statement waits for its expression to become TRUE  as a result of a value being changed in another process. As in  this case and the  others to be presented here, the operation of the wait statement is dependent on the actions of concurrent processes in the system. 4.1Concurrent Processes"
"We have defined a process to be an  abstraction of a controller, a thread of control that evokes the change of values stored in the system’s registers. We conceive of a digital system as a set of communicating, concurrent processes or independent control activities that pass information among themselves. What is important  is that each of these processes contains state information and that this state is altered as a function of the process’ cu rrent inputs and present state.110 The Verilog Hardware Description Language"
"Example 4.1 shows an abstract description of a computer. An implementation of the hardware controller for the process described in the always statement is a sequential state machine with output and next state logic. This state machine would control a data path that includes the registers, arithmetic-logic units, and  steering logic such as buses and multiplexors."
"Consider that this process may interact wit h another process in the system, possibly an input interface that receives bit-serial information from a modem. The  process abstraction is necessary in this case because there are two  independent, but communicating, threads of control: the computer, and the input interface. The input interface process watches for new input bits from the modem and signals the computer when a byte of data has been received. The other process, the computer described in"
"These two processes could have been described as one, but  it would have been quite messy and hard to read. Essentially, each statement of the computer process would have to include a check for new input data from the interface and a description of what to do if it is found. In the worst case, if we have two processes that have n and m states respectively, then the combined process with equivalent functionality would have n*m states — a description of far higher complexity. Indeed, it is  necessary to conceive of the  separate processes in a system and describe them separately."
"When, when several processes exists in  a system and information is to be passed among them, we must synchronize the processes to make sure that correct information is being passed. The reason for this is that one process does not know what state another process is in unless there is some explicit signal from that process giving such information. That is, each of  the processes is asynchronous with respect to the others."
"For instance, they may be operating at their own clock rate, or they may be producing data at intervals that are not synchronized with the intervals when  another process can consume the data. In such instances, we must synchronize the processes, provid-Concurrent Processes 111 ing explicit  signals between them that indicate something about their internal state and that of the data shared among them."
"In hardware, one  approach to synchronization is implemented with “data-ready” handshakes — one process will not read the shared data until the other signals with a “data-ready” signal that new data is present. When the other signals that the data has been read, th e first unasserts the “data-ready” signal until new information is available."
"It is important to note that the constructs described in this section trigger on a change in a value. That is,  they are edge-sensitive. When control passes to one of these statements, the initial value of the input being tr iggered on is checked. When the value changes later (for instance, when a positive edge on the value ha s occurred), then the event control statement completes and  control continues with the next statement."
"The general form of the event control statement is: blank. The  expression is a gate output, wire, or register whose value is generated as a result of activity  in another process. The event control begins watching for the specified change from the time procedural control passes to it. Changes prior to the time when control passed to  the event control statement are ignored. After the  event occurs, the statement is executed. If, while waiting for the event, a new value for the expression is  generated that happens to be the same as the old value, then no event occurs. event_ control @ event_identifier @ (event_expression) @* @ (*) event_expression expression hierarchical_identifier posedge  expression negedge  expression event_expression  or event_expression event_expression, event_expression| | | | | | | |"
"Any number of events can be exp ressed in the event control statement such that the occurrence of any one of them will trigger the execution of the statement. A time-out example is shown in Example 4.3. always begin // start the timer that will produce the timeOut signal; @(posedge inputA, posedge timeOut) if (timeOut) // … error recovery else regA = regB; // normal operation //…other statements end"
"The comma-separated event list is important in concurrent process applications (the BNF also allows for the list to be or-separated). If a process needs to wait for any of several events to occur, it does not want to prematurely commit itself to w aiting for one specific event before waiting for another. Indeed, since the events may not occur in a given sequential order — the  order of  arrival may be data dependent  — waiting for individual events in a specific sequential order will probably cause the system to deadlock.  That  is, one  process will  be waiting  for an  event that will never occur.  The comma-separated event list allows us to wait for any of several events."
"The event control statements described above require that a change be specified explicitly. A more abstract version of event control, the  named event, allows a trigger to be sent to another part of the design. The trigger is not implemented as a register114 The Verilog Hardware Description Language or wire and thus is abstract in nature. Further, even if it crosses module boundaries, it requires no port specification. Other parts of the de sign may watch for the occurrence of the named event before proceeding."
"The name “ng.ready” is a  hierarchical name  for event ready and will be explained after we dispense with how the named event works. For module fibNumCalc to receive the trigger, it must first  have started to execute the @event  statement, and then the trigger statement in module numberGen  must be executed. At this time, module fibNum-"
"Module numberGen  produces a value every 100 time units and sends a trigger. If module fibNumCalc  did not get around its always loop in less than that time, it would miss numberGen’s trigger. The result would be that the Fibonacci number of every other number produced by numberGen would be calculated.Concurrent Processes 115"
"The expression  is evaluated  and if it is TRUE , the process proceeds  to execute  the statement.  If it is FALSE , the process  stops until  it becomes TRUE . At that time,  the process will proceed with the statement. Note that the wait statement does not,  itself, have a semicolon at its end; the statement_or_null  contains the semicolon. Again, the change in the expression must come  about from the actions of another concurrent process."
"It is interesting  to note that there would be a problem simulating Example 4.5 if there were no other event control or delay operations in the always statement. If  this were true, then once the wait condition becomes TRUE , the loop would continue to be executed forever as the wait will never be FALSE . In one sense, this problem comes about because the simulator is  simulating concurrent processes in a sequential manner and only switching between simulating the concurrent processes when a wait for a"
"Actually, this is a more general problem in describing concurrent systems. In general, we cannot assume much about the speed of the processes in relation to each other, and thus, we need  to introduce more synchronization signals to insure their correct execution. If Example 4.5 had another synchronization point, say a wait (-ready), then the producer and consumer in the example would be more tightly synchronized to each other’s operating rate. Further, the s imulation would also run correctly! The next section illustrates this with further examples."
"This me thod of transferring data between two concurrent processes will work correctly regardless of the timing delays between the processes and regardless of their relative speeds of execution. That is, because each process waits on each level of the other process’ synchronization signal (i.e. the producer waits for both consReady and120 The Verilog Hardware Description Language !consReady), the processes are guaranteed to remain in lockstep. Thus, the consumer cannot get around its al ways loop and quickly reread the previously transferred data."
"Nor, can the producer work so  quickly to make the consumer miss some data. Rather, the producer waits for the consumer to indicate that it has received the data. Systems synchronized in this way are called  self-timed  systems because the two interacting processes keep themselves synchronized; no external synchronization signal, such as a clock, is needed. ready is FALSE ), conceptually we are synchronizing separate processes and we should use the appropriate wait construct."
"A further explanation of the differences between the wait and while  involves the use of the simulator. Assuming a uniprocessor running a s imulator, each always and initial statement is simulated as a separate process, one at a time. Once started, the simulator continues executing a process until either a delay control (#), a wait with a"
"FALSE  condition,  or an  event  (@) statement  is encountered.  In the case  of the delay control, event,  or a wait with  aFALSE  condition,  the simulator  stops  executing  the process and finds the next item in the time queue to simulate. In the case of the wait with aTRUE expression, simulation continues  with  the same  process.  A while statement will never stop the simulator fro m executing the process."
"Therefore, since the while statement shown in Example 4.7 waits for an external variable to change, it will cause the simulator to go into an endless loop. Essentially, the process that controls inputA will never get a chance to change it. Further, if the loop were corrected by using a wait statement in place of the while, an infinite loop would still occur. Since  the wait  is level sensitive, once  its condition becomes TRUE, it will continue to execute unless stopped by a wait with a FALSE  condition, event control, or delay statement within the loop."
"When control passes to this statement, if clock has the value  one, the  execution will stop until the next transition to one. That is, the event operator  does not assume that since clock is one that a positive edge must have occurred. Ra ther, it must see the positive edge before proceeding."
Figure 4.2 illustrates the synchronous bus protocol to be used in our  example. A clock s ignal is transmitted on the bus and  is used to synchronize the actions of the bus master and bus slave. A write bus cycle takes one full clock period and a read cycle takes two. The type of bus cycle being performed is indicated by the  rwLine  bus line; a zero indicates a read and a one indicates  a write.
"At the beginning of a write cycle the bus master drives the  rwLine, addrLines, and dataLines  lines and waits for the end of the clock cycle. At the end of the clock cycle, the values will have propagated down the bus to the  slave. On the negative edge of clock, the slave loads the  dataLines  into the memory location specified by the addrLines  lines."
"A read cycle takes two clock periods to  complete. During the first, and continuing through the second, the bus master drives the  rwLine  and addrLines  lines. During the second clock period, the bus slave drives the  data  lines with the  value read from Concurrent Processes 123 memory at address  addrLines. On the negative edge of second clock cycle, the master loads dataLines into an internal register."
"First, it loads memory  m from an external file called “memory.data” using the memh system task. The operation  of this task will be described later. Secondly,  clock is initialized to 0; it is important to initialize values that are used to  synchronize processes. Finally, the statement displays the values  rwLine, dataLines, addressLines, and anytime any of the first three change."
"The bus master is  written assuming that clock  has just fallen and a new bus cycle is beginning. If the bus cycle is a  WRITE, the then  part of the  if is exec uted, loading addressLines  and dataLines  with the values passed to the task. The task then waits for the next negative edge of the  clock  (i.e. the end of the write cycle) before returning from the task. When that negative edge occurs, we know that the end of the  WRITE cycle has occurred and, as we will see, the bus slave has loaded the value in  dataLines into m at the address in  addressLines. The #1 assures that all other a lways and initial blocks execute first."
"Let’s trace the action of the slave during the write cycle. The bus slave process begins by waiting for the negative edge of the clock. Remember that these models are written assuming  that a negative clock edge has just occurred and that a bus cycles is just beginning. Thus the “@(negedge clock)” statement waits until the end of the cycle just started, at which point it executes its  if statement. Since we are tracing a write cycle, the  else part of the  ifis executed and the value in  dataLines  is copied into m as addressed by  addressLines. The slave process then waits for the end of the next clock cycle."
"Let’s a ssume that two back-to-back writes are going to be done to memory. It is instructive to examine how the two “@(negedge clock)” statements at end of the write cycle work; the one clock event is near the end of the  wiggleBusLines  task and the other is the clock event at the start of the slave process. Both processes are waiting for this edge to occur. When it does, one or  the other will e xecute first; we do not know which. The value at issue is  dataLines. If wiggleBusLines  executes first and starts the second write, it will assign  dataLines  with a new value of data in the first  then  part. If the slave starts first, it  will write the value of dataLines  into memory. So, which value ofdataLines  will be written into memory? Given that both transfers are non-blocking, the transfers are synchronized an d order independent. Indeed, care must be taken to insure the order  independence of data transfers. In cycle-accurate descriptions, non-blocking assignments insure this."
"The read cycle requires an extra clock period in the master and slave models. Task wiggleBusLines  loads  addressLines  with the address to read from and waits for the end of the second clock cycle before continuing. At the end of the second cycle, the value in  dataLines  is loaded into  data  and that value is returned from the task to the bus master."
The bus slave waits for the end of the first clock cycle and then puts the value read from address  addressLines  of m into dataLines. Thus the value read appears at the beginning of the second clock cycle. The slave then waits for the next negative clock edge event (i.e. the end of the read cycle) before looping around for the next bus cycle.
"The printing is controlled by the statement in the initial statement. Since values only change on the clock edges, each line of the simulation trace shows the values in the system at the end of a clock cycle. The first line shows values in the system when the                  first executes. The second line shows the values when the wiggle-"
"The bus master and slave processes are synchronized to the clock signal. At the end of the clock period when the negative edge  occurs, these processes execute. It is important to note that none of these processes immediately changes any of the registers used to pass information bet ween the processes (i.e. rwLine,  addrLines, dataLines).  If one of the processes had changed any of these registers, the result of the simulation would have relied on the order in which the simulator executed these events — not good. Non-blocking assignments insure correct op eration."
"Note that READ  and  WRITE  were defined to be constants but  tClock  was defined to be a parameter. Parameters provide a means  of specifying a default constant to use for a module. However, when the module is instantiated, the values of the parameters may  be overridden. Section 5.2 discusses parameters in more detail."
"The model for the processor, using the cycle-accurate style of specification, is shown in Example 4.9. An abstract level of modeling a processor allows the designer to understand what functionality will occur during each clock cycle, how that functionality is impacted by concurrent activity in other stages of the processor’s pipeline, and what the performance of the machine will be, at least in terms of clock cycles."
"This example is composed of two always blocks, one for each pipestage of thissimple processor. The first always block models the first pipestage of the processor which fetches instructions. The second al ways block models the second  pipestage w hich executes the instructions. Since each is described by an always block, we have modeled the concurrency found between pipestages of a processor.Concurrent Processes 129"
"Non-blocking assignment is used across the design to synchronize the updating of state to th e clock edge ck. With non-blocking assignment, it is important to remember that all of the right-hand sides of the assignments across the whole design (the two always blocks here) are evaluated before any of  the left-hand sides are updated. In this example, note that the instruction register ( ir) is loaded in the first always block and it is accessed in the second. Since all accesses are implemented with non-blocking assignments, we know that the instruction fetch which loads the instruction register will not interfere with the instruction execution in the second always block — all right-hand sides in the  second al ways block will be evaluated before ir is updated by the first always block."
"In the general case, having the same register written by two separate always blocks leads to indeterminate values being stored in the register. If a model can guarantee that the two always blocks never write the register at the same time (i.e., during the same state or clock time), then writing a register from two always blocks is perfectly valid. However, in our case though, pc is written during every state by the fetch process and during some states by the execution  process."
"At the same time, the next sequential instruction is fetched and  thepc is incremented by the fetch stage. However, since a branch is being executed, this instruction and the incremented pc are not needed. A separate indicator register, skip,  is set by the execution stage to indicate that a branch occ urred and that the next instruction should be fetched from m[pctemp]  rather than from m[pc].  Additionally, since the instruction after the branch was already fetched, skip also controls the execution stage to keep it from being executed."
"In Example 3.4, we showed how the disable statement could be used to break out of a loop or continue executing with the n ext iteration of the loop. The disable statement, using the same syntax, is also applicable in concurrent process situations. Essentially, the disable statement may be used to disable (or stop) the execution of any named begin-end block — execution will then continue with the next statement following the block."
"Consider how the module  works. At the start of time, both the initial and al ways block can begin executing. One stops to wait for a negative edge on reset while the other waits  forreset  to be TRUE . If we  assume  that reset  is unasserted  (1), then  the always block will begin executing its cycle-accurate specification. At some time, reset is asserted (i.e., it bec omes 0), and its negative edge activates the initial block. The initial block disables main , which is the name of the begin-end block in the always block. No matter where the main  block was in its execution, it is exited, and the always block is restarted. The first statement at the start is a wait for reset to be TRUE — unasserted. Thus, when reset  is asserted, the main  block is stopped, and it does not restart at the beginning until reset  becomes unasserted."
"The action of the disable statement not  only stops the named block, but also any functions or tasks that have been called from it. Also, any functions or t asks they have called are also s topped. Execution continues at the next statement after the block. If you disable the task (or function) you are in, then you return from the task (or function)."
"It is also interesting to point out what is not stopped by the disable statement. If the disabled named block has triggered an event control, by changing a value or by triggering a named event, the processes watching for these events will already have been triggered. They will not be stopped by the disable."
"Example 4.11, if we assume that the first state of the controller implementing the always statement is encoded as state zero, then the initial block could be implemented as an asynchronous reset of the state register of the always’ controller. That is, the initial statement w ould not look like a state machine, rather it would be some simple reset logic. The point is that regardless of the implementation of the two processes, there are two independent activities in the system capable of changing state. Each is active an d operating independently of the other."
"The actions performed respectively are: delay 25 time units and then assign the value ofb to a; and delay until there is a positive edge on w  and then assign the value of r  to q. What is common  about these behavioral  statements is the “delay” (either the  # or the @) occurs before the a ssignment is performed. Indeed, the  right-hand side of the statement is not evaluated until after the “delay” per iod. Intra-assignment  timing controls allow for the “delay” to occur w ithin the assignment — between when the  righthand side is evaluated and when the left-hand side is assigned. Conceptually, these assignments have a master-slave  character; inputs are sampled, a delay occurs, and then later th e outputs are assigned."
"The assignments are w ritten with the delay or event control specification in the middle of the assignment justfollowing the “=”. This makes intuitive sense when reading such an assignment. Given that the  right-hand side of the equation is evaluated first and then assigned to the left-hand side, having the delay or  event c ontrol in the middle of  the assignment keys the reader that you must delay before c ompleting the right-to-left assignment.  Although all of our examples here are with blocking assignments, intra-assignment control and timing events can be used with  non-blocking assignments as well. The intra-assignment timing control versions of the statements above are: Concurrent Processes 135"
"The actions taken by the first two assignments are respectively: evaluate b and store the value in a temporary place, delay 25 time units, and then assign the  stored value to a; and evaluate r and store the value in a temporary place, wait for the next positive edge on w, and then store the temporary value in q. These correspond to the illustrations above. The third entry shows the intra-assignment repeat which was not illustrated above. The right-hand side is calculated and  assigned to a temporary place."
"The three forms of the  intra-assignment statement, for both blocking and nonblocking assignments, are described below: statement blocking_assignment ; nonblocking_assignment ; blocking_assignment variable_1value = [ delay_or_event_control ] expression nonblocking_assignment variable_1value <= [ delay_or_event_control ] expression delay_or_event_control delay_control event_control repeat ( expression ) event_control delay _control # delay_value #( mintypmax_expression ) 136 The Verilog Hardware Description Language event_control @ event_identifier @ (event expression) @* @(*) event_expression expression hierarchical_identifier posedge  expression negedge  expression event_expression  or event_expression event_expression, event_expression"
"This statement samples the value of d whenever the statement is executed. Then when the positive edge of the clock  occurs, q is assigned that value. Given that the initial value of d could be sampled well before the time of the clock  edge, the typical behavior of a flip flop is not captured."
"The continuous assignment statement presented  in an earlier chapter, allows for the description of  combinational logic whose output is to be computed anytime any one of the inputs change. There is a procedural version of the  continuous assignment statement that allows for continuous assignments to be made to registers for certain specified periods of time. Since the assignment is not in force forever, as is true with the continuous assignment, we call this the  procedural continuous assignment (these were called “quasi-continuous” in earlier versions  of the manuals),  While the procedural continuous assignment is in effect, the statement acts like a continuous assign.Concurrent Processes 137"
"Example 4.12. Note first that the difference between continuous and procedural continuous is immediately obvious from the c ontext; the procedural continuous assignment is a procedural  statement executed only when control passes to it. (The continuous assignment is always active, changing its outputs whenever its inputs change.) In this example, the first al ways statement describes a process th at reacts to a change in either the  clear or preset signals. If  clear  becomes zero, then we assign  register q to be zero. If preset  becomes zero, then we assign register q to be one. When a change occurs and neither are zero, then we deassign q (essentially undoing the previous procedural continuous assignment), an d then  q can be loaded with a value using the normal clock method described by the second always statement."
"It is important to note that the procedural continuous assignment overrides a normal procedural assignment to a register. W hile the procedural continuous assignment is in effect, the reg_assignment acts like a c ontinuous assignment. Thus, even if the negative edge of the clock occurred as watched for in  the second always statement, the procedural assignment of d toq would not take effect. Further, if the value of the right-hand side of a procedural continuous assignment changes (it was not a constant138 The Verilog Hardware Description Language as in the above example), then the left-hand side will follow it. The value proceduralcontinuously assigned remains in the register after the deassignment."
An alternate  version of the sequential beginend block is  the parallel or fork-join block shown below. Each statement  in the fork-join block is a separate process that begins when control is passed to the fork. The join waits for all of the processes to complete before continuing with the next statement beyond the  fork-join block.
"This example illustrates the description of  an asynchronous reset restarting a process. A resetSequence initializes registers and then begins the fork-join block named mainWork. The first statement of the fork is a forever loop that describes the main behavior of the microprocessor. The second statement is the process that watches for the positive edge of the reset  signal. When the positive edge of the reset occurs, the mainWork block is disabled. As described previously, when a block is disabled, everything in the named block is disable d and execution continues with the  next  statement, in this case the next iteration of the always statement. Thus, no matter what was happening in the fetch and execute behavior of the system, the reset is able to asynchronously restart the whole system."
"The general form for the parallel block is  given below. Like the named (sequential) blocks previously described, naming the block allows for the optional block_declarations that can introduce new names for the scope of the block.Concurrent Processes 139 statement par_block par_block fork [: block _identifier { block_item_declaration } ] { statement} join block_item_declaration parameter_declaration local_parameter_declaration integer_declaration real_declaration time_declaration realtime_declaration event_declaration"
"Consider four named events:  e1, e2, e3,  and e. Write a description to trigger event e after e1, e2,  and e3 have occurred in a strict sequence Namely, if any event goes out of order the sequence is to be reset. Then, write a description to trigger event e after e1, e2 , and  e3 have each occurred three times in any order."
"Add a third stage to the pipeline of Example 4.10. The second stage should only fetch operands; values read from memory should be put in a memory data register (mdr). The third stage will execute the instructions, loading the resulting values (mdr) in acc, pctemp, or m. Assume that the memory has multiple read and write ports. Handle any  interstage conflicts that may arise.5Module Hierarchy"
"A structural model  of a digital system uses Verilog  module definitions to describe arbitrarily complex elements composed of other modules and gate primitives. As we have seen in earlier examples, a structural module may contain a combination of behavioral modeling statements (an always statement), continuous assignment statements (an assign statement), or module instantiations referencing other modules or gate level primitives. By using module definitions to describe complex modules, the designer can better  manage the complexity of a design.  In this chapter we explore module hierarchy and how it is specified as we cover instantiation, parameterized modules, and iterative generation. 5.1 Module Instantiation and Port Specifications"
An input port specifies the internal name for a vector or scalar that is driven by an external entity. An output port specifies the internal name for a vector or  scalar which is driven by an internal entity and is available external to the  module. An inout port144 The Verilog Hardware Description Language specifies the internal name for a vector or scalar that can be driven either by an internal or external  entity.
"It is useful to recap some of the do’s and don’t’s in their specifica tion. First, an input or inout port cannot be declared to be of type register. Either of these port types may be read into a register using a procedural assignment statement, used on the righthand side of a c ontinuous assignment, or used as input to in stantiated  nected internally to gate outputs or  inputs. Externally, only nets may be connected to a module’s outputs."
"ToESe g will be connected to wire eSeg , port A to wire w3, port B to wire w2, port C to wire w1, and port D to wire w0. The period (“.”) introduces the port name as defined in the module being instantiated. G iven that both names are specified together, the connections may be listed in any order. If a port is to be left uncon-Module Hierarchy 145 module _identifier [ parameter_value_assignment ] module_instance { , module_instance } ; parameter_value_assignment #(expression { ,expression } ) module_instance name_of_instance ([list_of_module_connections] ) name_of_instance module_instance_identifier [ range ] list_of_module_connections ordered_port_connection { , ordered_port_connection } named_port_connection { , named_port_connection } ordered_port_connection [ expression ] named_port_connection port_identifier ([ expression ] )nected, no value is specified  in the parentheses — thus .D() would indicate that no connection is to be made to port D  of instance m1 of module binaryToESeg."
"This example showed the case where each instance was connected to a bit-select of the outputs and inputs. When the instances are  generated and the connections are made,  there must be an equal number of bits provided by the terminals (ports, wires, registers) and needed by the instances. In  this, eight instances needed eight bits in each of the output and input ports. (It is an error if the numbers are not equal.) However, instances are not limited to bit-select connections. If a terminal has only one bit (it is scalar) but there are n instances, then each instance will be connected to the one-bit terminal."
"The statements controlling the generation of objects within a generate…endgenerate block are limited to for, if-then-else, and case. The index of the for loop must be a genvar and  both assignments in the for must be to the same genvar. The genvar can only be assigned a value as part of the for loop and it can only take on the values of 0 and positive integers. The genvar declaration may be outside of the generate…end-152 The Verilog Hardware Description Language generate block, ma king it available to other generate blocks. A named begin…end block must be used to specify the contents of the for loop; this provides hierarchical naming to the generated items."
"Three different situations are broken out for separate handling. For most of the stages, the carry in of a stage is connect to the carry out of the previous stage. For the least significant bit (bit 0), the carry in is connected to the module’s carry in ( cIn). For the most significant bit (which is parameterized as width ), the carry out ( cOut ), over-"
"To this point, we have concentrated mostly on behavioral modeling of a digital system. Behavioral models are more concerned with describing the abstract functionality of a module, regardless of its actual implementation. Logic level modeling is used to model the logical structure of a module, specifying  its ports,  submodules, logical function, and interconnections in a way that directly corresponds to its implementation."
"A gate level model of a circuit describes the circuit in terms of interconnections of logic primitives such as AND,OR, and XOR. Modeling at this level allows the designer to describe the actual logic implementation of a design in terms of elements found in a technology library or  databook and thus be able to  accurately analyze the design for such features as its timing and functional correctness. Since gate level modeling is so158 The Verilog Hardware Description Language pervasive, the Verilog language provides  gate level primitives for the standard logic functions."
"A more abstract  means of describing the  combinational logic of a design is provided by the continuous assignment statement. This approach allows for logic functions to be specified in a form similar to Boolean algebra. The continuous assignment statement typically describes the behavior of a combinational logic module, and not its implementation."
"To help in reading and  writing models at these levels, it is useful to understand how the simulator executes them. The basic data type in this style of modeling is the net which is driven by gate and continuous assign outputs. These nets  then are inputs to other gates and continuous assigns, as well as to the right-hand side of  procedural assignment statements. Anytime the input to a gate or continuous assign statement changes, its output is evaluated and any change to the output  is propagated, possibly with a delay, via its output net to other inputs. We call this method of  updating outputs when any input changes the  Verilog gate level timing model; this is discussed further in Cha pter 8."
"In contrast, procedural assignment statements found in behavioral modeling  only execute when control is passed to them. Thus just because a net on the right-hand side of a procedural assignment statement changes doesn’t mean that the statement will execute. Rather, that input would have to have been to an event (“@”) or wait statement which  when triggered will cause the procedural statements in the behavioral model to execute."
"The general syntax for instantiating a gate is given by: gate instantiation n_input_gatetype [drive_strength] [delay2] n_input_gate_instance {, n_input_ gate_instance }; n_input_gatetype and | nand | or | nor  | xor | xnor n_input_gate_instance [name_of_gate_instance] (output_terminal, input_ terminal {, input_terminal} ) name_of_gate_instance gate_Instance_identifier [range] input_terminal expression output_terminal net_lvalue where the n_input_gatetype specifies one of the gate level primitives listed above, the optional drive_strength specifies the electrical characteristics of the gate’s output, the optional delay specifies the simulation gate delay to  be used with this instance, and the list of gate instances is a comma-separated list specifying the terminals of each gate instance and, optionally, names of each instance. The default strengths are strong0 and strong1. The default delay is 0. Further discussion of strengths is given in"
"The drive strength and delay specifications qualify the gate instantiation(s). When one (or both) of these qualifiers is given, then it applies to all of the defined instances in the comma-separated list. To change one or both of these qua lifiers, the gate instantiation list must be ended (with a “;”) and restarted."
"For the gate level primitives in the first column, the first ide ntifier in the gate instantiation is the single output or bidirectional port and all the other identifiers are 162 The Verilog Hardware Description Language the inputs. Any number of inputs may be listed. Buf and not gates may have any number of outputs; the  single input is listed last."
Each of the primitive gates are de fined in terms of these four logic values. Table 6.2 shows the definition of an AND gate. Note that a zero on the input of an AND will force the output to a zero regardless of the other input — even if it isx orz.
"Nets are a fundamental data type of the language, and are used to model an electrical connection. Except for the  trireg  net which models a wire as a capacitor that stores electrical charge, nets do  not store  values. Rather, they only transmit values that are driven on them by structural  elements such as  gate outputs and assign statements, and registers in a behavioral model."
"However, we also find many more wires  declared implicitly  in Example 6.1. For instance,  net x9 which  is the  output  of the XNOR  gate  has not  been declared  in the ful1Adde r module. If an identifier appears in the connection list of an instance of a gate primitive, module, or on the left-hand side of a continuous assignment, it  will implicitly be declared a net. If the net is connected to a module port, its default width will be that of the port declaration. Otherwise, it will be a scalar. By default, the type of an implicit declaration  iswire. However, this  may be  overridden  by the  default_nettype typeOfNet  compiler directive where typeOfNet is any of the net types listed in"
"Here we illustrate the differences between the normal wire and wand net types, d  is declared to be a wire net, and c is declared to be a wand net. c is driven by two different NOT gates as is d . A net declared wand will implement the wiredAND function."
"On the other hand, d is a wire net driven by two gates. Its value will be unknown (x) unless both gates drive it to the same value. Essentially the wand allows for several drivers on the net and will implement the wiredAND function between the drivers, while the wire net will show an unknown ( x) when different values are driven on it."
"The general form of the net declaration is: net_declaration net_type [ vectored | scalared ] [signed] range [delay3] list_of_net_identifiers ; |      net_type [signed] [delay3] list_of_net_identifiers; |      net_type [drive strength] [ vectored | scalared ] [signed] range [delay3] list_of_net_decl_assignments ; | net_type [drive strength] [s igned] [delay3] list_of_net_decl_assignments ; |trireg  [charge_strength] [ vectored | scalared ] [ signed ] range [delay3] list_of_net_identifiers ; net_type wire | tri | tril | supply0 | wand | triand | tri0 | s upply1 | wor | trior list_of_net_identifiers net_identifier [dimension {dimension}] { , net_identifier [dimension {dimension}] } list_of_net_assignments net_decl_assignment { , net_decl_assignment} net_decl_assignment net_identifier = expression range [ msb_constant_expression: 1sb _constant_expression ]"
"The range of nets can  optionally be declared as  vectored or  scalared. Scalered is the default case an d indicates that the individual bits of a vector (i.e. a multibit net)might be accessed using bitand part-selects. This allows individual bits and parts of a net to be driven by the outputs of gates, primitives, and modules, or to be on the left-hand side of a continuous assign. When specified as vectored, the items are represented internally as a single unit for efficiency. In this case, for instance, gate outputs cannot drive a bus specified as vectored.166 The Verilog Hardware Description Language"
"Hamming en coding and  decoding function. Hamming encoding is used when there is a possibility of noise entering a system and data being corrupted.  For instance, data in a memory might be stored in an encoded form. The example presented here will encode eight bits of data, pass the encoded data through a noisy channel, and then regenerate the original data, correcting a single bit e rror if necessary. Detailed derivation and presentation of the technique can be found in most introductory logic design texts."
The error detection and  correction is implemented by adding extra bits to the message to be encoded. The basic encoding is shown in Figure 6.2. Here we see eight original bits (Dx) on the left being encoded into twelve bits on the right. The original data bits are interleaved with four Hamming bits (Hx) as shown in the center column.
The four bits are determined by XORing certain of the original bits. The interleaved ordering of the bits is important as the final decoding of  the bits will indicate which of the bits (including the Hamming bits) is incorrect by specifying its bit position. The bit numbering of the encoded data is shown on the right.
"Returning to module  hamTest,  we see that  original  is the input to  hamEncode  and thatencoded  is its output.  Encoded  is then the input to the assign statement which produces  messedUp.  The purpose of the assign statement is to simulate a noisy channel where one of the input bits gets inverted. In this case bit 7 is inverted. The output of the assign  (messedUp)  is input to  hamDecode  which corrects this inversion and produces the original data on  regenerated."
"The only procedural statements in the whole example are in the initial statement of this module. Their purpose is  to run test vectors through the system. To do this, we use the system task to produce random numbers. Here, we set the seed value for to 1 an d enter a forever loop. Original is loaded with the result of"
"Seed is declared to be an integer. Integers are often used for ancillary calculations in a simulation model. In a real design, this value would not exist as it is only there for testing purposes. Registers should be used when modeling real parts of hardware. See Appendix E for more discussion on  integers."
"Continuous assignments provide a means to abstractly model combinational hardware driving values onto nets. An alternate v ersion of the one-bit full adder in the previous section is shown using continuous assignments in Example 6.4. Here we show the two outputs sum and cOut being described with an assign statement. The first (sum) is the exclusive-or of the three inputs, and the second is the majority function of the three inputs."
"The continuous assignment is different from the procedural assignment  presented in the chapters on behavioral modeling. The continuous assignment is always active (driving a 0, , x,o rz), regardless of any state sequence in the circuit. If any input to 172                                                                             The Verilog Hardware Description Language the assign statement changes at any time, the assign statement will be reevaluated and the output will be propagated. This is  a characteristic of combinational logic and also of the Verilog gate level timing model."
"The continuous assign provides a means of  abstracting from a gate level model of a circuit. In this sense, the continuous assign is a form of behavioral modeling for combinational circuits. That is, we only need specify the Boolean algebra of the logic function, not its  actual gate level implementation. The final gate level implementation is then left to a logic synthesis program or further designer effort.Logic Level Modeling 173"
"Recall that within a function, we may have procedural statements such as case and looping statements, but not wait, @event, or #delay. Thus we may use procedural statements to describe a complex combinational logic function. For instance, in Example  6.5 a description of a multiplexor illustrates a function call in an assign."
"The combined use of a net specification and continuous assign is formally specified with the following descriptions of a net_declaration: net_declaration | net_type [drive strength] [ vectored | scalared ] [ signed ] range [delay3]Logic Level Modeling                                                                                            175 list_of_net_decl_assignments; net_type [drive strength] [ signed] [delay3] list_of_net_decl_assignments; list_of_net_decl_assignments net_decl_assigmnent { , net_decl_assignment} net_decl_assignment net_identifier = expression"
"Here we see  busEnable  being used to select between  bufInput  driving the  busLine and a high impedance driving the line. However, no matter what the state of busEnable, bufferedVal  always follows the value of busLine.  Thus  busLine  may be driven in an external  module when  busEnable  is zero and  bufferedVal  will show  its value.176 The Verilog Hardware Description Language"
"Again we have a bus master process communicating with a bus slave process. In contrast to the previous example,  the communication in Example 6.10 is carried out over wires def ined in the sbus module. Here we see wires  rw, addr,  and data  being the only means of communication between the instantiated master  and slave  modules."
"The rw and addr  lines are driven only by the bus  master.  However, the  data  lines must be driven during a write cycle by the  master,  and during a read cycle by the slave . Thus we need to develop a means of synchronizing the driving of the data lines."
"Of course, the  rw line produced by the  master  is the global indicator of whether a bus read or write is in progress. Both the master  and slave  modules include a registerLogic Level Modeling                                                                                                  177 called enable  which is used internally to enable the bus drivers at the appropriate times."
"The main difference being that the module does not also act as a bus receiver. The module is parameterizable to the bus size, and will drive the bus with  valueToGo  if driveEnabl e isTRUE . Otherwise  it drives  a z. This  module  is instantiated into both themaster  and slave  modules."
"Other tristate modeling primitives include bufif0 which reverses the sense of the control input from  bufif1, notif1 w hich inverts the data input and drives the output when the c ontrol input is one, and notif0 which inverts the data input and drives the output when the control input is zero. Truth ta bles for these gates may be found in"
"The functionality of Example 6.11 may now be described. The basic latch function is implemented  by the  cross-connected NAND gates  and When  the clock  is low, the outputs of d and nd are held high and the latch pair hold their value. When theclock  is high, then the d and nd values propagate through and change the latch value.  The and NAND gates follow  thedata  input  as long  as the clock  is high."
"Gate, continuous assign, and net delays provide a means of accurately describing the delays through a circuit. The gate delays describe the delay from when the inputs of a gate change until when the  output of the gate is changed and propagated. Continuous assign delays describe the  delay from when a value on the right-side changes to when the left-hand side is changed and propagated. Net delays describe the delay from when any of the net’s dr iving gates or assign statements change to when the value is propagated. The default delay for gates, nets, and assign statements is zero. If one delay parameter is specified, then the value is used for all propagation delays associated with the gate, net, or assign. Logic Level Modeling 183"
"If the case of a c ontinuous assign where the left-hand side is a vector, then multiple delays are handled by testing the value of the right-hand side. If the  value was nonzero and becomes zero, then the falling delay is used. If the value becomes z, then the turn-off delay is used. Otherwise, the rising  delay is  used. Logic Level Modeling 185"
"The specparams name constants that will be used in the module  path declarations. The module path declarations list paths from the module’s inputs and inouts (also called the path’s  source), to its inouts and outputs (also called the path’s  destination). The timing specified will be  used for all instances of the module."
"Two methods  are used  to describe  the module paths,  one using  “=>” and the  other using  “*>”.  The  “=>” establishes  a parallel connection  between source input  bits and destination output bits. The inputs and outputs must have the same number of bits. Each bit in the source connects to its corresponding bit in the destination."
"Module paths may connect any combination of vectors and scalars, but there are some restrictions. First, the module path source must be declared as a module input or inout. Secondly, the module path destination must be declared as an output or inout, and be driven by a gate level primitive other than  a bidirectional transfer gate."
"These two statements as shown are equivalent; both perform a bitwise AND ofb and c, and assign the result to a. The way to think about these statements is that any time any of the inputs ( b or c) changes, the output a is re-evaluated. Further, in both of these statements, ais a net."
"The loading of the value into the register or memory is done only when control is transferred to the procedural assignment statement. Control is transferred to a procedural assignment  statement in a sequential manner, flowing from one statement to the next. In this way, procedural assignments function similar to a normal software programming language assignment statement. However, the flow of control can be inter-190 The Verilog Hardware Description Language rupted by an  event ( @) statement (and as we’ll see later, wait and  #delay statements), and then is only reactivated when the event occurs."
"The procedural assignments  “=” and  “<=”  can be  further categorized  by when  the left-hand side is updated. The “=” updates its  left-hand side immediately so that this new value  is available  in the  next procedural statement.  In contrast,  “<=” updates  its left-hand side only after  all of the right-hand  sides  of “<=” statements waiting  on the same edge in the whole design have been calculated. Thus, the new value on the lefthand side is not available in the next procedural statement. This leads to anomalous descriptions such as: @(posedge clock) begin // somewhere in an evil always block m = 3; n = 75; n <= m; r = n;"
"When it is read, it should be decoded and corrected. Add a bus line driven by theslave and read by the master  that indicates when a double error has occurred. Devise a m eans for the data in the memory to become corrupted, and a means of displaying when a double error has  occurred."
"Using the cycle-accurate style of description, an “@(posedge clock);” statement is followed by behavioral statements and then by another “@(posedge clock)” statement. We’ll call this “@(posedge clock)”  the clock  event.  The statements between the two clock events constitute a state. The clock event statements need not appear in pairs; if there is only one clock event statement in a loop body, then the loop executes in one state and the next clock event is , indeed, itself."
"This style of  description is used at the point in system de sign when we want to specify the cycle-by-cycle behavior of the system but we are not too concerned with the actual datapath for the design. We have specified the  simple calculation and which states the new values will be produced in. But, we haven’t specified any datapath for it; that is left for a later stage of the design process."
"The use of blockin g (“=”) and non-blocking (“<=”) assignments was mixed in this specification. Non-blocking assignments were used for registers x and y which are used outside  of the al ways block. This effectively synchronizes their loading to the clock edge specified. For registers used only in one always block, such as register i, this is not necessary. Remember that when you assign using non-blocking assignments, the value is not available by the register’s name until after the clock edge. i.e, it’s not available on the next line of the description! Further, only one unconditional nonblocking assignment can be made to any register in a state. However, you can use blocking assignments to calculate intermediate values and values  only used inside the always block. Of course, these are immediately available on the next line of the description. In this example, the i used in comparison at the end of the loop is the i calculated in the loop b ecause we  used a blocking assignment. 198 The Verilog Hardware Description Language 7.2Cycle-Accurate Specification"
"The basis for cycle-accurate specifications is the always statement, which is  viewed as a specification of a thread of control: a process. The resulting register-transfer level implementation of the al ways statement will include a data path to perform the processing specified in the al ways statement, and a description of a finite-state machine to evoke the register-transfer operations in the data path. A"
"More formally, the  internal register set of an always block is the set of all named entities on the left-hand side of the procedural assignment statements in the always block that are only used internal to the always block. These  include registers and memories. In  Example 7.2, register q is a member of the internal register set. Register qout is not a member of the internal set b ecause it is also used outside of the module."
"The output set of an always statement is the set  of all named entities on the lefthand side of the  procedural assignment statements that are not members of the internal set. That is, these entities are used on the right-hand side of a continuous assign, are input to a gate primitive, or are in the input set of another al ways block. In"
"An always block used in cycle-accurate specification often has clock and reset inputs as well. Indeed, Example 7.2 shows the  use of  input clock. For the sake of the above definitions, we do not consider these to be inputs of the al ways block. Rather we will view them as special control inputs. This is similar to the practice in finite state machine design where clock and reset are not considered part of the systems inputs. (To make our point, we intentionally left clock out of the input port list.)"
"Consider how to read the  above statements. The statement labelled State A  above indicates the  action that occurs in one  state of the system. When the posedge of the clock is seen, q will be loaded with the sum of r and s. That is, even though q <= r + s is written on the text line after  the event statement waiting for the edge, we know from the simulation semantics of the language that q will be  calculated based on val200 The Verilog Hardware Description Language ues of r and s existing just before the clock edge. q will be updated after all such righthand sides have been calculated. Likewise, qout  will be loaded at the second clock edge based on the value of q and qout  just before this edge (this will be the q calculated in the previous state). From this specification, we infer that we have one clock period in which to calculate the sum of r,s, and qout . That is, in state A, the r and s inputs are sampled and summed to produce q. State B then accumulates that sum into qout."
"The Verilog description is shown again in Figure 7.3, this time with  a timing diagram and a state transition diagram. Note that the clock edge that transits the  system from state A to state B is the same one that loads the new value generated for qin state A. Thus, the new value of q is generated by state A; it will not be available in register q until the system is in state B."
"When modeling systems using the cycle-accurate approach, we are  only sampling the always block inputs on the edge of the clock at the end of the state. Thus, as shown in the figure, even though r and s were generated earlier in time (possibly at the previous clock event), we only require that they be valid at the clock edge at the end of the state. After all, the specification is only accurate  at the clock cycles (clock events); thus the name. Since all actions occur at the clock edge, assignments to members of the output set must be  non-blocking."
"Assume the output set is f and h, the input set is i, j, and k, and registers g,q, r, and s are part of the internal set. Note that either of the multiplies in state C could have been executed in state B because the values being multiplied in each of the statements were calculated before state B. Rescheduling one of these would be advantageous because state C has two multiplies scheduled in it. That means that the data path to implement this Ve rilog fragment would have to have two separate multiply cells to execute both multiplies in the same state. If we moved one of the multiplies to state B, then each of the states would only need one multiply in the data path — a savings in area. Behaviora l synthesis tools are capable of recognizing the opportunities of rescheduling operators into other states to make such savings."
"If q = r * s was moved intostateB , there would be no  change in input/output functionality. However, if f <= f * g is moved, then f would appear one state too early. The timing relationships of the input and output sets would  be changed, A behavioral synthesis tool knows to insert a temporary register to load this value in state B, and then transfer the value to the output f in state C . It is possible that an extra register already exists in the design. For instance, if g is not accessed after state C  before it is rewritten in the next  iteration of  the al ways statement, the result of the multiply could be loaded into register g and then transferred to register f in stateC . The states B and C are rewritten below as Bnew and Cnew  to illustrate this: 202 The Verilog Hardware Description Language @ (posedge clock) h <= f + k; g = f* g; @ (posedge clock) f <= g; q = r *  s;"
"One might observe that a designer can recognize  these opportunities for optimization and could pe rform them. In fact, a designer could rewrite the descriptions as we have to specify different schedulings of operations to control states. However, a behavioral synthesis tool, given one of these specifications, can  rapidly suggest alternate implementations  that exhibit different trade-offs. The designer can select from the most appropriate. Not  all behaviora l synthesis tools can make all of these transformations. Your mileage may vary."
"The example discussed  above is expanded here in Example 7.4 to include a specification for the behavior  of the circuit when it is reset. Module accumulate has ports for the output ( qout ), ports for the inputs ( rands), as well as the special inputs for the system ( clock and reset )."
"There are a few points to note. If reset is unasserted, the behavior of the always block is that of the example in the previous section.  Reset could have been specified as asserted-high by waiting for the positive edge of reset  in the initial block, and then waiting for ~reset  in the always block. Finally, no action can be specified between the “wait(reset);” and the “@(posedge clock)”. Such an action can’t be part of state B because it would have to be conditioned by the reset  — an action not normally allowed in finite state machine design. Any such action there would have to be implemented as another state executing when reset becomes unasserted and a clock event Cycle-Accurate Specification 203"
"Our full, cycle-accurate specification of a system now includes both the always and initial blocks. Together these specify a thread of control and how that thread is  reset into a known state. Whe n discussing the input and output sets of an always block at this level of design, it is more accurate to  consider both the al ways and initial blocks together. Analyze only the always block to determine the sets. The initial block only specifies the reset behavior. 7.3Mealy/Moore Machine Specifications"
"In the example, the final value of delta  in state A  depends on whether the then path of the if  statement is  taken. That is, the control signals to the data path depend on state information (we’re in state A) as well as the system input switch . This requires a Mealy machine implementation."
"Module firFiltMealy  in Example 7.7 is a one-state specification of the FIR algorithm. As is  typical with Mealy machine implementations, actions are encoded on the different next state arcs of the finite state machine. Here, the actions of firFilt  above are so encoded. firFiltMealy  shows three separate actions that can occur; all with the same next state (which is the current state). The firstaction is the then part of  the first if statement. This corresponds to the initialization of the loop in firFilt . The second action is the else part, which actually has two possible a ctions. The first ac tion, where loop1  is not disabled, updates acc and index  and corresponds to the loop body of firfilt. The second action updates acc and index , but also updates y and start_pos . This corresponds to exiting the loop in module firFilt . Interesting, when firFiltMealy  is synthesized, there is no identifiable finite state machine. All actions are conditioned by the comparison of registers index  and start_pos ; only datapath registers are clocked."
"Behavioral synthesis tools aid in the  design of  register transfer level systems — finite state machine with datapath systems. As illustrated in Figure 7.5, a cycle-accurate description is used to specify the functionality of the system. From the cycle accurate nature of the description, timing relationship s involving the inputs and outputs of the system are derived. The behavioral synthesis tool designs a datapath and finite state machine implementing the functionality and meeting these timing relationships. The design is specified in terms of functional datapath modules such as ALUs, register files, and multiplexor/bus drivers that are pr ovided in a technology library file. In addition, the finite state machine for the system is specified. Downstream design tools include logic synthesis to design the finite state machine an d module generation to design the datapath."
"Scheduling assigns operations to control states. Given that the input to a behavioral synthesis system is a cycle-accurate specification, one might wonder what role scheduling plays. To behavioral synthesis, cycle-accurate specifications only constrain when input ports are read and when results are made available on an output port. Internally, there is flexibility  to schedule the operations that produce  the results as long as the result is available at the appropriate time."
"The cycle-accurate specification only tells us how to calculate the outputs from the inputs. The behavioral synthesis tool selects the number of op erators (i.e., should there be one multiplier or two?), the number of registers, and the number of buses in a design. In conjunction with sche duling, allocation provides a wide range of 210 The Verilog Hardware Description Language trade-offs in implementation. That is, if two multipliers are  available, then two multiply operations could be done in one control state, making the implementation faster but larger."
"Mapping assigns operations (e.g. the “+” and “-” in Verilog procedural statements) to functional modules. Given that a behavioral synthesis tool has  decided to have two adders in the datapath, select which of the + operators in the description are going to be mapped into which of the functional modules. 7.5Summary"
"This chapter has described the cycle-accurate style of specification in Verilog. This style is often used in high level simulation of systems and it is beginning to be  used for behavioral synthesis. Since synthesis technology is still young, the  restrictions on the language styles will evolve; the user manual for the tools must be consulted.8Advanced Timing"
"The previous chapters were based on a relatively straight-forward understanding of how the Verilog simulator schedules and executes events. This chapter develops a more detailed model of the simulator, including the processing of a number of the more subtle timing semantics of the language. Topics include the simulator scheduling algorithm, non-deterministic aspects of the language, and non-blocking assignments."
"The material in this chapter is meant to explain conceptually how  Verilog simulators are expected to  work. However, the presentation may not match any particular implementation. There are plenty of short-cuts, tricks, and go-fasts that are or could be implemented. Their mileage and software-engineering appropriateness may vary and are not the topic of the chapter. 8.1Verilog Timing Models"
"A hardware description language is  used to model both the function and timing of digital systems. The simulation of these models is  organized around events. An  event is a change in a value in the simulation model at a specific time. The semantics of the language specify how an event causes other events to occur in time. Through this sequence of events, simulation models are executed, and simulation time is advanced.212 The Verilog Hardware Description Language"
"A timing model is a model of how simulation time is advanced — it is tied closely to the semantics of the hardware description language. So far, we have seen two timing models used by the Ve rilog language. These timing models are illustrated by gate level and behavioral level descriptions."
"A simulation model should not be confused with a  timing model. The first is a model of digital  hardware: e.g., an ALU or register file. The latter is a model of how time is advanced by the simulator. In this section, we will discuss these  timing models and how the simulator advances time."
"Example 8.1 A NAND Latch of inputs to the simulation model that, when a change occurs on one or more of them, will cause the model to be  executed. The  sensitivity list is a different view of a fanout list. The fanout list is organized around the element producing a new value — it tells us which elements need to be  evaluated when an event oc curs. The sensitivity list is organized around the element receiving new values — it tells  us which of the inputs are to cause the model to be executed when  a change  occurs."
"Example 8.1 illustrates the Verilog  gate level timing model.  When  any input changes at any time, the gate instance will execute to  evaluate its output, and create a new event, possibly in the future, if the output changes. All inputs are always sensitive to a change; the change will cause the evaluation  of the simulation model. The gate level timing model applies to all the gate primitives, user defined primitives, continuous assignment statements, and  procedural continuous assignment statements. A continuous assignment statement is sensitive to any change at any time on its right-hand side. The change will cause the expression to be evaluated and assigned to the lefthand side,  possibly at a future time."
"Another characteristic of the gate level timing model pertains to the scheduling of new events. Consider the situation where an event for a particular element exhibiting the gate level timing model has previously been scheduled but has not occurred. If a new event is generated for the output of that element, the previously scheduled event is cancelled and the new one is scheduled. Thus, if a pulse that is shorter than the propagation time of a gate appears on the gate’s input, the output of the gate will not change. An  inertial delay is the minimum time a set of inputs must be present for aAdvanced Timing 213 change in the output to be seen. Verilog gate models have  inertial delays just g reater than their propagation delay. That is, a pulse on a gate’s input will not be seen on the output unless its width is greater than the propagation delay of the gate. As we will see, if the input pulse is equal to the propagation delay, it is indeterminate whether it affects the output. This is true for all elements exhibiting the gate level timing model."
"Now consider the behavioral model of a D flip flop shown in Example 8.2. The semantics of the language tell us that the always statement will begin executing and will wait for a positive edge on the clock  input. When a positive edge occurs, the model will delay five time units, set q equal to the value on the d input at that time, and then wait for the next positive edge on clock . In contrast to the gate level timing model, this example illustrates a different timing model."
"For instance, during the time the always is delaying for five time units, another positive edge on the clock  input will have no effect. Indeed that second positive edge will not be seen by the simulation model since when the 5 time units are up, the model will then wait for the next clock edge. It will only be sensitive to positive clock edges that are greater than 5 time units apart. Thus the al ways statement is only sensitive to clock when execution of the model is stopped at the “@”. Further, the always statement is never sensitive to the d input — a change on d will not cause the always statement to do any processing."
"This example illustrates the Verilog  procedural timing model  which occurs in the behavioral blocks contained in initial and always statements. In general, the initial and always statements are only sensitive to a subset of their inputs, and this sensitivity changes over time with the execution of the model. Thus the sensitivities are dependent on what part of the behavioral model is c urrently being executed."
"Another characteristic of the procedural timing model pertains to how events are scheduled. Assume that an update event for a register has already been scheduled. If another update event for the same register is scheduled, even for the same time, the previous event is not cancelled. Thus there can be multiple events in  the event list for an entity such as a register. If there are several update events for the same time, the order of there execution is indeterminate. This is in contrast to the gate level timing model where new update events for an output will cancel previously scheduled events for that output.214 The Verilog  Hardware Description Language"
"There is an overlap in the simulation models that can be built using the  two Verilog timing models. Indeed, in terms  of input sensitivities, the  procedural timing model can be used to model a super set of what a gate level timing model can. To see this, consider  the behavioral NAND  gate model shown  in Example 8.3.  This  model uses  the or construct with the control event (“@ ”) to mimic the input sensitivities of the gate level timing model. If there is a change on in1, in2, or in3, the output will be evaluated. Thus, the procedural timing model can be used mimic the input sensitivities of the gate level timing model. However, as shown above, the procedural timing model can have other timing sensitivities, making it more fl exible."
"There  are several subtle  differences  between Example  8.3 and a  three-input NAND gate instantiation. First, the procedural assignment makes the behavioral model insensitive to the inputs during the propagation delay of the gate. Second, if the inputs of a gate level timing model change and there  is already a new output scheduled for a future time, th e previously scheduled up date will be cancelled and a new event will be scheduled."
"In summary,  elements of a Verilog description follow either the gate level or procedural timing model. These timing models define two broad classes of elements in the language, specifying how  they are sensitive to changes on their inputs. Further, these specify two methods for how events are scheduled for future action. 8.2Basic Model of a Simulator"
"Clearly, a gate level event-driven simulator needs to keep track of the output values of all the gate instances, the f uture times at which new events will occur, and a fanout list for each of the gate instances in the simulation model. The events are stored in a list ofevent lists. The first list is ordered by times in the future. For each future time, there 216 The Verilog Hardware Description Language is a list of events; all events for a specific time are kept together. A simulator scheduler keeps track of the new events occurring and maintains the event list. The scheduler can schedule an event at a future time by inserting the event into the event list. The scheduler can also unschedule an event by removing it from the list."
"From here on, we will distinguish between two types of  events:  update events, and evaluation events.  An update event  causes a value to be updated at a specified time. An evaluation event causes a gate (or as we will see later, a behavioral model) to be evaluated, possibly producing a new output.  Indeed, update events cause evaluation events, and evaluation events may cause update events."
"Figure 8.2 illustrates the interconnection of the major elements of an event-driven simulator. The simulation scheduler is shown here as  being the major actor in the system. Each of the arrows connecting to it has a label attached describing the actions taken by the scheduler. From the last section, we remember that curren t update  events (new values) are removed from the event list and gate output values are updated."
"If the event selected is an update event, the assignment is made and the fanout list is followed, building a list of gates to evaluate. These gates are evaluated and any resulting output changes are scheduled as update events. If there are behaviors on the fanout, evaluation events is scheduled for them. If the event selected is an evaluation event, the gate or behavioral model is executed. Any output change causes an update event for the output. Note that the new update event may be for the current time (e.g., a gate of zero delay was executed). This event is still inserted into the event list and will be removed at the next cycle of the outer loop. Thus, there may be several simulation cycles at the current time."
"Behavioral models in Verilog follow the procedural timing model. Thus, these simulation models ar e sensitive only to a subset of their inputs, and these sensitivities may change over the execution of the model. In this section we will consider the various aspects of simulating behavior models, including handling fanout lists, and  register updates."
"Consider Example 8.4, a be havioral model of a master-slave latch. The operation of the latch is dependent on the two clock phases phi1 and phi2 . First the latch waits for the positive edge of phi1 . When this occurs, the value of d is saved internally and then the always waits for the positive edge of phi2 ."
"The important point to realize is that over the execution of this behavioral model, it is alternately sensitive to the positive edges of phi1 and phi2 , and is never sensitive to input d. A behavioral model has a sensitivity list — a list that specifies which of its inputs the always or initial statement is  currently sensitive to."
"Not only is the process statement placed on the fanout list, but also an indicator as to where to resume executing the process is ma intained. This is analogous to a soft ware program trying to read from an input device. The operating system will suspend execution of the program until the input has arrived. Once input has arrived, the program continues executing from the point where it wa s suspended. In like manner, a suspended Verilog process resumes executing from where it was suspended.220 The Verilog Hardware Description Language"
"Registers are assigned new values as a result of executing  behavioral models. The values are assigned immediately without need for creating update eve nts. Thus if a register is assigned to on the left-hand side of a procedural expression, and immediately used in the next  statement on the right-hand side, its new value is used. In addition, registers that are  outputs of the process will also create update events. So, if a register is used as a source in a c ontinuous assignment, or in  a wire, or if another behavioral process is waiting (with  @ or wait) for a change in the register, the update event will cause evaluation events to be scheduled."
A simulator executes events scheduled for the same time in a group. It may take several simulation cycles to execute all of these events b ecause some events may create other events for the  current time. We speak of executing events for the same time as executing them in  zero-time. It is not that these take no time to execute. Rather all of the events occur without the passage of simulation time. They occur in zero-time.
"Further, it  specifies that the order in which these events are executed is arbitrary. The arbitrary execution order of events in zerotime is a source of non-determinism in the simulation language. When writing models, one needs to be se nsitive to the fact that the ordering of events in zero-time is unspecified."
"They are both correct because the simulator is allowed to take events out of the event list for the current time and execute them in whatever order it pleases. If you think that q and qBar (and thus f) should always appear to have complementary values, t hen you need to change the simulation model. For  example, one change is to combine the second always statement and the not gate instantiation, leaving only the al ways statement shown in Example 8.7."
"This problem can be  corrected by using the intra-assignment delay statement “q = #3 d;” in the dff module. This statement will cause all of the d inputs of the dff instances to be sampled and stored as update events in the event list before any of the updates are made to the instances of q. Thus, the instances can be executed in any order and the behavior  is deterministic. The problem can also be corrected by using non-blocking assignment: “q <= d;” in the dff module. Here the non-blocking assign-Advanced Timing 223 ment works with the clock  edge to separate the reading of all of the d’s from the updating of the q’s."
"The second source of non-determinism in Verilog stems from potential interleaving of the statements in different behavioral processes. By behavioral process models, we mean the behavioral statements f ound in al ways and initial statements. Update events and all evaluation events except for th e execution of behavioral process models are atomic actions; these events are guaranteed to be executed in their entirety  before another event is executed. The behavioral process models found in initial and always statements live by a different set of rules."
"Consider first a software programming environment.  In a normal programming language such as C, a single process is described thatstarts and ends with the “main” function. As it executes, we expect the statements to be executed in the order written and for the values  calculated and stored in a variable on one line to have the same value when used as sources on succeeding lines. Indeed, this is the case as long as there is only one process. However, if there is more than one process and these pro-cesses share information — they store their variables in the same memory locations — then it is possible that the value in a variable wil l change from one line to the next because some other software process overwrote it."
"Continuing with the software analogy, consider the excerpts from two processes shown in Figure 8.5 executing in a parallel programming environment. Each process is its own thread of control, executing at its own rate. But the two processes share a variable — in this case the variable  a in both processes refers to the same memory words. If these processes were being executed on one processor, then process A might execute for a while, then process B would execute, and then A again, and so on. The operating system scheduler would be charged with giving time to each of the processes in a fair manner, stopping one when its time is up and then starting the other."
"Of course, there could be a problem if process A is stopped right after the “a = b + c” statement and process B is started; process B will change the value of a seen by processA and the result calculated for q when process A is finally resumed will be different than if process A executed the two shown statements without interruption.224 The Verilog Hardware Description Language"
"Alternatively, these two  processes could be executed on  two parallel processors with the variable a  in a shared memory. In this case, it is possible that process B will execute its “a = a + 3” statement between process A’s two statements and change the value ofa. Again, the result of q is not deterministic."
"In a software  parallel programming environment, we  are guaranteed  that the statements in any process will be executed in the order written. However, between the statements of one process, statements from other processes may be interleaved. Given the parallel pro gramming environments suggested here, there could be many different interleavings. We will call any specific interleaving of statements in one process by those of  other processes a  scenario. The two following scenarios give rise to the two differing values for q described above."
"Which of these two scenarios is correct? According to the normal understanding of a parallel programming environment, both interpretations are correct! If the writer wanted Scenario 2 to be the correct way for q to be determined, then the writer would have to change the description to insure that this is the only way q can be calculated."
"The above discussion of parallel software programing environments is exactly the environment that Verilog processes execute in. Specifically, the  execution rules for behavioral processes are: Advanced Timing 225 the statements in a begin-end block in a Verilog process (i.e., the statements within an al ways or initial statement) are guaranteed to execute in the order  written. the statements in a Verilog process may be interleaved by  statements from other"
"Interestingly, in concurrent software languages, high level methods are provided to synchronize multiple processes when they try to share informa tion. P and V semaphores are one approach; critical  sections are another. To make these methods work, there are instructions (such as “test and set”) that are atomic — they cannot be interrupted by another process. These instructions, acting in “zero-time,” provide the basis for the higher level synchronization primitives. In  hardware, synchronization between processes is maintained by clock edges, interlocked handshake signals, and in some cases timing constraints."
"The non-blocking  assignment  is indicated  by the  “<=”  operator instead  of the “=” operator used for blocking assignments. The <= operator is allowed anywhere the = is allowed in procedural assignment statements. The non-blocking assignment operator cannot be used in a continuous assignment statement. Although <= is also used for the less-than-or-equal operator, the context of usage determines whether it is part of an expression and thus a less-than-or-equal operator, or whether it is part of a procedural assignment and thus a non-blocking assignment."
"Using non-blocking assignments causes these two assignments to be concurrent — to appear to happen at  the same time. The first statement in the always block is executed and a non-blocking update for cS1 is scheduled for the current time. However, the update is not made immediately and execution continues with the s econd line.228 The Verilog Hardware Description Language"
"Here a non-blocking update for cS0 is scheduled for the current time. This update is not made immediately and execution continues with the al ways block waiting for the next posedge clock. Thus, the cS1 calculated on the first line is not the same value used on the right-hand side of next statement."
When will the values of cS1 and cS0 be updated? They will be updated only after all blocking updates for the current time are executed. This includes any blocking updates or evaluation events generated from them. Thus all righthand sides will be evaluated before any of the left-hand sides are updated. The effect is that all non-blocking assignments appear to happen concurrently across the whole design. The order of the two statements for cS1 and cS0 could be switched in the description with no change in the resulting value.
"When we get to the next simulation cycle and there are more regular events, these are handled as just described. When there are no more re gular events for the current time, events from the non-blocking layer are moved to the  regular event layer and executed. These in turn may cause other regular event s and non-blocking events which are  scheduled into their respective sections. The event scheduling algorithm continues repeatedly executing all  of the regular events for the current time, followed by the non-blocking events for the current time until no more events (regular or nonblocking) exist for the cu rrent time. At this point, the  scheduler handles monitor events. These are inserted in the monitor events layer when the input to a monitor statement changes. These are the last to be handled before time  is advanced. They cause no further events."
"The general form for the non-blocking assignment is shown below: nonblocking_assignment vaiable_lvalue <= [ delay_or_event_control ] expression delay_or_event_control delay_control | event_control | repeat ( expression ) event_control delay _control # delay_value | #  (mintypmax_expression) event_control @ event_identifier | @ (event expression) | @* | @(*) event_expression expression hierarchical_identifier posedge_expreession negedge_expression event_expression  or event_expression event_expression , event_expression232 The Verilog  Hardware Description Language"
"A differentiating feature of the nonblocking assignment is the fact that it schedules an assignment but does not block the current pro cess from executing further. Consider the behavioral model of aNAND gate, shown  in Example 8.11, thatchanges the inertial  delay of a gate to zero. Any change on a orb will cause an update event for fto be scheduled pDelay time units in the future. A non-blocking assignment is necessary here because it allows the behavioral model to remain sensitive to its inputs; a change one time unit later will cause another update event on f. If a blocking assignment had been used, the behavioral model would be delaying and the input change one time unit later would have been missed until after the delay."
"Consider a behavioral model of a pipelined multiplier shown in Example 8.12. The latency for the multiplier is four clock periods and it can accept a new set of inputs each clock period. A positive edge on go is the signal to start a multiply. At that time, the inputs are multiplied together and product  is scheduled to be upd ated on the fourth positive edge of clock. Since this is a non-blocking assignment, the calculated product  is stored internally in the event list and the always can then wait for the next go signal which will start another, possibly overlapping, multiply. In this situation, go must be synchronous with respect to clock  because we  cannot have more than one multiply started for each clock edge. However, we can have one multiply started each clock period. The example further illustrates that the event list can be used to store multiple events for the same name and from the same assignment."
"An interesting contrast  between gate level timing models and procedural timing models is illustrated here. If an update is generated for the  output of an element using the Verilog gate level timing model, update events already scheduled in the event list for that element will be removed and the new update will be scheduled. This is not the case with elements using the procedural timing model. As we have seen in this example, multiple update events for product  are scheduled without changing any of the already scheduled up date events."
"C. As mentioned, the models are not equivalent. Briefly explain why the models are not equivalent. Change the bMux  model to make it equivalent to sMux  in function and timing by rewriting the al ways statement. Asp ects you may or may not want to consider: functionality only, input sensitivity, and/or timing with respect to inertial delay. Explain your changes."
"Verilog provides a set of 26 gate level primitives for modeling t he actual logic implementation of a digital system.  From these primitives, presented in Chapter 6, larger structural models may be  hierarchically described. This chapter presents  an advanced method for extending the set of gate level primitives to  include user-defined combinational, and leveland edge-sensitive sequential circuits."
"As shown in Example 9.1, user-defined primitives are defined in a manner similar to a truth table e numeration of a logic function. Primitives are defined at the same lexical level as modules, i.e. primitives are not defined within modules. This example describes a primitive for generating the carry out of a single-bit full adder. carry-"
"The user-defined primitives act the same as other gate primitives and continuous assign statements. When one of their inputs changes, then the new output is determined from the table and is propagated on the output. The input values in a row ofthe table must co rrespond exactly to the values of the input ports  for the row’s output value to be selected. If a set of inputs appears on the ports for  which there is no exact match, then the output will default to x. Any time delay to be associated with the primitive is specified when instances of the primitive are defined.  Because primitives cannot generate the value z, only two  delays (rising and  falling) can be specified per instance.User-Defined Primitives 241"
"As can be seen, the definition of a user-defined primitive follows closely the definition of a module. However, the keyword primitive introduces the definition and the keyword endprimitive closes it. Declarations within a primitive can only be inputs, outputs, an d registers (i.e. no inouts). udp_declaration primitive  udp_identifier ( udp_port_list); udp_port_declaration { udp_port_declaration } udp_body endprimitive primitive  udp_identifier (udp_declaration_port_list); udp_body endprimitive udp_port_list output_port_identifier, input_port_identifier {, input_port_identifier } udp_port_declaration udp_output_declaration udp_input_declaration udp_reg_declaration"
"Beyond this point,  the primitive definition departs greatly from that of a module definition. The  primitive has no internal instantiations, a ssign statements, or always statements. (However, sequential primitives may have initial statements.)  Rather, the primitive requires a table definition whose syntax is partially detailed below. udp_body combinational_body sequential_body combinational_body table combinational_entry { combinational_entry } endtable combinational_entry level_input_list: output_symbol; sequential_body [udp_initial_statement] table_sequential_entry {sequential_entry } endtable udp_initial_statement initial  output_port_identifier = init_val;242 The Verilog Hardware Description Language"
"The table enumeration allows for the specification of 1,0, and x values in its input and output sections. Further, it allows for the specification of a don’t care in the table meaning that any of the three logic values are to be substituted for it when evaluating the inputs. Consider the expanded definition of the carry primitive s hown in"
"Since they are sequential devices, they have internal state that must be modeled  with a register variable and  a state column must be added to the table specifying the behavior of the primitive. The  output of the device is driven  directly by the  register. The output field in the table in the primitive definition specifies the next state."
"The level-sensitive behavior of a latch is shown in Example 9.4. The latch output holds its value when the clock is one, and tracks the input when the clock is zero. Notable differences between combinational and sequential de vice specification are  the state specification (surrounded by colons), and a register specification for the output."
"To understand the behavior specifi cation, consider the first row. When theclock  is zero and the data is a one, then when the state is zero, one or x (as indicated by the ?), the output is one. Thus, no matter what the state is, the output (next state) depends only on the input. Line two makes a similar statement for having zero on the data input."
The table entries for modeling edgesensitive behavior are similar to those for level-sensitive  behavior except that a rising or falling edge must be specified on one of the inputs. It is illegal to specify more than one edge per line of the table. Example 9.5 illustrates the basic notation with the description of an  edge-triggered Dtype flip flop.
"Finally, we have the cases that reduce the pessimism of the example by specifying outputs for more situations. The first three lines include the full set of rising-edge cases, i.e. those clock  edges including x. Following these, the next four lines make further specifications on when a negative edge including x occurs on the clock . Finally, the specification for clock  having the value x is given. In all of these “pessimism reducing” cases, we have specified no change to the output."
"Case B is a level-sensitive situation and case D is an edge-sensitive situation, but they define conflicting next state values for the same input combinations. In these two cases, the j,k,p, and c inputs are the same. Case B states that when the clock  is one and the state is zero, then the next state is one. However, case D states that when there is a one to zero transition on the clock  and the state is zero, then the next state is zero. But for a falling edge to be on the clock  with the other inputs as given, the clock must just previously have been one and thus the  next state should have already changed to one, and not zero. In  all cases, the level-sensitive specification dominates and the next state  will be one. 9.5Summary"
"Designs at the logic level of abstraction, describe a digital circuit in terms of primitive logic functions such as OR, and NOR, etc., and allow for the nets interconnecting the logic functions to carry 0,1, x and z values. At the analog-transistor level of modeling, we use an electronic model of the circuit elements and allow for analog values of voltages or currents to represent logic values on the interconnections."
"The switch level of modeling provides a level of abstraction between the logic and analog-transistor levels of abstraction, describing the interconnection of transmission gates which are abstractions of individual MOS and CMOS transistors. The switch level transistors are modeled as being either on or off, conducting or not conducting. Further, the values carried by the interconnections are abstracted from the whole range of analog voltages or currents to a small number of discrete values. These values are referred to as signal  strengths. 10.1 A Dynamic MOS Shift Register Example"
"Three trireg nets, wa1, wa2, and wa3, are declared. Trireg nets are different from other types of nets in that they store a value when all gates driving the net have turned off. That is, a driver can drive  them (i.e. charge them) and then turn off. The value driven will remain on the trireg net even though it is no  longer being driven.  These nets are used in this example to model the dynamic storage of the shift register stages."
"Module waveShReg initializes shiftin,  phase1,  and phase2 to zero, prints a header line for the output table, and then sets up the monitoring of certai n nets  within instance cctof module shreg. Note that the nets within instance cct are referencedSwitch Level Modeling 255 with the hierarchical naming convention (e.g. “cct.wbl”). The clockcct  task is executed twice, evoking actions within the shift register. After two iterations of clockcct , the simulation is finished."
"The bufif1 gate is the read/write control for the circuit. In read mode, the bufif1 control line ( write ) is zero and its output is high impedance. When the cell is addressed, the value in the latch is connected to the output buffer g5. In write mode when the cell is addressed, the bufif1 gate drives w4through the tranif1 gate, possibly changing the latch’s state."
"At time 700, the write  line has been one for 100 time units, driving w1 and dataOut  to a one. Since the tranif1 gate is conducting, w1andw4 are connected. At this point, we have gate g4 (the NOT gate) and g1 (the bufif1 gate) both driving these connected lines. However, since g4 has been defined to have driving strength pull0 and pull1  in the zero and one states respectively, its drive strength is not as strong as the bufif gate which has the d efault  strong drive strengths. In this case, the  strong drive overwhelms the pull drive and w4 follows w1, and w3becomes the complement. w3 on the input to g4 then completes the changing of the ram cell value."
"There are four dr iving strengths and three charge storage strengths. The driving strengths are associated with gate and continuous assignment outputs, and the charge storage strengths are associated with the trireg net type.  The strengths may be associated with either a 1, 0, or x value. That is, a gate may drive a weak zero, a weak one, or a weak  x. The declaration abbreviation should be used with a zero or one (e.g. pull0) when gate instances and strengths are declared. The printed abbreviation column indicates how the  strength is printed when the %v format is used (see later examples)."
"Strengths associated with gate instances and assign statements are specified within parentheses as shown in the examples and in the following formal syntax: gate instantiation n_input_gatetype [drive_strength] [delay2] n_input_gate_instance { , n_input_ gate_instance } ; continuous_assign assign [drive_strength] [delay3] list_of_net_assignments ; |…260 The Verilog Hardware Description Language drive_strength (strength0 , strength1 ) (strength1, strength0) (strength0, highly ) ( strength1 , highz0) ( highz1,  strength0) ( highz0,  strength1 ) strength0 supply0 | strong0 | pull0 | weak0 strength1 supply1| strong1 | pull1 | weak1"
"When a trireg net is declared, a charge storage strength is  specified to  model the size of the capacitance exhibited by the net. However, charge stored in the net does not decay with time unless  a three-delay specification is given. The third delay  parameter specifies the time until the stored charge decays to an x  value. Trireg declarations are a form of net specifications as shown in the formal syntax: net_declaration trireg [charge_strength] [signed] [delay3] list_of_net_identifiers; trireg [charge_strength] [signed]  [delay3] list_of_net_decl_assignments; trireg [charge_strength ][ vectored | scalared  ] [signed] range [delay3] list_of_net_identifiers; trireg [charge_strength] [  vectored | scalared  ] [signed] range [delay3] list_of_net_dec1_assignments; charge strength (small)  |(medium) | (large)"
"Thus, address, dataIn ,write ,w1, and dataOut  are all strong-strength signals, whereas w3 is a pull strength. w4 is connected to g4 which is a pull-strength gate and to the tranif1 gate. Since it is connected to more than one gate output, we would have expected to see a range  of strengths driven on  it. Indeed this could be the case. However, it is not the tranif1 gate driving w4. Rather it is the bufif1 gate driving w4 through the tranif1.The MOS gates do not have their own drive strength. They merely 262 The Verilog Hardware Description Language propagate the values and strengths at their input (with a possible reduction in strength depending on gate type and strength input)."
"At time 500, we see net w1 listed as 56X, indicating that it is being driven by both a pull x and strong 1 driver. This indication arises because the bufif1 gate (strong) is driving an H (its control line is x) and the tranif1 gate is passing a pull-strength x from gate g4. The two combine to drive an x on w1. Since w1 and w4 are connected together through the tranif1 gate, they both have  the same indication."
"The MOS gates can  be modeled as either resistive or  nonresistive devices. Non resistive gates (nmos, pmos,  cmos, tran, tranif0, and tranif1) do not effect the signal strength from input to output (i.e. between bidirectional  terminals) except that a supply strength will be reduced to a strong strength. In addition,  pullup and pulldown gates drive their output with a pull strength. However, when the resistive model is used (rnmos, rpmos, rcmos, rtran, rtranif0, rtranif1), then a value passing through the  gate undergoes a reduction in drive strength as enumerated in Table 10.7"
"It is important to note that this version of the sram  does not work! The previous versions of the sram  changed the stored value because the strong output of the bufif1 gate overpowered the pull output of g4. But in this case, the rtranif1 gate reduces the strong output to a pull output which does not overpower the output of g4. Thus, g3 does not change its output and the latching mechanism comprised of g3 and g4 does not capture the new value. 10.3 Ambiguous Strengths"
"In this case, each output has an ambiguous strength, listed here as being both strong and pull. When these two outputs, one driving a one and the  other driving a zero, are combined on the net, the result is an x. All the bits between the values are set as shown in the result."
The above illustrations were meant to give an intuitive feel for the  operation of the simulator in the  presence of ambiguous strengths. In this section we present portions of the miniSim  example shown in full detail in Section 10.4. The miniSim  is a Verilog description of a very simple simulator that handles strengths. We will present only the portions of the Verilog description that do the strength calculations.
"Example 10.4 illustrates the log3 function which is called when a gate input is evaluated. The function converts the value inVal  specified with two strength bytes into a three-valued logic. In the de scription, the first strength byte is the zero byte and the second is the one byte. The first casez  expression says that if none of the strength bits are set, then the value is a x. The second expression states that if only some of the zero strength bits are one, the value is a zero. Next, if only some of the one strength bits are one, the value is a one. If none of the above conditions hold, the value is unknown."
"MiniSim is a description of a very simplified gate level simulator. Only three primitives have been  included:  a NAND  gate,  a D positive edge-triggered flip flop, and  a wire that handles the fullstrength algebra that is used in Verilog. All primitive timing is unit delay, and a record is kept of the stimulus pattern number and simulation time within each pattern. Each primitive is limited to two inputs and one output that has a maximum fanout of two."
The exercises at the end of the previous chapters have been short  questions to help you think about the material in the  chapter. This chapter contains two projects that each encompass many aspects of the Verilog language. Each of these projects has been used in Junior level university classes for electrical and computer engineering students.
"The projects are all open-ended; there is no one correct answer. Instructors should realize that the projects were aimed at a set of  students with a certain course background that may not match the background of their current students. Further, the projects were tailored to the specific material being presented in class at the time."
"The adds are organized like a balanced tree and the operations occur in a single clock period of (essentially implementing a = ((b + c) + (d + e)). i.e., b and c are added together at the same time d and e are added together. Then the sums are added producing a."
"And yet another ve rsion that takes two clock periods, each of time to implement the balanced tree. That is, during the first clock period, b and c are added and stored in a register. Also during that first clock period, d and e are added and put into a separate register. During the second clock period, these two registers are added."
"B. Build the different circuits suggested above. Instantiate an d connect the 16bit adder modules  built in part A to do this. Ignore the carryout from the most significant bit. For  each circuit, build a testbench module that will present input vectors to your circuit. Use a random number generator (see to generate 2000 different input sets. (An input set includes different numbers for b, c, d, and e.) Check a few to see if your circuits really do add the numbers correctly!"
"C.Now that you have things working correctly, change the fulladder module to use a new  type  ofNAND  gate called  “my NAND ” (or similar). Write  a behavioral model  for my NAND that  can be  directly substituted  for the  original NANDS . That is, anytime any of the inputs change, the behavioral model should execute, determine if a zero-to-one output transition will occur, and then update a global counter indicating that the transition occurred. Of course, it should schedule its output to change after a gate delay of time. The global counter is a register in the top module of the simulation which you will initialize to zero when simulation starts. Anytime a zero-to-one transition occurs in any instantiated gate in the system, this counter will be updated. Use hierarchical naming to get access to it."
"D. Change the delays of the my NAND  module to be proportional to the number of fanouts.  Let’s  say delay will just equal fanout. Define  a parameter  in myNAND that initializes  the delay  to 1.  When  you  instantiate  myNAND , override  the parameter with a count of the gate’s fanout. (Be as accurate as you can.) Also change the model so  that the global counter is incremented by the delay number. Thus a gate with large fanout will take more power every  time it changes from zero to one, and it will also take more time to  propagate the change."
"In this project, each two-person team will use Verilog to create a model of part of a floppy disk controller. A floppy disk controller takes a stream of data bits  mingled with a clock signal, decodes the stream to separate the clock and data, and computes the Cyclic Redundancy Checksum ( CRC) of the data to ensure that no errors have occurred. Once the data is found to be correct, it is placed in a FIFO, and from there it is placed into main memory via direct memory access ( DMA). Your Verilog model will take the stream of data bits from the disk as input, and will negotiate with the memory bus as output."
The other  output  from  the disk media  isRDDATA .RDDATA  is the stream  of data bits mingled  with  the clock  signal. Module DECODE  extracts  the data  from  the clock  signal and presents both  to module Series-to-parallel (SerPar). Module SerPar then c ollects the bits into bytes and interprets them as per the sector fo rmat.
"SerPar : SerPar takes as its input IDX, the sector index signal from the disk media; the clock and data signals from Decode; and the sector number and go signals from the simulation interface. On the positive edge of go, SerPar resets the CRC, and begins counting IDX pulses until the proper sector is found. Once the proper sector is found,"
"SerPar begins monitoring the data line from Decode for the sync byte. SerPar then transfers the data a bit at a time to CRC, and a byte at a time to FIFO. When it has received all the data from the sector it compares the 16-bit checksum stored after the data in the sector to the one that has just been computed by CRC for the data. If the two checksums are the same, then SerPar raises the done signal for the simulation interface. If the two checksums are different, then SerPar raises the err signal for the simulation interface. Projects 289"
"FIFO: FIFO is a 16-byte  First  In, First  Out queue.  It serves  as a buffer  for the  data between SerPar, and DMA and memory. Once it receives a byte from SerPar, FIFO should signal to DMA that a transaction is necessary. When DMA has gained access to main memory, FIFO will transfer its contents to memory via DMA."
"RDDATA  is high.  If it is, I have  a 1. If  not, I have  a 0.”  If you write  a simulation where the clock comes along every and the data is  exactly between the clock pulses, the simulation works, and you’re happy. But real  disk drives depend on motors  and magnetic media, so  sometimes the clock c omes along at and  sometimes it comes along at with the data at"
Disk drive controllers use something called a ph ase-locked loop (PLL) to latch onto the frequency of the clock and to adjust to its variations as the motor changes speed and the bits jitter around. You need to come up with a way to find the data in between the clock pulses without depending on  the clock pulses being exactly apart. The
"The CRC computation uses a shift register and XOR gates. Unlike a normal shift register, some of the stages shift in the previous bit XOR’d with the bit being shifted out of the shift register. The bits from the data stream are shifted in from the l eft. Numbering the bits from 1 on the left to 16 on the right, the input to the first, sixth, and thirteenth bits of the register are XOR’d with the output of the sixteenth bit."
"The shift register is initialized to zero. After the entire data stream has been read in, the content of the shift register is the checksum for the sector. It is compared bitby-bit with the  checksum stored with the sector on the disk. If the two checksums match, then it is unlikely that a bit error has occurred, and the controller can transfer the data to memory. If the checksums do not match, then some bit(s) of data must have been corrupted. The controller should then signal that an error has occurred."
There are several Verilog modules providing  the stream of data and clock coming from the disk. Some  modules will have correct data and some erroneous data; the file names  are “correct x.v” and “error x.v.” The memory  and bus  controller modules  are provided in “memory.v.” The module declarations for these files are shown in
"Some of the questions assume  that the  reader has access to a Verilog simulator — the one included on the book’s CD will suffice. A few of the questions assume access to a synthesis tool; limited access to one is available through the CD. Finally, the book’s CD includes copies of th e books examples; retrieve them from there to avoid retyping."
"Thus, identifiers d,e, and fare all defaulted to be of type wire. a,b, and c are not declared and will thus cause errors. Why is the output of a primitive gate  defaulted to be a wire? Real combinational logic gates are connected to wires. In the Verilog language, new values are either driven on nets (wires are the default type of net) or loaded into re gisters. Primitive gates al ways drive wires."
"But, this description w ouldn’t do much except parse correctly. The goal is to simulate the design and convince yourself that the specification performs the logic function that you expect. Now we need to specify a set of inputs (called test vectors) so that we can simulate the circuit  and observe its output."
"Discussion: To use the registers that we put in the description for the gate inputs, we need to write an initial block — registers can only be loaded by assignment statements in initial and al ways blocks. We’ll use an in itial block since these are often used to provide test vector inputs."
"Discussion:   There are two errors here. One error is there  is no means of displaying the output when the inputs change. Let’s add a statement to display the data to the screen whenever any value changes. Additionally, we will have the simulation time reported. In our case we will use the statement:             ""a=%b, b=%b, c=%b, d=%b, e=%b, f =%b"", a, b, c, d, e, f);"
"The monitor statement is not just a print statement. It will cause a printing of the quoted string when executed but then it will continue to monitor for changes on any of the input identifiers ( a,b,c,d,e, and fhere), printing the quoted string when any one changes. Only one of these statements can be ac tive at the same time.  If one is reached while another is active, the new one cancels the old."
"The problem is that the inputs change again before the logic values have time to propagate to the  output. The delay we include in the description needs to be longer than the longest delay through the gates. In  this case, se tting it to six would work since the longest path from inputs to outputs is five. You could also set it  to #3072 with no change in the results."
"The module system  is the top level of our design — it has no inputs or outputs and the other modules are instantiated within it. When the modules are instantiated, instance names are given to each: halfadder is named AddUnit, and testadder is named TestUnit . In effect, we have wired up a half adder module to a module that creates inputs for the half adder. O utputs from the half adder are monitored by the test module."
"Do not think of this as executing the halfadder , then executing the testadder —  these are not function calls. Rather, these define that an instance of each of  these modules is to be connected together using wires as shown. Reversing the order of the two statements has no effect."
"Do This — Run the simulator on this file. The simulator should display all the inputs and outputs, with the simulation time.  Reason your way through the execution of these modules. Note that the testadder  module will set x and y to certain values and then wait 10 time units. During that time, the XOR and AND gates in the halfadder module will execute and change their outputs. And then the testadder  module will continue to  execute."
"But we can break that rule. Here is a correct always block for the above pr oblem with out an else. The trick is that  the statement assigning f to zero creates a default value for f, the rest of the description can then concentrate on when to set it to 1. always @(a, b, c) begin f = 0; if (c + (a&~b)) f = l; end"
"Missing Input Sensitivity      —This is generally a simple matter that something was left out. A fundamental characteristic of  combinational circuits is that they are al ways sensitive to all of their inputs. That is, a change on any input could cause a change on the output. Thus,  the event statement (“ @”) in the always block has to include all of the combinational inputs. The expression in  the parentheses of  the event statement is called th e sensitivity list. The following is how  not to write the sensitivity list."
"This will have the effect of not updating the output when b changes, leaving it wherever it was until either a orc change. The simulation will give bad results. A synthesis tool will not think of this as a combinational circuit. It will think: anytime b changes, the circuit has to remember the previous before b changed. This requires memory in the circuit. Combinational circuits do not have memory; their outputs are a function only of the current inputs.305"
"The spacing of tokens is free format — the specific choice of tabs, spaces, or newlines to separate lexical tokens is not important to the compiler. However, th e choice is important for giving a readable structure to the description. It is important that you develop a consistent style of writing your Verilog descriptions. We offer the examples in the book as a starting point to develop your own personal style."
"A string is a sequence of characters enclosed by double quotes. It must be contained on a single line. Special characters may be specified in a string using the “\” escape character as follows:312 The Verilog Hardware Description Language \n new line character. Typically the  return key. \t tab character. Equivalent to typing the tab key. \\ is the \ character. \"" is the "" character \ddd is an ASCII character specified in one to three octal digits."
"Identifiers are names that are given to elements such as modules, registers,  ports, wires, instances, and  begin-end blocks. An identifier is any sequence of letters, digits, and the underscore (_) symbol except that: the first character must not be a digit, and the identifier must be 1024 characters or less."
"Assign one of twovalues based on expressionIf the left operand is signed, the vacated bit positins will be filled  with copies of the sign bit. Otherwise it will fill with zeros. condExpr ? trueExpr : falseExpr. If condExpr is TRUE, the trueExpr is the result of the operator. If condExpr is"
"If all of the operands of an expression are signed, then signed operations are performed. If any operand is not signed, then unsigned operations are used. The and operations above is used, for instance, to change an unsigned operand into a signed one so that an expression can be calculated in  a signed manner.320 The Verilog Hardware Description Language"
"The operator precedences are shown below. The top of the table is the highest precedence, and the bottom is the lowest. Operators listed on the same line have the same precedence. All operators associate left to right in an expression (except ?:). Parentheses can be used to  change the precedence or clarify the situation. When in doubt, use parentheses. They are easier to read, and reread!"
These gates model NMOS and PMOS transistors. The “r” versions model NMOS and PMOS transistors with significantly higher resistivity when conducting. The resistive forms reduce the driving strength from input to output. The nonresistive forms only reduce the supply strength to a strong strength. See Table 10.7. Drive strengths may not be  specified for these gates.
"CMOS gates represent the typical situation where nmos and pmos transistors are paired together to form a transmission gate. The first terminal is the  data output, the second is the data input, the third is the n-channel c ontrol, and the last is the p-channel control. The cmos  gate is a relatively low  impedance device. Th e rcmos version has a higher impedance when c onducting."
"Registers are used to model hardware. Sometimes though, it is useful to perform calculations for simulation purposes. For example, we may want to turn  off monitoring after a certain time has passed. If we use registers fo r this purpose, the operations on them may be confused with actions of the actual hardware.  Integer and  time  variables provide a means of describing calculations pertinent to the simulation. They are provided for c onvenience and make the description more self documenting.332 The Verilog Hardware Description Language"
The command is used to print information whenever there is a  change in one or more specified values. The monitor prints at the end of the current time so that all changes at the current time will be reflected by the pr intout. The parameters for the task are the same as for the task.
"Whenever the task is called, it will print the values and set up the simulator to print them anytime one of the parameters changes. Only one display list may be active at a time. If time is being pr inted as in the following statement, a change in simulation time will not trigger the to pr int.335 ( ""regA = "", regA);"
"The general syntax for the task call is: (“filename”,  <memname>,  <<start_addr>  <,<finish_addr>>?>?); where: x is “b” or “h” <memname> specifies the Verilog identifier of the memory to be loaded. <start_addr> optionally specifies the starting a ddress of the data. If none is specified, the left-hand a ddress given in the memory declaration is used. If the <finish_addr> is specified, loading begins at the <start_addr> and c ontinues to the <finish_addr>. Also see below for an alternate specification of the starting  address. <finish_addr> is the last address to be written into."
Addresses can be specified within the file as well. The construct “@hhh…h” within the file specifies the  hexadecimal address to use as the starting address. Subsequent data is loaded starting at that memory address. Note that the “h” specifies hexadecimal digits only. There is no length or base format specified. There may be several address specifications allowing several sub-blocks of memory to be lo aded while the rest remains untouched.
"As a key, the construct before the is the item to be de fined. The line with the starts the definition of the construct (later we will see that “|” indicates an alternate definition). Any other items in regular text are constructs that are defined elsewhere. Finally, bold text indicates literal text — text like “module” or “;” that will appear directly in the description. Typically, these are keywords an d language punctuation. Some items are listed with the first part being italic and the rest being regular text. The italic part adds extra semantic information to the regular text item. The item to be used is found under the definition of the re gular text item."
"Now let’s consider the ports. Above we see that a module has an optional list_of_ports. Below we see that a list_of_ports is one or more comma-separated ports listed within parentheses. Thus if there are no ports to the module (after all, they’re optional), then nothing is specified — not even a null “()”. However, if there is at least one port, then  parentheses are used to contain the lis t of comma-separated ports. list_of_ports (port {,port})"
"A port is an optional port_expression which in turn is either a port_reference or a concatenation of port_references. A port_reference is either a port_identifier (which is actually an identifier), a bit-select of a port_identifier (the second alternative in the list), or a part-select of  port_identifier (the third alternative). The items in the bitand part-selects are  constants indicating which bits are to be used. The selects are enclosed in literal square brackets and the constants of  a part-select are separated by a literal colon. port [ port_expression ] port_expression port_reference |      {port_reference {, port reference} } port_reference port_identifier | port_identifier [ constant_expression ] | port_identifier [ range_expression ]"
"Going further with the module definition, we see that it also includes zero, one, or more module_items. One item is the module_or_generate_item which is itself a long list of alternatives — some of which we see in Example G.1. For instance, the Example contains gate instantiations, initial constructs, and always constructs. We also see other familiar items — gate and module instantiations, and  continuous assignments. module_item module_or_generate_item |port_declaration |generated_instantiation |local_parameter_declaration | parameter_declaration 343 module_or_generate_item module_or_generate_item_declaration | continuous_assignment | gate_instantiation | initial_construct | always_construct"
"G.2.4 Module parameters and ports module_parameter_port_list ::= # (parameter_declaration { , parameter_declaration} ) list_of_port s ::= ( port {,  port}) list_of_port_declarations ::= (port_declaration { , port_declaration }  ) |() port ::= [ port_expression ] |   port_identifier ([ port_expression ] ) port_expression ::= port_reference | { port_reference { , port_reference } } port_reference ::= port_identifier | port_identifier [ constant_expression  ] | port_identifier [ range_expression ] port_declaration ::= {attribute_instance} inout_declaration"
G.2.5  Module items module_item ::= module_or_generate_item | port_declaration ; | { attribute_instance  } generated_instantiation | { attribute_instance  } local_parameter_declaration | { attribute_instance } parameter_declaration | { attribute_instance } specify_block | { attribute_instance } specparam_declaration module_or_generate_item ::= { attribute_instance } module_or_generate_item_declaration | { attribute_instance } parameter_override | { attribute_instance } continuous_assign| { attribute_instance  } gate_instantiation | { attribute_instance } udp_instantiation | { attribute_instance } module_instantiation | { attribute_ins tance } initial_construct | { attribute_instance } always_construct module_or_generate_item_declaration ::= net_declaration | reg_declaration | integer_declaration | real_declaration | time_declaration | realtime_declaration | event_declaration | genvar_declaration | task_declaration | function_declaration on_port_module_item ::= {attribute_instance } generated_instantiation | { attribute_instance } local_parameter_declaration | {attribute_instance } module_or_generate_item | {attribute_instance  } parameter_declaration | { attribute_instance } specify_block | { attribute_instance  } specparam_declaration
"G.3.2  Declaration lists list_of_event_identifiers ::=  event_identifier [ dimension { dimension }] {, event_identifier [ dimension { dimension }] } list_of_genvar_identifiers ::=  genvar_identifier { , genvar_identifier } list_of_net_decl_assignments ::= net_decl_assignment { , net_decl_assignment} list_of_net_identifiers ::= net_identifier [ dimension { dimension }] {, net_identifier [ dimension { dimension }]} list_of_param_assignments ::=param_assignment { , param_assignment} list_of_port_identifiers ::= port_identifier { , port_identifier} list_of_real_identifiers ::= real_type { , real_type } list_of_specparam_assignments ::=specparam_assignment { , specparam_assignment } list_of_variable_identifiers ::= variable_type { ,variable_type } list_of_variable_port_identifiers ::= port_identifier [ = constant_expression ]"
"G.3.5 Function declarations function_declaration ::= function  [automatic  ] [signed  ] [ range_or_type ] function_identifier ; function_item_declaration { function_item_declaration } function_statement endfunction |function  [automatic  ] [signed  ] [ range_or_typ e ] function_identifier ( function_port_list )  ; block_item_declaration { block_item_declaration } function_statement endfunction function_item_declaration ::= block_item_declaration | tf_input_declaration ; function_port_list ::= { attribute_instance } tf_input_declaration { , { attribute_instance } tf_input_declaration } range_or_type ::= range | integer  |real |realtime  |time"
"G.3.6 Task declarations task_declaration ::= task [ automatic  ] task_identifier ; { task_item_declaration } statement endtask | task [ automatic  ] task_identifier ( task_port_list ) ; { block_item_declaration } statement endtask task_item_declaration ::= block_item_declaration | { attribute_instance } tf_input_declaration ; | { attribute_instance } tf_output_declaration ; | { attribute_instance  } tf_inout_declaration ; task_port_list ::= task_port_item { , task_port_item } task_port_item ::= { attribute_instance } tf_input_declaration | { attribute_instance  } tf_output_declaration | { attribute_instance } tf_inout_declaration tf_input_declaration ::= input [ reg] [ signed  ] [ range ] list_of_port_identifiers | input  [ task_port_type  ] list_of_port_identifiers tf_output_declaration ::= output [ reg] [ signed  ] [ range ] list_of_port_identifiers | output  [ task_port_typ e ] list_of_port_identifiers tf_inout_declaration ::= inout [ reg] [ signed  ] [ range  ] list_of_port_identifiers | inout [  task_port_type ] list_of_port_identifiers task_port_type ::= time | real | realtime | integer"
"G.4.1 Primitive instantiation and instances gate_instantiation ::= cmos_switchtype [delay3] cmos_switch_instance { , cmos_switch_instance } ; | enable_gatetype [drive_strength] [delay3] enable_gate_instance { , enable_gate_instance } ; | mos_switchtype  [delay3] mos_switch_instance { , mos_switch_instance } ; | n_input_gatetype [drive_strength] [delay2] n_input_gate_instance { , n_input_gate_instance } ; | n_output_gatetype [drive_strength] [delay2] n_output_gate_instance { , n_output_gate_instance } ; | pass_en_switchtype [delay2] pass_enable_switch_instance { , pass_enable_switch_instance } ; | pass_switchtype pass_switch_instance { , pass_switch_instance } ; |pulldown  [pulldown_strength] pull_gate_instance { , pull_gate_instance } ; |pullup  [pullup_strength] pull_gate_instance { , pull_gate_instance } ; cmos_switch_instance ::= [ name_of_gate_instance ] ( output_terminal , input_terminal , ncontrol_terminal , pcontrol_terminal ) enable_gate_instance ::= [ name_of_gate_instance ] ( output_terminal , input_terminal , enable_terminal ) mos_switch_instance ::= [ name_of_gate_instance ] ( output_terminal , input_terminal"
G.4.4  Primitive gate and switch types cmos_switchtype ::=  cmos | rcmos enable_gatetype ::=  bufif0 | bufif1 | notif0 | notif1 mos_switchtype ::=  nmos | pmos | rnmos | rpmos n_input_gatetype ::=  and | nand | or| nor | xor| xnor n_output_gatetype ::=  buf| not pass_en_switchtype ::=  tranif0 | tranif1 | rtranif1 | rtranif0 pass_switchtype ::=  tran | rtran
"G.5.1 Module instantiation module_instantiation ::= module_identifier [ parameter_value_assignment ] module_instance { , module_instance } ; parameter_value_assignment ::= # ( list_of_parameter_assignments ) list_of_parameter_assignments ::= ordered_parameter_assignment { , ordered_parameter_assignment } | named_parameter_assignment { , named_parameter_assignment } ordered_parameter_assignment ::=  expression named_parameter_assignment ::= parameter_identifier ( [ expression ] ) module_instance ::= name_of_instance ( [ list_of_port_connections ] ) name_of_instance ::= module_instance_identifier [ range ] list_of_port_connections ::= ordered_port_connection { , ordered_port_connection } | named_port_connection { ,named_port_connection } ordered_port_connection ::= { attribute_instance  } [ expression ] named_port_connection ::= { attribute_instance } .port_identifier ( [ expression ] )"
G.7.2 Procedural blocks and assignments initial_construct ::=  initial  statement always_construct ::=  always  statement blocking_assignment ::= variable_lvalue = [ delay_or_event_control ] expression nonblocking_assigmnent ::=variable_lvalue<= [ delay_or_event_control ] expression procedural_continuous_assignments ::= assign  variable_assignment | deassign  variable_lvalue | force  variable_assignment | force  net_assignment | release  variable_lvalue | release  net_lvalue function_blocking_assignment ::= variable_lvalue = expression function_statement_or_null ::= function_statement | { attribute_instance } ;
G.7.5 Timing control statements delay_control ::= # delay_value | #( mintypmax_expression ) delay_or_event_control ::= delay_control | event_control | repeat ( expression ) event_control disable_statement ::= disable  hierarchical_task_identifier ; | disable  hierarchical_block_identifier ; event_control ::= @ event_identifier | @( event_expression ) | @* | @  (*) event_trigger ::= -> hierarchical_event_identifier ; event_expression ::= expression | hierarchical_identifier | posedge  expression | negedge  expression
G.7.6  Conditional statements conditional_statement ::= if ( expression ) statement_or_null [  else statement_or_null ] | if_else_if_statement if_else_if_statement ::= if ( expression ) statement_or_null { else if (  expression ) statement_or_null } [ else  statement_or_null ] function_conditional_statement ::= if ( expression ) function_statement_or_null [ else function_statement_or_null ] |  function_if_else_if_statement function_if_else_if_statement ::= if ( expression ) function_statement_or_null { else if (  expression ) function_statement_or_null} [ else function_statement_or_null ]
"G.7.7 Case statements case_statement ::= case ( expression ) case_item { case_item }  endcase | casez ( expression ) case_item { case_item }  endcase | casex (  expression ) case_item { case_item }  endcase case_item ::= expression { , expression } : statement_or_null | default  [: ] statement_or_null function_case_statement ::= case (  expression ) function_case_item { function_case_item }  endcase | casez (  expression )"
G.7.8 Looping statements function_loop_statement ::= forever  function_statement | repeat ( expression ) function_statement | while ( expression ) function_statement | for ( variable_assignment ; expression ; variable_assignment ) function_statement loop_statement ::= forever  statement | repeat (  expression ) statement | while ( expression ) statement | for (  variable_assignment ; expression ; variable_assignment ) statement
"G.8.2 Specify path declarations path_declaration ::= simple_path_declaration ; | edge_sensitive_path_declaration ; | state_dependent_path_declaration ; simple_path_declaration ::= parallel_path_description = path_delay_value | full_path_description = path_delay_value parallel_path_description ::= ( specify_input_terminal_descriptor [ polarity_operator ] => specify_output_terminal_descriptor ) full_path_description ::= ( list_of_path_inputs [ polarity_operator ] *> list_of_path_outputs ) list_of_path_inputs ::= specify_input_terminal_descriptor { , specify_input_terminal_descriptor } list_of_path_outputs ::= specify_output_terminal_descriptor { , specify_output_terminal_descriptor }"
"G.9.1  Concatenations concatenation ::= { expression {, expression } } constant_concatenation ::= { constant_expression { , constant_expression } } constant_multiple_concatenation ::= { constant_expression  constant_concatenation } module_path_concatenation ::= {module_path_expression { , module_path_expression} } module_path_multiple_concatenation ::= { constant_expression module_path_concatenation } multiple_concatenation ::= {constant_expression concatenation } net_concatenation ::= {net_concatenation_value { , net_concatenation_value } } net_concatenation_value ::= hierarchical_net_identifier | hierarchical_net_identifier [ expression ] { [ expression ] } | hierarchical_net_identifier [ expression ] { [ expression ] } [ range_expression ] | hierarchical_net_identifier [ range_expression ] | net_concatenation variable_concatenation ::= { variable_concatenation_value { , variable_concatenation_value } } variable_concatenation_value ::= hierarchical_variable_identifier | hierarchical_variable_identifier [ expression ] { [ expression ] } | hierarchical_variable_identifier [ expression ] { [ expression ] }[ range_expression ] | hierarchical_variable_identifier [ range_expression ] | variable_concatenation"
G.9.3  Expressions base_expression ::=  expression conditional_expression ::= expressionl ? { attribute_instance } expression2 : expression3 constant_base_expression ::= constant_expression constant_expression ::= constant_primary | unary_operator { attribute_instance } constant_primary | constant_expression binary_operator { attribute_instance } constant_expression | constant_expression ? { attribute_instance  } constant_expression : constant_expression | string constant_mintypmax_expression ::= constant_expression | constant_expression : constant_expression : constant_expression constant_range_expression ::= constant_expression | msb_constant_expression : 1sb_constant_expression | constant_base_expression +: width_constant_expression | constant_base_expression -: width_constant_expression dimension_constant_expression ::= constant_expressionexpression1 ::= expressionexpression2 ::= expression expression3 ::=  expression expression ::= primary | unary_operator { attribute_instance } primary | expression binary_operator { attribute_instance } expression | conditional_expression | string
G.9.5   Expression left-side values net_1value ::= hierarchical_net_identifier | hierarchical_net_identifier [ constant_expression ] { [ constant_expression ] } |hierarchical_net_identifier [constant_expression ] {[ constant_expression  ]} [ constant_range_expression ] | hierarchical_net_identifier [ constant_range_expression ] | net_concatenation variable_1value ::= hierarchical_variable_identifier | hierarchical_variable_identifier [ expression ] { [ expression ] } | hierarchical_variable_identifier [ expression ] { [ expression ] } [ range_expression ] | hierarchical_variable_identifier [ range_expression ] | variable_concatenation
G.9.6  Operators unary_operator ::= + | |! |~ | & |~& ||| ~| | ^ |~^ |^~ binary_operator ::= + | -|* | /|% | == |!= | ===  |!== |&& | || |** | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> |  <<< unary_module_path_operator ::= !|~ |& |~& | | |~| | ^ |~^ | ^~ binary_module_path_operator ::=
"New York, NY 10020. Copyright © 2014 by The McGraw-Hill Companies, Inc. All rights reserved. No part of this publication may be reproduced or distributed in any form or by any means, or stored in a database or retrieval system, without the prior written consent of The McGraw-Hill Companies, Inc., including, but not limited to, in any network or other electronic storage or transmission, or broadcast for distance learning."
"Stephen Brown received his B.A.Sc. degree in Electrical Engineering from the University of New Brunswick, Canada, and the M.A.Sc. and Ph.D. degrees in Electrical Engineering from the University of Toronto. He joined the University of Toronto faculty in 1992, wherehe is now a Professor in the Department of Electrical & Computer Engineering. He is alsothe Director of the worldwide University Program at Altera Corporation."
"He is a coauthor of four other books: Computer Organization and Embedded Systems, 6th ed.; Fundamentals of Digital Logic with VHDL Design, 3rd ed.; Microcomputer Structures; and Field-Programmable Gate Arrays. In 1990, he received the Wighton Fellowship for “innovative and distinctive contributions to undergraduate laboratory instruction.” In2004, he received the Faculty Teaching Award from the Faculty of Applied Science andEngineering at the University of Toronto."
"This book is intended for an introductory course in digital logic design, which is a basic course in most electrical and computer engineering programs. A successful designer of digital logic circuits needs a good understanding of basic concepts and a ﬁrm grasp of themodern design approach that relies on computer-aided design (CAD) tools."
"The main goals of the book are (1) to teach students the fundamental concepts in classical manual digital design and (2) illustrate clearly the way in which digital circuitsare designed today, using CAD tools. Even though modern designers no longer use manualtechniques, except in rare circumstances, our motivation for teaching such techniques isto give students an intuitive feeling for how digital circuits operate. Also, the manualtechniques provide an illustration of the types of manipulations performed by CAD tools,giving students an appreciation of the beneﬁts provided by design automation. Throughoutthe book, basic concepts are introduced by way of examples that involve simple circuitdesigns, which we perform using both manual techniques and modern CAD-tool-basedmethods. Having established the basic concepts, more complex examples are then provided,using the CAD tools. Thus our emphasis is on modern design methodology to illustratehow digital design is carried out in practice today."
"The book discusses modern digital circuit implementation technologies. The emphasis is on programmable logic devices (PLDs), which is the most appropriate technology for use in atextbook for two reasons. First, PLDs are widely used in practice and are suitable for almostall types of digital circuit designs. In fact, students are more likely to be involved in PLD-based designs at some point in their careers than in any other technology. Second, circuitsare implemented in PLDs by end-user programming. Therefore, students can be providedwith an opportunity, in a laboratory setting, to implement the book’s design examples inactual chips. Students can also simulate the behavior of their designed circuits on their owncomputers. We use the two most popular types of PLDs for targeting of designs: complexprogrammable logic devices (CPLDs) and ﬁeld-programmable gate arrays (FPGAs)."
"Chapter 2 introduces the logic circuits. It shows how Boolean algebra is used to represent such circuits. It introduces the concepts of logic circuit synthesis and optimization,and shows how logic gates are used to implement simple circuits. It also gives the readera ﬁrst glimpse at Verilog, as an example of a hardware description language that may beused to specify the logic circuits."
Chapter 7 is a discussion of a number of practical issues that arise in the design of real systems. It highlights problems often encountered in practice and indicates how they canbe overcome. Examples of larger circuits illustrate a hierarchical approach in designingdigital systems. Complete Verilog code for these circuits is presented.
"Asynchronous sequential circuits are discussed in Chapter 9. While this treatment is not exhaustive, it provides a good indication of the main characteristics of such circuits.Even though the asynchronous circuits are not used extensively in practice, they providean excellent vehicle for gaining a deeper understanding of the operation of digital circuitsin general. They illustrate the consequences of propagation delays and race conditions thatmay be inherent in the structure of a circuit."
"Much of the material in the book can be covered in 2 one-quarter courses. A good coverageof the most important material can be achieved in a single one-semester, or even a one-quarter course. This is possible only if the instructor does not spend too much time teachingthe intricacies of Verilog and CAD tools. To make this approach possible, we organizedthe Verilog material in a modular style that is conducive to self-study. Our experience inteaching different classes of students at the University of Toronto shows that the instructormay spend only three to four lecture hours on Verilog, describing how the code should bestructured, including the use of design hierarchy, using scalar and vector variables, and onthe style of code needed to specify sequential circuits. The Verilog examples given in thebook are largely self-explanatory, and students can understand them easily."
"Verilog is a complex language, which some instructors feel is too hard for beginning students to grasp. We fully appreciate this issue and have attempted to solve it. It is not necessary to introduce the entire Verilog language. In the book we present the important Verilogconstructs that are useful for the design and synthesis of logic circuits. Many other languageconstructs, such as those that have meaning only when using the language for simulationpurposes, are omitted. The Verilog material is introduced gradually, with more advancedfeatures being presented only at points where their use can be demonstrated in the designof relevant circuits."
"To gain proper appreciation of the design process, it is highly beneﬁcial to implement the designs using commercially-available CAD tools. Some excellent CAD tools are availablefree of charge. For example, the Altera Corporation has its Quartus II CAD software, whichis widely used for implementing designs in programmable logic devices such as FPGAs."
"We wish to express our thanks to the people who have helped during the preparation of the book. Dan Vranesic produced a substantial amount of artwork. He and DeshanandSingh also helped with the preparation of the solutions manual. Tom Czajkowski helpedin checking the answers to some problems. The reviewers, William Barnes, New JerseyInstitute of Technology; Thomas Bradicich, North Carolina State University; James Clark,McGill University; Stephen DeWeerth, Georgia Institute of Technology; Sander Eller, CalPoly Pomona; Clay Gloster, Jr., North Carolina State University (Raleigh); Carl Hamacher,Queen’s University; Vincent Heuring, University of Colorado; Yu Hen Hu, University of"
"Wisconsin; Wei-Ming Lin, University of Texas (San Antonio); Wayne Loucks, University of Waterloo; Kartik Mohanram, Rice University; Jane Morehead, Mississippi StateUniversity; Chris Myers, University of Utah; V ojin Oklobdzija, University of California(Davis); James Palmer, Rochester Institute of Technology; Gandhi Puvvada, University ofSouthern California; Teodoro Robles, Milwaukee School of Engineering; Tatyana Roziner,Boston University; Rob Rutenbar, Carnegie Mellon University; Eric Schwartz, Universityof Florida; Wen-Tsong Shiue, Oregon State University; Peter Simko, Miami University;Scott Smith, University of Missouri (Rolla); Arun Somani, Iowa State University; BernardSvihel, University of Texas (Arlington); and Zeljko Zilic, McGill University provided con-structive criticism and made numerous suggestions for improvements."
"This book is about logic circuits—the circuits from which computers are built. Proper understanding of logic circuits is vital for today’s electrical and computer engineers. These circuits are the key ingredient of computers and are also used in many other applications. They are found in commonly-used products likemusic and video players, electronic games, digital watches, cameras, televisions, printers, and many householdappliances, as well as in large systems, such as telephone networks, Internet equipment, television broadcastequipment, industrial control units, and medical instruments. In short, logic circuits are an important part ofalmost all modern products."
"The material in this book will introduce the reader to the many issues involved in the design of logic circuits. It explains the key ideas with simple examples and shows how complex circuits can be derivedfrom elementary ones. We cover the classical theory used in the design of logic circuits because it providesthe reader with an intuitive understanding of the nature of such circuits. But, throughout the book, wealso illustrate the modern way of designing logic circuits using sophisticated computer aided design (CAD) software tools. The CAD methodology adopted in the book is based on the industry-standard design languagecalled the Verilog hardware description language. Design with Verilog is ﬁrst introduced in Chapter 2, and usage of Verilog and CAD tools is an integral part of each chapter in the book."
"Logic circuits are implemented electronically, using transistors on an integrated circuit chip. Commonly available chips that use modern technology may contain more than a billion transistors, as in the case of somecomputer processors. The basic building blocks for such circuits are easy to understand, but there is nothingsimple about a circuit that contains billions of transistors. The complexity that comes with large circuits canbe handled successfully only by using highly-organized design techniques. We introduce these techniques inthis chapter, but ﬁrst we brieﬂy describe the hardware technology used to build logic circuits. 1.1 Digital Hardware"
"About 30 years ago Gordon Moore, chairman of Intel Corporation, observed that integrated circuit technology was progressing at an astounding rate, approximately doubling the number of transistors that could be placed on a chip every two years. This phenomenon,informally known as Moore’ s law, continues to the present day. Thus in the early 1990s microprocessors could be manufactured with a few million transistors, and by the late 1990sit became possible to fabricate chips that had tens of millions of transistors. Presently, chipscan be manufactured containing billions of transistors."
"Figure 1.2 An estimate of the maximum number of transistors per chip over time. in existing chips that are readily available. This situation simpliﬁes the design task and shortens the time needed to develop the ﬁnal product. Before we discuss the design processin detail, we should introduce the different types of integrated circuit chips that may beused."
"There exists a large variety of chips that implement various functions that are useful in the design of digital hardware. The chips range from simple ones with low function-ality to extremely complex chips. For example, a digital hardware product may require amicroprocessor to perform some arithmetic operations, memory chips to provide storagecapability, and interface chips that allow easy connection to input and output devices. Suchchips are available from various vendors."
"In contrast to standard chips that have ﬁxed functionality, it is possible to construct chipsthat contain circuitry which can be conﬁgured by the user to implement a wide range ofdifferent logic circuits. These chips have a very general structure and include a collectionofprogrammable switches that allow the internal circuitry in the chip to be conﬁgured in many different ways. The designer can implement whatever functions are required for aparticular application by setting the programmable switches as needed. The switches areprogrammed by the end user, rather than when the chip is manufactured. Such chips areknown as programmable logic devices (PLDs)."
"FPGAs are available as off-the-shelf components that can be purchased from different sup-pliers. Because they are programmable, they can be used to implement most logic circuitsfound in digital hardware. However, they also have a drawback in that the programmableswitches consume valuable chip area and limit the speed of operation of implemented cir-cuits. Thus in some cases FPGAs may not meet the desired performance or cost objectives.In such situations it is possible to design a chip from scratch; namely, the logic circuitry thatmust be included on the chip is designed ﬁrst and then the chip is manufactured by a com-pany that has the fabrication facilities. This approach is known as custom orsemi-custom design, and such chips are often called application-speciﬁc integrated circuits (ASICs)."
"A disadvantage of the custom-design approach is that manufacturing a custom chip often takes a considerable amount of time, on the order of months. In contrast, if an FPGA can be used instead, then the chips are programmed by the end user and no manufacturingdelays are involved. 1.2 The Design Process"
"The availability of computer-based tools has greatly inﬂuenced the design process in a wide variety of environments. For example, designing an automobile is similar in the generalapproach to designing a furnace or a computer. Certain steps in the development cycle mustbe performed if the ﬁnal product is to meet the speciﬁed objectives."
"The ﬂowchart in Figure 1.3 depicts a typical development process. We assume that the process is to develop a product that meets certain expectations. The most obviousrequirements are that the product must function properly, that it must meet an expectedlevel of performance, and that its cost should not exceed a given target."
"The process begins with the deﬁnition of product speciﬁcations. The essential features of the product are identiﬁed, and an acceptable method of evaluating the implementedfeatures in the ﬁnal product is established. The speciﬁcations must be tight enough toensure that the developed product will meet the general expectations, but should not beunnecessarily constraining (that is, the speciﬁcations should not prevent design choicesthat may lead to unforeseen advantages)."
"From a complete set of speciﬁcations, it is necessary to deﬁne the general structure of an initial design of the product. This step is difﬁcult to automate. It is usually performed bya human designer because there is no clear-cut strategy for developing a product’s overallstructure—it requires considerable design experience and intuition."
"Many types of CAD tools are available, ranging from those that help with the designof individual parts of the system to those that allow the entire system’s structure to berepresented in a computer. When the initial design is ﬁnished, the results must be veriﬁedagainst the original speciﬁcations. Traditionally, before the advent of CAD tools, this stepinvolved constructing a physical model of the designed product, usually including just thekey parts. Today it is seldom necessary to build a physical model. CAD tools enabledesigners to simulate the behavior of incredibly complex products, and such simulationsare used to determine whether the obtained design meets the required speciﬁcations. Iferrors are found, then appropriate changes are made and the veriﬁcation of the new designis repeated through simulation. Although some design ﬂaws may escape detection viasimulation, usually all but the most subtle problems are discovered in this way."
"To understand the role that logic circuits play in digital systems, consider the structure of a typical computer, as illustrated in Figure 1.4a . The computer case houses a number of printed circuit boards (PCBs), a power supply, and (not shown in the ﬁgure) storage units, like a hard disk and DVD or CD-ROM drives. Each unit is plugged into a main PCB, calledthemotherboard. As indicated on the bottom of the ﬁgure, the motherboard holds several integrated circuit chips, and it provides slots for connecting other PCBs, such as audio,video, and network boards."
"Figure 1.4b illustrates the structure of an integrated circuit chip. The chip comprises a number of subcircuits, which are interconnected to build the complete circuit. Examplesof subcircuits are those that perform arithmetic operations, store data, or control the ﬂowof data. Each of these subcircuits is a logic circuit. As shown in the middle of the ﬁgure, alogic circuit comprises a network of connected logic gates. Each logic gate performs a very simple function, and more complex operations are realized by connecting gates together.Logic gates are built with transistors, which in turn are implemented by fabricating variouslayers of material on a silicon chip."
"In this book we use a modern design approach based on the Verilog hardware descriptionlanguage and CAD tools to illustrate many aspects of logic circuit design. We selectedthis technology because it is widely used in industry and because it enables the readers toimplement their designs in FPGA chips, as discussed below. This technology is particularlywell-suited for educational purposes because many readers have access to facilities for usingCAD tools and programming FPGA devices."
"In addition to codes that represent characters and letters, the ASCII code includes punctuation marks such as ! and ?, commonly used symbols such as & and %, and acollection of control characters. The control characters are those needed in computersystems to handle and transfer data among various devices. For example, the carriagereturn character, which is abbreviated as CR in the table, indicates that the carriage, orcursor position, of an output device, such as a printer or display, should return to the left-most column."
"CAD tools not only made it possible to design incredibly complex circuits but also made the design work much simpler in general. They perform many tasks automatically,which may suggest that today’s designer need not understand the theoretical concepts usedin the tasks performed by CAD tools. An obvious question would then be, Why should onestudy the theory that is no longer needed for manual design? Why not simply learn how touse the CAD tools?"
"There is another good reason to learn some logic circuit theory even if it were not required for CAD tools. Simply put, it is interesting and intellectually challenging. In the modern world ﬁlled with sophisticated automatic machinery, it is tempting to rely on tools asa substitute for thinking. However, in logic circuit design, as in any type of design process,computer-based tools are not a substitute for human intuition and innovation. Computer-based tools can produce good digital hardware designs only when employed by a designerwho thoroughly understands the nature of logic circuits."
"The study of logic circuits is motivated mostly by their use in digital computers. But such circuits also form the foundation of many other digital systems, such as those that perform control applications or are involved in digital communications. All such applications are based on some simple logical operations that are performedon input information."
"Binary logic circuits have the dominant role in digital technology. We hope to provide the reader with an understanding of how these circuits work, how are they represented in mathematical notation, and howare they designed using modern design automation techniques. We begin by introducing some basic conceptspertinent to the binary logic circuits. 2.1 V ariables and Functions"
The parallel connection of two switches is given in Figure 2.3b. In this case the light will be on if either the x1orx2switch is closed. The light will also be on if both switches are closed. The light will be off only if both switches are open. This behavior can be stated as
"The+symbol is called the OR operator, and the circuit in Figure 2.3b is said to implement alogical OR function. It is important not to confuse the use of the +symbol with its more common meaning, which is for arithmetic addition. In this chapter the +symbol represents the logical OR operation unless otherwise stated."
"So far we have assumed that some positive action takes place when a switch is closed, suchas turning the light on. It is equally interesting and useful to consider the possibility that apositive action takes place when a switch is opened. Suppose that we connect the light asshown in Figure 2.5. In this case the switch is connected in parallel with the light, ratherthan in series. Consequently, a closed switch will short-circuit the light and prevent thecurrent from ﬂowing through it. Note that we have included an extra resistor in this circuitto ensure that the closed switch does not short-circuit the power supply. The light will beturned on when the switch is opened. Formally, we express this functional behavior as"
"L(x)is a complement of xin this example. Another frequently used term for the same operation is the NOT operation. There are several commonly used notations for indicating the complementation. In the preceding expression we placed an overbar on top of x. This notation is probably the best from the visual point of view. However, when complements are needed in expressions that are typed using a computer keyboard, which is often donewhen using CAD tools, it is impractical to use overbars. Instead, either an apostrophe isplaced after the variable, or an exclamation mark (!), the tilde character (∼), or the wordNOT is placed in front of the variable to denote the complementation. Thus the followingare equivalent: x=x/prime=!x=∼ x=NOT x"
"Figure 2.7 Three-input AND and OR operations. can have. The next column deﬁnes the AND operation for each combination of values of x1 andx2, and the last column deﬁnes the OR operation. Because we will frequently need to refer to “combinations of logic values” applied to some variables, we will adopt a shorter term, valuation, to denote such a combination of logic values."
"A designer of digital systems is faced with two basic issues. For an existing logic network, it must be possible to determine the function performed by the network. This task is referredto as the analysis process. The reverse task of designing a new network that implements a desired functional behavior is referred to as the synthesis process. The analysis process is rather straightforward and much simpler than the synthesis process."
"Timing diagrams are used for many purposes. They depict the behavior of a logic circuit in a form that can be observed when the circuit is tested using instruments such as logic analyzers and oscilloscopes. Also, they are often generated by CAD tools to showthe designer how a given circuit is expected to behave before it is actually implementedelectronically. We will introduce the CAD tools later in this chapter and will make use ofthem throughout the book."
"We have already established this equivalence through detailed analysis of the two circuits and construction of the truth table. But the same outcome can be achieved through algebraicmanipulation of logic expressions. In Section 2.5 we will introduce a mathematical approachfor dealing with logic functions, which provides the basis for modern design techniques."
"The signals xandyare inputs to a logic circuit that controls a light L. The required behavior is that the light should be on only if one, but not both, of the toggle switchesis in the top position. This speciﬁcation leads to the truth table in part ( b) of the ﬁgure."
"Notice that we have listed the axioms and the single-variable theorems in pairs. This is done to reﬂect the important principle of duality. Given a logic expression, its dual is obtained by replacing all +operators with ·operators, and vice versa, and by replacing all 0s with 1s, and vice versa. The dual of any true statement (axiom or theorem) in"
"Boolean algebra is also a true statement. At this point in the discussion, the reader mightnot appreciate why duality is a useful concept. However, this concept will become clearlater in the chapter, when we will show that duality implies that at least two different waysexist to express every logic function with Boolean algebra. Often, one expression leads toa simpler physical implementation than the other and is thus preferable."
"Again, we can prove the validity of these properties either by perfect induction or by performing algebraic manipulation. Figure 2.13 illustrates how perfect induction can be used to prove DeMorgan’s theorem, using the format of a truth table. The evaluation ofleft-hand and right-hand sides of the identity in 15a gives the same result."
"The Venn diagram has traditionally been used in mathematics to provide a graphical illustration of various operations and relations in the algebra of sets. A set sis a collection of elements that are said to be the members of s. In the Venn diagram the elements of a set are represented by the area enclosed by a contour such as a square, a circle, or anellipse. For example, in a universe Nof integers from 1 to 10, the set of even numbers is"
"As another example, consider the identity x·y+x·z+y·z=x·y+x·z which is illustrated in Figure 2.16. Notice that this identity states that the term y·zis fully covered by the terms x·yandx·z; therefore, this term can be omitted. This identity, which we listed earlier as property 17a , is often referred to as consensus."
"The reader should use the Venn diagram to prove some other identities. The examples below prove the distributive property 12b, and DeMorgan’s theorem, 15a . xy z y x zxy z xy yz xy x + zxzxy z xy xy z xz xy x + zy z+xy zxy z· · ·· · ·· ···"
"Figure 2.17. Parts (a) and (b) of the ﬁgure depict the terms xandy·z, respectively, and part (c) gives the union of parts (a) and (b). Parts (d) and (e) depict the sum terms (x+y) and(x+z), and part ( f) shows the intersection of (d) and (e). Since the diagrams in (c) and ( f) are the same, this proves the identity. (b) yz(a) x y x zy x z (c) xy+ zy x z(e) xz+(d) xy+ y x zy x z (f) (xy )+( xz ) +y x z· · ·"
"Using the three basic operations—AND, OR, and NOT—it is possible to construct an inﬁnitenumber of logic expressions. Parentheses can be used to indicate the order in which theoperations should be performed. However, to avoid an excessive use of parentheses, anotherconvention deﬁnes the precedence of the basic operations. It states that in the absence ofparentheses, operations in a logic expression must be performed in the order: NOT, AND,and then OR. Thus in the expression x 1·x2+x1·x2 it is ﬁrst necessary to generate the complements of x1andx2. Then the product terms x1·x2 andx1·x2are formed, followed by the sum of the two product terms. Observe that in the absence of this convention, we would have to use parentheses to achieve the same effect asfollows: (x 1·x2)+((x1)·(x2))"
"The conveyor pushes the gumballs over a “trap door” that it used to reject the ones that are not properly formed. A gumball should be rejected if it is too large, or both too smalland too light. The trap door is opened by setting the logic function fto the value 1. By inspection, we can see that an appropriate logic expression is f=s 1s2+s3. We will use"
"The observant reader will notice that using the combining property 14a is really just a short form of ﬁrst using the distributive property 12a and then applying rule 8b, as we did in the previous step. Our simpliﬁed expression for fis the same as the one that we determined earlier, by inspection."
"For a function of nvariables, a product term in which each of the nvariables appears once is called a minterm. The variables may appear in a minterm either in uncomplemented or complemented form. For a given row of the truth table, the minterm is formed by including x iifxi=1 and by including xiifxi=0."
"The preceding discussion has shown how logic functions can be realized in the form of logic circuits, consisting of networks of gates that implement basic functions. A givenfunction may be realized with various different circuit structures, which usually impliesa difference in cost. An important objective for a designer is to minimize the cost of thedesigned circuit. We will discuss strategies for ﬁnding minimum-cost implementations inSection 2.11."
"We have discussed the use of AND, OR, and NOT gates in the synthesis of logic circuits.There are other basic logic functions that are also used for this purpose. Particularly useful are the NAND and NOR functions which are obtained by complementing the output gener-ated by AND and OR operations, respectively. These functions are attractive because theyare implemented with simpler electronic circuits than the AND and OR functions, as wediscuss in Appendix B. Figure 2.25 gives the graphical symbols for the NAND and NORgates. A bubble is placed on the output side of the AND and OR gate symbols to representthe complemented output signal."
"Logic circuits provide a solution to a problem. They implement functions that are needed tocarry out speciﬁc tasks. Within the framework of a computer, logic circuits provide completecapability for execution of programs and processing of data. Such circuits are complex anddifﬁcult to design. But regardless of the complexity of a given circuit, a designer of logiccircuits is always confronted with the same basic issues. First, it is necessary to specify thedesired behavior of the circuit. Second, the circuit has to be synthesized and implemented.Finally, the implemented circuit has to be tested to verify that it meets the speciﬁcations."
"In computer systems it is often necessary to choose data from exactly one of a numberof possible sources. Suppose that there are two sources of data, provided as input signalsx 1andx2. The values of these signals change in time, perhaps at regular intervals. Thus sequences of 0s and 1s are applied on each of the inputs x1andx2. We want to design a circuit that produces an output that has the same value as either x1orx2, dependent on the value of a selection control signal s. Therefore, the circuit should have three inputs: x1, x2, and s. Assume that the output of the circuit will be the same as the value of input x1if s=0, and it will be the same as x2ifs=1."
"A logic circuit can be deﬁned by drawing logic gates and interconnecting them with wires. A CAD tool for entering a designed circuit in this way is called a schematic capture tool. The word schematic refers to a diagram of a circuit in which circuit elements, such as logic gates, are depicted as graphical symbols and connections between circuit elementsare drawn as lines."
"A schematic capture tool uses the graphics capabilities of a computer and a computer mouse to allow the user to draw a schematic diagram. To facilitate inclusion of gatesin the schematic, the tool provides a collection of graphical symbols that represent gatesof various types with different numbers of inputs. This collection of symbols is called alibrary. The gates in the library can be imported into the user’s schematic, and the toolprovides a graphical way of interconnecting the gates to create a logic network."
Any subcircuits that have been previously created can be represented as graphical symbols and included in the schematic. In practice it is common for a CAD system user tocreate a circuit that includes within it other smaller circuits. This methodology is knownashierarchical design and provides a good way of dealing with the complexities of large circuits.
"Ahardware description language (HDL) is similar to a typical computer programming language except that an HDL is used to describe hardware rather than a program to beexecuted on a computer. Many commercial HDLs are available. Some are proprietary,meaning that they are provided by a particular company and can be used to implementcircuits only in the technology offered by that company. We will not discuss the proprietaryHDLs in this book. Instead, we will focus on a language that is supported by virtuallyall vendors that provide digital hardware technology and is ofﬁcially endorsed as an Institute of Electrical and Electronics Engineers (IEEE) standard. The IEEE is a worldwide organization that promotes technical activities to the beneﬁt of society in general. One ofits activities involves the development of standards that deﬁne how certain technologicalconcepts can be used in a way that is suitable for a large body of users."
"Verilog provides design portability. Acircuit speciﬁed in Verilog can be implemented in different types of chips and with CAD tools provided by different companies, without having to change the Verilog speciﬁcation. Design portability is an important advantage becausedigital circuit technology changes rapidly. By using a standard language, the designer canfocus on the functionality of the desired circuit without being overly concerned about thedetails of the technology that will eventually be used for implementation."
"Design entry of a logic circuit is done by writing Verilog code. Signals in the circuit can be represented as variables in the source code, and logic functions are expressed byassigning values to these variables. Verilog source code is plain text, which makes it easyfor the designer to include within the code documentation that explains how the circuitworks. This feature, coupled with the fact that Verilog is widely used, encourages sharingand reuse of Verilog-described circuits. This allows faster development of new products incases where existing Verilog code can be adapted for use in the design of new circuits."
"Regardless of what type of design entry is used, the initial logic expressions produced by the synthesis tools are not likely to be in an optimal form because they reﬂect the designer’sinput to the CAD tools. It is impossible for a designer to manually produce optimal resultsfor large circuits. So, one of the important tasks of the synthesis tools is to manipulate theuser’s design to automatically generate an equivalent, but better circuit."
"The measure of what makes one circuit better than another depends on the particular needs of a design project and the technology chosen for implementation. Earlier in thischapter we suggested that a good circuit might be one that has the lowest cost. There are otherpossible optimization goals, which are motivated by the type of hardware technology usedfor implementation of the circuit. We discuss implementation technologies in Appendix B."
"Logic gates and other logic elements are implemented with electronic circuits, and thesecircuits cannot perform their function with zero delay. When the values of inputs to thecircuit change, it takes a certain amount of time before a corresponding change occurs atthe output. This is called a propagation delay of the circuit. The propagation delay consists of two kinds of delays. Each logic element needs some time to generate a valid outputsignal whenever there are changes in the values of its inputs. In addition to this delay, thereis a delay caused by signals that must propagate along wires that connect various logicelements. The combined effect is that real circuits exhibit delays, which has a signiﬁcantimpact on their speed of operation."
We strongly encourage the reader to obtain access to suitable CAD tools and implement some examples of circuits by using these tools. Two examples of commonly-used CADtools are the Quartus II tools available from Altera Corporation and the ISE tools providedby Xilinx Corporation. Both of these CAD systems can be obtained free-of-charge foreducational use from their respective corporations’ websites. 2.10 Introduction to Verilog
"Verilog was originally intended for simulation and veriﬁcation of digital circuits. Subsequently, with the addition of synthesis capability, Verilog has also become popular foruse in design entry in CAD systems. The CAD tools are used to synthesize the Verilogcode into a hardware implementation of the described circuit. In this book our main use of"
"Verilog is a complex, sophisticated language. Learning all of its features is a daunting task. However, for use in synthesis only a subset of these features is important. To simplifythe presentation, we will focus the discussion on the features of the Verilog language thatare actually used in the examples in the book. The material presented is sufﬁcient to allowthe reader to design a wide range of circuits. The reader who wishes to learn the complete"
Verilog is introduced in several stages throughout the book. Our general approach will be to introduce particular features only when they are relevant to the design topics covered in that part of the text. In Appendix A we provide a concise summary of the Verilog featurescovered in the book. The reader will ﬁnd it convenient to refer to that material from time totime. In the remainder of this chapter we discuss the most basic concepts needed to writesimple Verilog code.
"When using CAD tools to synthesize a logic circuit, the designer can provide the initial description of the circuit in several different ways, as we explained in the previous section.One efﬁcient way is to write this description in the form of Verilog source code. The Verilogcompiler translates this code into a logic circuit."
"Verilog syntax requires that procedural statements be contained inside a construct called analways block, as shown in Figure 2.42. An always block can contain a single statement, as in this example, or it can contain multiple statements. A typical Verilog design module may include several always blocks, each representing a part of the circuit being modeled."
"When learning how to use Verilog or other hardware description languages, the tendency for the novice is to write code that resembles a computer program, containing many variablesand loops. It is difﬁcult to determine what logic circuit the CAD tools will produce whensynthesizing such code. This book contains more than 100 examples of complete Verilogcode that represent a wide range of logic circuits. In these examples the code is easilyrelated to the described logic circuit. The reader is advised to adopt the same style of code."
"Once complete Verilog code is written for a particular design, the reader is encouraged to analyze the resulting circuit produced by the CAD synthesis tools; typical CAD systemsprovide graphical viewing tools that can display a logic circuit that corresponds to the outputproduced by the Verilog compiler. Much can be learned about Verilog, logic circuits, andlogic synthesis through this process. We provide additional guidelines for writing Verilogcode in Appendix A. 2.11 Minimization and Karnaugh Maps"
"DeMorgan’s theorem, and the combining property. In general, it is not obvious whento apply these theorems and properties to ﬁnd a minimum-cost circuit, and it is oftentedious and impractical to do so. This section introduces a more manageable approach, calltheKarnaugh map, which provides a systematic way of producing a minimum-cost logic expression."
"The combining property 14a allows us to replace two minterms that differ in the value of only one variable with a single product term that does not include that variable at all. Forexample, both m 0andm2include x1andx3, but they differ in the value of x2because m0 includes x2while m2includes x2. Thus x1x2x3+x1x2x3=x1(x2+x2)x3 =x1·1·x3 =x1x3"
"A three-variable Karnaugh map is constructed by placing 2 two-variable maps side by side. Figure 2.51a lists all of the three-variable minterms, and part (b) of the ﬁgure indicates the locations of these minterms in the Karnaugh map. In this case each valuationofx 1andx2identiﬁes a column in the map, while the value of x3distinguishes the two rows. To ensure that minterms in the adjacent cells in the map can always be combinedinto a single product term, the adjacent cells must differ in the value of only one variable."
"Again, the reader should note that if the remaining two 1s were implemented as a group of two, the result would be the product term x1x3x4. Implementing these 1s as a part of a group of four 1s, as shown in the ﬁgure, gives the less expensive product term x1x4."
"But these two 1s can be realized more economically by treating them as a part of a group of four 1s. They can be included in two different groups of four, as shown in the ﬁgure.One choice leads to the product term x 1x2, and the other leads to x2x3. Both of these terms have the same cost; hence it does not matter which one is chosen in the ﬁnal circuit. Notethat the complement of x 3in the term x2x3does not imply an increased cost in comparison with x1x2, because this complement must be generated anyway to produce the term x1x3, which is included in the implementation."
"A collection of implicants that account for all valuations for which a given function is equal to 1 is called a cover of that function. A number of different covers exist for most functions. Obviously, a set of all minterms for which f=1 is a cover. It is also apparent that a set of all prime implicants is a cover."
"We have seen that it is possible to implement a given logic function with various circuits.These circuits may have different structures and different costs. When designing a logic circuit, there are usually certain criteria that must be met. One such criterion is likely tobe the cost of the circuit, which we considered in the previous discussion. In general, thelarger the circuit, the more important the cost issue becomes. In this section we will assumethat the main objective is to obtain a minimum-cost circuit."
"The choice of nonessential prime implicants to be included in the cover is governed by the cost considerations. This choice is often not obvious. Indeed, for large functions there may exist many possibilities, and some heuristic approach (i.e., an approach that considers only a subset of possibilities but gives good results most of the time) has to be used. One suchapproach is to arbitrarily select one nonessential prime implicant and include it in the coverand then determine the rest of the cover. Next, another cover is determined assuming thatthis prime implicant is not in the cover. The costs of the resulting covers are compared, andthe less-expensive cover is chosen for implementation."
"We can illustrate the process by using the function in Figure 2.58. Of the six prime implicants, only x3x4is essential. Consider next x1x2x3and assume ﬁrst that it will be included in the cover. Then the remaining three minterms, m10,m11, and m15, will require two more prime implicants to be included in the cover. A possible implementation is f=x3x4+x1x2x3+x1x3x4+x1x2x3"
"Sometimes there may not be any essential prime implicants at all. An example is given in Figure 2.59. Choosing any of the prime implicants and ﬁrst including it, then excluding it from the cover leads to two alternatives of equal cost. One includes the prime implicantsindicated in black, which yields f= x1x3x4+x2x3x4+x1x3x4+x2x3x4"
This procedure can be used to ﬁnd minimum-cost implementations of both small and large logic functions. For our small examples it was convenient to use Karnaugh mapsto determine the prime implicants of a function and then choose the ﬁnal cover. Othertechniques based on the same principles are much more suitable for use in CAD tools; wewill introduce such techniques in Chapter 8.
"The freedom in choosing the value of don’t-cares leads to greatly simpliﬁed realizations. If we were to naively exclude the don’t-cares from the synthesis of the function, by assuming that they always have a value of 0, the resulting SOP expression would be f=x1x2x3+x1x3x4+x2x3x4 and the POS expression would be f=(x2+x3)(x3+x4)(x1+x2)"
"In this chapter we introduced the concept of logic circuits. We showed that such circuits canbe implemented using logic gates and that they can be described using a mathematical modelcalled Boolean algebra. Because practical logic circuits are often large, it is important tohave good CAD tools to help the designer. We introduced the Verilog hardware descriptionlanguage that can be used to specify circuits for use in a CAD tool. We urge the reader tostart using CAD software for the design of logic circuits as soon as possible."
"Solution: The equation is valid if the expressions on the leftand right-hand sides represent the same function. To perform the comparison, we could construct a truth table for each side and see if the truth tables are the same. An algebraic approach is to derive a canonicalsum-of-products form for each expression."
"Example 2.22 Problem: A circuit that controls a given digital system has three inputs: x1,x2, and x3.I t has to recognize three different conditions: • Condition Ais true if x3is true and either x1is true or x2is false • Condition Bis true if x1is true and either x2orx3is false • Condition Cis true if x2is true and either x1is true or x3is false"
"To ﬁnd the minimum-cost SOP expression, it is necessary to ﬁnd the prime implicants that cover all 1s in the map. The don’t-cares may be used as desired. Minterm m6is covered only by the prime implicant x1x2, hence this prime implicant is essential and it must be included in the ﬁnal expression. Similarly, the prime implicants x1x2andx3x4are essential because they are the only ones that cover m10andm15, respectively. These three prime implicants cover all minterms for which f=1 except m12. This minterm can be covered in two ways, by choosing either x1x3x4orx2x3x4. Since both of these prime implicants have the same cost, we can choose either of them. Choosing the former, the desired SOP expression is f=x1x2+x1x2+x3x4+x1x3x4"
"In this chapter we will discuss logic circuits that perform arithmetic operations. We will explain how numbers can be added, subtracted, and multiplied. We will also show how to write Verilog code to describe the arithmetic circuits. These circuits provide an excellent platform for illustrating the power and versatility of"
"Another interesting feature of XOR gates is that a two-input XOR gate can be thought of as using one input as a control signal that determines whether the true or complementedvalue of the other input will be passed through the gate as the output value. This is clearfrom the deﬁnition of XOR, where x i⊕yi=xy+xy. Consider xto be the control input."
"To assess the suitability of different number representations, it is necessary to investigate their use in arithmetic operations—particularly in addition and subtraction. We can illustrate the good and bad aspects of each representation by considering very small numbers. We willuse four-bit numbers, consisting of a sign bit and three signiﬁcant bits. Thus the numbershave to be small enough so that the magnitude of their sum can be expressed in three bits,which means that the sum cannot exceed the value 7."
Addition of positive numbers is the same for all three number representations. It is actually the same as the addition of unsigned numbers discussed in Section 3.2. But thereare signiﬁcant differences when negative numbers are involved. The difﬁculties that arisebecome apparent if we consider operands with different combinations of signs.
"However, if the operands have opposite signs, the task becomes more complicated. Thenit is necessary to subtract the smaller number from the larger one. This means that logiccircuits that compare and subtract numbers are also needed. We will see shortly that itis possible to perform subtraction without the need for this circuitry. For this reason, thesign-and-magnitude representation is not used in computers. 1’s Complement Addition"
"Thus a circuit that forms the 9’s complement, combined with a normal adder circuit, will sufﬁce for both addition and subtraction of decimal signed numbers. A key point is that thehardware needs to deal only with ndigits if n-digit numbers are used. Any carry that may be generated from the left-most digit position is simply ignored."
"The result of addition or subtraction is supposed to ﬁt within the signiﬁcant bits used to represent the numbers. If nbits are used to represent signed numbers, then the result must be in the range −2n−1to 2n−1−1. If the result does not ﬁt in this range, then we say that arithmetic overﬂow has occurred. To ensure the correct operation of an arithmetic circuit, it is important to be able to detect the occurrence of overﬂow."
"When buying a digital system, such as a computer, the buyer pays particular attention to the performance that the system is expected to provide and to the cost of acquiring thesystem. Superior performance usually comes at a higher cost. However, a large increase inperformance can often be achieved at a modest increase in cost. A commonly used indicatorof the value of a system is its price/performance ratio."
"To reduce the delay caused by the effect of carry propagation through the ripple-carry adder, we can attempt to evaluate quickly for each stage whether the carry-in from the previous stage will have a value 0 or 1. If a correct evaluation can be made in a relatively short time,then the performance of the complete adder will be improved."
"The total delay in the n-bit carry-lookahead adder is four gate delays. The values of allgiandpisignals are determined after one gate delay. It takes two more gate delays to evaluate all carry signals. Finally, it takes one more gate delay (XOR) to generate all sum bits. The key to the good performance of the adder is quick evaluation of carry signals."
"The preceding delay analysis assumes that gates with any number of inputs can be used. But, the number of gate inputs, referred to as the fan-in of the gate, has to be limited in practice as we discuss in Appendix B. Therefore the reality of fan-in constraints must be taken into account. To illustrate this problem, consider the expressions for the ﬁrst eightcarries: c 1=g0+p0c0 c2=g1+p1g0+p1p0c0 ... c8=g7+p7g6+p7p6g5+p7p6p5g4+p7p6p5p4g3+p7p6p5p4p3g2 +p7p6p5p4p3p2g1+p7p6p5p4p3p2p1g0+p7p6p5p4p3p2p1p0c0"
"Suppose that the maximum fan-in of the gates is four inputs. Then it is impossible to implement all of these expressions with a two-level AND-OR circuit. The biggest problemisc 8, where one of the AND gates requires nine inputs; moreover, the OR gate also requires nine inputs. To meet the fan-in constraint, we can rewrite the expression for c8as c8=(g7+p7g6+p7p6g5+p7p6p5g4)+[(p7p6p5p4)(g3+p3g2+p3p2g1+p3p2p1g0)] +(p7p6p5p4)(p3p2p1p0)c0"
"To implement this expression we need ten AND gates and three OR gates. The propagation delay in generating c8consists of one gate delay to develop all giandpi, two gate delays to produce the sum-of-products terms in parentheses, one gate delay to form the productterm in square brackets, and one delay for the ﬁnal ORing of terms. Hence c 8is valid after ﬁve gate delays, rather than the three gate delays that would be needed without the fan-inconstraint."
"The schematic capture tools provide a library of graphical symbols that represent basic logic gates. These gates are used to create schematics of relatively simple circuits. Inaddition to basic gates, most schematic capture tools also provide a library of commonly-used circuits, such as adders. Each circuit is provided as a module that can be importedinto a schematic and used as part of a larger circuit."
"The four-bit adder in Figure 3.22 is described using four instantiation statements. Each statement begins with the name of the module, fulladd, that is being instantiated, followed by an instance name. The instance names must be unique. The least-signiﬁcant stage in the adder is named stage0 and the most-signiﬁcant stage is stage3. The signal names in the adder4 module that are to be connected to each input and output port on the fulladd module are then listed. These signals are listed in the same order as in the fulladd module, namely the order Cin, x,y,s,Cout."
"In Figure 3.23 we instantiated four copies of the fulladd subcircuit to specify a four-bit ripple-carry adder. This approach can be used to specify an n-bit adder by using a loop that instantiates the fulladd subcircuit ntimes. The Verilog generate construct provides the desired capability. It allows instantiation statements to be included inside forloops and if-else statements. If a forloop is included in the generate block, the loop index variable has to be declared of type genvar .Agenvar variable is similar to an integer variable, but it can have only positive values and it can be used only inside generate blocks."
"A variable can be assigned a value in one Verilog statement, and it retains this value until it is overwritten by a subsequent assignment statement. There are two types of variables: regandinteger . As mentioned in Chapter 2, all signals that are assigned a value using procedural statements must be declared as variables by using the regorinteger keywords."
"For decimal numbers it is not necessary to give the radix identiﬁer d. When an unsizednumber is used in an expression the Verilog compiler gives it a certain size, which is typicallythe same as the size of the other operand(s) in the expression. To improve readability, it ispossible to use the underscore character. Instead of writing 12’b100010101001, it is easierto visualize the same number as 12’b1000_1010_1001."
"The speciﬁed size may exceed the number of bits that are actually needed to represent a given number. In this case, the ﬁnal representation is padded to the left to yield the requiredsize. However, if there are more digits than can ﬁt into the number of bits given as the size,the extra digits will be ignored."
"Before we discuss the general issue of multiplication, we should note that a binary number,B, can be multiplied by 2 simply by adding a zero to the right of its least-signiﬁcant bit. This effectively moves all bits of Bto the left, and we say that Bisshifted left by one bit position."
"When a shifted version of the multiplicand is added to a partial product, overﬂow has to be avoided. Hence the new partial product must be larger by one extra bit. Figure3.36a illustrates the process of multiplying two positive numbers. The sign-extended bits are shown in blue. Part (b)of the ﬁgure involves a negative multiplicand. Note that the resulting product has 2n bits in both cases."
"In scientiﬁc applications it is often necessary to deal with numbers that are very large orvery small. Instead of using the ﬁxed-point representation, which would require manysigniﬁcant digits, it is better to use the ﬂoating-point representation in which numbers arerepresented by a mantissa comprising the signiﬁcant digits and an exponent of the radix R."
"In the circuit in Figure 3.48, the longest path is through the right-most FAs in the ﬁrst and second rows, followed by all four FAs in the bottom row. Therefore, the critical delay is six times the delay through a full-adder block plus the AND-gate delay needed to formthe inputs to the ﬁrst FA in the top row."
"Previous chapters have introduced the basic techniques for design of logic circuits. In practice, a few types of logic circuits are often used as building blocks in larger designs. This chapter discusses a number of these blocks and gives examples of their use. The chapter also includes a major section on Verilog, which describesseveral key features of the language. 4.1 Multiplexers"
"Theif-else statement provides the means for choosing an alternative based on the value of an expression. When there are many possible alternatives, the code based on this statement may become awkward to read. Instead, it is often possible to use the Verilog case statement which is deﬁned as case (expression) alternative1: statement;alternative2: statement;···alternativej: statement;[default: statement;] endcase"
"The value of the controlling expression and each alternative are compared bit by bit. When there is one or more matching alternative, the statement(s) associated with the ﬁrst match(only) is executed. When the speciﬁed alternatives do not cover all possible valuations ofthe controlling expression, the optional default clause should be included. Otherwise, the"
"Boolean operations on the inputs AandB. In this table +means arithmetic addition, and −means arithmetic subtraction. To avoid confusion, the table uses the words XOR, OR, and AND for the Boolean operations. Each Boolean operation is done in a bitwise fashion.For example, F=AAND Bproduces the four-bit result f 0=a0b0,f1=a1b1,f2=a2b2, andf3=a3b3."
"It is also possible to implement circuits that can produce three different types of output signals. In addition to the usual 0 and 1 values, there is a third value that indicates that the output line is not connected to any deﬁned voltage level. In this state the output behaves likean open circuit, as explained in Appendix B. We say that the output is in the high-impedance state, which is usually denoted by using the letter z."
"A loop control variable, which has to be of type integer , is set to the value given as the initial index. It is used in the statement or a block of statements delineated by begin andend keywords. After each iteration, the control variable is changed as deﬁned in the increment."
"Unlike forloops in high-level programming languages, the Verilog forloop does not specify changes that take place in time through successive loop iterations. Instead, during each iteration it speciﬁes a different subcircuit. In Figure 3.25 the forloop was used to deﬁne a cascade of full-adder subcircuits to form an n-bit ripple-carry adder. The forloop can be used to deﬁne many other structures as illustrated by the next two examples."
Note that each successive iteration through the loop corresponds to a higher priority. Verilogsemantics specify that a signal that receives multiple assignments in an always block retains the last assignment. Thus the iteration that corresponds to the highest priority input that isequal to 1 will override any setting of Yestablished during the previous iterations.
"The ! operator has the same effect on a scalar operand as the ∼operator. Thus, f =!w =∼w. But the effect on a vector operand is different, namely if f=!A; then fwill be equal to 1 (true) only if all bits of Aare equal to 0 (false). Hence, f= a2+a1+a0."
"These operators have the same meaning as the corresponding operators in the C programming language. An expression that uses the relational operators returns the value 1 if it isevaluated as true, and the value 0 if evaluated as false. If there are any x(unknown) or z bits in the operands, then the expression takes the value x."
"This chapter has introduced a number of circuit building blocks. Examples using these blocks to construct larger circuits will be presented in later chapters. To describe thebuilding block circuits efﬁciently, several Verilog constructs have been introduced. Inmany cases a given circuit can be described in various ways, using different constructs. Acircuit that can be described using an if-else statement can also be described using a case statement or perhaps a forloop. In general, there are no strict rules that dictate when one style should be preferred over another. With experience the user develops a sense for whichtypes of statements work well in a particular design situation. Personal preference alsoinﬂuences how the code is written."
"LUT must make the choice between w2andw3when s1=1. But, the choice can be made only by knowing the value of s0. Since it is impossible to have ﬁve inputs in the LUT, more information has to be passed from the ﬁrst to the second LUT. Observe that when s1=1 the output fwill be equal to either w2orw3, in which case it is not necessary to know the values of w0andw1. Hence, in this case we can pass on the value of s0through the ﬁrst"
Two kinds of parity can be used. For even parity thepbit is given the value such that the total number of 1s in the n+1 transmitted bits (comprising the n-bit data and the parity bit p) is even. For odd parity thepbit is given the value that makes the total number of 1s odd.
"Note that observing c=0 is not a guarantee that the received item is correct. If two or any even number of bits have their values inverted during the transmission, the parity of thedata item will not be changed; hence the error will not be detected. But if an odd numberof bits are corrupted, then the error will be detected."
"In previous chapters we considered combinational circuits where the value of each output depends solely on the values of signals applied to the inputs. There exists another class of logic circuits in which the values of the outputs depend not only on the present values of the inputs but also on the past behavior of the circuit. Suchcircuits include storage elements that store the values of logic signals. The contents of the storage elementsare said to represent the state of the circuit. When the circuit’s inputs change values, the new input values either leave the circuit in the same state or cause it to change into a new state. Over time the circuit changesthrough a sequence of states as a result of changes in the inputs. Circuits that behave in this way are referredto as sequential circuits."
"In this chapter we will introduce circuits that can be used as storage elements. But ﬁrst, wewill motivate the need for such circuits by means of a simple example. Suppose that we wishto control an alarm system, as shown in Figure 5.1. The alarm mechanism responds to thecontrol input On/"
"Off. It is turned on when On/Off=1, and it is off when On/Off=0. The desired operation is that the alarm turns on when the sensor generates a positive voltagesignal, Set, in response to some undesirable event. Once the alarm is triggered, it must remain active even if the sensor output goes back to zero. The alarm is turned off manuallyby means of a Reset input. The circuit requires a memory element to remember that the alarm has to be active until the Reset signal arrives."
"If the delays through the two NOR gates are exactly the same, the oscillation will continueindeﬁnitely. In a real circuit there will invariably be some difference in the delays throughthese gates, and the latch will eventually settle into one of its two stable states, but we don’tknow which state it will be. This uncertainty is indicated in the waveforms by dashed lines."
"A corresponding characteristic table is given in Figure 5.16b. The circuit is called a JK ﬂip-ﬂop. It combines the behaviors of SR and T ﬂip-ﬂops in a useful way. It behaves as the SR ﬂip-ﬂop, where J=SandK=R, for all input values except J=K=1. For the latter case, which has to be avoided in the SR ﬂip-ﬂop, the JK ﬂip-ﬂop toggles its state likethe T ﬂip-ﬂop."
"In Chapter 3 we dealt with circuits that perform arithmetic operations. We showed how adder/subtractor circuits can be designed, either using a simple cascaded (ripple-carry)structure that is inexpensive but slow or using a more complex carry-lookahead structurethat is both more expensive and faster. In this section we examine special types of additionand subtraction operations, which are used for the purpose of counting. In particular, wewant to design circuits that can increment or decrement a count by 1. Counter circuits areused in digital systems for many purposes. They may count the number of occurrences ofcertain events, generate timing intervals for control of various tasks in a system, keep trackof time elapsed between speciﬁc events, and so on."
"The asynchronous counters in Figures 5.19a and 5.20a are simple, but not very fast. If a counter with a larger number of bits is constructed in this manner, then the delays causedby the cascaded clocking scheme may become too long to meet the desired performancerequirements. We can build a faster counter by clocking all ﬂip-ﬂops at the same time,using the approach described below."
"Instead of using AND gates of increased size for each stage, we use a factored arrangement as shown in the ﬁgure. This arrangement does not slow down the response of the counter,because all ﬂip-ﬂops change their states after a propagation delay from the positive edgeof the clock. Note that a change in the value of Q 0may have to propagate through several"
"While the toggle feature makes T ﬂip-ﬂops a natural choice for the implementation of counters, it is also possible to build counters using other types of ﬂip-ﬂops. The JKﬂip-ﬂops can be used in exactly the same way as the T ﬂip-ﬂops because if the JandK inputs are tied together, a JK ﬂip-ﬂop becomes a T ﬂip-ﬂop. We will now consider using Dﬂip-ﬂops for this purpose."
We have included an extra AND gate that produces the output Z. This signal makes it easy to concatenate two such counters to create a larger counter. It is also useful in applications where it is necessary to detect the state where the count has reached its maximumvalue (all 1s) and will go to 0 in the next clock cycle.
"The sequential circuits presented in this chapter, namely, registers and counters, have a regular structure that allows the circuits to be designed using an intuitive approach. InChapter 6 we will present a more formal approach to design of sequential circuits and showhow the circuits presented in this chapter can be derived using this approach."
"Analways construct is used to deﬁne a circuit that responds to changes in the signals that appear in the sensitivity list. While in the examples presented so far the always blocks are sensitive to the levels of signals, it is also possible to specify that a response should take place only at a particular edge of a signal. The desired edge is speciﬁed by using the Verilog keywords posedge andnegedge , which are used to implement edge-triggered circuits."
"This notation is called a blocking assignment. A Verilog compiler evaluates the statements in an always block in the order in which they are written. If a variable is given a value by a blocking assignment statement, then this new value is used in evaluating all subsequentstatements in the block."
"Q2<=Q1; the variables Q1 and Q2 have some value at the start of evaluating the always block, and then they change to a new value concurrently at the end of the always block. This code generates a cascaded connection between ﬂip-ﬂops, which implements the shift register depicted in Figure 5.39."
"There are two key aspects of the Verilog semantics relevant to this code: 1. The results of non-blocking assignments are visible only after all of the statements in thealways block have been evaluated. 2. When there are multiple assignments to the same variable inside an always block, the result of the last assignment is maintained."
"VLED=VDD, the cathode voltage is 0 V and the LED is on. The amount of current that ﬂows is limited by the value of the resistor RL. This current ﬂows through the LED and the inverter. Since the current ﬂows into the inverter, we say that the inverter sinks the current. The maximum current that a logic gate can sink without sustaining permanentdamage is usually called I"
"To calculate the minimum period of the clock signal, Tmin=1/F max, we need to consider all paths in the circuit that start and end at ﬂip-ﬂops. In this simple circuit there isonly one such path, which starts when data is loaded into the ﬂip-ﬂop by a positive clockedge, propagates to the Q output after the t cQdelay, propagates through the NOT gate, and ﬁnally must meet the setup requirement at the Dinput. Therefore"
"In the above analysis we assumed that the clock signal arrived at exactly the same time at all four ﬂip-ﬂops. We will now repeat this analysis assuming that the clock signal stillarrives at ﬂip-ﬂops Q 0,Q1, and Q 2simultaneously, but that there is a delay in the arrival of the clock signal at ﬂip-ﬂop Q 3. Such a variation in the arrival time of a clock signal at different ﬂip-ﬂops is called clock skew, tskew, and can be caused by a number of factors."
"The techniques described above for Fmaxand hold time analysis can be applied to any circuit in which the same, or related, clock signals are connected to all ﬂip-ﬂops. Consideragain the reaction-timer circuit in Figure 5.61. The clock divider in part ( a) of the ﬁgure generates the c 9signal, which drives the clock inputs of the ﬂip-ﬂops in the BCD counter."
"Figure P5.5 A ring oscillator. (a) Assume that all the inverters are identical; hence they all have the same delay, calledt p. Let the output of one of the inverters be named f. Give an equation that expresses the period of the signal fin terms of nandtp. (b) For this part you are to design a circuit that can be used to experimentally measure thedelay t pthrough one of the inverters in the ring oscillator. Assume the existence of an input called Reset and another called Interval. The timing of these two signals is shown in Figure"
"This type of circuit generates a counting sequence of pseudo-random numbers that repeats after 2n−1 clock cycles, where nis the number of ﬂip-ﬂops in the LFSR. Synthesize a circuit to implement the LFSR in a chip. Draw a diagram of the circuit. Simulate thecircuit’s behavior by loading the pattern 001 into the LFSR and then enabling the registerto count. What is the counting sequence?"
In preceding chapters we considered combinational logic circuits in which outputs are determined fully by the present values of inputs. We also discussed how simple storage elements can be implemented in the form of ﬂip-ﬂops. The output of a ﬂip-ﬂop depends on the state of the ﬂip-ﬂop rather than the value of its inputsat any given time; the inputs cause changes in the state.
"In this chapter we deal with a general class of circuits in which the outputs depend on the past behavior of the circuit, as well as on the present values of inputs. They are called sequential circuits. In most cases a clock signal is used to control the operation of a sequential circuit; such a circuit is called a synchronous sequential circuit. The alternative, in which no clock signal is used, is called an asynchronous sequential circuit. Synchronous circuits are easier to design and are used in a vast majority of practical applications;they are the topic of this chapter. Asynchronous circuits will be discussed in Chapter 9."
"Synchronous sequential circuits are realized using combinational logic and one or more ﬂip-ﬂops. The general structure of such a circuit is shown in Figure 6.1. The circuit has a set of primary inputs, W, and produces a set of outputs, Z. The stored values in the ﬂip-ﬂops are referred to as the state, Q, of the circuit."
"Although the outputs always depend on the present state, they do not necessarily have to depend directly on the primary inputs. Thus the connection shown in blue in the ﬁgure may or may not exist. To distinguishbetween these two possibilities, it is customary to say that sequential circuits whose outputs depend only onthe state of the circuit are of Moore type, while those whose outputs depend on both the state and the primary inputs are of Mealy type. These names are in honor of Edward Moore and George Mealy, who investigated the behavior of such circuits in the 1950s."
"Sequential circuits are also called ﬁnite state machines (FSMs), which is a more formal name that is often found in technical literature. The name derives from the fact that the functional behavior of these circuits can be represented using a ﬁnite number of states. In this chapter we will often use the term ﬁnite state machine, or simply machine, when referring to sequential circuits. 6.1 Basic Design Steps"
"The state table in Figure 6.4 deﬁnes the three states in terms of letters A,B, and C. When implemented in a logic circuit, each state is represented by a particular valuation (combi-nation of values) of state variables. Each state variable may be implemented in the form of a ﬂip-ﬂop. Since three states have to be realized, it is sufﬁcient to use two state variables.Let these variables be y 1andy2."
"The signals y1andy2are also fed back to the combinational circuit that determines the next state of the FSM. This circuit also uses the primary input signal w. Its outputs are two signals, Y1andY2, which are used to set the state of the ﬂip-ﬂops. Each active edge of the clock will cause the ﬂip-ﬂops to change their state according to the values of Y1and"
"Y2at that time. Therefore, Y1andY2are called the next-state variables, and y1andy2are called the present-state variables. We need to design a combinational circuit with inputs w,y1, and y2, such that for all valuations of these inputs the outputs Y1andY2will cause the machine to move to the next state that satisﬁes our speciﬁcation. The next step in the design process is to create a truth table that deﬁnes this circuit, as well as the circuit thatgenerates z."
"A computer system usually contains a number of registers that hold data during various operations. Sometimes it is necessary to swap the contents of two registers. Typically,this is done by using a temporary location, which is usually a third register. For example,suppose that we want to swap the contents of registers R1 and R2. We can achieve this by ﬁrst transferring the contents of R2 into the third register, say R3. Next, we transfer the contents of R1 into R2. Finally, we transfer the contents of R3 into R1."
"Bthe signals required to transfer the contents of R2 into R3 are asserted. The next active clock edge places these contents into R3. This clock edge also causes the circuit to change to state C, regardless of whether wis equal to 0 or 1. In this state the signals for transferring"
"R1 into R2 are asserted. The transfer takes place at the next active clock edge, and the circuit changes to state Dregardless of the value of w. The ﬁnal transfer, from R3t oR1, is performed on the clock edge that leaves state D, which also causes the circuit to return to state A."
"In general, circuits are much larger than our example, and different state assignments can have a substantial effect on the cost of the ﬁnal implementation. While highly desirable,it is often impossible to ﬁnd the best state assignment for a large circuit. The exhaustiveapproach of trying all possible state assignments is not practical because the number ofavailable state assignments is huge. CAD tools usually perform the state assignment usingheuristic techniques. These techniques are usually proprietary, and their details are seldompublished."
"In previous examples we used the minimum number of ﬂip-ﬂops to represent the states of the FSM. Another interesting possibility is to use as many state variables as there are states.In this method, for each state all but one of the state variables are equal to 0. The variablewhose value is 1 is deemed to be “hot.” The approach is known as the one-hot encoding method."
"Note that none of the next-state variables depends on the present-state variable y2. This suggests that the second ﬂip-ﬂop and the expression Y2=wy1are not needed. (CAD tools detect and eliminate such redundancies!) But even then, the derived expressions are not simpler than those obtained using the state assignment in Figure 6.16. Although in this casethe one-hot assignment is not advantageous, there are many cases where this approach isattractive."
The examples considered to this point show that there are many ways to implement a given ﬁnite state machine as a sequential circuit. Each implementation is likely to have adifferent cost and different timing characteristics. In the next section we introduce anotherway of modeling FSMs that leads to even more possibilities. 6.3 Mealy State Model
"The preceding discussion deals with the basic principles involved in the design of sequential circuits. Although it is essential to understand these principles, the manual approach used in the examples is difﬁcult and tedious when large circuits are involved. Wewill now show how CAD tools are used to greatly simplify the design task. 6.4 Design of Finite State Machines Using CAD Tools"
"Sophisticated CAD tools are available for ﬁnite state machine design, and we introducethem in this section. A rudimentary way of using CAD tools for FSM design could beas follows: The designer employs the manual techniques described previously to derive acircuit that contains ﬂip-ﬂops and logic gates from a state diagram. This circuit is enteredinto the CAD system by drawing a schematic diagram or by writing structural hardwaredescription language (HDL) code. The designer then uses the CAD system to simulate thebehavior of the circuit and uses the CAD tools to automatically implement the circuit in achip, such as a PLD."
"CAD system and perform the entire synthesis process automatically. CAD tools support this approach in two main ways. One method is to allow the designer to draw the statediagram using a graphical tool similar to the schematic capture tool. The designer drawscircles to represent states and arcs to represent state transitions and indicates the outputsthat the machine should generate. Another and more popular approach is to write HDLcode that represents the state diagram, as described below."
"The state transitions are speciﬁed by two separate always blocks. The ﬁrst block describes the required combinational circuit. It uses a case statement to give the value of the next state Yfor each value of the present state y. Each case alternative corresponds to a present state of the machine, and the associated if-else statement speciﬁes the next state to be reached according to the value of w. This portion of the code corresponds to the combinational circuit on the left side of Figure 6.5."
"Having examined the simulation output, we should consider the question of whether we can conclude that the circuit functions correctly and satisﬁes all requirements. For our simple example it is not difﬁcult to answer this question because the circuit has only one input and its behavior is straightforward. It is easy to see that the circuit works properly."
"In the preceding example we saw that a Mealy-type FSM nicely meets the requirement for implementing the serial adder. Now we will try to achieve the same objective using aMoore-type FSM. A good starting point is the state diagram in Figure 6.40. In a Moore-typeFSM, the output must depend only on the state of the machine. Since in both states, Gand"
"It is possible to deﬁne a minimization procedure that searches for any states that are equiv-alent. Such a procedure is very tedious to perform manually, but it can be automated foruse in CAD tools. We will not pursue it here, because of its tediousness. However, to pro-vide some appreciation of the impact of state minimization, we will present an alternativeapproach, which is much more efﬁcient but not quite as broad in scope."
"From Deﬁnition 6.1 it follows that if the states SiandSjare equivalent, then their corresponding k-successors (for all k) are also equivalent. Using this fact, we can formulate a minimization procedure that involves considering the states of the machine as a set andthen breaking the set into partitions that comprise subsets that are deﬁnitely not equivalent."
"P2. The 1-successors are (ECDG ). Since these states are not in the same block in P2,i t means that at least one of the states in the block (CEFG )is not equivalent to the others. In particular, the state Fmust be different from the states C,E, and Gbecause its 1-successor isD, which is in a different block than C,E, and G. Hence"
"Since P5=P4and no new blocks are generated, it follows that states in each block are equivalent. If the states in some block were not equivalent, then their k-successors would have to be in different blocks. Therefore, states AandDare equivalent, and C,E, and G are equivalent. Since each block can be represented by a single state, only four states are needed to implement the FSM deﬁned by the state table in Figure 6.51. If we let the symbolArepresent both the states AandDin the ﬁgure and the symbol Crepresent the states C,"
"The effect of the minimization is that we have found a solution that requires only two ﬂip-ﬂops to realize the four states of the minimized state table, instead of needing threeﬂip-ﬂops for the original design. The expectation is that the FSM with fewer states will besimpler to implement, although this is not always the case."
"All electronic signals in the vending machine are synchronized to the positive edge of a clock signal, named Clock. The exact frequency of the clock signal is not important for our example, but we will assume a clock period of 100 ns. The vending machine’s coin-receptor mechanism generates two signals, sense Dandsense N, which are asserted when a dime or a nickel is detected. Because the coin receptor is a mechanical device and thus very slowcompared to an electronic circuit, inserting a coin causes sense"
"Note that the condition D=N=1 is denoted as don’t care in the table. Note also other don’t cares in states S4,S5,S7,S8, and S9. They correspond to cases where there is no need to check the DandNsignals because the machine changes to another state in an amount of time that is too short for a new coin to have been inserted."
"The ﬁnal partition has ﬁve blocks. Let S2 denote its equivalence to S6, let S4 denote the same with respect to S7 and S8, and let S5 represent S9. This leads to the minimized state table in Figure 6.56. The actual circuit that implements this table can be designed as explained in the previous sections."
"Three state variables are needed to represent the eight states. Let these variables, denoting the present state, be called y2,y1, and y0. Let Y2,Y1, and Y0denote the corresponding next-state functions. The most convenient (and simplest) state assignment is to encode each state with the binary number that the counter should give as output in that state. Thenthe required output signals will be the same as the signals that represent the state variables."
"A state-assigned table is essentially the state table in which each state is encoded using the state variables. When D ﬂip-ﬂops are used to implement an FSM, the next-state entries in the state-assigned table correspond directly to the signals that must be applied to theDinputs. This is not the case if some other type of ﬂip-ﬂops is used. A table that gives the state information in the form of the ﬂip-ﬂop inputs that must be “excited” to cause thetransitions to the next states is usually called an excitation table. The excitation table in"
"A state diagram for the desired FSM, designed as a Moore-type machine, is depicted in Figure 6.72. Initially, on reset the machine is in the state called Idle. No grant signals are asserted, and the shared resource is not in use. There are three other states, called gnt1, gnt2, and gnt3. Each of these states asserts the grant signal for one of the devices."
"To analyze a circuit, we simply reverse the steps of the synthesis process. The outputs of the ﬂip-ﬂops represent the present-state variables. Their inputs determine the next statethat the circuit will enter. From this information we can construct the state-assigned tablefor the circuit. This table leads to a state table and the corresponding state diagram bygiving a name to each state. The type of ﬂip-ﬂops used in the circuit is a factor, as we willsee in the examples that follow."
"This chapter has presented the synchronous sequential circuits using a rather informal approach because this is the easiest way to grasp the concepts that are essential in designing such circuits. The same topics can also be presented in a more formal manner, which hasbeen the style adopted in many books that emphasize the switching theory aspects ratherthan the design using CAD tools. A formal model often gives a concise speciﬁcation thatis difﬁcult to match in a more descriptive presentation. In this section we will describe aformal model that represents a general class of sequential circuits, including those of thesynchronous type."
"There are delay elements in the feedback paths for the state-variables which ensure that y will take the values of Yafter a time delay /Delta1. In the case of synchronous sequential circuits, the delay elements are ﬂip-ﬂops, which change their state on the active edge of a clock signal. Thus the delay /Delta1is determined by the clock period. The clock period must be long enough to allow for the propagation delay in the combinational circuit, in additionto the setup and hold parameters of the ﬂip-ﬂops."
"The existence of closed loops and delays in a sequential circuit leads to a behavior that is characterized by the set of states that the circuit can reach. The present values of the inputs are not the sole determining factor in this behavior, because a given valuation of inputs maycause the circuit to behave differently in different states."
The propagation delays through a sequential circuit must be taken into account. The design techniques presented in this chapter are based on the assumption that all changes inthe circuit are triggered by the active edge of a clock signal. Such circuits work correctlyonly if all internal signals are stable when the clock signal arrives. Thus the clock periodmust be longer than the longest propagation delay in the circuit.
"In the previous chapters we showed how to design many types of simple circuits, such as multiplexers, decoders, ﬂip-ﬂops, registers, and counters, which can be used as building blocks. In this chapter we provide examples of more complex circuits that can be constructed using the building blocks as subcircuits. Suchlarger circuits form a digital system. For practical reasons our examples of digital systems will not be large, but the design techniques presented are applicable to systems of any size."
"Therefore, some special gates are needed if the outputs of two registers are to be connected to a common set of wires. A commonly used circuit element for this purpose is shownin Figure 7.1a . It has a data input w, an output f, and an enable input e. Its operation is illustrated by the equivalent circuit in part (b). The triangular symbol in the ﬁgure representsa noninverting driver, which is a circuit that performs no logic operation and its outputsimply replicates the input signal. Its purpose is to provide additional electrical drivingcapability. In conjunction with the output switch, it behaves as indicated in Figure 7.1c ."
"It is essential to ensure that only one circuit block attempts to place data onto the bus wires at any given time. The control circuit must ensure that only one of the tri-statedriver enable signals, R1 out,...,Rk out, is asserted at a given time. The control circuit also produces the signals R1in,...,Rk in, which determine when data is loaded into each register."
"In general, the control circuit could perform a number of functions, such as transferring thedata stored in one register into another register and controlling the processing of data invarious functional units of the system. Figure 7.2 shows an input signal named Function that instructs the control circuit to perform a particular task. The control circuit is synchronizedby a clock input, which is the same clock signal that controls the kregisters."
"Note that we say that the contents of one register, Ri, are “transferred” into another register, Rj. This jargon is commonly used to indicate that the new contents of Rjwill be a copy of the contents of Ri. The contents of Riare not changed as a result of the transfer."
"The same FSM control circuit is used. However, the control signals R1out ,R2out , andR3out are not needed because tri-state drivers are not used. Instead, the required multiplexers are deﬁned in an if-else statement by specifying the source of data based on the state of the FSM. Hence, when the FSM is in state A, the selected input to the multiplexers isData. When the state is B, the register R2 provides the input data to the multiplexers, and so on. 7.2 Simple Processor"
"SubRx,Ry Rx←[Rx]−[ Ry] theLoad operation the meaning of Rx←Data is that the data on the external Data input is transferred across the bus into any register, Rx, where Rxcan be R0t oR3. The Move operation copies the data stored in register Ryinto register Rx. In the table the square brackets, as in [Rx], refer to the contents of a register. Since only a single transfer across the bus is needed, both the Load andMove operations require only one step (clock cycle) to be completed. The AddandSuboperations require three steps, as follows: In the ﬁrst step the contents of Rxare transferred across the bus into register A. Then in the next step, the contents of Ryare placed onto the bus. The adder/subtractor module performs the required function, and the results are stored in register G. Finally, in the third step the contents of G are transferred into Rx."
"We will develop the expressions for R0inandR0outby examining Table 7.2 and then show how to derive the expressions for the other register control signals. The table shows thatR0inis set to the value of X0in the ﬁrst step of both the Load andMove operations and in the third step of both the AddandSuboperations, which leads to the expression"
"Figure 7.13 Code for the processor (Part a). signal, and the two-bit signal Count is used instead of T. These signals are used in the case statements. The code sets Ito the value of the two left-most bits in the Function Register, which correspond to the stored values of the input F."
"The number of clock cycles that the circuit requires to generate the ﬁnal product is determined by the left-most digit in Bthat is 1. It is possible to reduce the number of clock cycles needed by using more complex shift registers for AandB. If the two right-most bits inBare both 0, then both AandBcould be shifted by two bit positions in one clock cycle."
"Given two unsigned n-bit numbers AandB, we wish to design a circuit that produces two n-bit outputs Q and R, where Q is the quotient A/BandRis the remainder. The procedure illustrated in Figure 7.28 bcan be implemented by shifting the digits in Ato the left, one digit at a time, into a shift register R. After each shift operation, we compare Rwith"
"We need n-bit shift registers that shift right to left for A,R, and Q. An n-bit register is needed for B, and a subtractor is needed to produce R−B. We can use an adder module in which the carry-in is set to 1 and Bis complemented. The carry-out, c out, of this module has the value 1 if the condition R≥Bis true. Hence the carry-out can be connected to the serial input of the shift register that holds Q, so that it is shifted into Q in state S3. Since"
"S3 for 2n clock cycles. If these states can be merged into a single state, then the number of clock cycles needed can be reduced to n. In state S3, if cout=1, we load the sum output (result of the subtraction) from the adder into R, and (assuming z=0) change to state S2."
"Assume that kn-bit numbers are stored in a set of registers R0,...,R k−1. We wish to design a circuit that computes the mean Mof the numbers in the registers. The pseudo-code for a suitable algorithm is shown in Figure 7.37a . Each iteration of the loop adds the contents of one of the registers, denoted Ri,t oa Sum variable. After the sum is computed, Mis obtained as Sum/k . We assume that integer division is used, so a remainder R, not shown in the code, is produced as well."
"Each iteration of the outer loop places the number in RiintoA. Each iteration of the inner loop compares this number to the contents of another register Rj. If the number in Rjis smaller than A, the contents of RiandRjare swapped and Ais changed to hold the new contents of Ri."
"Cithat represents iin the outer loop is cleared. When the machine changes to state S2,Ais loaded with the contents of Ri. Also, Cj, which represents jin the inner loop, is initialized to the value of i. State S3 is used to initialize jto the value i+1, and state S4 loads the value of RjintoB. In state S5,AandBare compared, and if B<A, the machine moves to state S6. States S6 and S7 swap the values of RiandRj. State S8 loads Afrom Ri. Although this step is necessary only for the case where B<A, the ﬂow of control is simpler if this operation is performed in both cases. If Cjis not equal to k−1, the machine changes from"
"Verilog code for the sorting operation is presented in Figure 7.45. The FSM that controls the sort operation is described in the same way as in previous examples, using the always blocks State_table, State_ ﬂipﬂops, and FSM_outputs. Following these blocks, the code instantiates the registers R0toR3, as well as AandB. The counters CiandCjhave the instance names OuterLoop andInnerLoop, respectively. The multiplexers with the outputs"
"Figure 7.47 An H tree clock distribution network. of a ﬂip-ﬂop; for clarity, the ﬂip-ﬂops are not shown. The buffer on the left of the ﬁgure produces the clock signal. This signal is distributed to the ﬂip-ﬂops such that the length ofthe wire between each ﬂip-ﬂop and the clock source is the same. Due to the appearance ofsections of the wires, which resemble the letter H, the clock distribution network is knownas an Ht r e e . In PLDs the term global clock refers to the clock network. A PLD chip usually provides one or more global clocks that can be connected to all ﬂip-ﬂops. Whendesigning a circuit to be implemented in such a chip, a good design practice is to connectall the ﬂip-ﬂops in the circuit to a single global clock."
"We discussed the timing parameters for storage elements in Chapter 5. Data to be clocked into a ﬂip-ﬂop must be stable tsubefore the active clock edge and must remain stable thafter the clock edge. A change in the value of the output Q appears after the clock-to-Q delay, tcQ.A n output delay time, tod, is required for the change in Q to propagate to an output pin on the chip. These timing parameters account for the behavior of an individual ﬂip-ﬂop without considering how the ﬂip-ﬂop is connected to other circuitry in an integrated circuitchip."
"Figure 7.48 depicts a ﬂip-ﬂop as part of an integrated circuit. Connections are shown from the ﬂip-ﬂop’s clock, D, and Q terminals to pins on the chip package. There is an input buffer associated with each pin on the chip. Other circuitry may also be connected to theﬂip-ﬂop; the shaded box represents a combinational circuit connected to D. The propagation delays between the pins on the chip package and the ﬂip-ﬂop are labeled in the ﬁgure ast"
"In digital systems the output signals from one chip are used as the input signals to another chip. Often the ﬂip-ﬂops in all chips are driven by a common clock that has lowskew. The signals must propagate from the Q outputs of ﬂip-ﬂops in one chip to the D inputs of ﬂip-ﬂops in another chip. To ensure that all timing speciﬁcations are met, it isnecessary to consider the output delays in one chip and the input delays in another."
Thet codelay determines how long it takes from when an active clock edge occurs at the clock pin on the chip package until a change in the output of a ﬂip-ﬂop appears at anoutput pin on the chip. This delay consists of three main parts. The clock signal must ﬁrstpropagate from its input pin on the chip to the ﬂip-ﬂop’s Clock input. This delay is labeled t
"If chips are separated by a large distance, the propagation delays between them must be taken into consideration. But in most cases the distance between chips is small, and the propagation time of signals between the chips is negligible. Once a signal reaches the inputpin on a chip, the relative values of t"
"Commercial chips, such as PLDs, specify the minimum allowable clock period that has to be used for the circuit in Figure 7.50 to solve the metastability problem. In practice, it isnot possible to guarantee that node Awill always be stable before a clock edge occurs. The data sheets specify a probability of node Abeing stable, as a function of the clock period."
"FSMs as well as building blocks like adders, registers, shift registers, and counters. We have shown how ASM charts can be used as an aid for designing a digital system, and we haveshown how the circuits can be described using Verilog code. A number of practical issueshave been discussed, such as clock distribution, synchronization of asynchronous inputs,and switch debouncing. Some notable books that also deal with the material presented inthis chapter include [3–10]."
References 489 a desired clock signal. It is possible to choose both the period of the clock signal and its duty cycle. The term duty cycle refers to the percentage of the clock period for which the signal is high. The following equations deﬁne the clock signal produced by the chip
"In Chapter 2 we showed how to ﬁnd the lowest-cost implementations of logic functions by using either algebraic manipulation or Karnaugh maps. The reader is probably convinced that it is not at all obvious how to apply the theorems of Boolean algebra to ﬁnd a minimum-cost circuit. Karnaugh maps provide asystematic way of manually deriving minimum-cost implementations of simple logic functions, but theybecome impractical for functions of many variables."
"If CAD tools are used to design logic circuits, the task of minimizing the cost of implementation does not fall to the designer; the tools perform the necessary optimizations automatically. Even so, it is important toknow something about this process. Most CAD tools have many features and options that are under controlof the user. To know when and how to apply these options, the user must have an understanding of what thetools do."
"In the sum-of-products form, the ﬁrst level comprises AND gates that are connected toa second-level OR gate. In the product-of-sums form, the ﬁrst-level OR gates feed thesecond-level AND gate. We have assumed that both true and complemented versions of theinput variables are available so that NOT gates are not needed to complement the variables."
"A two-level realization is usually efﬁcient for functions of a few variables. However, as the number of inputs increases, a two-level circuit may result in logic gates that have toomany inputs. Whether or not this is an issue depends on the type of technology that is usedto implement the circuit. For example, consider the following function: f(x 1,...,x 7)=x1x3x6+x1x4x5x6+x2x3x7+x2x4x5x7"
"This is a minimum-cost SOP expression. Now consider implementing fin two types of chips: a CPLD and an FPGA. Figure 8.1 shows a logic element in a typical CPLD, likethose shown in Appendix B. The ﬁgure indicates in blue the circuitry used to realize thefunction f. The CPLD architecture is well-suited for SOP implementations."
"In the preceding example, the number of inputs, or fan-in, of each LUT is restricted to four because of the FPGA architecture. But even if we were to make a custom chip to implement a circuit it would still be necessary to limit the fan-in of gates. This limit iscaused by practical issues related to transistor technology, which is discussed in AppendixB. Suppose that the available gates in a custom chip have a maximum fan-in of four. Then,if a logic expression includes a seven-input product term, we would have to use 2 four-input"
"Because our objective is to design the lowest-cost combined circuit that implements f1 andf2, it seems that the best result can be achieved if we use the factored forms for both functions, in which case the sum term (x3+x4)can be shared. Moreover, observing that x1x2=x1+x2, the sum term (x1+x2)can also be shared if we express f1in the form f1=x3x4+x1+x2(x3+x4)"
"In the preceding examples, which illustrated the factoring approach, multilevel circuits were used to deal with fan-in limitations. However, such circuits may be preferable totheir two-level equivalents even if fan-in is not a problem. In some cases the multilevelcircuits may reduce the cost of implementation. On the other hand, they usually implylonger propagation delays, because they use multiple stages of logic gates. We will explorethese issues by means of illustrative examples."
"Complexity of a logic circuit can often be reduced by decomposing a two-level circuit into subcircuits, where one or more subcircuits implement functions that may be used inseveral places to construct the ﬁnal circuit. To achieve this objective, a two-level logicexpression is replaced by two or more new expressions, which are then combined to deﬁnea multilevel circuit. We can illustrate this idea by a simple example."
"Observing that g=x3⊕x4leads to the circuit shown in Figure 8.6b. It has ﬁve logic gates plus nine inputs to gates, leading to a total cost of 13. The cost of this multilevel circuit is signiﬁcantly lower than that of the SOP implementation of f. The trade-off is an increased propagation delay because the circuit has an extra level of logic."
"In the two preceding examples, the decomposition is such that a decomposed subfunction depends on some primary input variables, whereas the remainder of the implementationdepends on the rest of the variables. Such decompositions are called disjoint decompositions in the technical literature. It is possible to have a non-disjoint decomposition, where the variables of the subfunction are also used in realizing the remainder of the circuit. Thefollowing example illustrates this possibility."
"Functional decomposition is a powerful technique for reducing the complexity of circuits. A big problem in functional decomposition is ﬁnding the possible subfunctions. For functions of many variables, an enormous number of possibilities should be tried. Thissituation precludes attempts at ﬁnding optimal solutions. Instead, heuristic approaches thatlead to acceptable solutions are used."
"In Section 2.7 we showed that two-level circuits consisting of AND and OR gates canbe easily converted into circuits that can be realized with NAND and NOR gates, usingthe same gate arrangement. In particular, an AND-OR (sum-of-products) circuit can berealized as a NAND-NAND circuit, while an OR-AND (product-of-sums) circuit becomesa NOR-NOR circuit. The same conversion approach can be used for multilevel circuits."
"Binary decision diagrams (BDDs) represent logic functions in the form of a graph. BDDs are attractive for use in CAD tools because a logic function can be represented as a BDDwithout requiring a lot of memory space. To illustrate how we can derive a BDD fora function f, consider the two-variable truth table shown in Figure 8.19 a. A graph that corresponds to this truth table is given in part (b) of the ﬁgure in the form of a decision tree."
"Also, let the don’t-cares be speciﬁed as minterms. This allows us to create a list of vertices for which either f=1 or it is a don’t-care condition. We can compare these vertices in pairwise fashion to see if they can be combined into larger cubes. Then we can attempt tocombine these new cubes into still larger cubes and continue the process until we ﬁnd theprime implicants."
"Having generated the set of all prime implicants, it is necessary to choose a minimumcost subset that covers all minterms for which f=1. As a simple measure we will assume that the cost is directly proportional to the number of inputs to all gates, which means to the number of literals in the prime implicants chosen to implement the function."
"In this example we used the concept of row dominance to reduce the cover table. We removed the dominated rows because they cover fewer minterms and the cost of their prime implicants is the same as the cost of the prime implicants of the dominating rows. However,a dominated row should not be removed if the cost of its prime implicant is less than thecost of the dominating row’s prime implicant."
"The initial prime implicant cover table is shown in Figure 8.29a . There are no essential prime implicants. Also, there are no dominant rows or columns. Moreover, all prime implicants have the same cost because each of them is implemented with two literals. Thus, the tabledoes not provide any clues that can be used to select a minimum-cost cover."
"Assume that the initial speciﬁcation of a function fis given in terms of implicants that are not necessarily either minterms or prime implicants. Then it is convenient to deﬁne an operationthat will generate other implicants that are not given explicitly in the initial speciﬁcation,but which will eventually lead to the prime implicants of f. One such possibility is known as the ∗-product operation, which is usually pronounced the “star-product” operation. We will refer to it simply as the ∗-operation. ∗-Operation"
"The∗-operation provides a simple way of deriving a new cube by combining two cubes that differ in the value of only one variable. Let A=A 1A2···A nandB=B1B2···B nbe two cubes that are implicants of an n-variable function. Thus each coordinate AiandBi is speciﬁed as having the value 0, 1, or x. There are two distinct steps in the ∗-operation."
"The result of the ∗-operation may be a smaller cube than the two cubes involved in the operation. Consider A={1x1} andB={11x}. Then C=A∗B={111}. Notice that C is included in both AandB, which means that this cube will not be useful in searching for prime implicants. Therefore, it should be discarded by the minimization algorithm."
"As a ﬁnal example, consider A={x10} andB={0x1}. Then C=A∗B={01x}. All three of these cubes are the same size, but Cis not included in either AorB. Hence Chas to be considered in the search for prime implicants. The reader may ﬁnd it helpful to draw a Karnaugh map to see how cube Cis related to cubes AandB."
"Again, let A=A1A2···A nandB=B1B2···B nbe two cubes (implicants) of an nvariable function. The sharp operation A#Bleaves as a result “that part of Athat is not covered by B.” Similar to the ∗-operation, the #-operation has two steps: Ai#Biis evaluated for each coordinate i, and then a set of rules is applied to determine the overall result."
"The second condition reﬂects the case where Ais fully covered by B. For example, 0x1 # 0xx =ø. The third condition is for the case where only a part of Ais covered by B.I n this case the #-operation generates one or more cubes. Speciﬁcally, it generates one cube for each coordinate ithat is x in Ai, but is not x in Bi. Each cube generated is identical to"
"This means that piis essential if there exists at least one vertex for which f=1 that is covered by pi, but not by any other prime implicant. The #-operation is also performed with the set of don’t-care cubes because vertices in pithat correspond to don’t-care conditions are not essential to cover. The meaning of pi#(P−pi)is that the #-operation is applied successively to each prime implicant in P. For example, consider P={p1,p2,p3,p4}and"
"Prime implicants of fcan be generated using the ∗-operation, and the #-operation can be used to ﬁnd the essential prime implicants. If the essential prime implicants cover the entire ON-set, then they form the minimum-cost cover for f. Otherwise, it is necessary to include other prime implicants until all vertices in the ON-set are covered."
"The purpose of the above discussion was to give the reader some idea about how minimization of logic functions may be automated for use in CAD tools. We chose a schemethat is not too difﬁcult to explain. From the practical point of view, this scheme has somedrawbacks. The main difﬁculty is that the number of cubes that must be considered in theprocess can be extremely large."
"If the goal of minimization is relaxed so that it is not imperative to ﬁnd a minimum-cost implementation, then it is possible to derive heuristic techniques that produce good resultsin reasonable time. A technique of this type forms the basis of the widely used Espressoprogram, which is available from the University of California at Berkeley via the World"
"To describe CAD tools, some new terminology has been invented. In particular, we should mention two terms that are widely used in industry: technology-independent logic synthesis andtechnology mapping. The ﬁrst term refers to techniques that are applied when optimizing a circuit without considering the resources available in the target chip. Most of the techniques presented in this chapter are of this type. The second term, technologymapping, refers to techniques that are used to ensure that the circuit produced by logicsynthesis can be realized using the logic resources available in the target chip. A goodexample of technology mapping is the transformation from a circuit in the form of logicoperations such as AND and OR into a circuit that consists of only NAND operations. Thistype of technology mapping is done when targeting a circuit to a gate array that containsonly NAND gates. Another example is the translation from logic operations to lookuptables, which is done when targeting a design to an FPGA."
"This chapter has attempted to provide the reader with an understanding of various aspects of synthesis for logic functions. In the next chapter we discuss asynchronous sequentialcircuits. In the design of these circuits we will make use of many of the synthesis techniquescovered in the previous chapters, as well as the cubical notation that we introduced in thischapter. 8.6 Examples of Solved Problems"
"This implementation requires two AND gates, two OR gates, and 10 inputs to the gates, for a total cost of 14. Compared to the SOP and POS implementations, this has the lowest cost in terms of gates and inputs, but it results in a slower circuit because there are three levelsof gates through which the signals must propagate."
"Changes in state can occur on the positive or negative edge of each clock pulse. Since they are controlled bypulses, synchronous sequential circuits are said to operate in pulse mode. In this chapter we present sequential circuits that do not operate in pulse mode and do not use ﬂip-ﬂops to represent state variables. These circuitsare called asynchronous sequential circuits."
"To achieve reliable operation, the inputs to the circuit must change in a speciﬁc manner. In this introductory discussion we will concentrate on the simplest case in which a constraint is imposed that the inputs mustchange one at a time. Moreover, there must be sufﬁcient time between the changes in input signals to allowthe circuit to reach a stable state, which is achieved when all internal signals stop changing. A circuit that adheres to these constraints is said to operate in the fundamental mode."
"Asynchronous circuits are much more difﬁcult to design than synchronous circuits. Specialized techniques, which are beyond the scope of this book, have been developed for dealing with large asynchronouscircuits. Our main reason for the discussion in this chapter is the fact that the asynchronous circuits, evenin their simplest form, provide an excellent vehicle for gaining a deeper understanding of the operation ofdigital circuits in general. In particular, they illustrate the timing issues caused by propagation delays in logiccircuits."
The design approaches presented in this chapter are classical techniques that are suitable only for very small circuits. They are easy to understand and they demonstrate the problems that arise from timing con-straints. In synchronous circuits these problems are avoided by using a clock as a synchronizing mechanism. 9.1 Asynchronous Behavior
"The concept of stable states is very important in the context of asynchronous sequential circuits. For a given valuation of inputs, if a circuit reaches a particular state and remains in this state, then the state is said to be stable. To clearly indicate the conditions under which the circuit is stable, it is customary to encircle the stable states in the table, as illustrated in"
"If we were deriving a synchronous sequential circuit using the methods in Chapter 6, thenYwould be connected to the Dinput of a ﬂip-ﬂop and a clock signal would be used to control the time when the changes in state take place. But since we are synthesizing anasynchronous circuit, we do not insert a ﬂip-ﬂop in the feedback path. Instead, we create acircuit that realizes the preceding expression using the necessary logic gates, and we feedback the output signal as the present-state input y. Implementation using NOR gates results in the circuit in Figure 9.1a . This simple example suggests that asynchronous circuits and synchronous circuits can be synthesized using similar techniques. However, we will seeshortly that for more complex asynchronous circuits, the design task is considerably moredifﬁcult."
"To gain familiarity with asynchronous circuits, it is useful to analyze a few examples. We will keep in mind the general model in Figure 6.85, assuming that the delays in the feedbackpaths are a representation of the propagation delays in the circuit. Then each gate symbolwill represent an ideal gate with zero delay."
"This diagram actually implements a control mechanism for a simple vending machine that accepts two types of coins, say, dimes and nickels, and dispenses merchandise such ascandy. If w 1represents a nickel and w2represents a dime, then a total of 10 cents must be deposited to get the FSM into state Cwhere the candy is released. The coin mechanism accepts only one coin at a time, which means that w2w1=11 can never occur. Therefore, the transition discussed above, from BtoC, through the unstable state Dwould not occur."
"Synthesis of asynchronous sequential circuits follows the same basic steps used to synthesizethe synchronous circuits, which were discussed in Chapter 6. There are some differencesdue to the asynchronous nature, which make the asynchronous circuits more difﬁcult todesign. We will explain the differences by investigating a few design examples. The basicsteps are •Devise a state diagram for an FSM that realizes the required functional behavior. •Derive the ﬂow table and reduce the number of states if possible. •Perform the state assignment and derive the excitation table. •Obtain the next-state and output expressions. •Construct a circuit that implements these expressions."
The uncertainty caused by multiple changes in the state variables in response to an input that should lead to a predictable change from one stable state to another has to be eliminated. The term race condition is used to refer to such unpredictable behavior. We will discuss this issue in detail in Section 9.5.
"In the preceding derivation we designed a circuit that changes its state on every edge of the input signal w, requiring a total of eight states. Since the circuit is supposed to count the number of complete pulses, which contain a rising and a falling edge, the output countz 2z1changes its value only in every second state. This FSM behaves like a synchronous sequential circuit in which the output count changes only as a result of wchanging from 0 to 1."
"We will now consider an example of a simple arbiter implemented as an asynchronous sequential circuit. To keep the example small, suppose that two devices are competingfor the shared resource, as indicated in Figure 9.19a . Each device communicates with the arbiter by means of two signals—Request andGrant. When a device needs to use the shared resource, it raises its Request signal to 1. Then it waits until the arbiter responds with theGrant signal."
"The ﬂow table for this FSM is given in Figure 9.26 b. It shows explicitly all don’t-care entries. Such unspeciﬁed entries provide a certain amount of ﬂexibility that can be exploited in reducing the number of states. Note that in each row of this table there is only one stablestate. Such tables, where there is only one stable state for each row, are often referred to asprimitive ﬂow tables."
"In Example 9.7 it was easy to decide which rows should be merged because the only possibilities are to merge row Cwith either AorE. We chose to merge CandEbecause this can be done preserving the Moore model, which is likely to lead to a simpler expression that realizes the output z."
"Deﬁnition 9.1 –Two states (rows in a ﬂow table), S iand S j, are said to be compatible if there are no state conﬂicts for any input valuation. Thus for each input valuation, one ofthe following conditions must be true: •both S iand S jhave the same successor, or •both S iand S jare stable, or •the successor of S ior S j, or both, is unspeciﬁed."
"Consider the primitive ﬂow table in Figure 9.28. Let us examine the compatibility between different states, assuming that we would like to retain the Moore-type speciﬁcationof outputs for this FSM. State Ais compatible only with state H. State Bis compatible with states FandG. State Cis not compatible with any other state. State Dis compatible with state E; so are state Fwith Gand state Gwith H. In other words, the following compatible pairs exist: (A,H),(B,F),(B,G),(D,E),(F,G), and (G,H). The compatibility relationship among various states can be represented conveniently in the form of a merger diagram, as follows:"
"Any set of rows that are pairwise compatible for all pairs in the set can be merged into a single state. Thus states B,F, and Gcan be merged into a single state, but only if states G andHare not merged. State Ccannot be merged with any other state. States DandEcan be merged."
"In this case going to the Mealy model is unlikely to result in a simpler circuit. Although several merger possibilities exist, they all require at least four states in the reduced ﬂowtable, which is not any better than the solution obtained in Figure 9.30. For example, onepossibility is to perform the merge based on the partition (A,H),(B,C,G)(D,E)(F)."
"Mealy model. When going from the Moore model to the Mealy model, a stable state in the Mealy model must generate the same output as it had in the Moore model. It is alsoimportant to ensure that transitions in the Mealy model will not produce undesirable glitchesin the output signal."
"FSMs is complex. The time needed to change the value of a state variable depends on the propagation delays in the circuit. Thus it is impossible to ensure that a change in thevalues of two or more variables will take place at exactly the same time. To achieve reliableoperation of the circuit, the state variables should change their values one at a time incontrolled fashion. This is accomplished by designing the circuit such that a change fromone state to another entails a change in one state variable only."
"A good state assignment results if the transition diagram does not have any diagonal paths. A general way of stating this requirement is to say that it must be possible to embed the transition diagram onto a k-dimensional cube, because in a cube all transitions between adjacent vertices involve the Hamming distance of 1. Ideally, a transition diagram for an"
"To depict the possibility of having alternative paths, we will indicate in blue the corresponding transitions on the diagram. Thus a complete transition diagram will show alldirect transitions to stable states in black and possible indirect transitions through unstablestates in blue. Figure 9.51b shows the complete transition diagram for the ﬂow table in"
"The outputs are speciﬁed using the Moore model, because the only unstable states are those involved in changing from one member of the equivalent pair to another, and bothmembers generate the same outputs. For instance, in the previously described transitionfrom AtoC, if the starting point is A2, it is necessary to go ﬁrst to A1 and then to C1. Even though A1 is unstable for w 2w1=10, there is no problem because its output is the same as that of A2. Therefore, if the original ﬂow table is deﬁned using the Moore model, then the modiﬁed ﬂow table can also be done using the Moore model."
"Figure 9.60. The four states, A,B,C, and D, are assigned one-hot codes. As seen in the ﬁgure, it is necessary to introduce six unstable states, Ethrough J, to handle the necessary transitions. These unstable states have to be speciﬁed only for the speciﬁc transitions,whereas for other input valuations they may be treated as don’t cares."
"The outputs can be speciﬁed using the Moore model. In some cases it does not matter when a particular output signal changes its value. For instance, state Eis used to facilitate the transition from state AtoC. Since z 2z1=00 in Aand 10 in C, it is not important if z2 changes when passing through state E."
In asynchronous sequential circuits it is important that undesirable glitches on signals should not occur. The designer must be aware of the possible sources of glitches and ensure thatthe transitions in a circuit will be glitch free. The glitches caused by the structure of a givencircuit and propagation delays in the circuit are referred to as hazards. Two types of hazards are illustrated in Figure 9.61.
"A potential hazard exists wherever two adjacent 1s in a Karnaugh map are not covered by a single product term. Therefore, a technique for removing hazards is to ﬁnd a coverin which some product term includes each pair of adjacent 1s. Then, since a change in aninput variable causes a transition between two adjacent 1s, no glitch can occur because both1s are included in a product term."
"Example 9.17 From the previous examples, it seems that static hazards can be avoided by including all prime implicants in a sum-of-products circuit that realizes a given function. This is indeedtrue. But it is not always necessary to include all prime implicants. It is only necessaryto include product terms that cover the adjacent pairs of 1s. There is no need to cover thedon’t-care vertices."
"Asynchronous sequential circuits are more difﬁcult to design than the synchronous sequential circuits. The difﬁculties with race conditions present a problem that must be handled carefully. At the present time there is little CAD support for designing asynchronous cir-cuits. For these reasons, most designers resort to synchronous sequential circuits in practicalapplications."
"An important advantage of asynchronous circuits is their speed of operation. Since there is no clock involved, the speed of operation depends only on the propagation delaysin the circuit. In an asynchronous system that comprises several circuits, some circuits mayoperate faster than others, thus potentially improving the overall performance of the system.In contrast, in synchronous systems the clock period has to be long enough to accommodatethe slowest circuit, and it has a large effect on the performance."
"The next phase is gate optimization, which performs the kinds of logic optimizations described in the preceding chapters. These optimizations manipulate the netlist to obtain anequivalent, but better circuit according to the optimization goals. As we said previously,the measurement of what makes one circuit better than another may be based on the costof the circuit, its speed of operation, or a combination of both."
"The ﬁnal phase of synthesis is technology mapping. This phase determines how each component in the netlist can be realized in the resources available in the target chip, such as an FPGA. A logic block for a typical FPGA is depicted in Figure 10.5 a. It contains a four-input LUT and a ﬂip-ﬂop, and has two outputs. A multiplexer is provided to allowloading of the ﬂip-ﬂop from the LUT or directly from input In3. Another multiplexer allows the stored value in the ﬂip-ﬂop to be fed back to one input of the LUT. There are a number ofdifferent ways, or modes, in which this logic block can be used. The most straightforward choice is to implement a function of up to four inputs in the LUT, and store this function’svalue in the ﬂip-ﬂop; both the LUT and ﬂip-ﬂop can provide outputs from the logic block.Parts btoeof the ﬁgure illustrate four other modes of using the block. In parts bandconly the LUT or the ﬂip-ﬂop is used, but not both. In part donly the LUT provides an output of the logic block, and one of the LUT’s inputs is connected to the ﬂip-ﬂop."
"Figure 10.5e shows one way in which such circuitry can be realized. The LUT is used in two halves, where one half produces the sum function of three LUT inputs and the other halfproduces the carry function of these inputs. The sum function can provide an output of theblock or be stored in the ﬂip-ﬂop, and the carry function provides a special output signal."
"To ﬁnd a good placement solution a number of different locations have to be considered for each logic block. For a large circuit, which may contain tens of thousands of blocks,this is a hard problem to solve. To appreciate the complexity involved, consider how manydifferent placement solutions are possible for a given circuit. Assume that the circuit hasNlogic blocks, and it is to be placed in an FPGA that also contains exactly Nblocks. A placement tool has Nchoices for the location of the ﬁrst block that it selects. There remain"
"In the previous chapters we have discussed the design of logic circuits. Following a sound design procedure, we expect that the designed circuit will perform as required. But how does one verify that the ﬁnal circuit indeed achieves the design objectives? It is essential to ascertain that the circuit exhibits the required functionalbehavior and that it meets any timing constraints that are imposed on the design. We have discussed the timingissues in several places in the book. In this chapter we will discuss some testing techniques that can be usedto verify the functionality of a given circuit."
"There are several reasons for testing a logic circuit. When the circuit is ﬁrst developed, it is necessary to verify that the designed circuit meets the required functional and timing speciﬁcations. When multiplecopies of a correctly designed circuit are being manufactured, it is essential to test each copy to ensure thatthe manufacturing process has not introduced any ﬂaws. It is also necessary to test circuits used in equipmentthat is installed in the ﬁeld when it is suspected that there may be something wrong."
"A circuit functions incorrectly when there is something wrong with it, such as a transistor fault or an interconnection wiring fault. Many things can go wrong, leading to a variety offaults. A transistor switch can break so that it is permanently either closed or open. A wirein the circuit can be shorted to V"
A circuit can be faulty because it has either a single fault or possibly many faults. Dealing with multiple faults is difﬁcult because each fault can occur in many different ways. A pragmatic approach is to consider single faults only. Practice has shown that a set of teststhat can detect all single faults in a given circuit can also detect the vast majority of multiplefaults.
"CMOS logic circuits present some special problems in terms of faulty behavior. Thetransistors may fail in permanently open or shorted (closed) state. Many such failuresmanifest themselves as stuck-at faults. But some produce entirely different behavior. Forexample, transistors that fail in the shorted state may cause a continuous ﬂow of current fromV"
"DDto ground, which can create an intermediate output voltage that may not be determined as either logic 0 or 1. Transistors failing in the open state may lead to conditions where theoutput capacitor retains its charge level because the switch that is supposed to discharge itis broken. The effect is that a combinational CMOS circuit starts behaving as a sequentialcircuit."
"There is large difference in testing combinational and sequential circuits. Combinational circuits can be tested adequately regardless of their design. Sequential circuits present amuch greater challenge because the behavior of a circuit under test is inﬂuenced not onlyby the tests that are applied to the external inputs but also by the states that the circuit isin when the tests are applied. It is very difﬁcult to test a sequential circuit designed by adesigner who does not take its testability into account. However, it is possible to designsuch circuits to make them more easily testable, as we will discuss in Section 11.6. We willstart by considering the testing of combinational circuits."
"Deriving a test set by considering the individual faults on all wires in a circuit, as done inSection 11.2, is not attractive from the practical point of view. There are too many wiresand too many faults to consider. A better alternative is to deal with several wires that forma path as an entity that can be tested for several faults using a single test. It is possible toactivate a path so that the changes in the signal that propagates along the path have a directimpact on the output signal."
"In general, the fault on a given wire can be detected by propagating the effect of the fault to the output, sensitizing an appropriate path. This involves assigning values to otherinputs of the gates along the path. These values must be obtainable by assigning speciﬁcvalues to the primary inputs, which may not always be possible. Example 11.2 illustratesthe process."
"So far we have considered the task of deriving a deterministic test set for a given circuit, primarily relying on the path-sensitizing concept. In general, it is difﬁcult to generate suchtest sets when circuits become larger. A useful alternative is to choose the tests at random,which we will explore in this section."
"Figure 11.9 The effect of various faults. an output value that is different from the correct function. Thus each application of a new test essentially cuts in half the number of faulty functions that have not been detected.Consequently, the probability that the ﬁrst few tests will detect a large portion of all possiblefaults is high. More speciﬁcally, the probability that each faulty circuit can be detected bythe ﬁrst test is"
"A combinational circuit can be tested by comparing its behavior with the functionality speciﬁed in the truth table. An equivalent attempt would be to test a sequential circuit by comparing its behavior with the functionality speciﬁed in the state table. This entailschecking that the circuit performs correctly all transitions between states and that it producesa correct output. This approach may seem easy, but in reality it is extremely difﬁcult. Abig problem is that it is difﬁcult to ascertain that the circuit is in a speciﬁc state if the statevariables are not observable on the external pins of the circuit, which is usually the case."
"The inputs to the combinational network are the primary inputs, w1through wn, and the present state variables, y1through yk. The outputs of the network are the primary outputs, z1through zm, and the next-state variables, Y1through Yk. The combinational network could be tested using the techniques presented in the previous sections if it were possible to apply tests on all of its inputs and observe the results on all of its outputs. Applying thetest vectors to the primary inputs poses no difﬁculty. Also, it is easy to observe the valueson the primary outputs. The question is how to apply the test vectors on the present-stateinputs and how to observe the values on the next-state outputs."
"Apossible approach is to include a two-way multiplexer in the path of each present-state variable so that the input to the combinational network can be either the value of the statevariable (obtained from the output of the corresponding ﬂip-ﬂop) or the value that is a partof the test vector. A signiﬁcant drawback of this approach is that the second input of eachmultiplexer must be directly accessible through external pins, which requires many pins ifthere are many state variables. An attractive alternative is to provide a connection that allowsshifting the test vector into the circuit one bit at a time, thus trading off pin requirementsfor the time it takes to perform a test. Several such schemes have been proposed, one ofwhich is described below."
The preceding approach is based on testing a sequential circuit by testing its combinational part using the techniques developed in the previous sections. The scan-path facilitymakes it also possible to test the sequential circuit by making it go through all transitionsspeciﬁed in the state table. The circuit can be placed into a given state simply by scanninginto the ﬂip-ﬂops the valuation of the state variables that denotes this state. The result ofthe transition can be checked by observing the primary outputs and by scanning out thevaluation that presents the destination state. We leave it to the reader to develop the detailsof this approach (see Problem 11.16).
Until now we have assumed that testing of logic circuits is done by externally applying thetest inputs and comparing the results with the expected behavior of the circuit. This requiresconnecting external equipment to the circuit under test. An interesting question is whetherit is possible to incorporate the testing capability within the circuit itself so that no externalequipment is needed. Such built-in capability would allow the circuit to be self-testable.
"A practical approach for generating the test vectors on-chip is to use pseudorandom tests, which have the same characteristics as random tests but are produced deterministically and can be repeated at will. The generator for pseudorandom tests is easily constructed using a feedback shift-register circuit. A small example of a possible generator is given in"
"After applying a number of test vectors, the resulting values of pdrive the SIC and, coupled with the LFSR functionality, produce a four-bit pattern. The pattern generated by the SICis called a signature of the tested circuit for the given sequence of tests. The signature represents a single pattern that may be interpreted as a result of all the applied tests. It canbe compared against a predetermined pattern to see if the tested circuit is working properly.Storing a single n-bit pattern for comparison purposes presents only a small overhead. The randomizing nature of the compressor circuits based on LFSRs provides a good coverageof patterns that may result from a faulty circuit [12]."
"Figure 11.17. The scan-path approach is used to provide a testable circuit. The test pat-terns that would normally be applied on the primary inputs W=w 1w2···w nare generated internally as the patterns on X=x1x2···x n. Multiplexers are needed to allow switching from WtoX, as inputs to the combinational circuit. A pseudorandom binary sequence generator, PRBSG-X , generates the test patterns for X. The portion of the tests applied p"
"The test outputs are compressed using the two compressor circuits. The patterns on the primary outputs, Z=z1z2···z m, are compressed using the MIC circuit, and those on the next-state wires Y=Y1Y2···Y k, by the SIC circuit. These circuits produce the Zsignature and Y-signature, respectively. The testing procedure is the same as given in"
"M 1andM2. The modes are as follows: •M1M2=11 — Normal system mode in which all ﬂip-ﬂops are independently controlled by the signals on inputs p0through p3. In this mode each ﬂip-ﬂop may be used to implement a state variable of a ﬁnite state machine by using p0top3asy0toy3. •M1M2=00 — Shift-register mode in which the ﬂip-ﬂops are connected into a shift register. This mode allows test vectors to be scanned in, and the results of applied teststo be scanned out, if the control input"
The testing techniques discussed in the previous sections are equally applicable to circuits that are implemented on single chips or on printed circuit boards that contain a number ofchips. A circuit can be tested only if it is possible to apply the tests to it and observe theoutputs produced. This involves having access to the primary inputs and outputs.
"Design and testing techniques presented in this book can be applied to any logic circuit,whether the circuit is realized on a single chip or its implementation involves a numberof chips placed on a printed circuit board (PCB). In this section we discuss some practicalissues that arise when one or more circuits that form a larger digital system are implementedon a PCB."
"A typical PCB contains multiple layers of wiring. When the board is manufactured, the wiring pattern on each layer is generated. The layers are separated by insulating materialand pressed together in sandwichlike fashion to form the board. Connections betweendifferent wiring levels are made through holes that are provided for this purpose. Chipsand other components are then soldered to the top and possibly to the bottom layers."
"In addition to the design issues discussed in the previous chapters, a large circuit implemented on a PCB is subject to some other constraints. Signals on the wiring tracesmay be affected by noise problems caused by crosstalk, spikes in the power supply voltage,and reﬂections from the end points of long traces."
"Appendix B, noise in a circuit can affect voltage levels, which can be troublesome. For example, if at some point in time the noise diminishes the value of a signal that should beat logic 1 to a level where this signal is interpreted by the next gate as being logic 0, then amalfunction in the circuit is likely to occur. Since the noise effects tend to be random, theyare often difﬁcult to detect."
"To minimize crosstalk, it is prudent to avoid having long wires running parallel in close proximity to each other. This may be difﬁcult to achieve because of limited space on a PCBand the need to provide a large number of wires. Using additional layers (planes) of wiringhelps in coping with crosstalk problems."
"DDandGround wires, in close proximity to the chip that causes the spikes to occur. Since these spikes have the characteristic of a very high frequency signal, thepath through the capacitor is essentially a short circuit for them. Thus the voltage spikes“bypass” the power supply lines and do not affect other chips connected to the same lines.Such capacitors are called bypass capacitors. They do not affect the DC voltage on the power supply lines."
"The manufactured PCB has to be tested thoroughly. Flaws in the manufacturing process may cause some connections to be broken and others to be shorted by a solder blob thattouches two adjacent wires. There may be problems caused by design errors that were notdiscovered during the design process. Finally, some chips and other components on thePCB may be defective."
"The ﬁrst step is to turn on the power supply. In the worst case this may cause some chip to be destroyed because of a fatal short-circuit condition (in an extreme case a chippackage may actually blow apart). Assuming that this is not the case, it is essential to checkif any of the chips is becoming inordinately hot. Overheating is a symptom of a seriousproblem that must be corrected."
"Full Functional TestingHaving veriﬁed the operation of smaller subcircuits, it is necessary to test the functionality of the entire system on the PCB. The number of errors often depends on the thoroughness of the simulation done during the design process. In general, it is difﬁcultto simulate large digital systems fully, so some errors are likely to be found on the PCB."
"The details of individual signals can be examined using an oscilloscope. This instrument displays the voltage waveform of a signal, showing the potential problems with respectto propagation delay and noise. The waveform displayed on an oscilloscope shows the ac-tual voltage levels of the signal; it does not depict the simpliﬁed view of ideal waveformsthat have perfectly square edges. If the user wants to see only the logic values of a signal(0 or 1), then a different type of instrument called a logic analyzer can be used."
"Looking at the waveforms taken when the circuit under test is working properly is not helpful in the debugging process. It is essential to see the waveforms generated when amalfunction takes place. The logic analyzer can be “triggered” to record a window of eventsthat occurred before and after the trigger event. The user must specify the trigger event.For example, suppose that a malfunction is suspected to be caused by two control signals,AandB, being asserted at the same time, even though the design speciﬁcation requires that these signals be mutually exclusive. A useful trigger point can then be established as thetime when the AND of AandBhas the value 1. Finding suitable trigger events can be difﬁcult, and the user must rely on intuition and experience."
Manufactured products must be tested to ensure that they perform as expected. All of thetechniques discussed in this chapter are relevant for this type of testing. The developmentof tests and the required responses is based on the assumption that the circuits are designedcorrectly. Thus it is the validity of the physical implementation that is being tested.
"Another aspect of testing occurs during the design process. The designer has to ascertain that the designed circuit meets the speciﬁcations. From the testing point of view, this posesa signiﬁcant problem because there exists no provably good circuit that can be used togenerate the desired tests. CAD tools are helpful in deriving tests for a designed circuit, butthey cannot determine whether the circuit is indeed what the designer intended to achievein terms of its functionality. A design error usually results in a circuit that has somewhatdifferent functionality than required by the speciﬁcation."
"This appendix is not meant to be a comprehensive Verilog manual. While we discuss almost all the features of Verilog that are useful in the synthesis of logic circuits, we do notdiscuss many of the features that are useful only for simulation of circuits. Although theomitted features are not needed for any of the examples used in this book, a reader whowishes to learn more about Verilog can refer to specialized texts [1–7]."
"The tendency for the novice is to write Verilog code that resembles a computer program, containing many variables and loops. It is difﬁcult to determine what logic circuit the CADtools will produce when synthesizing such code. The task of a synthesis tool is to analyzea piece of Verilog code and determine, according to the semantics of the language, whatcircuit can be used to implement the code. Consider a code fragment such as if(s==0) f=w0; else f=w1;"
"We can understand the semantics by considering each statement in sequence, in the way that a simulation tool would. The code results in fbeing assigned the value of either w 0or w1, depending on the value of s. A synthesis tool would usually implement this behavior using a multiplexer circuit."
"Although Verilog is a fairly straightforward language to learn and use, the novice designer will tend to make some common errors in syntax and semantics. A list of typical errors is given in Section A.15, as well as a set of guidelines that expert Verilog codersrecommend as good style for writing clear and effective code."
"Documentation can be included in Verilog code by writing a comment. A short comment begins with the double slash, //, and continues to the end of the line. A long comment canspan multiple lines and is contained inside the delimiters /* and */. Examples of commentsare // This is a short comment/*This is a long Verilog comment that spans two lines */"
"In Verilog, a signal in a circuit is represented as a netor avariable with a speciﬁc type. The term netis derived from the electrical jargon, where it refers to the interconnection of two or more points in a circuit. A net or variable declaration has the form type [range] signal_name{, signal_name};"
"Identiﬁers are the names of variables and other elements in Verilog code. The rules for specifying identiﬁers are simple: any letter or digit may be used, as well as the _ underscore and $ characters. There are two caveats: an identiﬁer must not begin with a digit and itshould not be a Verilog keyword. Examples of legal identiﬁers are f,x1,x_y, and Byte."
"For special purposes Verilog allows a second form of identiﬁer, called an escaped identiﬁer. Such identiﬁers begin with the (\) backslash character, which can then be followedby any printable ASCII characters except white spaces. Examples of escaped identiﬁersare\123, \sig-name, and \a+b. Escaped identiﬁers should not be used in normal Verilog code; they are intended for use in code produced automatically when other languages aretranslated into Verilog."
"The z and x values can also be denoted by the capital letters Z and X. The value x can be used to denote a don’t-care condition in Verilog code; the symbol ? can also be used forthis purpose. The value of a vector variable is speciﬁed by giving a constant of the form [size][’radix]constant where sizeis the number of bits in the constant, and radix is the number base. Supported radices are d=decimal b=binary h=hexadecimal o=octal"
"The square brackets are the syntax for specifying a vector’s range. The range [R a:Rb] can be either increasing or decreasing, as shown. In either case, Rais the index of the mostsigniﬁcant (leftmost) bit in the vector, and Rbis the index of the least-signiﬁcant (rightmost) bit. The indices RaandRbcan be either positive or negative integers."
"Nets provide a means for interconnecting logic elements, but they do not allow a circuit to be described in terms of its behavior. For this purpose, Verilog provides variables.A variable can be assigned a value in one Verilog statement, and it retains this value until itis overwritten in a subsequent assignment statement. There are two types of variables, reg andinteger. Consider the code fragment"
"In any hardware description language, including Verilog, the concept of a concurrent statement means that the code may include a number of such statements, and each represents a part of the circuit. We use the word concurrent because the statements are considered in parallel and the ordering of statements in the code does not matter. Gate instantiations are one type of concurrent statements. This section introduces another type of concurrentstatement, called the continuous assignment."
"Verilog treats the wire type as an unsigned number. Since a ﬁve-bit result is needed in {carryout, S}, each operand is padded with a zero. When using Verilog for synthesis, it isup to the compiler to determine, or infer, that a four-bit adder with carry-out is needed and to recognize the carry-in."
"In addition to the concurrent statements described in the previous section, Verilog alsoprovides procedural statements (also called sequential statements). Whereas concurrent statements are executed in parallel, procedural statements are evaluated in the order in whichthey appear in the code. Verilog syntax requires that procedural statements be containedinside an always block."
"Since the output variables sandcdepend on xandy, these signals are included in the sensitivity list, separated by a comma or by the keyword or. We use the comma in this book, but it should be noted that in the original version of Verilog it was necessary to usethe keyword or. When specifying a combinational circuit by using an always block, it is possible to write simply always @∗ which indicates that all input signals used in the always block are included in the sensitivity list. In the examples in this book we explicitly show the signals in the sensitivity list tomake it easier to understand the Verilog code."
"There are two kinds of assignments: blocking assignments, denoted by the =symbol, and non-blocking assignments, denoted by the <= symbol. The term blocking means that the assignment statement completes and updates its left-hand side before the subsequent statement is evaluated. This concept is best explained in the context of simulation. Considerthe blocking assignments"
"In this case, at simulation time tithe statements are still evaluated in order, but they both use the values of variables that exist at the start of the simulation time ti. The ﬁrst statement determines a new value for Sbased on the current values of XandY, but Sis not actually changed to this value until all statements in the associated always block have been evaluated."
"Therefore, the value of pat time tiis based on the value of Sat time ti−1. We can summarize the difference between blocking and non-blocking assignments as follows. For blockingassignments, the values of variables seen at time t iby each statement are the new values set in tiby any preceding statements in the always block. For non-blocking assignments, the values of variables seen at time tiare the values set in time ti−1."
"Figure A.13. The effect of the loop is to repeat its begin-end block for the speciﬁed values ofk. In this example, each loop iteration, k, deﬁnes a full-adder with the inputs xk,yk, and ck, and the outputs skandck+1. It is possible to deﬁne the integer k(parameters can also be deﬁned in this way) inside the always block if the begin-end block has a label. For example, always @(X, Y , carryin) begin: fulladders integer k;"
"A Verilog module can be included as a subcircuit in another module. For this to work, both modules must be deﬁned in the same ﬁle or else the Verilog compiler must be told where each module is located (the mechanism for doing this varies from one compiler to thenext). The general form of a module instantiation statement is similar to a gate instantiation statement module_name [#(parameter overrides)] instance_name ( .port_name ( [expression] ) {, .port_name ( [expression] )} );"
"Theinstance_name can be any legal Verilog identiﬁer and the port connections specify how the module is connected to the rest of the circuit. The same module can be instantiatedmultiple times in a given design provided that each instance name is unique. The #(param-eter overrides) can be used to set the values of parameters deﬁned inside the module_name module. We discuss this feature in the next section. Each port_name is the name of a port in the subcircuit, and each expression speciﬁes a connection to that port. The syntax .port_name is provided so that the order of signals listed in the instantiation statement does not have to be the same as the order of the ports given in the module statement of the subcircuit. In Verilog jargon, this is called named port connections. If the port connections are given in the same order as in the subcircuit, then .port_name is not needed. This format is called ordered port connections."
"Theadder4 module instantiates four copies of the full-adder subcircuit. In the ﬁrst three instantiation statements, we use ordered port connections because the signals are listed inthe same order as given in the declaration of the fulladd module in Figure A.2. The last instantiation statement gives an example of named port connections. The port connectionsused in the instantiation statements specify how the fulladd instances are interconnected by nets to create the adder module."
"It has the four-bit bcdinput, which represents a binary-coded-decimal digit, and the sevenbitleds output, which is intended to drive the seven segments atogon a digit-oriented display. Three copies of the seven-segment decoder are instantiated in the top module,group. It has a 12-bit input, Digits, and a 21-bit output, Lights, that are connected to the three instantiated subcircuits."
Figure A.18 instantiates four copies of the fulladd subcircuit to form a four-bit ripple-carry adder. A natural extension of this code is to add a parameter that sets the number of bits needed and then use a loop to instantiate the required subcircuits. This can be achievedwith the generate construct.
"This construct enhances the ﬂexibility of Verilog modules, because it allows instantiation statements to be included inside forloops and if-else statements. If a forloop is included in the generate block, the loop index variable has to be declared of type genvar .Agenvar variable is similar to an integer variable, but it can have only positive values and it can be used only inside generate blocks."
"Functions andtasks are not crucial for designing Verilog code, but they facilitate the writing of modular code without using separate modules. One advantage of functions andtasks is that they can be called from an always block, whereas these blocks are not allowed to contain instantiation statements. These features of Verilog become increasinglyimportant as the size of the code being developed increases."
"Verilog syntax requires that a sensitivity list contains either all edge-sensitive events or all level-sensitive events but not a mixture; hence, the reset condition is checked using negedge Resetn. An active-high reset would require the event posedge Reset and the if-else statement would then check for the condition (Reset ==1)."
"In general, Verilog offers a variety of ways to describe a given circuit. But, for specifying ﬂip-ﬂops, the format of the code is quite strict. Only minor variations of the code inFigures A.27 and A.28 can be made and still infer the desired ﬂip-ﬂops. For instance, theif-else statement could alternatively specify if(!Resetn), but this has to be the ﬁrst statement in the always block. Note that nothing is special about the variable name Clock; the keyword posedge and the format of the rest of the always block are what allow the Verilog compiler to recognize the ﬂip-ﬂop clock signal."
"An example of a sequential circuit is given in Figure A.35. It adds together the values of the k-bit input Xover successive clock cycles, and stores the sum of these values into a k-bit register. Such a circuit is often called an accumulator. To store the result of each addition operation, the circuit includes a k-bit register with an asynchronous reset input, Resetn.I t also has an enable input, E, which is controlled by a down-counter. The down-counter has an asynchronous load input and a count enable input. The circuit is operated by ﬁrst setting"
"Then, in each clock cycle, the counter is decremented, and the sum outputs from the adder are loaded into the register. When the counter reaches 0, the enable inputs on boththe register and counter are set to 0 by the OR gate. The circuit remains in this state untilit is reset again. The ﬁnal value stored in the register is the sum of the values of Xin each of the Yclock cycles."
"Figure A.36 Code for a k-bit accumulator circuit. it easy to change the bit width at a later time if desired. The code deﬁnes the signal Sum to represent the outputs of the adder; for simplicity, we ignore the possibility of arithmetic overﬂow and assume that the sum will ﬁt into kbits. The m-bit signal Crepresents the outputs from the down-counter. The Gosignal is connected to the enable inputs on the register and counter."
"Figure A.37 gives the state diagram of a simple Moore machine. Verilog code for thismachine is shown in Figure A.38. The two-bit vector yrepresents the present state of the machine, and the state codes are deﬁned as parameters. Some CAD synthesis systemsprovide a means of requesting that the state assignment be chosen automatically, but wehave speciﬁed the assignment manually in this example."
"Figure A.37 State diagram of a simple Moore-type FSM. always blocks. The top one describes a combinational circuit and uses a case statement to specify the values that Yshould have for each value of y. The other always block represents a sequential circuit, which speciﬁes that yis assigned the value of Yon the positive clock edge. The always block also speciﬁes that yshould take the value Awhen Resetn is 0, which provides the asynchronous reset."
"Since the machine is of the Moore type, the output zcan be deﬁned using the assignment statement z =(y==C) that depends only on the present state of the machine. This statement is provided as a continuous assignment at the end of the code, but it could alternatively have been given inside the top always block that represents the combinational part of the FSM."
"In a module that has multiple always blocks, all the always blocks are concurrent with respect to one another. Therefore, a given variable should never be assigned a value in more than one always block. Doing so would mean that there exist multiple concurrent assignments to this variable, which makes no sense."
"It is not possible to model both a combinational output and a sequential output in a single always block. The sequential output requires an edge-triggered event control, such as @(posedge Clock), and this means that all variables assigned a value in the always block will be implemented as the outputs of ﬂip-ﬂops."
"This appendix describes the important features of Verilog that are useful for the synthesis of logic circuits. As mentioned earlier, we do not discuss many features of Verilog which are useful only for simulation of circuits or for other purposes. A reader who wishes to learnmore about using Verilog can refer to specialized books [1–7]."
"Let us ﬁrst consider how logic variables can be physically represented as signals in electronic circuits. Our discussion will be restricted to binary variables, which can takeon only the values 0 and 1. In a circuit these values can be represented either as levels ofvoltage or current. Both alternatives are used in different technologies. We will focus onthe simplest and most popular representation, using voltage levels."
"Logic circuits are built with transistors. A full treatment of transistor behavior is beyondthe scope of this text; it can be found in electronics textbooks, such as [1] and [2]. Forthe purpose of understanding how logic circuits are built, we can assume that a transistoroperates as a simple switch. Figure B.2a shows a switch controlled by a logic signal, x. When xis low, the switch is open, and when xis high, the switch is closed. The most popular type of transistor for implementing a simple switch is the metal oxide semiconductor ﬁeld-effect transistor (MOSFET). There are two different types of MOSFETs, known as nchannel, abbreviated NMOS, and p-channel, denoted PMOS."
"DD, leading to the simpliﬁed symbol in Figure B.3c .I fVGis high, then the PMOS transistor is turned off and acts like an open switch. When VGis low, the transistor is turned on and acts as a closed switch that connects the source and drain. In the PMOS transistor the source is the nodewith the higher voltage."
"VDD. Because of the way the transistors operate, an NMOS transistor cannot be used to pull its drain terminal completely up to VDD. Similarly, a PMOS transistor cannot be used to pull its drain terminal completely down to Gnd. We discuss the operation of MOSFETs in considerable detail in Section B.8."
"The ﬁrst schemes for building logic gates with MOSFETs became popular in the 1970s and relied on either PMOS or NMOS transistors, but not both. Since the early 1980s, a combination of both NMOS and PMOS transistors has been used. We will ﬁrst describehow logic circuits can be built using NMOS transistors because these circuits are easierto understand. Such circuits are known as NMOS circuits. Then we will show howNMOS and PMOS transistors are combined in the presently popular technology known ascomplementary MOS,o rCMOS."
"So far we have considered the implementation of logic gates using NMOS transistors. For each of the circuits that has been presented, it is possible to derive an equivalent circuitthat uses PMOS transistors. However, it is more interesting to consider how both NMOSand PMOS transistors can be used together. The most popular such approach is known asCMOS technology. We will see in Section B.8 that CMOS technology offers some attractivepractical advantages in comparison to NMOS technology."
"A key point is that no current ﬂows in a CMOS inverter when the input is either low or high. This is true for all CMOS circuits; no current ﬂows, and hence no power is dissipatedunder steady state conditions. This property has led to CMOS becoming the most populartechnology in use today for building logic circuits. We will discuss current ﬂow and powerdissipation in detail in Section B.8.6."
"As another example, consider again the circuit in Figure B.15. Its truth table, in terms of voltage levels, is given in Figure B.20a . Using the positive logic system, this circuit represents an AND gate, as indicated in Figure B.20b. But using the negative logic system,the circuit represents an OR gate, as depicted in Figure B.20c."
"In recent years the concept of classifying circuits according to their size has become oflittle practical use. Most integrated circuits today contain many thousands or millions oftransistors. Regardless of their exact size, these large chips are said to be made with very large scale integration (VLSI) technology. The trend in digital hardware products is to integrate as much circuitry as possible onto a single chip. Thus most of the chips usedtoday are built with VLSI technology, and the older types of chips are used rarely."
"The function provided by each of the 7400-series parts is ﬁxed and cannot be tailored to suit a particular design situation. This fact, coupled with the limitation that each chip containsonly a few logic gates, makes these chips inefﬁcient for building large logic circuits. It ispossible to manufacture chips that contain relatively large amounts of logic circuitry witha structure that is not ﬁxed. Such chips were ﬁrst introduced in the 1970s and are calledprogrammable logic devices (PLDs)."
"APLD is a general-purpose chip for implementing logic circuits. It contains a collection of logic circuit elements that can be customized in different ways. A PLD can be viewed asa “black box” that contains logic gates and programmable switches, as illustrated in FigureB.24. The programmable switches allow the logic gates inside the PLD to be connectedtogether to implement whatever logic circuit is needed."
"Based on the idea that logic functions can be realized in sum-of-products form, a PLAcomprises a collection of AND gates that feeds a set of OR gates. As shown in the ﬁgure,the PLA’s inputs x 1,...,x npass through a set of drivers (which provide both the true value and complement of each input) into a circuit block called an AND plane,o r AND array."
"The AND plane produces a set of product terms P1,...,P k. Each of these terms can be conﬁgured to implement any AND function of x1,...,x n. The product terms serve as the inputs to an OR plane, which produces the outputs f1,...,f m. Each output can be conﬁgured to realize any sum of P1,...,P kand hence any sum-of-products function of the PLA inputs."
"A more detailed diagram of a small PLA is given in Figure B.26, which shows a PLA with three inputs, four product terms, and two outputs. Each AND gate in the AND planehas six inputs, corresponding to the true and complemented versions of the three inputsignals. Each connection to an AND gate is programmable; a signal that is connected toan AND gate is indicated with a wavy line, and a signal that is not connected to the gate isshown with a broken line. The circuitry is designed such that any unconnected AND-gateinputs do not affect the output of the AND gate. In commercially available PLAs, several f1AND plane OR planeInput drivers invertersand"
"In a PLA both the AND and OR planes are programmable. Historically, the programmable switches presented two difﬁculties for manufacturers of these devices: they were hard tofabricate correctly, and they reduced the speed-performance of circuits implemented in thePLAs. These drawbacks led to the development of a similar device in which the AND planeis programmable, but the OR plane is ﬁxed. Such a chip is known as a programmable array logic (P AL) device."
"Figure B.27, the PAL offers less ﬂexibility; the PLA allows up to four product terms perOR gate, whereas the OR gates in the PAL have only two inputs. To compensate for thereduced ﬂexibility, PALs are manufactured in a range of sizes, with various numbers ofinputs and outputs, and different numbers of inputs to the OR gates."
"Figure B.30 The 22V10 macrocell. permanently enabled or connected to a product term from the AND plane. Either the Q output from the ﬂip-ﬂop or the output of the tri-state driver can be connected to the AND plane. If the tri-state driver is disabled, then the corresponding pin can be used as an input."
"PLAs or PALs used as part of a logic circuit usually reside with other chips on a printed circuit board (PCB). The procedure described above assumes that the chip can be removedfrom the circuit board for programming in the programming unit. Removal is made possibleby using a socket on the PCB, as illustrated in Figure B.31. Although PLAs and PALs areavailable in the DIP packages shown in Figure B.21a , they are also available in another popular type of package, called a plastic-leaded chip carrier (PLCC), which is depicted in"
"Figure B.31. On all four of its sides, the PLCC package has pins that “wrap around” theedges of the chip, rather than extending straight down as in the case of a DIP. The socketthat houses the PLCC is attached by solder to the circuit board, and the PLCC is held in thesocket by friction."
"Instead of relying on a programming unit to conﬁgure a chip, it would be advantageous to be able to perform the programming while the chip is still attached to its circuit board. Thismethod of programming is called in-system programming (ISP). It is not usually provided for PLAs or PALs, but is available for the more sophisticated chips that are described below."
"PLAs and PALs are useful for implementing a wide variety of small digital circuits. Each device can be used to implement circuits that do not require more than the number of inputs,product terms, and outputs that are provided in the particular chip. These chips are limitedto fairly modest sizes, typically supporting a combined number of inputs plus outputs of notmore than 32. For implementation of circuits that require more inputs and outputs, eithermultiple PLAs or PALs can be employed or else a more sophisticated type of chip, calledacomplex programmable logic device (CPLD), can be used."
"The interconnection wiring contains programmable switches that are used to connect the PAL-like blocks. Each of the horizontal wires can be connected to some of the vertical wires that it crosses. One detail to note is that when a pin is used as an input, the macrocellassociated with that pin cannot be used and is therefore wasted. Some CPLDs includeadditional connections between the macrocells and the interconnection wiring that avoidswasting macrocells in such situations."
"Group. Figure B.34b illustrates the use of a JTAG port for programming two CPLDs on a circuit board. The CPLDs are connected together so that both can be programmed using the same connection to the computer system. Once a CPLD is programmed, it retains theprogrammed state permanently, even when the power supply for the chip is turned off. Thisproperty is called nonvolatile programming."
"CPLDs are used for the implementation of many types of digital circuits. In industrial designs that employ some type of PLD device, CPLDs are used often, while SPLDs arebecoming less common. A number of companies offer CPLDs, including Altera, Lattice,and Xilinx. Information about these products is available on the internet."
"The types of chips described above, 7400 series, SPLDs, and CPLDs, are useful for implementation of small or moderately-sized logic circuits. One way to quantify a circuit’s size is to assume that the circuit is to be built using only simple logic gates and then estimatehow many of these gates are needed. A commonly used measure is the total number oftwo-input NAND gates that would be needed to build the circuit; this measure is oftencalled the number of equivalent gates."
"Aﬁeld-programmable gate array (FPGA) is a programmable logic device that supports implementation of relatively large logic circuits. FPGAs are quite different from SPLDs andCPLDs because FPGAs do not contain AND or OR planes. Instead, FPGAs provide logic elements for implementation of the required functions. The general structure of an FPGA is illustrated in Figure B.35a . It contains three main types of resources: logic elements, I/O blocks for connecting to the pins of the package, and interconnection wires and switches."
"When x1=x2=0, the output of the LUT is driven by the top storage cell, which represents the entry in the truth table for x1x2=00. Similarly, for all valuations of x1andx2, the logic value stored in the storage cell corresponding to the entry in the truth table chosen by the particular valuation appears on the LUT output."
"To provide the largest number of logic gates, highest circuit speed, or lowest power, a so-called custom chip can be manufactured. Whereas a PLD is prefabricated, containing logic gates and programmable switches that are programmed to realize a user’s circuit, acustom chip is created from scratch. The designer of a custom chip has complete ﬂexibilityto decide the size of the chip, the number of transistors the chip contains, the placement ofeach transistor on the chip, and the way the transistors are connected together. The processof deﬁning exactly where on the chip each transistor and wire is situated is called chip layout. For a custom chip the designer may create any layout that is desired. A custom chiprequires a large amount of design effort and is therefore expensive. Consequently, suchchips are produced only when standard parts like FPGAs do not meet the requirements. Tojustify the expense of a custom chip, the product being designed must be expected to sell insufﬁcient quantities to recoup the cost. Two examples of products that are usually realizedwith custom chips are microprocessors and memory chips."
"In situations where the chip designer does not need complete ﬂexibility for the layout of each individual transistor in a custom chip, some of the design effort can be avoided byusing a technology known as standard cells. Chips made using this technology are often called application-speciﬁc integrated circuits (ASICs). An example of a small section of an"
"Like a custom chip, a standard-cell chip is created from scratch according to a user’s speciﬁcations. The circuitry shown in Figure B.40 implements the two logic functions that we realized in a PLA in Figure B.26, namely, f1=x1x2+x1x3+x1x2x3andf2= x1x2+x1x2x3+x1x3. Because of the expense involved, a standard-cell chip would never be created for a small circuit such as this one, and thus the ﬁgure shows only a portionof a much larger chip. The layout of individual gates (standard cells) is predesigned andﬁxed. The chip layout can be created automatically by CAD tools because of the regulararrangement of the logic gates (cells) in rows. A typical chip has many long rows of logicgates with a large number of wires between each pair of rows. The I/O blocks around theperiphery connect to the pins of the chip package, such as a QFP, PGA, or BGA package."
"Another technology, similar to standard cells, is the gate-array technology. In a gate array parts of the chip are prefabricated, and other parts are custom fabricated for a par-ticular user’s circuit. This concept exploits the fact that integrated circuits are fabricatedin a sequence of steps, some steps to create transistors and other steps to create wires toconnect the transistors together. In gate-array technology, the manufacturer performs mostof the fabrication steps, typically those involved in the creation of the transistors, withoutconsidering the requirements of a user’s circuit. This process results in a silicon waferof partially ﬁnished chips, called the gate-array template. Later the template is modiﬁed, usually by fabricating wires that connect the transistors together, to create a user’s circuitin each ﬁnished chip. The gate-array approach provides cost savings in comparison to thecustom-chip approach because the gate-array manufacturer can amortize the cost of chipfabrication over a large number of template wafers, all of which are identical. Many vari-ants of gate-array technology exist. Some have relatively large logic cells, while others areconﬁgurable at the level of a single transistor."
"Silicon is an electrical semiconductor, which means that it can be manipulated such that it sometimes conducts electrical current and at other times does not. A transistor isfabricated by creating areas in the silicon substrate that have an excess of either positiveor negative electrical charge. Negatively charged areas are called type n, and positively charged areas are type p . Figure B.43 illustrates the structure of an NMOS transistor. It has type nsilicon for both the source and drain terminals, and type pfor the substrate terminal."
"When MOSFETs were invented, the gate terminal was made of metal. Now a material known as polysilicon is used. Like metal, polysilicon is a conductor. The gate is electrically isolated from the rest of the transistor by a layer of silicon dioxide (SiO 2), which is a type of glass that acts as an electrical insulator between the gate terminal and the substrate ofthe transistor. The transistor’s operation is governed by electrical ﬁelds caused by voltagesapplied to its terminals, as discussed below."
"The transistor’s state when VGS>VTis illustrated in Figure B.43b. The gate terminal is connected to VDD, resulting in VGS=5 V . The positive voltage on the gate attracts free electrons that exist in the type nsource terminal, as well as in other areas of the transistor, toward the gate. Because the electrons cannot pass through the layer of glass under the gate, they gather in the region of the substrate between the source and drain, which is calledthechannel. This concentration of electrons inverts the silicon in the area of the channel from type pto type n, which effectively connects the source and the drain. The size of the channel is determined by the length and width of the gate. The channel length Lis the dimension of the gate between the source and drain, and the channel width Wis the other dimension. The channel can also be thought of as having a depth, which is dependent onthe applied voltages at the source, gate, and drain."
"Dmay ﬂow from the drain node to the source. For a ﬁxed value of VGS>VT, the value of IDdepends on the voltage applied across the channel VDS.I f VDS=0 V , then no current ﬂows. As VDSis increased, ID increases approximately linearly with the applied VDS, as long as VDis sufﬁciently small to provide at least VTvolts across the drain end of the channel, that is VGD>VT. In this range of voltages, namely, 0 <VDS<(VGS−VT), the transistor is said to operate in the triode region, also called the linear region. The relationship between voltage and current is approximated by the equation"
"AsVDis increased, the current ﬂow through the transistor increases, as given by Equation B.1, but only to a certain point. When VDS=VGS−VT, the current reaches its maximum value. For larger values of VDS, the transistor is no longer operating in the triode region. Since the current is at its saturated (maximum) value, we say that the transistor is inthesaturation region. The current is now independent of V"
"The behavior of PMOS transistors is the same as for NMOS except that all voltages and currents are reversed. The source terminal of the PMOS transistor is the terminal with the higher voltage level (recall that for an NMOS transistor the source terminal is the one withthe lower voltage level), and the threshold voltage required to turn the transistor on has anegative value. PMOS transistors have the same physical construction as NMOS transistorsexcept that wherever the NMOS transistor has type nsilicon, the PMOS transistor has type p, and vice versa. For a PMOS transistor the equivalent of Figure B.43a is to connect both the source and gate nodes to V"
"Figure B.46 includes labels at the points where the output voltage begins to change from high to low, and vice versa. The voltage VILrepresents the point where the output voltage is high and the slope of the curve equals −1. This voltage level is deﬁned as the maximum input voltage level that the inverter will interpret as low, hence producing ahigh output. Similarly, the voltage V"
"The presence of noise may alter the voltage level, but as long as it remains less than VIL, it will be interpreted correctly by N2. The ability to tolerate noise without affecting the correct operation of the circuit is known as noise margin. For the low output voltage, we deﬁne the low noise margin as"
"The existence of stray capacitance has a negative effect on the speed of operation of logic circuits. V oltage across a capacitor cannot change instantaneously. The time needed tocharge or discharge a capacitor depends on the size of the capacitance Cand on the amount of current through the capacitor. In the circuit of Figure B.47b, when the PMOS transistor inN 1is turned on, the capacitor is charged to VDD; it is discharged when the NMOS transistor is turned on. In each case the current ﬂow IDthrough the involved transistor and the value ofCdetermine the rate of charging and discharging the capacitor."
This expression speciﬁes that the speed of the circuit depends both on the value of Cand on the dimensions of the transistor. The delay can be reduced by making Csmaller or by making the ratio W/Llarger. The expression shows the propagation time when the output changes from a high level to a low level. The low-to-high propagation time is given by the same expression but using k/prime pandW/Lof the PMOS transistor.
"Figure B.49 Transistor sizes. but a larger width. There is a trade-off involved in choosing transistor sizes, because a larger transistor takes more space on a chip than a smaller one. Also, increasing Wnot only increases the amount of current ﬂow in the transistor but also results in an increasein the parasitic capacitance (recall that the capacitance C gbetween the gate terminal and ground is proportional to W×L), which tends to offset some of the expected improvement in performance. In logic circuits large transistors are used where high capacitive loads mustbe driven and where signal propagation delays must be minimized."
"In an electronic circuit it is important to consider the amount of electrical power consumedby the transistors. Integrated circuit technology allows fabrication of billions of transistorson a single chip; hence the amount of power used by an individual transistor must be small.Power dissipation is an important consideration in all applications of logic circuits, but itis crucial in situations that involve battery-operated equipment, such as portable computersand the like."
"To distinguish between power consumed during steady-state conditions and power consumed when signals are changing, it is customary to deﬁne two types of power. Static power is dissipated by the current that ﬂows in the steady state, and dynamic power is consumed when the current ﬂows because of changes in signal levels. NMOS circuitsconsume static power as well as dynamic power, while CMOS circuits consume mostlydynamic power. Note that we mentioned in Section B.8.3 that a small amount of current,called leakage current, ﬂows through transistors that are turned off. Although this leakage current causes static power dissipation even when using CMOS circuits, we do not considerthis effect further in our discussion."
"Consider the CMOS inverter presented in Figure B.12a . When the input V xis low, no current ﬂows because the NMOS transistor is off. When Vxis high, the PMOS transistor is off and again no current ﬂows. Hence no current ﬂows in a CMOS circuit under steady-stateconditions. Current does ﬂow in CMOS circuits, however, for a short time when signalschange from one voltage level to another."
"The second, TG2, is used as a switch in the feedback loop that maintains the state of the circuit. The transmission gates are controlled by the Load signal. If Load=1, then TG1 is on and the point Awill have the same value as the Data input. Since the value presently stored at Output may not be the same value as Data, the feedback loop is broken by having"
"High fan-in CMOS logic gates always require either kNMOS or kPMOS transistors in series and are therefore never practical. In CMOS the only reasonable way to constructa high fan-in gate is to use two or more lower fan-in gates. For example, one way to realizea six-input AND gate is as 2 three-input AND gates that connect to a two-input AND gate.It is possible to build a six-input CMOS AND gate using fewer transistors than needed withthis approach, but we leave this as an exercise for the reader (see Problem B.4)."
"Figure B.48 illustrated timing delays for one NOT gate driving another. In real circuits each logic gate may be required to drive several others. The number of other gates that a speciﬁc gate drives is called its fan-out. An example of fan-out is depicted in Figure B.59a , which shows an inverter N 1that drives the inputs of nother inverters. Each of the other inverters contributes to the total capacitive loading on node f. In part (b)of the ﬁgure, theninverters are represented by one large capacitor Cn. For simplicity, assume that each inverter contributes a capacitance Cand that Cn=n×C. Equation B.4 shows that the propagation delay increases in direct proportion to n."
"Another type of driver is the inverting driver. It produces the same output as an inverter, f=x, but is built with relatively large transistors. The graphical symbol for the inverting driver is the same as for the NOT gate; an inverting driver is just a NOT gate that is capable of driving large capacitive loads. In Figure B.59 for large values of nan inverting driver could be used for the inverter labeled N1."
"The kind of wired connection used for the tri-state drivers is not possible with ordinary logic gates, because their outputs are always active; hence a short circuit would occur. Aswe already know, for normal logic circuits the equivalent result of the wired connection isachieved by using an OR gate to combine signals, as is done in the sum-of-products form."
"In Chapter 5 we introduced several types of circuits that can be used to store data. Assumethat we need to store a large number, m, of data items, each of which consists of nbits. One possibility is to use an n-bit register that consists of nD ﬂip-ﬂops for each data item. We would need to design circuitry to control access to each register, both for loading (writing)data into it and for reading data out."
"When mis large, it is awkward to use individual registers to store the data. A better approach is to make use of a static random access memory (SRAM) block. An SRAM block is a two-dimensional array of SRAM cells, where each cell can store one bit of information.If we need to store mitems with nbits each, we can use an array of m×nSRAM cells."
"Hence the transistor controlled by Selmay attempt to drive the stored data to one logic value while the output of the small NOT gate has the opposite logic value. To resolve thisproblem, the NOT gate in the feedback path is built using small (weak) transistors, so thatits output can be overridden with new data."
"To read data stored in the cell, we simply set Selto 1. In this case the Data node would not be driven to any value by external circuitry, so that the SRAM cell can place the storeddata on this node. The Data signal is passed through a driver, not shown in the ﬁgure, and provided as an output of the SRAM block."
"In this technology each pair of horizontal and vertical wires that cross is connected by asmall metal fuse. When the chip is programmed, for every connection that is not wantedin the circuit being implemented, the associated fuse is melted. The programming processis not reversible, because the melted fuses are destroyed. We will not elaborate on thistechnology, because it has mostly been replaced by another method."
"In currently produced PLAs and PALs, programmable switches are implemented using a special type of programmable transistor. Because CPLDs comprise PAL-like blocks, the technology used in SPLDs is also applicable to CPLDs. We will illustrate the main ideasby ﬁrst describing PLAs. For a PLA to be useful for implementing a wide range of logicfunctions, it should support both functions of only a few variables and functions of manyvariables. In Section B.8.9 we discussed the issue of fan-in of logic gates. We showed thatwhen the fan-in is high, the best type of gate to use is the NMOS NOR gate. Hence PLAsare usually based on this type of gate."
Figure B.67 An example of a NOR-NOR PLA. are arranged in a regular structure that is efﬁcient to create on an integrated circuit. This structure is called a NOR plane. The NOR plane is extended to larger sizes by adding columns for additional inputs and adding rows for more NOR gates.
"Strictly speaking, the term PLA should be used only for the ﬁxed type of PLA depicted in Figure B.67. The proper technical term for a programmable type of PLA isﬁeld-programmable logic array (FPLA). However, it is common usage to omit the F. Figure B.68a shows a programmable version of a NOR plane. It has ninputs, x 1,...,x n, andkoutputs, S1,...,S k. At each crossing point of a horizontal and vertical wire there exists a programmable switch. The switch comprises two transistors connected in series, anNMOS transistor and an electrically erasable programmable read-only memory (EEPROM) transistor."
"The programmable switch is based on the behavior of the EEPROM transistor. Electronics textbooks, such as [1, 2], give detailed explanations of how EEPROM transistorsoperate. Here we will provide only a brief description. A programmable switch is depictedin Figure B.68b, and the structure of the EEPROM transistor is given in Figure B.68c . The"
EEPROM transistor has the same general appearance as the NMOS transistor (see FigureB.43) with one major difference. The EEPROM transistor has two gates: the normal gatethat an NMOS transistor has and a second ﬂoating gate. The ﬂoating gate is so named because it is surrounded by insulating glass and is not connected to any part of the transistor.
"When the transistor is in the original unprogrammed state, the ﬂoating gate has no effect on the transistor’s operation and it works as a normal NMOS transistor. During normal useof the PLA, the voltage on the ﬂoating gate V eis set to VDDby circuitry not shown in the ﬁgure, and the EEPROM transistor is turned on."
"Programming of the EEPROM transistor is accomplished by turning on the transistor with a higher-than-normal voltage level (typically, Ve=12 V), which causes a large amount of current to ﬂow through the transistor’s channel. Figure B.68c shows that a part of the ﬂoating gate extends downward so that it is very close to the top surface of the channel."
"A high current ﬂowing through the channel causes an effect, known as Fowler-Nordheim tunneling, in which some of the electrons in the channel “tunnel” through the insulatingglass at its thinnest point and become trapped under the ﬂoating gate. After the programmingprocess is completed, the trapped electrons repel other electrons from entering the channel."
"ROM, called erasable PROM (EPROM). This type of transistor, which was actually created as the predecessor of EEPROM, is programmed in a similar fashion to EEPROM. However,erasing is done differently: to erase an EPROM transistor, it must be exposed to light energyof speciﬁc wavelengths. To facilitate this process, chips based on EPROM technology arehoused in packages with a clear glass window through which the chip is visible. To erasea chip, it is placed under an ultraviolet light source for several minutes. Because erasure of EPROM transistors is more awkward than the electrical process used to erase EEPROMtransistors, EPROM technology has essentially been replaced by EEPROM technology inpractice."
"NOR plane, then according to DeMorgan’s theorem, this is equivalent to creating an ANDplane. We can generate the complements at no cost in the PLA because each input is alreadyprovided in both true and complemented forms. An example that illustrates implementationof the sum-of-products form is given in Figure B.70. The outputs from the ﬁrst NORplane are labeled P 1,...,P 6to reﬂect our interpretation of them as product terms. The signal P1is programmed to realize x1+x2=x1x2. Similarly, P2=x1x3,P3=x1x2x3, and"
"An alternative to using a single NMOS transistor as a switch is to use a transmission gate, described in Section B.8.8. While this approach solves the voltage-level problem, it hastwo drawbacks. First, having both an NMOS and PMOS transistor in the switch increasesthe capacitive loading on the interconnection wires, which increases the propagation delaysand power consumption. Second, the transmission gate takes more chip area than does asingle NMOS transistor. For these reasons, commercial FPGA chips do not currently usetransmission-gate switches."
"Which of these two types of chips are used in a speciﬁc design situation depends on many factors. Following the trend of putting as much circuitry as possible into a single chip,FPGAs are more widely used than other PLDs. Most digital designs created in the industrytoday contain some type of FPGA."
"Since all input variables are complemented in this expression, we can directly derive the pull-up network as having parallel-connected PMOS transistors controlled by x1and x2, in series with parallel-connected transistors controlled by x3andx4, in series with a transistor controlled by x5. This circuit, along with the corresponding pull-down network, is shown in Figure B.76."
"When V x=VDD,Vfhas a low value. The NMOS transistor is operating in the triode region, while the PMOS transistor limits the current ﬂow because it is operating in thesaturation region. The current through the NMOS and PMOS transistors has to be equaland is given by Equations B.1 and B.2. Show that the low-output voltage, V f=VOLis given by"
"Vx=VDD, calculate the following: (a) The static current, Istat. (b) The on-resistance of the NMOS transistor. (c)VOL. (d) The static power dissipated in the inverter.(e) The on-resistance of the PMOS transistor.(f) Assume that the inverter is used to drive a capacitive load of 70 fF. Using Equation B.4,calculate the low-to-high and high-to-low propagation delays."
"B.32. The two NMOS transistors in a CMOS NOR gate are connected in parallel. The worst case current to drive the output low happens when only one of these transistors is turned “ON”. Thus each transistor has to have the same dimensions as the NMOS transistor in theinverter, namely W n/Ln=2."
"The two PMOS transistors are connected in series. If each of these transistors had the ratio Wp/Lp, then the two transistors could be thought of as one transistor with a Wp/2L p ratio. Thus each PMOS transistor must be made twice as wide as that in the inverter, namelyW n/Ln=8."
"His	main	research	interests	include	analog	and	mixed-signal	integrated-circuit design	and	energy	harvesting	and	sensor	networking	applications.Copyright	©	2017	by	McGraw-Hill	Education.	All	rights	reserved.	Except	as permitted	under	the	United	States	Copyright	Act	of	1976,	no	part	of	this publication	may	be	reproduced	or	distributed	in	any	form	or	by	any	means,	or stored	in	a	database	or	retrieval	system,	without	the	prior	written	permission	of the	publisher."
"All	trademarks	are	trademarks	of	their	respective	owners.	Rather	than	put	a trademark	symbol	after	every	occurrence	of	a	trademarked	name,	we	use	names in	an	editorial	fashion	only,	and	to	the	benefit	of	the	trademark	owner,	with	no intention	of	infringement	of	the	trademark.	Where	such	designations	appear	in this	book,	they	have	been	printed	with	initial	caps."
"Except	as	permitted	under	the	Copyright	Act	of	1976	and	the	right	to	store	and retrieve	one	copy	of	the	work,	you	may	not	decompile,	disassemble,	reverse engineer,	reproduce,	modify,	create	derivative	works	based	upon,	transmit,engineer,	reproduce,	modify,	create	derivative	works	based	upon,	transmit, distribute,	disseminate,	sell,	publish	or	sublicense	the	work	or	any	part	of	it without	McGraw-Hill	Education’s	prior	consent.	You	may	use	the	work	for	your own	noncommercial	and	personal	use;	any	other	use	of	the	work	is	strictly prohibited.	Your	right	to	use	the	work	may	be	terminated	if	you	fail	to	comply with	these	terms."
"McGraw-Hill	Education	nor	its	licensors	shall	be	liable	to	you	or	anyone	else	for any	inaccuracy,	error	or	omission,	regardless	of	cause,	in	the	work	or	for	any damages	resulting	therefrom.	McGraw-Hill	Education	has	no	responsibility	for the	content	of	any	information	accessed	through	the	work.	Under	no circumstances	shall	McGraw-Hill	Education	and/or	its	licensors	be	liable	for	any indirect,	incidental,	special,	punitive,	consequential	or	similar	damages	that result	from	the	use	of	or	inability	to	use	the	work,	even	if	any	of	them	has	been advised	of	the	possibility	of	such	damages.	This	limitation	of	liability	shall	apply to	any	claim	or	cause	whatsoever	whether	such	claim	or	cause	arises	in	contract, tort	or	otherwise.Contents"
"Therefore,	this	book	aims	to	guide	the	reader	to	mastering	FPGAs	through digital	system	design.	While	doing	this,	the	main	focus	will	be	on implementation.	Hence,	the	reader	will	grasp	theoretical	digital	design	concepts via	implementing	real-life	applications.	For	this	purpose,	we	pick	two	recent boards:	Basys3	and	Arty.	Both	boards	have	a	Xilinx	Artix-7	FPGA	on	them."
"Baysy3	has	most	of	the	required	peripherals	onboard.	Hence,	it	is	an	excellent candidate	for	being	used	in	digital	design	education.	Arty	has	Arduinocompatible	pins.	Since	Arduino	is	widely	accepted	as	a	microcontroller	platform by	hobbyists,	it	has	a	wide	range	of	peripheral	devices	as	shields.	Arty	allows	us to	benefit	from	these.	Moreover,	the	hobbyist	can	switch	from	Arduino	to	Arty when	a	custom-made	digital	design	is	required.	Throughout	the	book,	we	will provide	practical	application	examples	mostly	on	the	Basys3	board	due	to	its available	resources	onboard.	However,	these	applications	can	be	modified	to work	on	the	Arty	board	as	well.	Besides,	we	will	use	simulation	for	almost	all applications.	Hence,	buying	Basy3	or	Arty	is	not	a	must	to	follow	the	book."
"HDL	has	its	advantages	and	disadvantages.	Throughout	the	book,	we	will	cover both	HDLs	in	parallel.	This	will	allow	readers	to	choose	the	HDL	he	or	she likes.	Note	that	this	is	not	a	book	on	advanced	Verilog	or	VHDL.	We	will	focus only	on	important	and	necessary	topics.	This	way,	we	expect	the	beginner	or hobbyist	to	benefit	from	the	book."
"Before	diving	into	the	fascinating	world	of	digital	systems,	we	would	like	to remind	the	reader	of	one	or	two	things.	We	did	not	intend	to	write	a	standard textbook	for	a	digital	design	course.	Therefore,	we	did	not	cover	theoretical concepts	in	depth.	Instead,	we	tried	to	explain	all	these	concepts	using	real-life applications.	This	way,	we	hope	the	reader	will	grasp	digital	design	concepts better.	Moreover,	we	do	not	believe	digital	design	is	just	a	mandatory engineering	course	to	be	attended.	It	is	a	talent	every	engineering	student	should gain	for	the	job	market.	Besides,	it	is	fun	to	play	with,	as	done	by	most hobbyists.	So,	let’s	enjoy	digital	design	with	the	FPGA	while	mastering	it."
"T he	world	around	us	has	become	digital.	Hence,	digital	systems	have become	the	dominant	part	of	our	lives.	Although	most	of	us	enjoy	benefits offered	by	digital	systems,	it	is	the	duty	of	a	candidate	engineer	to	learn	how	to design	and	analyze	them.	Besides,	digital	design	concepts	have	become	topics	of interest	to	a	hobbyist	and	the	maker	community	due	to	their	power	in implementing	systems.	Therefore,	we	aim	to	introduce	digital	system	design techniques	throughout	this	book."
"Although	there	are	several	ways	to	implement	a	digital	system,	we	will	focus only	on	implementation	by	field-programmable	gate	arrays	(FPGAs)	in	this book.	FPGA	can	be	taken	as	a	generic	platform	such	that	a	digital	system	can	be implemented	on	it.	Recently,	the	price	of	a	standard	FPGA	chip	has	become affordable.	Moreover,	evaluation	boards	using	such	chips	became	widespread."
"FPGA	on	them.	Basys3	has	most	digital	peripherals	on	it.	Therefore,	it	is suitable	for	education	purposes.	On	the	other	hand,	Arty	has	Arduino	compatible pins	such	that	Arduino	shields	can	be	used	with	it.	Therefore,	it	is	suitable	for hobbyists	and	the	maker	community.	Throughout	the	book,	we	will	provide practical	application	examples	mostly	on	the	Basys3	board	due	to	its	available resources	onboard.	However,	these	applications	can	be	modified	to	work	on	the"
"Therefore,	this	book	can	also	be	of	use	without	any	FPGA	board	at	hand.	In	the same	line,	most	concepts	to	be	explained	throughout	the	book	do	not	depend	on a	specific	FPGA	platform.	Hence,	a	different	FPGA	platform	can	also	be	used	to implement	them.	However,	there	are	some	concepts	that	require	a	specific	FPGA platform.	For	these,	minor	modifications	should	be	made	by	the	reader	for implementation.	Bearing	this	in	mind,	we	should	also	mention	the	software	to	be used	throughout	the	book.	We	will	use	the	Vivado	design	suite	to	implement	the designed	digital	system	on	the	Xilinx	Artix-7	FPGA.	This	design	suite	is supported	by	Xilinx.	As	of	the	writing	of	this	book,	Vivado	was	available	from"
"An	FPGA	is	itself	a	digital	electronic	system.	Therefore,	first	we	have	tointroduce	the	basic	digital	electronics	background.	The	second	chapter	of	the book	handles	this.	However,	digital	system	concepts	will	be	explained	briefly	in this	chapter.	They	will	be	analyzed	in	detail	in	the	following	chapters.	The	third chapter	of	the	book	explores	properties	of	Basys3	and	Arty	boards.	Here,	the	aim is	getting	familiar	with	physical	hardware	to	be	used	throughout	the	book."
"Chapters 5 	and	 6 	can	also	be	taken	as	preparatory	steps	for	digital	system	implementation on	FPGA	via	HDL.	Based	on	these,	the	seventh	chapter	focuses	on combinational	circuits.	Here,	HDL	will	be	used	to	implement	basic combinational	circuits.	The	eighth	chapter	extends	these	concepts	further	such that	more	complex	digital	systems	can	be	constructed	via	HDL.	The	ninth chapter	is	on	data	storage	elements	that	are	extensively	used	in	constructing sequential	circuits.	As	a	follow-up,	the	tenth	chapter	introduces	sequential circuits.	Here,	standard	sequential	digital	systems	such	as	counters	and	registers are	evaluated.	Therefore,"
"T he	aim	of	this	book	is	explaining	field-programmable	gate	array	(FPGA) usage	for	digital	system	implementation.	Naturally,	the	first	step	in	doing	this	is explaining	what	an	FPGA	is.	An	FPGA	is	itself	a	digital	system	composed	of basic	building	blocks.	Therefore,	some	digital	logic	background	is	necessary	to understand	the	FPGA	architecture.	To	do	so,	we	adopt	the	following	strategy	in this	book.	We	start	with	the	basics	of	digital	electronics	in	this	chapter.	Then,	we explain	the	architecture	of	an	FPGA	using	abstract	building	blocks.	As	we overview	the	FPGA	architecture	in	this	chapter,	we	focus	on	the	digital	system design	and	implementation	philosophy	using	the	FPGA	next.	Finally,	we summarize	the	usage	areas	of	the	FPGA	to	motivate	the	reader. 2.1	A	Brief	Introduction	to	Digital	Electronics"
"There	are	two	main	approaches	in	explaining	digital	systems.	The	first	one starts	with	digital	electronic	representation	and	ends	up	with	it.	Here,	all concepts	are	explained	in	transistor	level.	Although	this	approach	is	reasonable, it	is	not	suitable	for	us	since	the	reader	does	not	need	such	a	detailed	explanation to	use	an	FPGA.	The	second	approach	is	not	mentioning	any	hardware representation	and	explaining	all	concepts	using	binary	representation	and"
"All	digital	devices	are	based	on	binary	representation.	In	other	words,All	digital	devices	are	based	on	binary	representation.	In	other	words, everything	in	a	digital	device	is	represented	in	terms	of	two	logic	levels	as	zero and	one.	At	first,	this	may	seem	unreasonable.	How	is	it	possible	to	represent data	processing	in	all	complex	digital	devices	(including	computers,	tablets, smart	phones,	etc.)	in	terms	of	zeros	and	ones?	Well,	this	is	the	case.	Throughout the	book,	we	will	try	to	convince	the	reader	that	all	complex	digital	systems	are composed	of	basic	building	blocks	working	on	binary	logic	levels.	Moreover,	we will	show	that	most	parts	of	these	devices	can	be	implemented	on	an	FPGA."
"Next	comes	the	second	question.	How	is	a	binary	digit	(or	a	bit,	in	short) represented	in	a	digital	device?	The	answer	to	this	question	leads	to understanding	digital	logic	concepts	in	the	physical	level.	In	its	basic	sense,	we have	two	voltage	levels	to	represent	a	binary	digit	(either	as	zero	or	one).	Let’s call	these	ground	(zero)	and	supply	voltage	("
"A	digital	circuit	can	be	constructed	by	transistors.	A	transistor	is	an	active circuit	element	used	either	as	an	amplifier	or	a	digital	switch.	The	latter	property is	extremely	important,	since	all	binary	logic	operations	can	be	performed	this way.	Instead	of	dealing	with	physical	properties	of	a	transistor,	we	can	simplify its	characteristics	as	follows."
"The	buffer	can	be	taken	as	a	logic	gate	which	feeds	its	input	to	output	without changing	it.	Therefore,	it	does	not	perform	any	logical	operation.	However,	the buffer	is	extremely	important	in	input/output	ports	of	digital	devices	to	minimize voltage	loading	effects	between	different	elements.	In	other	words,	the	buffer acts	as	a	protective	shield.	We	will	see	this	usage	extensively	in	the	input/output ports	of	an	FPGA	implementation	in	the	following	chapters.	We	can	represent the	buffer	in	symbolic	form	as	in"
"As	can	be	seen	in	Eq.	(2.1),	the	NOT	gate	is	a	simple	inverter	in	terms	of binary	logic.	When	a	logic	level	zero	is	applied	to	its	input,	output	will	be	logic level	one.	When	a	logic	level	one	is	applied	to	input	of	the	NOT	gate,	output	will be	zero."
"The	architecture	of	the	FPGA	should	be	known	by	the	reader	to	appreciate	its working	principles.	Although	the	reader	will	not	directly	interact	with	the architecture,	this	knowledge	will	lead	to	better	usage	of	the	FPGA.	Besides, design	principles	to	be	applied	in	implementing	a	digital	system	on	the	FPGA will	make	sense.	Therefore,	we	will	introduce	basic	building	blocks	of	the	FPGA (Xilinx	Artix-7	XC7A35T)	available	on	the	Basys3	and	Arty	boards	in	this section.	These	building	blocks	will	be	represented	in	abstract	form.	Since	we	do not	want	to	go	into	detail	of	digital	electronics,	we	believe	this	level	is	sufficient.not	want	to	go	into	detail	of	digital	electronics,	we	believe	this	level	is	sufficient."
"Input/output	pins	are	grouped	into	banks.	Two	pins	in	these	banks	are	grouped as	positive	(P)	and	negative	(N)	pairs.	These	can	be	used	in	two	modes	as	singleended	and	differential.	In	the	single-ended	mode,	input	will	be	recognized	as logic	level	zero	when	input	voltage	is	near	ground.	It	will	be	recognized	as	logic level	one	when	input	voltage	is	near"
"VCC .	In	the	differential	mode,	input	will	be recognized	as	logic	level	zero	when	the	voltage	at	pin	P	is	lower	than	the	voltage at	pin	N.	When	the	voltage	at	pin	P	is	higher	than	the	voltage	at	pin	N,	then	input will	be	taken	as	logic	level	one."
"XC7A35T	FPGA.	Therefore,	we	will	try	to	explain	it	using	known	digital devices.	A	LUT	can	be	thought	of	as	a	collection	of	flip-flops	connected	to	input pins	of	a	multiplexer.	Select	pins	of	the	multiplexer	will	be	taken	as	address	bits of	the	flip-flop	to	be	reached.	This	architecture	can	be	used	to	implement	any combinational	logic	function	which	has	total	number	of	variables	as	select	pins."
"Clock	is	basically	a	periodic	square	signal	such	that	it	stays	at	logic	level	zero and	one	for	certain	time	intervals.	Most	digital	systems	need	a	clock	signal	to operate	in	synchronous	manner.	In	such	a	setting,	logic	operations	are	done	in the	rising	edge	(from	logic	zero	to	one	transition)	or	falling	edge	(from	logic	one to	zero	transition)	of	the	clock	signal.	Hence,	period	of	the	clock	signal	indicates operation	speed	in	the	digital	system.	We	will	see	clock-based	operations	in"
"An	analog	signal	can	be	processed	by	a	digital	system	after	being	sampled	and quantized.	Module	performing	these	operations	is	called	the	analog-to-digital converter	(ADC).	Since	recent	advances	in	digital	systems	require	processing analog	signals,	the	Artix-7	FPGA	has	a	dedicated	block	called	XADC.The	Artix-7	XC7A35T	FPGA	has	one	XADC	block	which	consists	of	two"
"The	first	important	point	to	remember	while	using	an	FPGA	for	digital	system design	is	that	the	user	is	free	to	choose	the	design	methodology.	In	other	words, the	same	digital	system	can	be	implemented	in	more	than	one	way.	Therefore,	it is	the	designer’s	responsibility	to	pick	the	optimal	or	best	design	style	for	his	or her	needs."
"The	second	important	point	to	remember	while	using	FPGAs	is	that	in	thebeginning	there	is	no	predefined	block	to	do	the	job.	The	designer	has	a powerful	and	unconstrained	resource	(within	limits)	to	construct	required	design blocks.	Therefore,	a	strong	digital	logic	knowledge	is	required	to	design	efficient and	optimized	FPGA	designs.	Vendors	are	also	providing	intellectual	property (IP)	blocks	to	simplify	the	FPGA	usage.	These	are	valuable	sources	used extensively	in	practical	applications.	We	will	introduce	how	to	use	them	in"
"We	can	categorize	digital	system	design	and	implementation	resources	into four	groups	as	discrete	element,	application-specific	integrated	circuit	(ASIC), the	FPGA,	and	microcontroller	based.	The	standard	question	arises.	When should	we	use	an	FPGA	instead	of	other	design	options?	Or,	what	are	the advantages	and	disadvantages	of	using	the	FPGA	over	other	design	options?"
"A	digital	system	can	be	implemented	using	discrete	elements.	This	has	been the	design	strategy	for	a	long	time.	The	advantage	here	is	that	the	designer	only uses	needed	logic	gates	or	discrete	elements.	Moreover,	using	these	does	not require	any	expertise	besides	basic	logic	knowledge.	On	the	other	hand,	using discrete	elements	in	logic	design	is	not	feasible	in	most	cases.	First,	physical space	needed	to	implement	them	may	be	limited.	Second,	wire	connections between	discrete	elements	may	become	prohibitive	in	implementation.	Third,	the design	will	be	static	once	implemented.	The	FPGA	provides	a	neat	solution	to these	problems.	Size	of	an	FPGA	chip	is	fixed	independent	of	logic	elementsthese	problems.	Size	of	an	FPGA	chip	is	fixed	independent	of	logic	elements inside	it.	Moreover,	interconnection	of	these	elements	is	implicit	in	the	FPGA."
"Therefore,	wiring	of	logic	elements	is	not	an	issue.	The	most	important advantage	of	the	FPGA	comes	when	design	needs	to	be	reconfigured.	Here, using	the	FPGA	simplifies	life	for	the	designer.	The	design	can	be	reconfigured by	altering	the	corresponding	HDL	section.	The	only	issue	here	is	the	need	of expertise	in	HDL."
"ASICs	provide	a	good	alternative	to	discrete	implementation.	They	overcome the	space	and	wiring	problems.	When	mass-produced,	an	ASIC	chip	becomes cheaper.	Moreover,	the	ASIC	chip	will	be	specific	to	the	design.	Therefore,	it will	only	use	the	required	number	of	digital	logic	elements.	Note	that	an	FPGA chip	can	also	be	taken	as	ASIC.	In	this	section,	we	specifically	call	a	digital circuit	as	ASIC	which	is	designed	for	a	specific	purpose.	Therefore,	once designed	the	topology	will	be	fixed.	This	is	the	drawback	of	ASIC	design.	The biggest	problem	in	using	ASIC	is	its	fabrication	time.	FPGAs	provide	a	clear advantage	here.	In	fact,	most	ASIC	designs	are	prototyped	and	verified	on	the"
"The	first	difference	between	them	is	that	the	microcontroller	has	a	unique	set	of commands	(instruction	set)	to	perform	an	action.	Therefore,	the	user	should adjust	his	or	her	design	accordingly.	This	is	not	an	issue	to	an	FPGA	user.	As	we have	mentioned	previously,	the	FPGA	can	be	taken	as	a	free	design	environment within	limits.	Therefore,	an	FPGA	is	more	flexible	compared	to	the microcontroller.	However,	we	should	admit	that	programming	a	microcontroller is	fairly	easy	compared	to	managing	an	FPGA.	The	second	difference	between the	microcontroller	and	FPGA	is	power	consumption	in	which	the	FPGA	has	a clear	advantage.	The	third	difference	between	the	microcontroller	and	FPGA	is in	the	inherent	parallel	implementation	capacity	of	the	FPGA.	A	microcontroller is	a	sequential	device	such	that	commands	are	performed	step	by	step.	However, the	FPGA	can	be	reconfigured	as	a	parallel	device.	Hence,	desired	operations can	be	performed	faster	in	 orders	of	magnitude	in	the	FPGA.	Note	that	a microcontroller	can	be	implemented	using	an	FPGA.	We	will	introduce	this concept	in"
"FPGAs	can	be	used	in	almost	all	areas	where	digital	systems	are	needed.	To motivate	the	reader	and	show	why	learning	digital	design	using	the	FPGA	is important,	we	list	possible	usage	areas	as	follows:	aerospace,	automotive, broadcast,	consumer	electronics,	defense,	high-performance	computing,broadcast,	consumer	electronics,	defense,	high-performance	computing, industrial	applications,	medical	applications,	and	wireless	and	wired communications.	These	are	not	the	only	usage	areas	of	FPGAs.	New applications	may	emerge	in	time. 2.5	Summary"
"In	this	chapter,	we	will	briefly	explore	the	properties	of	Basys3	and	Arty boards.	We	will	also	analyze	peripheral	devices	and	connectors	on	each	board besides	the	FPGA.	While	doing	this,	we	will	not	go	into	the	details	of	the connection	diagrams	and	pin	correspondence	between	a	device	(or	connector) and	an	FPGA.	Since	this	correspondence	will	be	done	by	the	Vivado	design	suite (to	be	introduced	in"
VCC 	supply	voltage.	The	FPGA	receives	and	transmits	digital	data through	the	remaining	Pmod	pins.	There	is	also	an	analog	signal	Pmod connector	(label	3)	on	the	Basys3	board.	Pins	in	this	connector	are	connected	to analog	input	pins	of	the	FPGA.	The	XADC	block	in	the	FPGA	(introduced	in
The	USB	host	connector	(label	11)	can	be	used	to	transfer	the	configuration file	to	the	FPGA.	The	connector	also	has	USB	human	interface	device	(HID) capability.	These	two	properties	can	be	performed	through	the	PIC24FJ128 microcontroller	(label	19)	connected	to	the	connector.	We	will	use	the	USB	HID capability	to	connect	keyboard	and	mouse	to	the	Basys3	board	in
"Fig.	3.2 .	In	other	words,	Pmod	connectors used	in	Arty	are	the	same	as	in	Basys3.	However,	Pmod	connectors	in	the	Arty board	are	grouped	into	two	categories	as	standard	(labeled	as	JA	and	JD	on	the board)	and	high	speed	(labeled	as	JB	and	JC	on	the	board).	Standard	Pmod connectors	are	connected	to	the	FPGA	via	series	resistors	which	prevent accidental	short	circuit.	High-speed	connectors	do	not	have	such	resistors."
"The	first	step	in	realizing	a	digital	system	on	the	FPGA	is	synthesizing	it.	This means	representing	digital	system’s	HDL	description	via	the	FPGA	elements introduced	in	Sec.	2.2.	In	other	words,	this	step	transforms	the	system description	from	code	to	physical	device.	Note	that	Vivado	is	responsible	for	this operation.	Therefore,	synthesis	steps	are	hidden	to	the	user."
"Simulation	 → 	Run	Behavioral	Simulation.	When	the	simulation	ends,	Vivado opens	a	waveform	window	in	the	workspace	named	“Untitled1.”	The	reader	can use	zoom	tools	on	the	left-hand	side	and	fit	waveforms	in	the	window	to	check all	input	and	output	combinations	in	time.	The	simulation	result	should	appear	as in"
"If	we	want	to	realize	the	implemented	digital	system	on	the	Basys3	board,	we should	assign	its	peripheral	devices	as	input	and	output	ports	first.	As	briefly explained	in	Sec.	3.1,	the	hardware–software	interface	between	the	Basys3	board and	the	implemented	design	can	be	set	up	by	a	constraint	file."
"Basys3_Master.xdc ,	move	it	to	your	project directory.	Click	on	Add	Sources	under	Project	Manager	and	select	“add	or	create constraint”	from	the	menu.	Click	Next.	Then,	click	on	Add	Files	in	the	opened window.	Browse	and	locate	the	constraint	file	added	to	the	project	folder.	As	thisfile	is	added	to	the	project,	it	can	be	seen	in	the	Sources	window	under	the"
"Listing	4.1 	in	our	first	project.	We	can	create	a	custom	IP	from this	description.	To	do	so,	we	should	first	select	“Create	and	Package	IP...” option	under	the	Tools	section	in	Vivado.	A	new	window	appears	titled	as “Create	and	Package	New	IP.”	As	we	click	Next,	a	new	window	 appears	as	in"
"Fig.	4.22 .	Within	this	section,	the	reader	can make	necessary	adjustments	related	to	the	generated	IP.	To	finalize	IP generation,	we	should	select	the	Review	and	Package	option.	In	default	settings, the	generated	custom	IP	will	not	be	archived	for	future	use.	Only	the	current project	can	use	it.	To	change	this	option,	we	should	select	“edit	packaging settings.”	In	the	opened	project	settings	window,	we	should	select	the	IP	tab."
"Then,	“create	archive	of	IP”	should	be	checked	under	the	“After	Packaging” part.	Within	the	window,	we	can	also	set	the	archive	name	and	location.	This information	will	be	important	while	using	the	generated	IP	in	another	project.	As we	press	OK,	Package	IP	button	appears.	Pressing	this	button	generates	the	IP block	for	the	first	system.FIGURE	4.22 	Package	IP	-	first	system."
"Vivado	is	a	design	platform	to	synthesize,	simulate,	and	implement	HDL descriptions.	It	can	also	be	used	to	program	a	target	FPGA.	This	chapter introduced	Vivado	such	that	it	can	be	used	in	realizing	digital	systems	in	the following	chapters.	To	do	so,	we	started	from	scratch	and	developed	a	project using	provided	Verilog	and	VHDL	descriptions.	At	this	stage,	the	reader	may not	know	the	structure	of	the	description	provided.	Such	a	strategy	was necessary	to	coherently	explain	the	working	principles	of	Vivado.	We	will explain	how	these	descriptions	are	constructed	in	detail	in"
"Two	popular	HDLs	are	Verilog	and	VHDL.	This	chapter	introduces	basics	of both	HDLs.	We	will	explore	these	HDLs	in	detail	in	representing	digital	systems in	the	following	chapters.	Although	we	provide	Verilog	and	VHDL	in	one chapter,	we	strongly	suggest	the	reader	to	master	one	HDL	first,	then	learn	the other.	Throughout	the	book,	we	give	precedence	to	Verilog	since	it	resembles	C programming	language.	Therefore,	we	start	with	Verilog	fundamentals	next."
"Let’s	analyze	this	structure	in	detail.	First,	the	 module 	should	have	a	unique name	which	should	not	be	the	same	as	any	of	the	predefined	Verilog	keywords.In	the	above	description,	we	set	the	name	as	  .	Note	that we	can	use	the	symbol	 // 	to	add	a	comment	to	the	Verilog	description."
"The	first	method	in	describing	a	digital	system	is	using	structural	modeling.	In this	method,	each	element	to	be	used	in	the	description	statement	should	have been	defined	under	Verilog	as	a	structure.	Since	logic	gates	are	extensively	used in	Verilog	descriptions,	they	have	been	defined	beforehand.	Therefore,	this description	method	is	also	called	gate-level	modeling."
"Each	gate	is	represented	by	the	following	structure	in	this	method.	First,	gate type	is	defined	by	the	corresponding	Verilog	keyword.	Then,	a	name	for	the	gate is	assigned.	Note	that	name	assignment	is	not	mandatory.	Finally,	output	and input	ports	for	the	gate	are	defined	within	parenthesis.	Therefore,	the	structural model	of	a	logic	gate	will	be	as	 gate_keyword	name 	( port_list ).	The	port	list should	be	such	that	output	of	the	structure	is	defined	first."
"Verilog	keywords	for	 these	are	 and ,	 or ,	 not ,	and	 xor ,	respectively.	Let’s	give	a name	to	each	logic	gate	to	be	used	in	the	description	as	 gate_and ,	 gate_or , gate_not ,	and	 gate_xor ,	respectively.	Using	these,	we	can	construct	the structural	model.	There	is	one	issue	to	be	solved	in	describing	the	digital	system."
"In	other	words,	Verilog	keywords	corresponding	to	conditional	and	recursive statements	can	be	used	within	the	model.In	behavioral	modeling,	statement	(or	statements)	to	be	executed	should	be triggered	by	a	signal	(or	signals)	to	operate.	The	keyword	 always 	is	used	to indicate	this	triggering	operation.	Once	the	signal	changes	its	state,	the	statement is	executed.	If	there	is	more	than	one	statement	to	be	executed,	then	they	should be	encapsulated	by	 begin 	and	 end 	keywords.	Hence,	syntax	for	this representation	becomes	as	follows:"
"Here,	 sensitivity_list 	stands	for	triggering	signal(s).	The	sensitivity	list can	be	formed	of	signals	separated	by	comma	or	combined	by	 or 	keyword.	If	the behavioral	description	is	to	be	executed	for	any	input	changes,	then	 * 	sign	can	be used	instead	of	the	sensitivity	list.	Here,	whenever	one	of	the	signals	in	the sensitivity	list	changes	its	state,	the	behavioral	description	is	executed.	Again, order	of	statements	is	not	important	in	behavioral	modeling."
"Therefore,	at	the	beginning	of	the	always	block,	the	sensitivity	list	will	consist	of inputs	 in1 	and	 in2 .	We	can	represent	the	relation	between	input	and	output	of the	system	as	in	dataflow	modeling.	However,	the	 assign 	keyword	will	not	be used	in	behavioral	modeling.	Since	there	is	more	than	one	statement	to	be executed,	they	are	encapsulated	within	 begin 	and	 end 	keywords.	As	a	result, behavioral	model	of	the	first	system	will	be	as	in"
"Listing	5.4 .	The	 always keyword	executes	the	beneath	description	block	(encapsulated	by	 begin 	and	 end keywords)	whenever	 in1 	or	 in2 	changes.	If	there	is	no	change	in	these	variables, output	will	not	be	provided	by	the	system.	Therefore,	we	have	to	save	previous output	values.	This	can	be	done	by	the	Verilog	keyword	 reg .	We	used	this keyword	to	keep	the	previous	value	of	 out1 	and	 out2 	in"
"There	are	two	assignment	types	in	behavioral	modeling.	These	are	called blocking	and	nonblocking.	Statements	having	blocking	assignment	are	executed one	by	one	in	sequential	order.	Therefore,	as	the	name	implies,	each	assignment blocks	the	execution	of	the	next	in	hierarchy.	Operator	for	the	blocking assignment	is	 = .	Statements	having	nonblocking	assignment	are	executed concurrently.	Therefore,	they	don’t	block	each	other.	Operator	for	the nonblocking	assignment	is	 <= ."
"Vivado	allows	adding	simulation	timings	in	Verilog	descriptions.	Moreover,	if a	blank	Verilog	file	is	to	be	opened,	Vivado	adds	the	first	line	automatically	as ’timescale	1ns	/	1ps .	These	are	the	default	timing	values	such	that	the	first one ( 1ns )	indicates	the	reference	time	unit.	Whenever	a	time	value	is	added	to	the"
"Verilog	description,	it	will	be	in	the	order	of	one	nanosecond.	The	second	timing value	( 1ps )	indicates	the	smallest	precision	that	can	be	achieved.	Hence,	the default	smallest	precision	in	simulation	is	one	picosecond.	Again,	these	values will	be	of	use	during	simulation.	They	will	have	no	effect	in	the	actual	FPGA realization	step."
"Listing	5.5 	An	Example	on	Blocking	and	Nonblocking	AssignmentsUp	to	this	point,	we	did	not	take	physical	characteristics	of	logic	gates	into account	in	simulation.	In	other	words,	we	assumed	all	delay	times	to	be	zero within	logic	gates.	If	the	user	wants	to	obtain	accurate	results	(especially	in timing	diagrams)	of	the	implemented	digital	system,	then	delay	values	should	be added	to	the	Verilog	description.	These	can	be	done	in	connection	with	the reference	time	unit."
"These	are	rise	delay,	fall	delay,	and	turn-off	delay.	The	rise	delay	indicates	the transition	time	needed	from	any	logic	value	to	logic	level	one.	The	fall	delay indicates	the	transition	time	needed	from	any	logic	value	to	logic	level	zero.	The turn-off	delay	indicates	the	transition	time	needed	from	any	logic	value	to	high impedance.	Next,	we	provide	an	example	on	the	usage	of	these	delay	times	in structural	modeling."
"Listing	5.2 .	We	can represent	the	same	description	as	a	combination	of	three	modules	such	that	AND and	OR	gates	are	described	in	different	modules.	Let’s	call	these	as	 and_module and	 or_module ,	respectively.	These	should	be	formed	as	valid	modules	with their	input/output	ports	and	descriptions.	We	should	instantiate	the	 and_module and	 or_module 	in	the	top	module	 first_system .	This	can	be	done	as	if structural	modeling	is	used.	In	other	words,	the	 and_module 	should	be represented	within	the	 first_system 	module	as	 and_module instantiation_name 	( port_list )."
"There	are	two	options	in	forming	port	list	correspondence	between	module	to be	instantiated	and	the	top	module	using	it.	The	first	one	is	using	locations.	Here, the	port	list	order	in	the	top	module	and	instantiation	should	be	the	same.	The second	method	in	forming	the	port	list	correspondence	is	using	the	declaration .sub_module_name	(top_module_name) .	Here,	port	in	the	module	to	be instantiated	is	declared	as	 sub_module_name .	The	corresponding	port	in	the	top module	is	declared	as	 (top_	module_name) .	This	operation	should	be	done	for all	input/output	ports.	We	will	use	both	declarations	throughout	the	book, although	the	second	one	should	be	picked	whenever	possible."
"Then,	the	testbench	module	is	declared	as	 module	first_system_tb .	We specifically	assigned	such	a	name	to	the	testbench	module	to	associate	it	with	the top	module	to	be	tested.	The	reader	is	free	to	choose	any	valid	name	here.	Next, input	and	output	ports	of	the	testbench	module	are	declared	as	 reg	in1t,	in2t and	 wire	out1t,	out2t .	Again,	the	reader	can	pick	any	valid	name	for	each input	or	output	port	in	the	testbench	module."
"Here,	testbench	input	ports	( in1t 	and	 in2t )	are	initialized	first.	Then,	a	delay of	100	ns	is	added	by	the	command	 #100 .	This	delay	is	added	such	that	the module	to	be	tested	is	reset	properly.	Otherwise,	some	undesired	effects	may occur	during	simulation.	Next,	input	values	are	fed	to	the	UUT.	In"
"Hence,	 \ 	 t%b 	stands	for	“add	tab	and	represent	the	value	in	binary	form.”	The corresponding	variable	to	be	displayed	is	provided	in	the	second	part	of	the function	as	 in1t .	All	input	and	output	ports	are	tabulated	this	way.	Therefore, whenever	a	change	in	input	occurs,	it	is	displayed	on	Vivado’s	Tcl	console.	The console	output	will	be	as	in"
"Here,	 system_name 	is	the	name	assigned	to	the	system	to	be	described.	The keyword	 port 	defines	actual	ports	of	the	device.	Each	port	entry	will	have	a unique	name	indicated	by	 port_name .	A	 port_mode 	can	be	 in ,	 out ,	or	 inout .	As the	name	implies,	the	 in 	keyword	declares	that	the	related	port	will	get	data	from outside	world.	The	 out 	keyword	declares	that	the	related	port	will	feed	data	to outside	world.	The	 inout 	keyword	declares	that	the	related	port	can	be	used	for both	input	and	output	purposes.	VHDL	requires	variable	and	port	types	to	be used	in	entity	declaration	to	be	strongly	defined.	Therefore,	 port_type 	should	be declared	within	 library_elements 	included	to	the	design	by	 library 	and	 use keywords."
"Listing	4.2 ,	the	library	used	in	operation	is	picked	as ieee .	Within	this	library,	all	types	defined	under	the	 ieee.std_logic_1164 subset	are	imported.	This	allows	using	the	 std_logic 	type	which	can	represent binary	values	such	as	logic	level	zero	and	one.	We	will	evaluate	this	operation	in detail	in"
"Listing	4.2 	has	been	formed	in	terms	of dataflow	modeling.	There,	we	named	the	architecture	as	 dataflow_model .	The system	name	defined	in	the	entity	declaration	has	also	been	used	in	the architecture	definition	as	 first_system .	We	used	logic	gates	AND,	OR,	NOT, and	XOR	within	the	architecture	declaration.	Corresponding	VHDL	keywords for	these	are	 and ,	 or ,	 not ,	 xor ,	respectively.	For	completeness,	let’s	provide	the dataflow	model	of	this	system	in"
"Here,	the	 sensitivity_list 	stands	for	the	triggering	signal(s).	In	VHDL,	the sensitivity	list	can	be	formed	of	signals	separated	by	comma	only.	Whenever	one of	the	signals	in	the	sensitivity	list	changes	its	state,	the	behavioral	description	is executed.	The	process	may	have	its	own	declarations	which	can	be	placed	before the	 begin 	keyword.	Then,	the	behavioral	model	is	encapsulated	by	 begin 	andend	process 	keywords.	To	note	again,	the	order	of	statements	is	not	important in	behavioral	modeling."
"Behavior	of	the	system	will	change	when	the	first	or	second	input	changes	its value.	Therefore,	the	sensitivity	list	for	the	process	will	consist	of	inputs	 in1 	and in2 .	We	can	represent	the	relation	between	inputs	and	outputs	of	the	system similar	to	dataflow	modeling.	As	a	result,	the	behavioral	model	of	the	first system	will	be	as	in"
"As	in	Verilog,	we	can	add	delay	times	to	descriptions	in	VHDL.	This	leads	to precise	simulation	results	especially	in	timing	diagrams.	Again,	these	values	will be	of	use	during	simulation.	They	will	have	no	effect	in	the	actual	FPGA realization	step.Different	from	Verilog,	delay	times	can	be	added	to	a	VHDL	description using	the	keyword	 after .	Let’s	assume	that	we	want	to	add	a	20-ns	delay	to	the second	output	( out2 )	in"
"There	are	two	options	in	forming	the	port	list	correspondence.	The	first	one	is using	locations.	Here,	the	port	list	order	in	the	main	entity	declaration	and instantiation	should	be	the	same.	Although	this	is	a	valid	option,	it	may	cause problems	in	implementation	if	the	port	order	is	not	followed	correctly.	The second	method	in	forming	the	port	list	correspondence	is	using	the	declaration component_port_name	=>	main_port_name .	Here,	a	correspondence	is	formed between	each	port	in	the	component	and	main	entity	declarations.	Based	on these,	hierarchical	structural	representation	of	the	first	system	will	be	as	in"
"Here,	the	testbench	is	declared	as	 first_system_tb .	We	specifically	assignedsuch	a	name	to	associate	it	with	the	architecture	to	be	tested.	The	reader	is	free	to choose	any	valid	VHDL	name	here.	Entity	declaration	of	the	testbench	is	empty since	it	will	not	get	any	input	or	feed	output.	Signals	to	be	used	within	the testbench	file	are	declared	next.	These	are	 in1t ,	 in2t ,	 out1t ,	and	 out2t .	Note that	these	signals	are	initialized	while	being	declared.	More	information	on	this operation	can	be	found	in"
"UUT .	Then,	each	port	in the	testbench	 and	the	unit	to	be	tested	are	associated	(or	connected)	such	as	 in1 =>	in1t .	Here,	the	port	in	unit	to	be	tested	is	declared	as	 in1 .	The	corresponding port	in	the	testbench	is	declared	as	 in1t .	This	is	done	for	all	input/output	ports."
"IP	catalog	of	the	current	project.	To	do	so,	we	should	first	locate	the	custom	IP files.	Then,	we	should	select	the	Interfaces	tab	in	the	IP	Catalog.	We	should press	the	IP	settings	button	(the	last	one)	there.	In	the	opened	window,	we	should select	the	Repository_Manager	in	the	IP	tab.	Here,	we	should	add	the	IP repository	by	pressing	the	green	+	sign.	Here,	we	should	use	location	of	thecustom	IP	to	be	added.	Then,	the	window	should	look	like	as	in"
Instantiation	Template	section.	These	are	 first_system_0.vho 	and first_system_0.veo .	These	are	instantiation	blocks	to	be	used	in	the	top module.	The	first	file	is	for	use	in	a	Verilog	description.	The	second	file	is	for use	in	a	VHDL	description. FIGURE	5.7 	IP	block	representation	in	the	IP	sources	section.
"Verilog	and	VHDL	are	the	HDLs	to	be	used	throughout	the	book.	We explored	the	fundamental	properties	of	both	HDLs	through	examples	in	this chapter.	Basically,	we	explored	the	module	representation	in	Verilog.	Then,	we introduced	three	modeling	methods	 related	to	it.	Afterward,	we	considered	the effect	of	timing	and	delays	in	modeling.	We	also	considered	hierarchical	module representation	in	Verilog.	We	finally	analyzed	how	a	testbench	can	be	formed	inVerilog.	We	followed	the	same	methodology	in	exploring	VHDL	fundamentals next.	We	also	considered	adding	an	IP	block	to	a	Verilog	and	VHDL	project."
"HDL	description.	Therefore,	we	will	first	consider	binary,	octal,	and hexadecimal	number	representations.	Then,	we	will	explore	methods	to represent	a	negative	number	in	a	digital	system.	We	will	next	introduce	methods to	represent	a	binary	number	with	fractional	parts.	Here,	we	will	use	fixed-and floating-point	representations.	We	will	also	consider	the	ASCII	code	to	represent characters	in	a	digital	system.	Then,	we	will	evaluate	arithmetic	operations	on binary	numbers.	In	the	second	part	of	the	chapter,	we	will	explore	data	types	and operators	defined	in	Verilog	and	VHDL.	Therefore,	we	will	review	most	of	the concepts	introduced	in	the	first	part	of	the	chapter	using	HDLs.	Moreover,	we will	also	refer	to	data	types	used	in	previous	chapters.	Finally,	we	will	analyze how	all	these	concepts	can	be	realized	in	an	FPGA. 6.1	Number	Representations"
"We	can	convert	a	binary	number	to	hexadecimal	by	grouping	bits	in	blocks	of four.	Then,	each	group	can	be	represented	by	the	corresponding	hexadecimal digit.	If	bit	groups	do	not	form	blocks	of	four,	then	we	append	zeros	to	the integer	part	of	the	binary	number	as	a	prefix	and	fractional	part	as	a	suffix.	As	a result,	we	will	obtain	the	hexadecimal	representation."
"The	first	representation	mimics	the	daily	life	practice	(negative	sign	in	front	of number)	by	a	sign	bit	in	the	MSB	of	number.	In	this	representation,	a	positive number	will	have	the	sign	bit	as	zero.	A	negative	number	will	have	the	sign	bit as	one.	Hence,	the	name	signed	bit	representation.	Although	this	method	seems straightforward,	it	is	not	very	effective	since	addition	and	subtraction	may	need extra	operations	as	will	be	seen	in	Sec.	6.5."
"The	third	representation	is	based	on	two’s	complement.	Here,	the	negative number	is	first	represented	in	one’s	complement	form.	Then,	the	result	is incremented	by	one.	Two’s	complement	has	a	major	advantage	compared	to	the previous	representations.	Subtracting	two	binary	numbers	can	be	formulated	as adding	the	first	number	with	 two’s	complement	of	the	second.	The	result	also keeps	the	sign	information.	Therefore,	need	for	an	extra	sign	bit	is	eliminated."
"Fixed-point	representation	is	easy	to	implement	and	process.	However,	it	has a	major	drawback.	The	number	of	bits	assigned	to	integer	and	fractional	parts	is always	fixed	in	this	representation.	This	causes	limitations	both	in	the	range	of numbers	to	be	represented	and	their	resolution.	Floating-point	representation	can be	used	to	overcome	these	problems.	As	the	name	implies,	the	number	of	bits assigned	to	integer	and	fractional	parts	is	not	fixed	in	this	representation.	Instead, the	assigned	number	of	bits	differ	for	each	number	depending	on	its	significant digits.	Therefore,	a	much	wider	range	of	values	can	be	represented	in	this	form."
"We	do	not	only	process	numbers	in	digital	systems.	For	some	applications,	wemay	need	to	handle	characters	and	symbols	as	well.	We	know	that	everything	in a	digital	system	is	represented	in	binary	form.	Therefore,	characters	and	symbols should	also	be	represented	as	such.	One	way	of	representing	characters	and symbols	in	binary	form	is	using	the	ASCII	code.	ASCII	stands	for	the	American"
"E )	should	be	the	same	for	both	numbers.	If	they	are	not	the same,	then	fractional	parts	should	be	adjusted	accordingly.	Then,	addition	can	be done.	After	addition,	the	fractional	part	and	exponent	should	be	adjusted	such that	a	valid	floating-point	representation	is	obtained.	Here,	we	 assume	that	thesign	bit	of	two	numbers	to	be	added	are	the	same.	We	will	handle	adding	two numbers	with	different	sign	bits	in	the	next	section	under	subtraction."
"Two	binary	numbers	can	be	subtracted	in	two	different	ways.	The	first	method is	plain	subtraction	as	in	decimal	numbers.	There	is	nothing	specific	about	this operation.	The	second	method	is	using	two’s	complement	representation.	Here, the	negative	number	is	represented	in	two’s	complement	form.	This	provides	a clear	advantage	such	that	subtraction	is	performed	by	addition.	Hence,	no	second circuitry	is	needed	for	the	subtraction	operation.	Moreover,	if	the	result	of subtraction	is	negative	it	is	automatically	represented	in	two’s	complement	form as	well.	Therefore,	this	method	is	used	in	most	digital	systems."
"We	can	represent	binary,	octal,	hexadecimal,	and	decimal	constant	values (besides	others)	in	Verilog.	General	structure	of	representing	a	constant	for	these types	is	 bit_width	’radix	constant_value .	Here,	 bit_width 	indicates	the number	of	bits	to	represent	the	constant	value.	If	this	is	not	set,	the	default	value is	16	bits.	The	 radix 	can	be	binary	( b ),	octal	( o ),	hexadecimal	( h ),	or	decimal( d ).	The	 constant_value 	is	the	actual	constant	to	be	represented."
"A	net	or	variable	need	not	be	composed	of	one	bit	in	Verilog.	Instead,	it	can be	represented	as	a	vector.	This	allows	us	to	represent	data	in	compact	form.	The vector	format	for	representation	will	be	the	same	as	a	net	or	variable	definition with	an	extra	 [N-1:0] 	prefix	which	indicates	that	there	will	be"
"Verilog	has	five	arithmetic	operations	as	addition	( + ),	subtraction	( ), multiplication	( * ),	division	( / ),	and	modulus	(%).	All	these	operations	can	be performed	on	vectors	with	user-defined	size.	Hence,	these	can	be	called	fixedpoint	operations	with	user-defined	format.	When	result	of	an	operation	becomes negative,	it	is	represented	in	two’s	complement	form."
"This	is	done	by	the	curly	bracket.	Let’s	give	an	example.	Assume	that	we	want to	merge	two	vectors	 num1 	and	 num2 .	We	can	do	this	by	{ num1 ,	 num2 }.	The replication	operation	can	be	used	to	copy	a	vector	multiple	times	to	generate	a new	vector.	This	can	be	done	by	 n { num1 }	where	 n 	is	the	duplication	number."
"Hence,	it	can	be	used	to	connect	two	elements.	The	signal	(with	its	assigned type)	can	be	defined	as	 signal	signal_name	:	signal_type .	The	 variable data	type	in	VHDL	is	similar	to	the	one	in	Verilog.	However,	it	is	generally	used in	storing	intermediate	values	and	loop	counters.	Therefore,	we	will	provide	its usage	in	the	following	chapters	when	needed."
"The	signal	should	have	an	associated	type	which	defines	values	that	can	be taken	by	it.	Although	there	are	several	signal	types	in	VHDL,	we	will	use	four	of them	at	this	level	as	 std_logic ,	 std_logic_vector ,	 signed ,	and	 unsigned .	We may	introduce	new	types	in	the	following	chapters	if	needed."
"We	are	familiar	with	logic	level	zero	and	one	from	previous	chapters.	The undefined	logic	level,	 ,	is	used	in	logical	operations	when	the	corresponding value	is	unknown	or	it	does	not	affect	the	operation.	For	the	second	case,	 	is most	of	the	times	called	“don’t	care”	condition.	The	high	impedance	value	 z indicates	that	connection	at	that	point	is	disabled.	In	other	words,	an	open	circuit is	present	at	that	location."
"In	VHDL,	we	can	use	 std_logic_vector ,	 signed ,	and	 unsigned 	types	to represent	bit	arrays.	The	signal	array	(with	its	assigned	type)	can	be	defined	as signal	array_	name	:	array_type	(low	to	high) 	or	 signal	array_name	: array_type	(high	downto	low) .	Here,	 low 	and	 high 	values	indicate	the	array’s first	and	last	index	values."
"We	will	use	seven	arithmetic	operators	in	VHDL	throughout	the	book.	These are	absolute	value	( abs ),	multiplication	( ∗ ),	division	( / ),	modulus	( mod ), remainder	( rem ),	addition	(+),	and	subtraction	(-).	Except	 abs ,	all	arithmetic operations	are	performed	on	signed	or	unsigned	numbers.	Obtained	result	from these	operations	will	also	be	either	a	signed	or	unsigned	number.	The	 abs 	needs a	signed	number	to	operate.	As	in	Verilog,	when	the	result	of	an	operation	is negative,	it	is	represented	in	two’s	complement	form	in	VHDL.	Note	that addition	and	subtraction	operations	can	also	be	applied	to	signals	defined	by std_logic_vector ."
"In	this	section,	we	will	construct	a	primitive	calculator	to	add,	subtract, multiply,	and	divide	two	four-bit	numbers	on	the	Basys3	board.	Input	bits	and the	operation	type	is	represented	by	switches	on	the	board.	Output	bit	values	are represented	by	LEDs	on	the	board.	The	reader	can	consult	Sec.	4.8	related	to	this setup.	In"
"Fig.	6.14 	is	kept	when	subtraction,	multiplication,	and division	operations	are	implemented.	However,	the	reader	should	remember	that these	operations	are	done	on	two	vectors	each	having	two	bits.	If	the	vector length	is	increased,	resource	usage	difference	between	arithmetic	operations become	more	apparent.	For	example,	when	eightbit	addition,	subtraction, multiplication,	and	division	operations	in"
"We	introduced	key	data	type	and	operator	concepts	in	this	chapter.	While doing	this,	we	first	explored	number	representations,	negative	numbers,	and fixed-and	floating-point	numbers	from	a	generic	point	of	view.	Then,	we explored	binary	arithmetic	operations.	We	next	explored	all	of	these	concepts using	HDLs.	We	postponed	floating-point	operation	implementation	in	HDL descriptions	till"
"Assume	that	the	analog	interfacing	is	done	and	the	ADC	module	is	set	to work.	Hence,	you	get	two	vectors	as	xp	and	yp	each	with	12	bits	each.	We will	take	the	most	significant	eight	bits	for	xp	 and	yp.	Hence,	sample hexadecimal	values	of	these	vectors	with	respect	to	joystick	position	are	as in"
"A digital	system	can	be	implemented	in	two	forms.	In	the	first	one,	output depends	on	current	input	only.	This	form	can	be	realized	by	combinational circuits,	which	is	the	main	topic	of	this	chapter.	In	the	second	form,	output depends	on	past	input	or	output	values	besides	the	current	input.	This	form	can be	realized	by	sequential	circuits,	which	will	be	introduced	in"
"To	understand	the	working	principles	of	a	combinational	circuit,	we	will	start with	basic	definitions.	Then,	we	will	review	logic	gates	from	a	combinational circuit	perspective.	Afterward,	we	will	introduce	tools	to	analyze	combinational circuits.	Related	to	this,	we	will	explore	how	a	combinational	circuit	can	be implemented	in	an	field-programmable	gate	array	(FPGA).	Then,	we	will evaluate	combinational	circuit	design	steps.	We	will	also	provide	sample	designs so	that	the	reader	can	grasp	the	idea	in	designing	such	a	circuit.	We	will	finally summarize	how	FPGA	building	blocks	are	used	in	combinational	circuit implementation. 7.1	Basic	Definitions"
"While	analyzing	or	designing	a	combinational	circuit,	logic	level	at	certain location	may	be	needed.	To	represent	this	value	in	generic	form,	we	will	assign	a binary	variable	at	that	location.	This	variable	can	only	take	either	logic	level	zero or	one	by	its	definition.	Since	we	will	be	extensively	using	these	logic	levels	for binary	variables,	we	will	call	them	as	0	and	1	from	this	point	on."
"A	logic	function	by	its	definition	is	formed	of	logic	gates	operating	on	binary variables.	To	be	more	specific,	inputs	of	a	logic	function	are	defined	as	binary variables.	Then,	logic	gates	operating	on	these	produce	output,	again	as	a	binary variable.	This	will	allow	us	to	represent	a	combinational	circuit	in	formal	way."
"One	way	of	describing	input/output	characteristics	of	a	logic	function	is	by forming	its	truth	table	which	will	tabulate	all	input	combinations	on	its	left-hand side.	For	each	input	combination,	corresponding	output	will	be	provided	on	the right-hand	side	of	the	table.	Hence,	a	generic	truth	table	will	be	as	in"
"A	NOT	gate	can	be	connected	to	output	of	the	OR	gate.	This	combination forms	the	NOR	(NOT-OR)	gate.	As	in	the	OR	gate,	let’s	assume	inputs	of	this gate	be	represented	by	binary	variables	 x 	and	 y ;	and	let	output	of	the	gate	be binary	variable	 z .	Then,	the	two-input	NOR	gate	can	be	represented	by	the	logic function	 z 	=	 x 	+	 y .	The	truth	table	of	the	NOR	gate	based	on	this	logic	function will	be	as	in"
"A	NOT	gate	can	be	connected	to	output	of	the	AND	gate.	This	combination forms	the	NAND	gate.	As	in	the	AND	gate,	let’s	assume	input	to	this	gate	be binary	variables	 x 	and	 y ;	and	output	of	the	gate	be	binary	variable	 z .	Then,	the two-input	NAND	gate	can	be	represented	by	the	logic	function	 z 	=	 x	·	y .	The truth	table	of	the	NAND	gate	based	on	this	logic	function	will	be	as	in"
"We	can	benefit	from	Boolean	algebra	for	gate-level	minimization.	Boolean algebra	is	the	framework	to	represent	and	analyze	logic	functions	formed	by binary	variables	and	 logic	gates.	Boolean	algebra	can	be	explained	in	a	rigorous way	using	mathematical	definitions.	However,	we	will	take	a	simpler	approach in	this	book.	The	idea	is	to	cover	basic	definitions	of	Boolean	algebra	necessary for	our	purposes."
"Commutative	property	tells	us	that	the	order	of	variables	in	logic	gates	 is	not important.	Associative	property	tells	us	that	if	more	than	one	operation	is	done, then	the	order	is	not	important.	Distributive	property	tells	us	that	AND	and	OR operations	are	distributive	on	each	other.	As	the	name	implies,	absorption property	discards	unnecessary	variables.	The	reader	can	remember	DeMorgan’s theorem	as	follows.	If	the	NOT	operation	is	applied	on	an	AND	or	ORoperation,	inputs	will	be	inverted.	Moreover,	the	operation	will	be	changed	from"
"Gate-level	minimization	aims	to	simplify	input/output	characteristics	of	a combinational	circuit.	The	idea	here	is	obtaining	the	same	truth	table	with	less number	of	logic	gates.	This	operation	can	be	done	using	Boolean	algebra identities	and	properties	introduced	in	the	previous	section.	However,	this requires	expertise.	There	are	also	very	effective	methods	for	gate-level minimization.	In	this	book,	we	will	depend	on	Vivado’s	optimization	tool	for gate-level	minimization	since	it	can	handle	most	cases	very	effectively.	This does	not	mean	that	the	reader	should	not	know	basics	of	gate-level	minimization."
"The	logic	function	 z 	=	 	·	 y 	+	 x	·	y 	can	be	described	by	only	mentioning	which input	combinations	produce	output	1.	This	representation	is	called	sum	of products	(SOP).	As	the	name	implies,	each	constraint	is	represented	by	an	AND gate.	The	final	logic	function	is	formed	by	applying	OR	gate	to	all	constraints."
"Fig.	7.10 .	Here,	the select	pin	of	 the	multiplexer	is	set	as	the	input	variable	 x .	The	multiplexer	input pins	are	connected	to	memory	elements	which	are	set	according	to	output	values of	the	logic	function	to	be	implemented	as	indicated	in	its	truth	table.	The multiplexer	output	corresponds	to	the	output	of	the	logic	function	 y ."
"Fig.	7.12 	as	in	the	previous section.	Here,	a	four-to-one	multiplexer	and	memory	elements	are	used.	The select	pins	of	the	multiplexer	are	set	as	input	variables	 x 	and	 y .	The	multiplexer input	pins	are	connected	to	memory	elements	which	are	set	according	to	output values	of	the	logic	function	to	be	implemented	as	indicated	in	its	truth	table.	The multiplexer	output	corresponds	to	the	output	of	the	logic	function	 z ."
"F (1,	1).	The	select	pin of	these	multiplexers	will	be	set	as	the	binary	variable	 y .	The	output	of	these multiplexers	is	fed	to	another	two-to-one	multiplexer	as	input.	The	select	pin	of this	multiplexer	will	be	connected	to	the	binary	variable	 x .	The	output	of	this multiplexer	corresponds	to	the	output	of	the	logic	function"
"Therefore,	the	corresponding	HDL	for	the	designed	combinational	circuit	should be	formed	first.	Afterward,	we	can	benefit	from	the	Vivado’s	optimization	tool for	gate-level	minimization.	It	is	also	advisable	to	simulate	the	designed	system before	implementation.	If	it	satisfies	all	design	constraints,	then	the corresponding	bitstream	can	be	generated	and	embedded	on	the	FPGA	chip."
"We	can	design	a	simple	digital	safe	using	combinational	circuits.	Assume	that the	system	has	a	four-bit	predefined	password.	We	will	use	four	switches	as	the input	to	the	system.	If	the	input	matches	the	predefined	password,	then	the	first output	will	have	logic	level	1.	Otherwise,	the	second	output	will	have	logic	level 1."
"When	the	smoke	density	is	maximum,	the	output	of	the	sensor	is	seven	in the	binary	form.	When	there	is	no	smoke	 detected,	the	output	of	the	sensor is	zero	in	the	binary	form.	The	alarm	will	be	active	if	the	output	of	the smoke	detector	exceeds	four	in	the	binary	form.	Implement	the	designed combinational	circuit	either	in	Verilog	or	VHDL. 7.14			(Sevensegment	display	decoder.) 	In	digital	systems,	sevensegment displays	are	used	extensively.	The	display	has	seven	independent	segments (A,	B,	C,	D,	E,	F,	G)	as	in"
"As	can	be	seen	in	this	figure,	the	keypad	has	seven	output	lines,	three	for row	and	four	for	column	locations,	respectively.	When	a	key	is	pressed, corresponding	row	and	column	lines	will	produce	logic	level	1.	Design	a combinational	circuit	working	as	a	keypad	decoder.	The	input	of	the	circuit will	be	the	output	lines	of	the	keypad.	The	output	of	the	circuit	will	be	thecorresponding	binary	number	in	three	bits."
"W e	have	introduced	combinational	circuits	in	the	previous	chapter.	There, the	focus	was	on	general	characteristics	of	these	circuits.	There	are	also	wellknown	combinational	circuit	blocks	used	in	digital	systems.	These	can	be counted	as	adders,	comparators,	decoders,	encoders,	multiplexers,	parity generators,	and	checkers.	This	chapter	discusses	these	combinational	circuit blocks. 8.1	Adders"
"Table	8.2 .	In	this	table,	binary	variables	 x 	and	 y 	stand	for	input	bits to	be	added.	Binary	variable	 ci 	stands	for	the	carry-in	bit.	Binary	variables	 s 	and co 	represent	sum	and	carry-out	bits,	respectively.	As	in	half	adder,	circuit diagram	of	full	adder	can	be	constructed	by	analyzing"
"We	may	need	to	compare	the	magnitude	of	two	binary	numbers	to	obtain	their status.	Here,	the	first	number	may	be	greater	than	the	second.	The	two	numbers may	be	equal.	Or,	the	first	number	may	be	less	than	the	second.	To	achieve	this goal,	we	will	need	a	comparator.	We	can	explain	the	comparison	operation	on two	binary	variables	 x 	and	 y 	 (each	being	one	bit)	using	the	truth	table	presented in"
"Verilog	allows	forming	conditional	statements	using	 if 	keyword	under behavioral	modeling.	Via	this	keyword,	given	statements	can	be	executed	if	the condition	is	satisfied.	The	condition	can	be	formed	by	a	single	variable,	two	or more	variables	combined	with	logical	operators,	or	relational	operators.	The syntax	of	a	conditional	statement	using	the	 if 	keyword	is	as	follows:"
"As	in	Verilog,	VHDL	allows	adding	conditional	statements	to	a	behavioral description	using	 if 	keyword.	Via	this	keyword,	given	statements	can	be executed	if	the	condition	is	satisfied.	The	condition	can	be	formed	by	a	single signal,	two	or	more	signals	combined	with	logical	operators,	or	relational operators.	The	syntax	of	a	conditional	statement	using	the	 if 	keyword	is	as follows:"
"As	can	be	seen	here,	the	variable	to	be	used	in	the	case	statement	is	defined	in parentheses	just	after	the	keyword.	For	each	value	of	this	variable,	a	statement	isassigned.	If	we	have	more	than	one	statement	for	a	variable,	then	we	should	use block	keywords	( begin 	and	 end )	to	encapsulate	them.	Note	that	variable	values need	not	be	exhaustive.	We	can	only	define	values	of	interest.	Then,	we	can define	a	default	value	for	the	rest.	Moreover,	we	can	group	variable	values	by adding	a	comma	in	between.	This	way,	we	can	eliminate	duplicates.	We provided	such	an	example	on	the	fourth	and	fifth	values	above."
"As	in	Verilog,	the	VHDL	description	of	the	three-to-eight	decoder	using dataflow	and	structural	modeling	will	be	complex.	Behavioral	modeling	will	be more	appropriate	for	this	case.	Here,	we	can	use	the	 if 	keyword	to	construct conditional	statements.	However,	VHDL	also	has	another	keyword	which	is more	appropriate	for	the	decoder	structure.	This	keyword	is	 case 	with	the	syntax as	follows:Listing	8.11 	VHDL	Description	of	Two-to-Four	Decoder"
"We	next	focus	on	an	eight-to-three	priority	encoder.	Unfortunately,	the dataflow	and	structural	models	will	be	complex	for	this	device.	Therefore,	we will	provide	only	the	behavioral	model	in	Verilog.	Here,	we	will	again	benefit from	the	 case 	keyword.	However,	since	we	have	don’t	care	conditions	in operation,	we	will	use	the	 casex 	keyword	instead.	We	provide	the	Verilog description	in"
"Listing	8.14 .	In	this	description,	the	input	to	the	encoder	is represented	by	an	eightelement	vector	 x .	The	output	of	the	encoder	is represented	by	a	three-element	vector	 y .	Within	this	description,	we	discarded the	valid	( v )	output.	Instead,	we	set	the	output	to	high	impedance	( z )	for	such cases.	We	provide	the	RTL	schematic	of	the	eight-to-three	priority	encoder	in"
"Chap.	7 .	For	completeness,	let’s review	its	fundamental	properties.	The	multiplexer	is	a	combinational	circuit	that transfers	data	coming	from	several	inputs	to	single	output.	Therefore,	it	can	be used	to	select	a	specific	input	from	a	group	of	inputs	and	feed	it	to	the	output.	To perform	this	task,	the	multiplexer	has"
"Listing	8.18 .	As	in	a	four-toone	multiplexer,	select	pins	are	represented	by	a	three-element	vector	 s ;	inputs are	represented	by	an	eightelement	vector	 x ;	and	the	output	is	represented	by	a binary	variable	 y 	in	this	description.	We	provide	the	RTL	schematic	of	an	eightto-one	multiplexer	in"
"Listing	8.20 .	As	in	a	four-to-one multiplexer,	select	pins	are	represented	by	a	three-element	array	 s ;	inputs	are represented	by	an	eightelement	array	 x ;	and	the	output	is	represented	by	a	binary variable	 y 	in	this	description.	The	RTL	schematic	of	the	VHDL	description	will be	as	in"
"Therefore,	the	change	can	be	detected	easily.	There	are	two	options	here.	The first	option	is	setting	the	total	number	of	ones	to	be	even.	This	is	called	even parity.	The	second	option	is	setting	the	total	number	of	ones	to	be	odd.	This	is called	odd	parity.called	odd	parity."
"We	have	provided	the	RTL	schematic	of	combinational	circuit	blocks considered	in	previous	sections.	The	reader	can	observe	that	different	RTL building	blocks	are	used	in	implementing	the	comparator,	decoder,	encoder, multiplexer,	parity	generators,	and	checkers.	In	fact,	all	these	combinational circuit	blocks	are	implemented	by	LUTs	on	an	FPGA.	To	be	more	specific,	fourbit	comparator	requires	five	LUTs.	An	eight-to-three	decoder	needs	four	LUTs."
"In	a	similar	manner,	a	three-to-eight	encoder	needs	four	LUTs.	An	eight-to-one multiplexer	needs	two	LUTs.	Finally,	a	three-bit	parity	generator	and	checker requires	one	LUT	for	each.	Hence,	CLBs	will	be	the	main	block	to	be	used	in this	chapter.	Besides,	interconnect	resources	and	input/output	blocks	are	needed while	implementing	combinational	circuit	blocks	considered	in	this	chapter. 8.9	Summary"
"Conditions	for	displaying	the	number	is	given	below: •	If	 btnL 	is	pressed,	the	number	will	be	displayed	only	on	the	first sevensegment	display	digit. •	If	 btnD 	is	pressed,	the	number	will	be	displayed	only	on	the second	sevensegment	display	digit. •	If	 btnR 	is	pressed,	the	number	will	be	displayed	only	on	the third	sevensegment	display	digit. •	If	 btnU 	is	pressed,	the	number	will	be	displayed	only	on	the fourth	sevensegment	display	digit.•	If	 btnC 	is	pressed,	the	number	will	be	displayed	on	all sevensegment	display	digits	at	the	same	time. •	If	more	than	one	button	is	pressed	at	the	same	time,	the	number should	be	displayed	on	the	corresponding	display	digit	according to	the	conditions	given	above. •	If	none	of	the	buttons	are	pressed,	all	display	digits	should	be turned	off. •	If	the	number	to	be	displayed	is	greater	than	9,	character"
"D ata	storage	in	a	digital	system	can	be	made	in	two	ways.	First,	the	system can	be	designed	as	a	sequential	circuit,	which	will	be	introduced	in	the	next chapter.	In	such	a	circuit,	the	output	depends	on	past	input	or	output	besides current	input	values.	Hence,	the	data	should	be	stored	within	the	system.	This operation	is	generally	performed	by	flip-flops.	Second,	the	data	can	be	stored	in a	memory	block	associated	with	the	system.	The	memory	block	can	also	be constructed	by	flip-flops.	Therefore,	we	will	introduce	data	storage	elements starting	from	latches	as	basic	building	block	of	flip-flops	in	this	chapter.	Then, we	will	introduce	different	flip-flop	types.	Flip-flops	can	be	used	to	form registers	as	basic	elements	of	memory	blocks.	Therefore,	we	will	evaluate register	formation	next.	Afterward,	we	will	focus	on	read-only	memory	(ROM) and	random	access	memory	(RAM).	In	constructing	ROM	and	RAM,	we	will extensively	use	IP	blocks	provided	by	Xilinx. 9.1	Latches"
One	way	to	avoid	setting	and	resetting	the	SR	latch	at	the	same	time	is	always feeding	inverse	inputs	to	 s 	and	 r .	We	can	achieve	this	by	adding	a	NOT	gate between	them.	We	call	the	new	structure	a	D	(or	data)	latch	since	it	saves	one	bit of	data.	The	circuit	diagram	of	a	D	latch	is	depicted	in
"Fig.	9.6 .	Here,	three-input	and	two-input	look-up	tables (LUTs)	are	used	in	implementation.	There	is	a	feedback	loop	between	the	output and	input	of	the	three-input	LUT	which	establishes	 the	data	storage	capability	of the	module.	Remember	that	feedback	loops	from	the	out-put	to	input	are	general characteristics	of	latches."
"We	can	obtain	a	specific	structure	called	a	T	(toggle)	flip-flop	by	connecting input	pins	of	a	JK	flip-flop.	Although	this	new	structure	may	seem	redundant,	it will	be	of	great	use	in	counters	to	be	introduced	in	Sec.	10.4.	The	characteristic table	of	the	T	flip-flop	is	presented	in"
"Listing 9.7 .	In	this	description,	inputs	of	the	flip-flop	are	 d 	(data),	 clk 	(clock),	and	 clr (clear).	The	data	input	is	for	a	bit	value	to	be	saved	in	the	flip-flop.	The	clock input	is	for	the	clock-based	operation.	The	clear	input	resets	the	flip-flop	output independent	of	its	input.	Outputs	of	the	flip-flop	are	denoted	by	 q 	and	 qn 	in	the description.	The	flip-flop	is	reset	when	a	negative	edge	of	the	clear	signal	comes."
"Listing	9.8 .	In	this description,	inputs	are	represented	as	 j 	(set),	 k 	(reset),	 clr 	(clear),	and	 clk (clock).	Outputs	of	the	flip-flop	are	denoted	by	 q 	and	 qn 	in	the	description.	The working	principles	of	a	JK	flip-flop	are	similar	to	those	of	a	D	flip-flop.	The only	difference	is	that	the	JK	flip-flop	has	two	inputs	to	set	and	reset	output."
"Fig.	9.19 .	As	can	be	seen	in	this	figure,	flipflops	share	the	same	clock.	Besides,	the	input	to	each	flip-flop	is	independent	of the	other.	Hence,	four	bits	can	be	stored	to	the	register	in	a	parallel	manner.	In the	same	way,	the	output	of	each	flip-flop	is	independent	of	the	other.	Therefore, stored"
"Fig.	9.21 .	As	can	be	seen	in this	figure,	the	data	input	to	two	separate	registers	are	done	in	parallel.	An	input register	is	selected	by	a	one-to-two	encoder	in	such	a	way	that	the	selected register	gets	the	clock	signal.	The	other	register	not	receive	the	clock.	Hence,	it will	be	disabled.	The	data	output	from	registers	are	selected	by	multiplexers."
"Xilinx	offers	IP	blocks	for	memory	construction,	with	two	options:	distributed and	block	memory	formation.	Distributed	memory	is	composed	of	LUTs.	In	fact, the	ROM	descriptions	in	the	previous	section	are	good	examples	of	distributed memory	formation.	Block	memory	uses	the	FPGA	parts	dedicated	for	this operation	as	explained	in"
"Memory	Generator.	Then	the	customized	IP	window	appears.	In	this	window,the	user	can	configure	the	memory	element	at	hand.	Since	we	plan	to	generate the	distributed	ROM,	we	should	apply	the	following	steps.	First,	we	should	set the	depth	and	data	width	of	the	memory	block	in	the	“memory	config”	tab."
"Assume	that	we	need	a	16-element	ROM,	each	element	with	eight	bits.	Hence, the	depth	will	be	16	and	data	width	will	be	eight.	Next,	we	should	select	the memory	type.	Here,	we	will	select	the	ROM.	We	can	set	input	and	output	port properties	in	the	“port	config”	tab.	Finally,	we	can	add	an	initialization	file	from the	“RS	&	initialization”	tab.	We	can	add	the	text	file"
"In	this	window,	the user	can	configure	the	memory	element	at	hand.	Since	we	plan	to	generate	a block	ROM,	we	should	apply	the	following	steps.	First,	we	should	set	the interface	type	as	“Native”	and	the	memory	type	as	“Single	Port	ROM”	from	the “Basic”	tab.	Then,	we	should	switch	to	the	“Port	A	Options”	tab	and	set	the “Port	A	Width”	and	“Port	A	Depth.”	Assume	that	we	need	a	16-element	ROM, each	element	with	eight	bits.	Hence,	the	width	will	be	eight	and	depth	will	be	16."
"In	other	words,	the	data	in	a	specific	memory	location	can	be	altered	within	the system.	Such	a	location	is	called	random	access	memory	(RAM).	We	can represent	the	RAM	both	in	Verilog	and	VHDL	by	modifying	ROM	descriptions in	Sec.	9.5.	The	only	difference	will	be	adding	a	data	write	option	to descriptions.	Instead,	we	will	directly	use	IP	blocks	introduced	in	the	previous section	to	construct	the	RAM."
"Listing	9.19 .	Here,	the	calculator	IP	is represented	as	 calculator_0 .	To	keep	the	result	of	an	operation	in	memory,	theuser	should	press	 btnC 	button	on	the	Basys3	board.	If	the	user	wants	to	add	a number	to	the	one	in	memory,	he	or	she	should	press	 btnL 	button	on	the	Basys3 board.	If	subtraction	is	required,	then	the	user	should	press	 btnR 	button	on	the"
"Since	buttons	are	used	in	all	operations,	we	should	eliminate	their	malfunction known	as	“debouncing.”	This	problem	occurs	when	physical	properties	of	the button	result	in	more	than	one	button	press	effect	when	it	is	actually	pressed once.	There	are	two	ways	to	eliminate	debouncing.	One	is	using	the	physical resistor	and	capacitor	circuitry	[32].	Although	this	is	a	good	solution,	we	should avoid	adding	discrete	circuit	elements	at	this	step.	Therefore,	the	second	solution is	adding	a	delay	element	to	the	button	press	port.	We	provide	the	Verilog module	performing	this	operation	in"
"Next,	let’s	focus	on	the	flip-flop	implementation	details.	Again,	here	the	main building	block	used	in	the	FPGA	implementation	is	the	D	flip-flop	independent of	flip-flop	type	considered.	This	is	also	because	of	the	fact	that	there	are	only	D flip-flops	in	the	Artix-7	XC7A35T	FPGA.	Therefore,	these	are	the	main	building blocks	in	operation.	Let’s	focus	on	the	D,	JK,	and	T	flip-flop	implementation details.	The	D	flip-flop	requires	two	LUTs	used	as	logic	elements,	two	slices, and	one	LUT	flip-flop	pairs	in	implementation.	The	JK	flip-flop,	on	the	other hand,	requires	four	LUTs	(two	being	used	as	logic	elements),	two	slices,	and	one"
"We	can	summarize	the	fundamental	results	while	implementing	data	storage elements	in	the	FPGA	as	follows.	Since	D	latches	and	flip-flops	reside	in	CLBs in	the	FPGA,	basically	they	are	used	in	implementation.	The	distributed	ROM and	RAM	is	also	constructed	in	the	same	way.	The	block	ROM	and	RAM	will be	based	on	specific	FPGA	blocks	for	implementation.	Besides,	interconnect resources	and	input/output	blocks	are	also	needed	while	implementing	data storage	elements,	as	considered	in	this	chapter."
"We	should	warn	the	reader	about	one	important	implementation	detail	of latches	and	flip-flops.	The	provided	Verilog	and	VHDL	descriptions	work without	any	problem	in	the	simulation	level.	However,	they	may	not	work	as expected	(or	the	corresponding	bitstream	cannot	be	generated)	when implemented	on	the	Basys3	or	Arty	board.	The	reason	for	this	shortcoming	is	as follows.	Vivado	specifically	asks	for	any	sensitivity	list	entry	labeled	by posedge 	or	 nededge 	to	be	a	clock	signal.	If	this	is	not	satisfied,	then	a	bitstream cannot	be	generated.	To	overcome	this	problem,	an	edge	detector	circuit	should be	used	in	the	description.	We	provide	such	an	edge	detector	for	Verilog	in"
"Data	storage	is	a	necessary	property	for	most	digital	systems.	A	latch	can	be taken	as	the	basic	data	storage	element	to	be	used	for	this	purpose.	However,	its usage	in	an	actual	FPGA	implementation	is	not	desired	since	a	latch	lacks	a synchronization	signal.	On	the	other	hand,	flip-flops	can	be	constructed	by	using latches.	Therefore,	exploring	the	latch	structure	was	necessary.	We	will	be	using flip-flops	extensively	in	constructing	sequential	circuits.	The	specific	type	to	be used	in	implementation	will	be	the	D	flip-flop	because	of	its	availability	in	the"
"XC7A35T	FPGA.	To	understand	sequential	circuits,	we	will	start	with	their analysis.	This	will	be	different	from	combinational	circuit	analysis	due	to memory	elements	in	the	sequential	circuit.	Therefore,	we	will	introduce	new methods	specific	for	this	purpose.	Then,	we	will	explore	the	timing	concept	in sequential	circuits.	Afterward,	we	will	explain	working	principles	of	two sequential	circuit	families	used	extensively.	These	are	shift	registers	and counters.	As	in	combinational	circuits,	we	will	review	the	basic	design methodology	for	sequential	circuits	by	adding	extra	tools.	Finally,	we	will	focus on	how	sequential	circuits	can	be	implemented	on	the	field-programmable	gate array	(FPGA). 10.1	Sequential	Circuit	Analysis"
"Hence,	we	can	characterize	the	sequential	circuit	using	its	state	transitions described	by	state	equations.	The	aim	here	is	representing	the	next	state	using the	present	state	and	input	values.	To	represent	the	output	of	a	sequential	circuit, we	can	use	two	different	models	as	Mealy	and	Moore.	In	Mealy	model,	the output	is	a	function	of	both	present	state	and	input.	In	Moore	model,	the	output is	a	function	of	the	present	state	only.	For	more	information	on	Mealy	and"
"Although	the	state	table	characterizes	a	sequential	circuit,	it	may	not	be descriptive	enough.	Therefore,	the	third	method	to	describe	the	sequential	circuit is	using	a	state	diagram	composed	of	circles	and	directed	arcs.	Each	circle represents	a	state.	A	directed	arc	represents	the	transition	between	states.	The directed	arc	also	holds	the	required	input	value	for	transition	to	occur.	However, transition	timings	are	not	explicitly	shown	in	the	state	diagram."
"Table 10.1 .	The	output	equation	of	the	circuit	clearly	indicates	that	this	is	a	Mealy model.	Besides,	there	are	four	states	based	on	two	flip-flops	in	the	circuit.Hence,	there	will	be	four	circles	in	the	state	diagram.	Since	there	is	one	input and	output	in	the	sequential	circuit,	its	state	diagram	will	be	as	presented	in"
"The	second	method	in	describing	the	sequence	detector	is	using	the	power	of behavioral	modeling.	VHDL	provides	an	extra	advantage	compared	to	Verilog such	that	states	in	the	device	can	be	represented	as	a	new	data	type	by	the	VHDL keyword	 type .	The	usage	of	this	keyword	will	be	as	 type	state_type	is (A,B,C,D) .	This	usage	defines	a	new	data	type	called	 state_type 	which	can take	four	values	as"
"What	we	mean	by	synchronous	operation	is	as	follows.	All	transitions	within the	sequential	circuit	are	done	in	clock	cycles.	In	other	words,	circuit	elements share	a	common	 clock	such	that	every	operation	is	synchronized	with	it.	The reason	of	using	such	a	synchronization	signal	is	as	follows.	When	there	are	flipflops	in	the	circuit,	we	may	need	present	state	values	in	obtaining	next	state values.	However,	these	operations	should	be	done	in	order.	Otherwise,	the	next state	value	may	be	used	erroneously	instead	of	the	present	state	value.	Hence, synchronization	is	necessary	within	the	circuit.	The	sequence	detector	introduced in	Sec.	10.1	is	a	good	example	of	the	synchronous	sequential	circuit.	As	can	be seen	in"
"Listing	10.2 ,	the description	under	 always	@	(posedge	clk) 	is	responsible	for	state	transitions and	output	formation.	The	 posedge 	keyword	indicates	that	the	 always 	block	is executed	whenever	a	rising	edge	of	clock	comes.	Since	all	state	transitions	are performed	in	the	 always 	block,	these	operations	are	synchronized	by	the	rising edge	of	clock.	The	same	operation	can	be	achieved	by	the	falling	edge	of	clock."
"Listing	10.5 .	Here, there	are	two	 always 	blocks.	The	first	one	is	triggered	by	the	positive	edge	of	the clock	signal.	The	second	block	is	triggered	by	the	negative	edge	of	the	binary variable	 q 	in	the	first	block.	In	other	words,	the	execution	of	the	second	block depends	on	the	first	block,	not	on	the	clock	signal.	This	is	a	simple	example	of asynchronous	operation	in	Verilog."
"Fig. 10.7 .	As	can	be	seen	in	this	figure,	the	shift	register	is	constructed	by	four	D	flipflops	connected	as	a	chain.	Hence,	the	output	of	one	flip-flop	is	connected	to	the input	of	the	next	flip-flop.	New	data	bit	is	fed	to	the	device	through	its	x	pin.	At each	clock	cycle,	bits	are	shifted	to	right	between	flip-flops.	Last	data	bit	is	fed to	output	from	y	pin."
"In	both	devices,	data	is	received	in	parallel	manner.	The	only	difference	between these	devices	is	how	input	is	fed	to	the	device.	In	the	parallel	in/parallel	out	shift register,	data	is	fed	all	at	once.	In	the	serial	in/parallel	out	shift	register,	data	is fed	bit	by	bit.	Besides,	shifting	operation	in	these	devices	is	the	same	as	in	the serial	in/serial	out	shift	register."
"We	can	use	shift	registers	to	multiply	or	divide	a	binary	number	by	integer powers	of	two.	Assume	that	we	keep	a	binary	number	in	shift	register.	As	we shift	all	its	bits	to	the	left,	while	feeding	input	of	logic	level	0,	the	result	will	be the	multiplication	of	original	number	by	two.	We	can	shift	the	result	again	to obtain	multiplication	by	four.	This	operation	can	be	repeated	many	times	to obtain	the	multiplication	of	original	number	by	a	power	of	two.	Here,	the	reader should	be	aware	of	overflow	possibility	such	that	the	most	significant	bit	may	be lost	during	operation.	Therefore,	this	bit	should	be	handled	specifically	during shifting.	If	shifting	is	done	to	the	right,	then	division	of	the	original	number	by the	power	of	two	will	be	obtained."
"Here,	a	number	of	clock	pulses	are	counted.	If	the	period	of	the	clock	is	known, then	the	total	time	passed	during	counting	operation	can	be	calculated.	The	third usage	area	of	the	counter	is	in	frequency	division	operation.	Here,	the	frequency of	the	input	clock	signal	is	divided	by	powers	of	two."
"Working	principles	of	a	counter	are	as	follows.	Whenever	an	input	signal comes,	the	counter	circuit	changes	its	state.	If	we	assign	successive	numbers	to states	in	the	circuit,	then	the	device	visits	each	number	successively.	Here,	the total	number	of	states	indicate	the	capacity	of	the	counter.	Based	on	the	number assignment	to	states,	upward	or	downward	counting	can	be	done."
"Hence,	we	may	need	to	change	it.	Module	performing	this	is	called	frequency divider.	Counters	can	be	used	for	this	purpose.	What	we	have	to	do	is	feeding the	clock	signal	as	input	and	obtaining	new	clock	signal	with	the	frequency divided	by	powers	of	two	from	the	output	of	counter	flip-flops.	We	provide	such a	synchronous	frequency	divider	in"
"We	have	introduced	combinational	circuit	design	steps	in	Sec.	7.5.	These apply	to	sequential	circuit	design	as	well.	However,	the	designer	has	to	plan	state representations	and	transitions	besides	usual	input/output	relationship	in designing	a	sequential	circuit.	In	fact,	the	main	design	criterion	is	deciding which	states	to	be	used.	We	can	benefit	from	either	the	state	diagram	or	state table	for	this	purpose.	The	easiest	way	is	using	the	state	diagram.	Through	it,	the designer	can	plan	state	transitions	and	corresponding	input/output	pairs	visually."
We	strongly	 suggest	the	latter	method	in	implementation	since	it	is	easy	to describe	working	principles	of	the	sequential	circuit	this	way.	Again	let’s emphasize	that	ideas	mentioned	here	do	not	reflect	a	complete	design methodology.	The	reader	should	take	these	just	as	introductory	steps.	Designing a	sequential	circuit	should	be	mastered	by	consulting	related	literature.
"Hence,	the	buzzer	stops.	If	the	door	is	opened,	then	the	user	has	20	seconds	to enter	the	password.	If	the	correct	password	is	entered	within	this	time	slot,	then the	alarm	turns	off.	Otherwise,	the	alarm	LED	turns	on	and	buzzer	startsworking.	Counting	of	20	seconds	is	displayed	on	the	two	leftmost	sevensegment display	digits	of	the	Basys3	board."
"Let’s	explain	the	 sevenseg_driver 	module	first.	The	main	purpose	of	this module	is	to	drive	the	sevensegment	display	on	the	Basys3	board.	This	display	is a	“common	anode”	type	four-digit	display.	There	are	seven	signals,	named	as seg ,	to	drive	four	digits	commonly,	and	four-digit	enable	signal,	named	 an ,	to enable	each	digit.	Since	these	are	all	common	anode	signals,	they	should	be	set to	logic	level	0	when	they	are	active.	Since	four	digits	have	common	 seg 	signals, an 	signal	should	be	periodically	changed	at	a	rate	faster	than	the	human	eye	can catch.	In	every	step,	seven-bits	 seg 	data	will	be	fed	to	the	selected	digit.	We provide	the	Verilog	description	of	the	module	in"
"Let’s	explain	the	 binarytoBCD 	module	next.	This	module	converts	a	binary number	to	the	corresponding	binary	coded	decimal	(BCD)	form.	For	example, when	we	have	an	eightbit	binary	number	11111111,	we	cannot	show	it	directly on	the	sevensegment	 display.	Therefore,	we	need	to	obtain	every	digit	as	a	fourbit	binary	decimal	code.	For	example,	the	corresponding	decimal	number	is	255."
"Listing	10.22 .	The	module	has	one input	as	 binary 	representing	the	binary	number	to	be	converted.	Outputs	of	the module	are	 thos ,	 huns ,	 tens ,	and	 ones .	Here,	we	had	to	use	blocking assignments	in	behavioral	model	to	keep	digit	values.	The	VHDL	version	of	the binary	to	BCD	converter	is	available	in"
"Basys3	board.	Here,	we	can	show	state	of	the	lock	and	the	new	password	on	the sevensegment	display.	To	do	so,	we	should	add	the	sevensegment	display module	as	an	IP	block.	Inputs	of	the	digital	safe	module	will	be	connected	to buttons	and	switches	on	the	Basys3	board.	Hence,	we	should	also	add	the debounce	module	as	an	IP	block.	We	provide	the	top	module	for	this	applicationin"
"We	can	improve	the	car	park	occupied	slot	counting	system	using	sequentialcircuits.	Hence,	we	will	use	the	sevensegment	display	to	show	total	occupied slots.	Since	we	can	use	more	than	one	sevensegment	display	digit	now,	we extend	the	car	park	system	to	count	for	16	slots.	We	provide	the	modified"
"We	should	mention	one	important	FPGA	building	block	usage	at	this	step.	If sensitivity	list	of	an	always	block	in	behavioral	description	depends	on	positive or	negative	edge	of	a	clock	signal	(such	as	 posedge	clk 	or	 negedge	clk ),	then any	variable	represented	by	the	 reg 	keyword	will	automatically	have	a	D	flipflop.	Hence,	this	value	can	be	kept	between	clock	cycles.10.8	Summary"
"HDL	examples	for	both.	Afterward,	we	handled	shift	registers	and	counters	as two	popular	sequential	circuit	families.	Then,	we	briefly	introduced	sequential circuit	design	methodology.	We	suggest	the	reader	to	master	how	sequential circuits	can	be	designed	using	related	literature.	We	believe	the	overall	handling of	sequential	circuits	in	this	chapter	will	help	the	reader	understand	advanced concepts	introduced	in	following	chapters."
"Chap.	2 .	Fortunately,	the	FPGA	design	allows	including	a	microcontroller	(in soft-core	form)	as	an	IP	block.	This	opens	up	a	way	to	benefit	from	advantages of	both	the	FPGA	and	microcontroller	platforms	at	once.	Therefore,	this	chapter focuses	on	how	a	soft-core	microcontroller	can	be	implemented	on	the	FPGA platform.	To	explain	this	process,	we	will	start	with	introducing	building	blocks of	a	generic	microcontroller.	While	doing	this,	we	will	reference	combinational and	sequential	circuit	blocks	introduced	in	previous	chapters.	Then,	we	will introduce	two	Xilinx	microcontroller	IP	cores	named	PicoBlaze	and	MicroBlaze."
"Data	or	instructions	to	be	processed	by	the	CPU	should	be	taken	from	other modules	such	as	memory	and	peripheral	units.	Two	set	of	wires	are	needed	for this	operation.	The	first	set	is	address	bus	which	holds	the	location	of	the	data	(or instruction)	to	be	processed.	The	actual	data	(or	instruction)	is	carried	by	the	data bus	which	is	the	second	set	of	wires.	The	size	of	the	data	bus	helps	decide	the type	of	microcontroller,	such	as	either	eight	bit	or	16	bit."
"Most	CPUs	have	registers	on	them.	These	are	data	storage	elements	as explained	in	Sec.	9.3.	The	bit	size	of	these	registers	should	also	be	in	line	with the	type	of	microcontroller.	Hence,	an	eightbit	microcontroller	will	have registers	formed	also	of	eight	bits.	The	first	group	of	registers	is	reserved	for	the operation	of	the	CPU.	One	such	register	is	the	program	counter	(PC)	which holds	the	address	of	the	next	instruction	to	be	executed.	Depending	on	the	type of	the	CPU,	there	may	also	be	a	specific	register	(status	register)	holding	the status	of	the	CPU	after	an	instruction	is	executed.	This	is	also	called	a	flag."
"The	digital	communication,	analog-to-digital	converter	(ADC),	and	digital-toanalog	converter	(DAC)	can	be	counted	as	such	blocks.	A	microcontroller implemented	on	the	FPGA	has	freedom	on	such	blocks	since	any	digital	device can	be	implemented	alongside	it.	In	other	words,	the	user	is	free	to	add	any peripheral	device	to	the	microcontroller	implemented	on	the	FPGA.11.2	Xilinx	PicoBlaze	Microcontroller"
"The	ALU	in	PicoBlaze	can	perform	arithmetic	and	logic	operations	required by	the	instruction	to	be	executed.	Arithmetic	operations	that	can	be	performed on	PicoBlaze	are	addition	and	subtraction.	Logic	and	compare	operations	that can	be	performed	on	the	microcontroller	are	bitwise	logic	operations,	arithmetic compare	and	bitwise	test	operations,	and	comprehensive	shift	and	rotate operations."
"Listing	11.1 .	Here,	all input	and	output	connections	of	the	microcontroller	are	defined.To	program	the	microcontroller,	the	reader	should	prepare	a	file	(with extension	 psm )	consisting	of	assembly	language	instructions.	These	should	be embedded	to	PROM.	To	do	so,	the	reader	should	run	the	assembler	 kcpsm6.exe which	can	be	found	in"
"To	show	how	an	actual	Verilog	project	can	be	established	using	PicoBlaze, we	direct	the	reader	to	Phil	Tracton’s	GitHub	repository	in	[37].	There	are several	projects	in	this	address.	However,	we	will	only	use	digital	I/O	example in	[38].	The	idea	of	this	project	is	controlling	first	eight	LEDs	of	the	Basys3 board	by	corresponding	eight	switches.	The	reader	can	benefit	from	this	project such	that	he	or	she	can	observe	how	PicoBlaze	can	be	used	with	GPIO.	As	we were	writing	this	book,	VHDL	version	of	the	project	was	not	available."
"GPI 	tab,	select	General	Purpose	Input	1 and	set	the	number	of	bits	to	16	since	we	will	use	all	switches	on	the	board.	As all	these	settings	are	done,	press	OK.	Generate	Output	Products	window	will appear.	Here,	click	on	Generate	to	proceed.	You	will	be	informed	by	a	window saying	“Out-of-context	module	run	was	launched	for	generating	output products.”	Just	click	OK.	Vivado	generates	the	instantiation	template	for	Verilog (in	simplified	form)	as	in"
"FPGAs	can	be	used	to	implement	soft-core	microcontrollers	available	either as	an	IP	block	or	a	HDL	description.	This	opens	up	a	way	to	design	custommade	microcontroller	systems.	Hence,	desired	or	unconventional	peripherals	can be	added	to	the	microcontroller	easily	via	the	FPGA	design.	In	this	chapter,	we explored	methods	for	such	implementations.	Note	that	the	coverage	of	the	topic in	this	chapter	can	be	considered	introductory.	The	reader	can	check	available references	to	master	this	topic.	Xilinx	also	offers	a	different	platform	called system	on	chip	(SoC)	which	incorporates	the	hardcore	processors	and	FPGA chips.	One	recent	SoC	is	Zynq	family	which	has	ARM	Cortex	A9	processors with	the	Artix-7	FPGAs.	This	SoC	family	deserves	special	consideration."
"A	universal	asynchronous	receiver/transmitter	(UART)	is	a	digital communication	protocol	for	two	or	more	devices.	We	will	focus	only	on	UART communication	between	two	devices	in	this	book.	Hence,	one	device	will	be	the transmitter;	the	other	will	be	the	receiver.	Communication	is	done	by	sending and	receiving	data	asynchronously	between	the	transmitter	and	receiver.	Being asynchronous,	the	UART	does	not	need	a	common	clock	between	the	transmitter and	receiver.	Thus,	connected	devices	can	work	independently.	The	serial	pin	of the	transmitter	is	generally	called	transmit	("
"TX 	pin	should	be	at	logic	level	1	when	the	transmitter	is	in	idle mode.	Once	transmission	starts,	a	falling	edge	is	created	on	the	data	transmit	line which	wakes	up	the	receiver.	Afterward,	the	clock	is	set	according	to	the	baudrate	and	all	bits	are	sent	one	by	one	in	every	clock	cycle	in	the	transmitter	side."
"To	do	so,	the	receiver	should	have	an	internal	timer	with	the	predetermined	baud rate	as	in	the	transmitter.	After	receiving	start	bit,	the	timer	waits	for	a	certain time	to	sample	the	first	data	bit.	This	offset	allows	starting	the	sampling	process in	the	middle	of	the	first	data	pulse.	Note	that	although	data	is	sent	as	logic levels	1	and	0	by	the	transmitter,	these	are	converted	to	analog	pulse	signals."
"The	working	principles	of	the	transmitter	module	(as	a	state	machine)	are	asfollows.	Within	the	module,	the	baud	rate	is	defined	as	a	parameter	and	set	to 9600	bps	by	default.	Here,	 baud_timer 	calculates	the	number	of	clock	cycles needed	for	a	particular	baud	rate	by	dividing	the	main	clock	frequency	to	the baud	rate.	The	transmitter	module	has	three	states	as"
"RX 	pin	of	the	device.	Through	it,	the receiver	module	listens	for	a	possible	incoming	package.	The	receiver	module has	four	outputs	as	 data ,	 parity ,	 ready ,	and	 error .	 data 	represents	the	received data.	 parity 	shows	the	received	parity	bit.	 ready 	indicates	that	the	receive operation	is	complete.	Finally,	 error 	shows	if	the	data	package	is	received	with or	without	error."
"The	working	principles	of	the	receiver	module	(as	a	state	machine)	are	as follows.	Within	the	module,	the	baud	rate	is	defined	as	a	parameter	and	set	to 9600	bps	similar	to	the	transmitter	module.	As	in	the	transmitter	module, baud_timer 	calculates	the	number	of	clock	cycles	needed	for	a	particular	baud rate	by	dividing	the	main	clock	frequency	to	baud	rate.	The	receiver	module	has five	states	as"
"Microsoft	Windows	operating	system.	Please	consult	related	resources	for	other operating	systems.	On	the	terminal,	set	the	baud	rate	to	9600	bps;	the	COM	port to	the	one	Basys3	board	connected;	parity	bit	to	“None”;	data	bits	to	eight;	and stop	bits	to	one.	The	default	demo	implemented	on	the	Basys3	board	includes	a"
"The	first	UART	application	will	be	on	transmitting	data	from	the	Basys3 board	to	host	PC.	Therefore,	connect	your	board	to	the	host	PC	and	check	the status	of	connection	as	explained	in	the	previous	section.	Assuming	that everything	is	set	correctly	and	working	properly,	we	will	implement	our application.	Therefore,	we	will	build	a	top	module	which	employs	the transmitter	module	and	transmits	incremental	ASCII	codes	starting	from hexadecimal	number	41	(corresponding	to	character"
"The	outputs	of	this	module	are	 sck ,	 mosi ,	 ss ,	and	 busy .	The	first	three	of	these are	directly	associated	with	the	SPI	lines.	The	fourth	output	shows	if	the	module is	busy	while	transmitting	data.	Within	the	module,	the	data	length	to	be	sent	is set	as	a	parameter.	The	frequency	division	is	applied	to	the	input	clock	so	that sck 	is	set	at	2	MHz."
"The	working	principle	of	the	leader-transmitter	module	can	be	explained	as follows.	The	module	is	a	state	machine	triggered	in	every	falling	edge	of	 sck .	In other	words,	the	data	on	the	 mosi 	line	does	not	change	while	 sck 	is	at	logic	level 1.	The	state	machine	is	initially	at"
"RDY 	state.	It	is	triggered by	the	falling	edge	of	 sck 	which	is	generated	by	the	leader-receiver.	If	 ss 	is	at logic	level	0,	then	 busy 	goes	to	logic	level	1.	The	first	bit	of	the	data	vector	is loaded	to	 mosi .	Then,	the	state	machine	goes	to	the	state"
"STOP 	state.	In	this	state,	 busy 	goes to	logic	level	0;	the	received	data	is	written	to	the	 data 	vector;	 data_temp 	is	set to	logic	level	0;	 index 	is	set	to	the	address	of	the	first	bit	of	 data .	In	the	next cycle,	the	state	machine	turns	back	to"
"To	provide	an	actual	application,	we	connect	Digilent’s	ambient	light	sensor (PmodALS)	module	to	the	Basys3	board.	The	sensor	module	returns	eightbit data	based	on	the	illumination	level	through	the	SPI.	In	our	application,	we	will receive	this	data	and	convert	it	to	BCD	form	to	show	it	on	the	sevensegment display	of	the	Basys3	board."
"The	sensor	module	is	connected	to	the	top	six	pins	(1	to	6)	of	the	JB	PMOD port	on	the	Basys3	board.	Necessary	adjustments	are	done	on	the	XDC	file	to use	this	pin.	Since	the	sensor	module	is	set	to	work	in	the	follower-transmitter mode,	we	set	Basys3	to	work	in	the	leader-receiver	mode.	We	provide	the"
"TRACK 	state,	 delay 	is	decreased	by	one	in	every	master	clock	cycle until	it	reaches	zero.	This	time	slot	is	referred	to	as	the	delay	time.	It	is specifically	introduced	to	keep	the	coherency	of	digits	in	the	sevensegment display.	When	 get 	goes	to	logic	level	1,	the	state	changes	to"
"GETIN 	and	the	SPI module	starts	working.	The	top	module	waits	until	the	SPI	module	does	its	job and	takes	 ready 	to	logic	level	1.	Afterward,	 get 	goes	to	logic	level	0;	 delay 	is set	to	its	initial	value	again;	 data 	from	the	SPI	module	is	written	to	the	 lightdata 	vector;	and	the	state	turns	back	to"
"Inter-integrated	circuit	(I 2 	C)	is	the	third	and	final	digital	communication protocol	we	will	cover	in	this	chapter.	As	in	the	UART	and	SPI,	we	will	first cover	the	working	principles	of	the	I 2 	C.	Then,	we	will	implement	its	Verilog and	VHDL	descriptions.	Finally,	we	will	provide	a	sample	application	using	the"
"As	mentioned	in	the	previous	section,	data	on	the	I 2 	C	communication	is carried	by	eightbit	packages.	The	leader	starts	the	transmission	by	sending	the follower	address	and	read/write	decision	bit.	The	follower	with	this	address	on the	network	wakes	up	and	acknowledges	the	leader	that	it	is	alive	and	ready	to talk.	Then,	depending	on	the	 decision	bit,	the	leader	writes	or	reads	data	from	the follower.	The	leader	ends	the	talk	by	sending	a	stop	signal."
"This	module	has	six	inputs	as	 clk ,	 reset_n ,	 ena ,	 addr ,	 rw ,	and	 data_wr .	 clk corresponds	to	the	clock	signal	to	be	used	in	the	module.	 reset_n 	indicates	the active	low	reset.	 ena 	is	for	the	active-high	enable	signal.	 addr 	represents	the address	of	the	follower	to	be	connected	to.	 rw 	stands	for	the	read/write	input."
"START 	state	and	pulls ena 	to	logic	level	1;	writes	the	follower	address	to	 addr 	vector;	sets	 rw 	to	write mode;	and	loads	data	to	be	written	in	 data_wr 	vector.	In	this	case,	the	first	data to	be	written	is	the	address	of	the	configuration	register	in	the	compass	chip which	is	02	in	hexadecimal	form.	Then,	the	state	machine	waits	for	 eop 	signal coming	from	the"
"READDATA 	by	incrementing	 pck_cnt by	one.	In	this	state,	 rw 	goes	to	logic	level	1,	which	corresponds	to	the	read mode.	With	the	next	 eop 	signal,	the	state	machine	will	be	ready	to	read	data	from the	 data_rd 	vector.	Before	the	last	bit	of	the	first	register	is	read,	 eop 	goes	to logic	level	1	and	the	state	changes	to"
"READXH .	When	 eop 	goes	back	to	logic	level 0,	the	eightbit	data	on	the	 data_rd 	vector	corresponds	to	the	first	eight	bits	of	the x-axis	on	the	compass.	Therefore,	we	write	it	to	the	MSB	eight	bit	of	the	 x_axis vector.	Then,	all	data	bits	are	received	similarly.	At"
"This	is	set	by	the	horizontal	synchronization	signal.	When	all	lines	in	a	frame	are displayed,	a	new	frame	should	be	formed.	This	is	set	by	the	vertical synchronization	signal	which	also	defines	the	refresh	rate	of	display.	The horizontal	and	vertical	synchronization	signals	depend	on	pixel	clock	by definition.	Moreover,	the	monitor	needs	some	time	before	applying	horizontal and	vertical	synchronization	signals.	This	is	called	front	porch.	Similarly,	we should	wait	for	a	certain	amount	of	time	after	displaying	pixels	in	a	horizontal line	and	frame.	This	is	called	back	porch.	More	information	on	the	VGA	timing can	be	found	in	[52]."
"MHz.	 pixel_data 	represents	the	vector	holding	RGB	pixel	values	to	be displayed.	The	VGA	module	is	set	to	work	with	eightbit	data.	Hence,	the	RGB values	get	three,	three,	and	two	bits,	respectively,	as	mentioned	before.	 sx 	and	 sy represent	the	image	size	to	be	displayed.	Although	the	default	display	size	in"
"The	Universal	Serial	Bus	(USB)	is	an	industry	standard	developed	to	unify connection,	communication,	and	power	supply	between	digital	devices.	It	can	be used	between	a	PC	and	keyboard,	mouse,	external	hard	drive,	printer,	and	digital camera.	The	Basys3	and	Arty	boards	have	USB	ports	used	for	powering	and programming	purposes	as	explained	in"
"Chap.	3 .	The	Basys3	board	also	has	an extra	USB	port	which	can	be	used	to	connect	peripherals	such	as	keyboard.	In low	level,	the	USB	operations	are	not	easy	to	manage.	Fortunately,	the	Basys3 board	has	a	PIC24FJ128	chip	which	provides	USB	HID	host	capability	as mentioned	in"
"The	keyscan	code	table	of	the	PS/2	keyboard	can	be	found	in	[53].	It	is straightforward	to	get	data	from	the	keyboard	and	check	if	it	matches	a	number between	one	to	eight.	However,	reading	a	keyboard	button	data	requires	some processing.	Therefore,	let’s	first	focus	on	this	operation.	Whenever	a	button	is pressed	on	the	keyboard,	its	make	code	should	be	sent.	The	make	code	is	the eightbit	code	you	see	on	the	reference	keyscan	code	table.	Once	the	button	is released,	a	break	code	is	transmitted.	The	break	code	has	a	specific	eightbit	code (the	hexadecimal	number"
"F0 	for	characters	and	numbers)	followed	by	the	same make	code	of	the	button.	Let’s	explain	how	this	is	done	by	an	example.	The hexadecimal	keyscan	code	of	the	button	for	number	one	is	 16 .	When	the	button is	pressed,	the	make	code	of	the	button	is	sent	immediately.	Once	the	button	is released,	the	keyboard	sends	the	break	code	as	hexadecimal	number"
"F0 ,	and	make	code	again.	If	the button	is	pressed	and	held	down,	this	key	is	called	typematic.	If	the	button	press exceeds	the	typematic	delay	time	of	the	keyboard,	it	continues	sending	the	make code	repeatedly	until	the	button	is	released.	Once	the	button	is	released,	the transmission	concludes	with	the	break	code.	This	should	be	taken	into	account	in reading	a	button	press	from	the	keyboard."
"EXTEND 	state	to	wait	for	the	button	release.	This	depends	on the	designer.	For	a	continuous	press,	you	can	send	multiple	characters	or	wait	for the	button	release	and	send	the	character	only	once.	We	selected	the	latter	option in	our	module.	Hence,	if	the	button	is	released,	the	last	eightbit	data	will	be received	and	written	to	the	least	significant	eight	bits	of	the	 received 	vector.	In"
"In	other	words,	HDL	modules	given	in	this	chapter	are	not	unique	for	a	given interfacing	option.	Hence,	comparing	different	digital	interfacing	options	based on	their	FPGA	resource	usage	will	not	be	fair.	As	a	result,	we	ask	the	reader	to check	his	or	her	digital	interfacing	application’s	FPGA	usage. 12.8	Summary"
"When	designing	a	digital	system	on	an	FPGA,	we	may	need	to	observe internal	signals	of	the	design.	Vivado	offers	a	way	to	achieve	this	by	integrated logic	analyzer	(ILA)	IP	core	usage.	This	core	acts	as	an	actual	logic	analyzer	for monitoring	signals	in	the	FPGA.	Since	this	is	a	very	important	topic	for	actual digital	system	realization,	we	focus	on	it	in	this	section.	We	pick	a	simple"
"Pmod	port	of	the	Basys3	board.	It	is	capable	of	converting	four	external differential	signals	to	digital	form	since	the	port	has	four	differential	pins.	Also,differential	signals	to	digital	form	since	the	port	has	four	differential	pins.	Also, the	XADC	block	has	an	internal	temperature	sensor	which	can	be	selected	to read	its	output.	In	this	section,	we	will	focus	on	the	usage	of	the	XADC	block with	two	applications.	The	first	application	will	be	on	reading	temperature	value from	the	internal	sensor	of	the	FPGA	chip.	The	second	application	will	be	on measuring	voltage	level	of	a	battery	connected	to	ports	of	the	Basys3	board."
"FPGA	Features	and	Design	 → 	XADC.	By	double-clicking	on	the	IP	block,	we can	open	its	configuration	window.	For	our	two	applications,	we	will	remove reset_in	and	change	Startup	Channel	Selection	mode	to	Channel	Sequencer	in the	Basic	tab.	We	can	select	which	channels	to	add	to	the	XADC	block	from	the"
Listing	13.4 .	This	module	has	four	inputs	as	follows.	 clk 	represents the	main	clock	to	be	fed	to	the	module.	 add 	is	for	starting	the	addition	operation. number1 	and	 number2 	stand	for	floating-point	numbers	to	be	added.	The	module has	two	outputs	as	 result 	and	 ready .	The	first	one	holds	the	result	of	the operation.	The	second	one	indicates	that	the	operation	has	ended.
"The	calculator	application	has	been	improved	up	to	this	chapter.	Now,	it	is time	to	finalize	it.	Therefore,	we	modify	it	such	that	two-digit	decimal	numbers can	be	taken	as	input.	A	USB	keyboard	can	be	used	for	this	purpose.	The	result (which	can	go	up	to	4096)	will	be	seen	on	sevensegment	display	of	the	Basys3 board.	We	provide	the	top	module	for	the	calculator	application	in"
"Listing	13.5 ,	the	direction	buttons	on	the	Basys3	board	are	used	as operation	entries.	Hence,	 btnU 	is	used	for	addition;	 btnD 	is	used	for	subtraction; btnR 	is	used	for	multiplication;	 btnL 	is	used	for	division;	and	 btnC 	is	used	as	the equal	sign.	The	top	module	uses	the	main	clock	of	Basys3	( clk )	and communicates	with	the	USB	keyboard	by"
"Board	in	VerilogLet’s	explain	the	working	principles	of	the	digital	safe	system	(as	a	state machine)	step	by	step.	The	system	starts	with	a	default	password	1234.	When the	user	enters	it,	the	safe	opens.	Here,	user	has	two	options.	The	first	one	is changing	the	password.	The	second	one	is	locking	the	safe	again.	When	 btnC 	on the	Basys3	board	is	pressed,	the	safe	locks	again.	If	the	user	presses	 btnU ,	digital safe	goes	to	the	password	changing	state.	Here,	it	expects	the	user	to	enter	a	new password.	This	can	be	done	by	using	numbers	on	the	keyboard.	Since	this	is	a prototype	system,	the	entered	password	is	also	shown	on	the	sevensegment display	(and	LEDs)	of	Basys3.	When	a	new	password	is	entered,	the	user	should press	 btnD 	to	save	it.	Afterward,	 btnC 	should	be	pressed	to	lock	the	safe	again."
"Listing	13.10 .	Different	from	previous	versions	of	the	application,	the proximity	sensor	is	located	in	the	garage	gate	which	controls	if	the	car	is	still passing	through.	Switches	on	the	Basys3	board	imitate	the	output	of	the proximity	sensors	located	in	each	parking	slot.	Once	the	user	approaches	the gate,	he	or	she	sends	the	character"
"O 	via	cell	phone	to	the	bluetooth	adapter connected	to	the	Basys3	board	via	UART	communication.	Then,	the	gate	opens and	waits	for	12	seconds	to	close	unless	the	car	is	still	passing	through.	Since	the steppermotor 	module	is	integrated	as	an	IP	block	to	the	project,	it	asks	for	the rotation	degree	in	initialization	window.	If	you	do	not	integrate	your	module	in your	IP	library,	then	you	have	to	add	90	degree	as	a	parameter	to	module initialization."
"Here,	the	digital	clock	module	is	used	again	without	its	outputs.	With	every	 btnU press,	the	chronometer	counts	or	pauses.	When	the	user	presses	 btnC ,	the	module clears	the	output	and	gets	ready	for	the	next	count.	All	three	modes	can	work	at the	same	time.	Therefore,	if	the	user	wants	to	use	the	chronometer	he	or	she	can do	so	without	disturbing	the	digital	clock	and	alarm	operations."
"PWM_generator 	module	to	drive	all	16	LEDs	on	the	Basys3 board	with	 different	duty	cycles.	To	have	a	moving	wave	effect	visible	to	our eyes,	we	apply	the	frequency	division	(with	a	counter	having	28	bits)	to	the	main clock	of	the	Basys3	board.	First	three	switches	on	the	Basys3	board	can	be	used to	adjust	speed	of	the	moving	wave."
"These	values	should	be	in	minutes	in	an	actual	system.	However,	we	set	such values	to	observe	the	system	output.	The	system	should	have	a	counter	for	these operations.	When	counter	reaches	the	designated	time	value,	the	kit	sprays	the fresh	odor	and	restarts	counting	again.	We	can	use	two	switches	to	select	among four	programs.	Besides,	there	should	be	an	instant	spray	button.	When	it	is pressed,	the	fresh	odor	should	be	sprayed	and	the	counter	should	be	reset.	When the	user	selects	another	program,	the	counter	should	restart	again.	There	should also	be	an	on/off	switch	for	the	system.	Spraying	fresh	odor	can	be	indicated	by blinking	an	LED	on	the	board	for	three	seconds. 13.13	Obstacle-Avoiding	Tank"
"We	can	modify	the	obstacle-avoiding	tank	system	developed	for	the	MSP430 microcontroller	to	work	on	the	Basys3	board	[32].	Hence,	we	will	build	a	tank which	is	driven	by	two	stepper	motors.	The	proximity	sensors	on	the	front	edges of	the	tank	will	be	used	to	sense	obstacles	on	the	way.	The	tank	will	change	its direction	by	controlling	motor	speeds	accordingly.	The	proximity	sensor	we have	used	in	previous	applications	can	also	be	employed	for	this	application.	By using	the	tuning	screw	on	the	sensor,	the	designer	can	adjust	the	distance	the tank	will	turn	when	it	faces	an	obstacle."
"The	normal	wash	program	can	be	improved	by	adding	intelligence	to	it.	To	do so,	we	can	include	an	IR	transmitter	and	receiver	LED	pair.	The	IR	transmitter emits	IR	light	when	fed	with	voltage.	The	IR	receiver	LED	produces	voltage when	it	absorbs	IR	light.	We	can	form	a	structure	by	using	the	IR	transmitter	and receiver	such	that	when	water	passing	through	them	is	dirty,	no	light transmission	occurs.	Hence,	the	output	of	the	receiver	LED	can	be	taken	as	logic level	0.	When	the	water	passing	through	these	LEDs	is	clean,	the	light transmission	occurs.	Hence,	the	output	of	the	receiver	LED	can	be	taken	as	logic level	1.	Therefore,	when	the	water	is	dirty,	normal	wash	program	is	repeated again.	This	program	ends	when	water	becomes	clean."
"When	the	main	on/off	button	is	pressed,	the	system	is	activated.	To	indicate this,	the	rightmost	LED	on	the	Basys3	board	will	turn	on.	In	this	state,	all programs	(prewash,	normal	wash,	and	final	spin)	can	be	performed.	Each program	can	be	selected	by	a	specific	button.	There	is	an	extra	button	for adjusting	the	rotation	speed	as	slow	and	fast.	Depending	on	the	selection,	the leftmost	LED	on	the	board	will	be	either	on	or	off.	When	the	main	on/off	button is	pressed	again,	the	system	will	be	deactivated.	To	indicate	this,	the	rightmost"
"LDR,	this	will	indicate	that	the	paper	towel	is	needed.	This	should	start	the timing	module.	The	rightmost	LED	on	the	Basys3	board	will	turn	on	for	four seconds	to	indicate	that	the	paper	towel	is	fed.	During	this	time,	no	other	paper towel	request	is	accepted.	When	the	waiting	time	is	over,	the	LED	will	turn	off."
"The	goal	of	this	application	is	building	a	body	weight	scale	we	use	in	our homes.	Basically,	we	need	four	load	cells	(also	called	strain	gauge)	to	be screwed	to	legs	of	the	scale.	These	load	cells	convert	the	applied	force	on	them to	the	electrical	voltage.	The	XADC	module	on	the	Basys3	board	can	be	used	to convert	this	voltage	to	digital	form.	Note	that	an	instrumentation	amplifier	may be	needed	between	the	sensor	and	Basys3	board	depending	on	the	sensor	output."
"The	system	works	as	follows.	The	cabin	starts	at	the	first	floor.	If	someone	at this	floor	presses	the	call	button,	the	door	of	the	cabin	will	open.	If	someone from	another	floor	presses	the	call	button,	the	cabin	moves	to	that	floor.	Assume that	the	travel	time	between	each	floor	is	three	seconds.	When	the	cabin	reaches the	target	floor,	its	door	opens	and	stays	in	that	state	for	ten	seconds.	Since	this	is a	prototype	system,	we	assumed	one	user	at	a	time.	Therefore,	scheduling	issues within	the	elevator	control	are	avoided.	However,	we	suggest	that	the	reader think	about	the	possibility	as	well	of	a	more	advanced	elevator	cabin	control system."
"The	seventh	LED	shows	if	the	elevator	is	busy	or	not.	The	eighth	LED	indicates whether	the	door	is	open	or	closed.	At	this	stage,	these	are	sufficient	for	a prototype	system.	We	can	improve	the	system	further	by	adding	a	proximity sensor	for	the	cabin	door.	Hence,	if	a	user	is	at	the	door,	it	stays	open.	Besides, we	can	add	two	stepper	motors:	one	to	move	the	cabin	and	the	other	to open/close	the	cabin	door. 13.21	Digital	Table	Tennis	Game"
"We	can	design	a	system	on	the	Basys3	board	to	count	customers	in	a	shopping mall	with	designated	doors	for	entrance	and	leaving.	To	do	so,	we	should	place	a proximity	sensor	to	each	door.	Hence,	we	can	detect	whether	a	customer	passing through	the	gate	is	entering	or	leaving.	The	customer	counter	is	reset	as	the	mall opens.	The	count	is	increased	by	one	for	each	entering	customer.	It	is	decreased by	one	for	each	leaving	customer.	The	total	number	of	customers	in	the	mall should	be	shown	on	the	sevensegment	display.	As	the	shopping	mall	closes,	the security	check	will	be	done	via	the	count	value.	If	no	one	is	left	in	the	mall,	gates will	be	locked.	This	can	be	simulated	by	an	LED	on	the	board.	We	can	further expand	the	system	by	adding	a	bluetooth	module	to	each	proximity	sensor section	such	that	they	communicate	with	a	main	module.	Hence,	the	two follower	modules	and	one	leader	module	will	be	needed	in	developing	the system. 13.23	Frequency	Meter"
Pedometer	is	a	device	that	counts	steps	when	you	carry	it	on.	We	can	design	a pedometer	using	a	three-axis	accelerometer	sensor	and	the	Basys3	board.	We can	pick	one	of	the	available	sensors	working	in	similar	ways.	They communicate	over	the	I 2 	C	interface	providing	16	bits	of	data	in	each	direction.
"IP	block	to	be	used	in	the	Verilog	or	VHDL	description.	We	will	explore	how this	can	be	done	in	this	chapter.	To	do	so,	we	will	start	with	Vivado	HLS.	Then, we	will	develop	a	project	under	it	to	generate	an	IP.	Finally,	we	will	show	how the	generated	IP	can	be	used	in	an	HDL	in	Vivado.	Therefore,	the	reader	can understand	steps	to	be	followed	for	such	an	implementation.	Topics	introduced in	this	chapter	are	more	complex	compared	to	the	ones	introduced	in	previous chapters.	Moreover,	it	is	not	possible	for	us	to	cover	them	in	depth	here."
"Let’s	create	a	new	project	in	the	welcome	screen.	Assume	that	we	want	to	addtwo	eightbit	numbers.	As	we	press	“Create	New	Project”	in	the	welcome	screen, a	new	window	appears	asking	for	the	“Project	Name”	and	“Location.”	Let	the project	name	be	 adder_HLS .	The	reader	should	also	find	a	suitable	location.	We pick	this	location	as"
"H:\Xilinx_Projects .	As	we	press	“Next,”	a	new	pop-up window	titled	“Add/Remove	Files”	appears	asking	for	the	“Top	Function”	in	the project.	As	for	now,	let’s	leave	it	empty.	As	we	press	“Next,”	the	pop-up window	asks	for	the	testbench	file	to	be	used.	Let’s	leave	this	one	also	empty."
"Fig.	14.3 .	The	user	can adjust	all	properties	of	the	project	through	this	interface.	Let’s	first	add	the	main file	titled	 adder.c 	to	the	project.	To	do	so,	right-click	on	the	“Source”	item	in the	“Explorer”	section;	select	the	“New	File”	option	and	create	the	file.	Let’s copy	the	C	source	code	in"
"Listing	14.1 ,	the	 adder.c 	file	only	has	a	function	definition adder .	Input	to	this	function	are	two	eightbit	numbers	 inA 	and	 inB 	defined	by type	 int8 .	The	output	of	the	function	is	 out1 	defined	as	a	pointer	to	another eightbit	number.	The	 adder.c 	file	also	refers	to	a	header	file	which	we	named	as adder.h 	available	in"
"The Verilog Golden Reference Guide is not intended as a replacement for the IEEE Standard Verilog Language ReferenceManual. Unlike that document, the Golden Reference guide does notoffer a complete, formal description of Verilog. Rather, it offersanswers to the questions most often asked during the practicalapplication of Verilog, in a convenient reference format."
"Nor is The Verilog Golden Reference Guide intended to be an introductory tutorial. Information is presented here in a tersereference format, not in the progressive and sympathetic mannernecessary to learn a subject as complex as Verilog. However,acknowledging that those already familiar with computer languagesmay wish to use this guide as a Verilog text book, a brief informalintroduction to the subject is given at the start."
"The main feature of The Verilog Golden Reference Guide is that it embodies much practical wisdom gathered over many Verilogprojects. It does not only provide a handy syntax reference; there aremany similar books which perform that task adequately. It alsowarns you of the most common language errors, gives clues whereto look when your code will not compile, alerts you to synthesisissues, and gives advice on improving your coding style."
"The Verilog Golden Reference Guide was developed to add value to the Doulos range of Verilog training courses, and also to complementHDL PaceMaker, the Verilog Computer Based Training packagefrom Doulos. 3PrefaceThe main body of this guide is divided into three main parts, each of which is organised alphabetically. Each section is indexed by a keyterm which appears prominently at the top of each page. Often youcan find the information you want by flicking through the guidelooking for the appropriate key term. If that fails, there is a full indexat the back."
"The syntax definitions are written to look like examples whereverpossible, but it has been necessary to introduce some extra notation.In brief, square brackets [] enclose optional items, three dots ... means repetition, and curly brackets {} enclose comments. ItalicNames represent parts of the syntax defined elsewhere. A full description of the notation follows:"
"Verilog is used to simulate the functionality of digital electronic circuits at levels of abstraction ranging from stochastic and purebehaviour down to gate and switch level, and is also used tosynthesize (i.e. automatically generate) gate level descriptions frommore abstract (Register Transfer Level) descriptions. Verilog iscommonly used to support the high level design (or language baseddesign) process, in which an electronic design is verified by means ofthorough simulation at a high level of abstraction before proceedingto detailed design using automatic synthesis tools. Verilog is alsowidely used for gate level verification of ICs, including simulation,fault simulation and timing verification."
"Nets  (and Registers ) have values formed from the logic values 0, 1, X (unknown or uninitialised) and Z (high impedance or floating). In addition to logic values, Nets  also have a Strength value. Strengths  are used extensively in switch level models, and to resolve situations where a net has more than one driver."
"Each Initial, Always, Continuous Assignment,  UDP and Gate Instance executes concurrently with respect to all others, but the Statements inside an Initial or Always are in many ways similar to the statements in a software programming language. They are executed at times dictated by Timing Controls , such as delays, and (simulation) event controls. Statements execute in sequence in a Begin-End  block, or in parallel in a Fork-Join  block.  A Continuous Assignment   modifies the values of Nets . An Initial or Always modifies the values of Registers ."
Verilog source code is usually typed into one or more text files on a computer. Those text files are then submitted to a Verilog compileror interpreter which builds the data files necessary for simulation orsynthesis. Sometimes simulation immediately follows compilationwith no intermediate data files being created.  7Module Structure  8Syntax SummaryStatements #delay wait (Expression)@(A or B or C)@(posedge Clk)
"Synthesis always is one of the most useful Verilog statements for synthesis, yet an always is often unsynthesizable. For best results, code should be restricted to one of the following templates: always @(Inputs) //  All the inputs begin   ... //  Combinational logic end always @(Inputs) //  All the inputs   if (Enable)   begin     ... //  Latched actions   end 12Alwaysalways @(posedge Clock) //  Clock only begin   ... //  Synchronous actions end always @(posedge Clock or negedge Reset) // Clock and Reset only begin   if (!Reset) //  Test active level of asynchronous reset     ... //  Asynchronous actions   else     ... //  Synchronous actions end //  Gives flipflops + logic"
"The Verilog LRM allows begin-end blocks to be interleaved during simulation.This means that even where a begin-end block contains two adjacentstatements with no timing control between them, a simulator may choose toexecute part of another process (E.g. statements in another always) between the two statements. This is a source of non-determinism in the language."
"An always describing combinational and latched logic must not contain feedback, i.e. registers assigned as outputs from the always must not be read as inputs to the always. 18Coding StandardsA clocked always must have only the clock and any asynchronous control inputs (usually reset or set) in the event control list."
"For finite state machines and other sequential circuits with unreachable states (e.g. a 4 bit decade counter has 6 unreachable states), if the behaviour of the hardware in such states is to be controlled, then the behaviour in all 2N possible states must be described explicitly in Verilog, including the behaviour in unreachable states. This allows safe state machines to be synthesized."
"Check carefully any Verilog code which uses dynamic indexing (i.e. a bitselect or memory element using a variable index or address), loopstatements, or arithmetic operators, because such code can synthesize tolarge numbers of gates which can be hard to optimize. 19Comments may be (should be!) included to document the Verilog source code."
"Use continuous assignments to describe combinational logic that can easilybe described using a straightforward expression. Functions can be used tostructure expressions. An always is usually better for describing more complex combinational logic, and may simulate more quickly than a number of separate continuous assignment statements. 21Continuous AssignmentContinuous assignments are useful for transferring register values to nets, when Verilog requires nets to be used. For example, to apply test stimulusdescribed in an initial to an inout port of a module instance."
Example begin : Break  forever  begin : Continue    ...     disable Continue; //  Continue with next iteration     ...     disable Break; //  Exit the forever loop     ...   end //  Continue end // Break 27DisableThis is a list of the most common Verilog errors. The top five account for about 50% of all errors.
"A set of nested if-else statements can be used to give priority to the conditions tested first. To decode a value without giving priority to certainconditions, use a case statement instead. 47IfExample if (C1 && C2) begin  V = !V;  W = 0;  if (!C3)    X = A;  else if (!C4)     X = B;   else    X = C;end"
"Where a range is given as part of an instance name, this indicates an array ofinstances. When the bit length of a port expression is the same as the bit length of the corresponding port of the module, UDP or gate being instanced, the entire expression is connected to that port of each instance. If the bitlengths are different, each instance gets a part select of the expression, asspecified in the range, starting with the right-hand index. It is an error if thereare too many or two few bits to connect to all instances."
"The # notation is used in two different ways. It is used both to override thevalues of one or more parameters in a module instance, and to specify delaysfor a UDP or gate instance. For a module instance, the first expression 51Instantiationreplaces the value of the first parameter declared in the module; the second expression replaces the value of the second parameter etc."
"It is easy to swap two ports accidently in an ordered list. If the ports are both the same width and direction, the first indication that anything is amiss may be when incorrect results are seen in simulation. Such errors can be difficult todebug. Use named port connections to avoid this problem for moduleinstances."
"Modules may be defined using the keyword macromodule . The syntax is otherwise exactly the same as for modules. A Verilog compiler may compilemacromodules differently from modules, for example by not creating a level ofhierarchy for a macromodule instance. This might make simulation more 54Moduleefficient in terms of speed or memory. In order to achieve this, macro , is used at the end of both  55See Also"
"An escaped identifier is introduced by a backslash, ends with white space (aspace, tab, form feed or new line), and consists of any printable characters,except white space. The backslash and white space do not form part of theidentifier; so, for example, the identifier Fred is identical to the escapedidentifier \Fred ."
"The following names are illegal, for the reasons given. 123a //  Starts with a number $data //  Starts with a dollar module //  A reserved word 58The following example illustrates the use of hierarchical names, and an upwards name reference.    59Nets are used to model connections (wires and busses) in structural descriptions. The value of a net is determined by the values of the net’sdrivers. The drivers may be outputs of gate, UDP or"
"If the keyword vectored is used, bit and part selects and strength specifications may not be permitted, and the PLI may consider the net ‘unexpanded’. If the keyword scalared is used, bit and part selects and strength specifications are permitted, and the PLI should consider the net‘expanded’. These keywords are advisory."
"The size of an unsized number may default to 32 or more bits, depending onthe implementation. 63NumberIf the size is greater than the number of bits specified, the number is padded on the left with 0s, unless the leftmost bit is X or Z, in which case the X or Z isused to pad to the left."
"As well as being declared as an input, output, or inout, a port may also bedeclared as a net or register; if not, it is implicitly declared as a wire with thesame range as the corresponding input, output or inout. If a port is declaredas a vector, the ranges of the two declarations must be identical. 72PortInputs and inouts may not be declared as registers. (Output) ports may not be declared with type real or realtime."
"A register may be assigned in more than one initial or always. The value of the register at any time is determined by the most recent event, irrespective of the source of the event. This is different from what happens with nets. A netmay be driven from two or more different sources, the resulting valuedepending on the type of the net (wire, wand etc.) 74Procedural AssignmentSynthesis"
"The right hand side expression is synthesized to combinational logic. In acombinational always, the left hand side is synthesized to wires, or latches for incomplete assignments. In a clocked always, the left hand side of a non-blocking assignment is synthesized as flip-flops, and the left hand side ofa blocking assignment is synthesized as a connection, unless it is usedoutside the always, or the value is read before it is assigned."
"Procedural continuous assignments can be used to model asynchronous resets and interrupts. 77Procedural Continuous AssignmentExample always @(posedge Clock)   Count = Count + 1; always @(Reset) //  Asynchronous Reset   if (Reset)     assign Count = 0; //  Prevents counting, until Reset goes low   else     deassign Count; //  Resume counting on next posedge Clock"
"Continuous Assignment, Force 78The Verilog Programming Language Interface (PLI) provides a means for users to call functions written in the C programming language from a Verilogmodule. Such functions may dynamically access and modify data in aninstantiated Verilog data structure, and the PLI provides a library of Clanguage functions to facilitate this."
"The PLI is invoked via user defined system tasks and functions, which the user writes to augment the built in system tasks and functions. Like the built inones, user defined system tasks and functions have names that start with a $ character. A user defined system task or function hides a built in system task or function having the same name."
"A register of type integer or time generally behaves like a reg with the same number of bits. Individual bits and part selects of integers and times can be made in the same way as they can for regs. However, in an expression, the value of an integer is treated as a signed value, whereas the value of a reg or time is treated as unsigned."
"Type realtime is a recent addition to the Verilog language, and is not yet supported by all tools. 80RegisterThe concept of signed and unsigned values is not fully consistent between the LRM and in the way different simulators work. Be careful when usingsigned numbers and vectors having a width of more than 32 bits."
"For, Forever, While, Timing Control 82RepeatThis is a complete list of reserved identifiers in Verilog. These reserved identifiers must not be used as user defined identifiers, unless they areescaped or are not lower-case. and alwaysassignbegin buf bufif0bufif1casecasexcasezcmosdeassign default defparamdisableedgeelseendendcaseendfunction endprimitive endmoduleendspecifyendtableendtaskeventfor forceforeverfork function highz0highz1ififnoneinitialinoutinput integer joinlargemacromodulemediummodulenandnegedge nor notnotif0notif1nmosoroutput parameterpmosposedge primitive pulldownpulluppull0pull1rcmosrealrealtime reg releaserepeatrnmosrpmosrtranrtranif0rtranif1 scalared smallspecifyspecparamstrengthstrong0strong1 supply0supply1table task trantranif0tranif1timetritriandtrior trireg tri0tri1vectoredwaitwandweak0weak1 while wireworxnorxor 83"
"State dependent path delay (SDPD) expressions may reference only ports,constants and locally defined registers or nets. A limited set of operators isvalid in SDPD expressions: bitwise ( ~  &  |  ^  ^~  ~^  ), logical and equality ( ==  !=  &&  ||  !  ), reduction ( &  |  ^  ~&  ~|  ^~  ~^  ), concatenation, replication and conditional ( {}  {{}}  ?:  ). The path delays only affect the paths if the conditional expression is true. (1, X and Z are all considered true in"
"Statements execute at times defined by timing controls (delays, eventcontrols and waits). Whenever two or more statements are required togetherthey must be enclosed in begin-end or fork-join blocks. In a begin-end block,statements are executed in sequence; in a fork-join block they are executedin parallel. Statements in one initial or always are executed concurrently with those in any other initial or always."
"Task inputs, inouts and outputs, and any local registers are stored statically.This means that even if a task is enabled (i.e. called) more than once, there isonly one copy of these registers. If a task is enabled a second time before thefirst enable has completed, the values of the input and inout registers, and possibly the local registers too, will be overridden. 94TaskThe values of the outputs and inouts are only copied to the corresponding register expressions in the task enable when the task completes. If there is atiming control in the task after an assignment to an output or inout, thecorresponding registers in the task enable will only be updated after the timingcontrol delay."
"Disable, Task, Function Call 99Used to delay or schedule execution of statements. Timing controls may either be placed in front of statements, or between the = or <= and the expression in procedural assignments. The former delays the execution of thestatement it precedes, and the latter delays the effect of the assignment."
"A wait control only delays the following statement if the expression is false (zero or X) when the wait is reached; the following statement is executed when the expression becomes true. If the expression is true (non-zero) when 100Timing Controlthe wait is reached, the following statement is not delayed, but executed immediately."
"The expression on the right hand side of a procedural assignment isevaluated when the assignment is executed. If there is no intra-assignmentdelay, the registers on the left hand side are updated immediately for blocking assignments, and in the next simulation cycle for non-blocking assignments. If there is an intra-assignment delay, the registers on the left hand side are onlyupdated after the intra-assignment delay has occurred."
"The behaviour of a UDP is defined in a table. The rows in the table define theoutput values for various input conditions. For a combinational UDP, each row defines the output for one or more combinations of input values. For a sequential UDP each row also takes into account the current value of theoutput reg. A row may have at most one edge change entry. The row defines the value of the output for the input and current output reg values, when the specified edge occurs."
"By default a simulator will choose the longest of the distributed delays and path delays. 112`define defines a text macro. Macros are substituted in the first phase of compilation. Macros can be used to improve the readability andmaintainability of the Verilog code where parameters or functions areinappropriate, or where they are not allowed."
"System Tasks and Functions 117The Verilog language includes a number of useful system tasks and functions. These can be enabled and called in the same way as user definedtasks and functions. They are guaranteed to be available in any tool thatconforms to the IEEE Verilog standard. The Verilog LRM also mentions anumber of other, commonly found system tasks and functions, which are notactually part of the standard, but may be found in some implementations."
"A whole family of system tasks to write text to the standard output or one or more files. For full details see below. $fopen and $fclose $fopen(""FileName""); {Returns an integer} $fclose( Mcd); $fopen is a system function to open a text file for writing. $fclose closes a file that was opened with $fopen."
"System functions to return the current simulation time. The time returned has the units of the module from which the system function was called, as definedby `timescale. $time returns a 64 bit unsigned value, rounded to the nearest unit. $stime returns a 32 bit unsigned value, truncating large time values. $realtime returns a real number."
"Convert between a real number and a bit level representation, so that a real number can be passed through the port of a module. (Ports are not allowed tobe declared as real). For an example, see Module. 119$rtoi and $itor $rtoi( RealExpression) {returns an integer} $itor( IntegerExpression) {returns a real number}"
"Four system tasks and a system function to support stochastic modelling by enabling the creation and management of queues. For full details, see below. 120Random Number Generation Functions $random[( Seed)]; $dist_chi_square( Seed, DegreeOfFreedom ); $dist_erlang( Seed, K_stage , Mean); $dist_exponential( Seed, Mean); $dist_normal( Seed, Mean, StandardDeviation ); $dist_poisson( Seed, Mean); $dist_t( Seed, DegreeOfFreedom ); $dist_uniform( Seed, Start , End);"
"ReferenceEvent , DataEvent , Limit [, Notifier ]); $nochange( ReferenceEvent , DataEvent ,           StartEdgeOffset , EndEdgeOffset [, Notifier ]); $period( ReferenceEvent , Limit [,Notifier ]); $recovery( ReferenceEvent , DataEvent , Limit [,Notifier ]); $setup( DataEvent , ReferenceEvent , Limit [, Notifier ]); $setuphold( ReferenceEvent , DataEvent ,            SetupLimit , HoldLimit [, Notifier ]); $skew( ReferenceEvent , DataEvent , Limit [, Notifier ]); $width( ReferenceEvent , Limit [,Threshold [, Notifier ]]);"
"System function to show the number of drivers on a specified scalar net or bit select of a vector net. Drivers include outputs of primitives and continuousassignments, but not an active force. $countdrivers returns 0 if the net has more than one driver, and 1 otherwise. All the arguments, except the first,return integer values."
"The “key” file records commands that are entered interactively. The “log” file records all messages that are written to the standard output during asimulation run. $nokey and $nolog disable recording. With no argument, $key and $log re-enable recording. With a file name argument, they create new files. 122$reset, $reset_count  and $reset_value $reset[( StopValue [, ResetValue [, DiagnosticsValue ]]); $reset_count; {Returns an integer} $reset_value; {Returns an integer} $reset resets a simulator so that simulation can restart from the beginning."
"DiagnosticsValue  specifies the kind of messages the tool displays before resetting. $reset_count returns the number of times $reset has been called. $reset_value returns the value passed to $reset. $save, $restart and $incsave $save(""FileName""); $incave(""FileName""); $restart(""FileName""); $save saves the complete state of the simulation to a file, so that it can be read using $restart. $incsave saves only what has changed since the last call to $save.$restart resets the simulation from a full or incremental save file. For an incremental save, the previous full save file must be present: it is referencedin the incremental save file. $showvars $showvars[("
"MemoryElement ); $getpattern is a system function which may only be used in a continuous assignment. The left hand side of the continuous assignment must be aconcatenation of scalar nets. $getpattern is used together with $readmemband $readmemh to apply test vectors from a text file. $getpattern providesfast processing when there are large numbers of scalar inputs involved. 123$sreadmemb  and $sreadmemh $sreadmemb(Memory, StartAddr, FinishAddr, String, ... ); $sreadmemh(Memory, StartAddr, FinishAddr, String, ... );"
"Converts a time value in one module to the time units of the module from which $scale is called. $scale takes a hierarchical reference to a delay value,such as a parameter in another module, and scales it to the time units of themodule from which it was called. 124Writes formatted text to the standard output and the simulator log, or to a file."
"The following format specifiers are allowed in strings: %b %B Binary %o %O Octal $d $D Decimal %h %H Hexadecimal %e %E %f %F %g %G Real %c %C Character%s %S String %v %V Binary and Strength %t %T Time %m %M Hierarchical Instance %v prints strengths as follows: supply Su, strong St, Pull Pu, Large La,"
"Example integer MessagesFile, DiagnosticsFile, AllFiles; initial begin  MessagesFile = $fopen(""messages.txt"");  if (!MessagesFile)  begin    $display(""Could not open \""messages.txt\"""");    $finish;  end   DiagnosticsFile = $fopen(""diagnostics.txt"");   if (!DiagnosticsFile)  begin    $display(""Could not open \""diagnostics.txt\"""");    $finish;  end   AllFiles = MessagesFile | DiagnosticsFile | 1; 127$fopen and $fclose  $fdisplay(AllFiles, ""Starting simulation ..."");   $fdisplay(MessagesFile, ""Messages from %m"");  $fdisplay(DiagnosticsFile, ""Diagnostics from %m""); ...  $fclose(MessagesFile);   $fclose(DiagnosticsFile); end"
"Data values must be the same width as the memory array, and be separatedby white space. They are read into successive memory locations, starting atthe start of the array, or the start address, if specified. Data values continue tobe read until the end of the file or the end address, if specified, is reached."
The syntax of the arguments to these system tasks and the text they write isexactly the same as for the equivalent $display tasks. $strobe only prints the text when all activity at the time at which it was calledhas completed. This includes the effects of all blocking and non-blocking assignments.
"Creates a queue. q_id (output) is a unique queue identifier, which is used to refer to that queue when calling the other queue tasks and functions. q_type (input) is either 1 for a first-in, first-out (FIFO), or 2 for last-in, first-out(LIFO) queue. max_length (input) is the maximum number of entries that are allowed in the queue. $q_add"
"Adds an entry to a queue. q_id (input) indicates to which queue to add the entry. job_id (input) identifies the job. This is usually an integer that is incremented by the user each time an element is added to the queue, and can be used toidentify the element when it is removed. inform_id (input) is used to associate information with the queue entry. Its meaning is user defined. 134Stochastic Modelling$q_remove"
"Syntax $hold( ReferenceEvent , DataEvent , Limit [, Notifier ]); $nochange( ReferenceEvent , DataEvent ,           StartEdgeOffset , EndEdgeOffset [, Notifier ]); $period( ReferenceEvent , Limit [,Notifier ]); $recovery( ReferenceEvent , DataEvent , Limit [,Notifier ]); $setup( DataEvent , ReferenceEvent , Limit [, Notifier ]); $setuphold( ReferenceEvent , DataEvent ,            SetupLimit , HoldLimit [, Notifier ]); $skew( ReferenceEvent , DataEvent , Limit [, Notifier ]); $width( ReferenceEvent , Limit [,Threshold [, Notifier ]]);"
"Note that not all simulators will support these options. -f CommandFile  read further command line options from CommandFile , as well as from the command line. -k KeyFile Record any interactive commands entered during simulation in the file KeyFile. -l LogFile Record simulator messages in LogFile (including output from $display etc.), as well as the standard output. -r SaveFile Restart simulation from a file that was created by the (non-standard) system task $save. -s Interrupt the simulator at time 0. This allows simulation to be controlled interactively. -u Treat Verilog source code as consisting entirely of upper-case characters, except for strings. Use this option with care. -v LibraryFile  Search for missing modules or UDPs in LibraryFile.  Only modules or UDPs that are instanced, but not defined in the rest of the designare compiled from"
"LibraryDirectory . A module is expected to be defined in a file in the library directory having the same name as the module. If the command line option +libext+extension  is given, it specifies the file extension that is appended to the module name to get the file name. For example, -y mylib +libext+.v meanslook for a missing module ‘mycell’ in the file mylib/mycell.v +define+MacroName  Defines the text macro MacroName , with a null value."
"Such macros can be used in `ifdef statements. +incdir+Directory[+Directory... ] Defines a search list of directories in which to search for files to be included with `include. The search starts in the currentdirectory, and if the include file is not found there, the search continuesthrough the +incdir directories in order. +libext+Extension  Defines the library file extension. See -y above. +notimingchecks  Turn off timing checks in specify blocks. This may speed up simulation, or suppress spurious timing error messages. Use with care. +mindelays, +typdelays, +maxdelays  Use, respectively, minimum, typical or maximum delays throughout the design. The default is to use typical 142Command Line Optionsdelays. You cannot mix minimum, typical and maximum delays in the same simulation run."
